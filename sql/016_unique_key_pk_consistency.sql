\i sql/include/test_setup.sql

BEGIN;

CREATE SCHEMA pk_consistency;

-- This test verifies the `enforce_consistency_with_primary_key` functionality of add_unique_key.
-- This feature adds a non-temporal EXCLUDE constraint to enforce that a natural
-- key value is permanently bound to a single primary key value throughout history.

-- Scenario 1: PK added first, then NK (default enforcement)
\echo --- Scenario 1: PK then NK (default) ---
SAVEPOINT s1;

CREATE TABLE pk_consistency.pk_first (
    id int GENERATED BY DEFAULT AS IDENTITY,
    natural_key text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.pk_first');
SELECT sql_saga.add_unique_key('pk_consistency.pk_first', ARRAY['id'], key_type => 'primary');
TABLE sql_saga.unique_keys;
\echo '--- Constraints after PK only ---'
\d pk_consistency.pk_first

SELECT sql_saga.add_unique_key('pk_consistency.pk_first', ARRAY['natural_key']); -- Use default enforcement
TABLE sql_saga.unique_keys;
\echo '--- Constraints after NK ---'
\d pk_consistency.pk_first

ROLLBACK TO SAVEPOINT s1;


-- Scenario 2: NK added first, then PK
\echo
\echo --- Scenario 2: NK then PK ---
SAVEPOINT s2;
CREATE TABLE pk_consistency.nk_first (
    id int GENERATED BY DEFAULT AS IDENTITY,
    natural_key text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.nk_first');
SELECT sql_saga.add_unique_key('pk_consistency.nk_first', ARRAY['natural_key']); -- Enforcement is requested by default
TABLE sql_saga.unique_keys;

\echo '--- Constraints after NK only ---'
\d pk_consistency.nk_first
SELECT sql_saga.add_unique_key('pk_consistency.nk_first', ARRAY['id'], key_type => 'primary'); -- This should retroactively apply the constraint
TABLE sql_saga.unique_keys;

\echo '--- Constraints after PK ---'
\d pk_consistency.nk_first

-- Verify it works
INSERT INTO pk_consistency.nk_first (id, natural_key, valid_from) VALUES (1, 'NK1', '2023-01-01');
SAVEPOINT expect_error;
INSERT INTO pk_consistency.nk_first (id, natural_key, valid_from) VALUES (2, 'NK1', '2023-02-01'); -- fails
ROLLBACK TO SAVEPOINT expect_error;

ROLLBACK TO SAVEPOINT s2;

-- Scenario 3: Opt-out of enforcement
\echo
\echo --- Scenario 3: Opt-out ---
SAVEPOINT s3;
CREATE TABLE pk_consistency.opt_out (
    id int GENERATED BY DEFAULT AS IDENTITY,
    natural_key text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.opt_out');
SELECT sql_saga.add_unique_key('pk_consistency.opt_out', ARRAY['id'], key_type => 'primary');
SELECT sql_saga.add_unique_key('pk_consistency.opt_out', ARRAY['natural_key'], enforce_consistency_with_primary_key => false);
TABLE sql_saga.unique_keys;

\echo '--- Constraints after opting out ---'
\d pk_consistency.opt_out
-- This would fail if the constraint existed
INSERT INTO pk_consistency.opt_out (id, natural_key, valid_from) VALUES (1, 'NK1', '2023-01-01');
INSERT INTO pk_consistency.opt_out (id, natural_key, valid_from) VALUES (2, 'NK1', '2023-02-01');
TABLE pk_consistency.opt_out;

ROLLBACK TO SAVEPOINT s3;

-- Scenario 4: FAIL on Composite Primary Key
\echo
\echo --- Scenario 4a: Fail on adding NK to existing Composite PK ---
SAVEPOINT s4a;
CREATE TABLE pk_consistency.composite_pk_a (
    org_id int,
    unit_id int,
    natural_key text,
    valid_from date,
    valid_until date
);
ALTER TABLE pk_consistency.composite_pk_a ADD PRIMARY KEY (org_id, unit_id);
SELECT sql_saga.add_era('pk_consistency.composite_pk_a');
SAVEPOINT expect_error;
SELECT sql_saga.add_unique_key('pk_consistency.composite_pk_a', ARRAY['natural_key']); -- fails
ROLLBACK TO SAVEPOINT expect_error;
ROLLBACK TO SAVEPOINT s4a;

\echo
\echo --- Scenario 4b: Fail on adding Composite PK to existing NK ---
SAVEPOINT s4b;
CREATE TABLE pk_consistency.composite_pk_b (
    org_id int,
    unit_id int,
    natural_key text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.composite_pk_b');
SELECT sql_saga.add_unique_key('pk_consistency.composite_pk_b', ARRAY['natural_key']);
SAVEPOINT expect_error;
SELECT sql_saga.add_unique_key('pk_consistency.composite_pk_b', ARRAY['org_id', 'unit_id'], key_type => 'primary'); -- fails
ROLLBACK TO SAVEPOINT expect_error;
ROLLBACK TO SAVEPOINT s4b;

-- Scenario 5: API Symmetry (Drop Key)
\echo
\echo --- Scenario 5a: Drop NK removes its consistency constraint ---
SAVEPOINT s5a;
CREATE TABLE pk_consistency.drop_nk (
    id int GENERATED BY DEFAULT AS IDENTITY,
    natural_key text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.drop_nk');
SELECT sql_saga.add_unique_key('pk_consistency.drop_nk', ARRAY['id'], key_type => 'primary');
SELECT sql_saga.add_unique_key('pk_consistency.drop_nk', ARRAY['natural_key']);
\echo '--- Constraints before drop ---'
\d pk_consistency.drop_nk
SELECT sql_saga.drop_unique_key('pk_consistency.drop_nk', ARRAY['natural_key']);
\echo '--- Constraints after drop ---'
\d pk_consistency.drop_nk
ROLLBACK TO SAVEPOINT s5a;

\echo
\echo --- Scenario 5b: Drop PK removes dependent consistency constraints ---
SAVEPOINT s5b;
CREATE TABLE pk_consistency.drop_pk (
    id int GENERATED BY DEFAULT AS IDENTITY,
    nk1 text,
    nk2 text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.drop_pk');
SELECT sql_saga.add_unique_key('pk_consistency.drop_pk', ARRAY['nk1']);
SELECT sql_saga.add_unique_key('pk_consistency.drop_pk', ARRAY['nk2']);
SELECT sql_saga.add_unique_key('pk_consistency.drop_pk', ARRAY['id'], key_type => 'primary');
\echo '--- Constraints before drop ---'
\d pk_consistency.drop_pk
SELECT sql_saga.drop_unique_key('pk_consistency.drop_pk', ARRAY['id']);
\echo '--- Constraints after drop ---'
\d pk_consistency.drop_pk
ROLLBACK TO SAVEPOINT s5b;

ROLLBACK;

\i sql/include/test_teardown.sql
