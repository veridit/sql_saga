\i sql/include/test_setup.sql

BEGIN;
\echo '----------------------------------------------------------------------------'
\echo 'Test: `temporal_merge_plan` EXPLAIN output for performance monitoring'
\echo 'This test verifies that the planner function produces a stable and efficient'
\echo 'EXPLAIN plan. Its output is captured to monitor for performance regressions.'
\echo '----------------------------------------------------------------------------'

SET client_min_messages TO WARNING;
CREATE SCHEMA tmpc;

CREATE TABLE tmpc.target (id int, valid_from date, valid_until date, value text);
SELECT sql_saga.add_era('tmpc.target', 'valid_from', 'valid_until');

CREATE TEMP TABLE source1 (row_id int, id int, valid_from date, valid_until date, value text);

\echo '--- Setting up tables with indexes and data for a realistic plan ---'
CREATE INDEX ON tmpc.target (id);
CREATE INDEX ON tmpc.target USING gist (daterange(valid_from, valid_until));
CREATE INDEX ON source1 (id);
CREATE INDEX ON source1 USING gist (daterange(valid_from, valid_until));

-- Insert enough rows to make an index scan more attractive to the planner.
INSERT INTO tmpc.target (id, valid_from, valid_until, value)
SELECT i, '2023-01-01', '2024-01-01', 'A' FROM generate_series(1, 1000) as i;

-- The source will patch a single row in the middle of the target's history.
INSERT INTO source1 VALUES (1, 500, '2023-06-01', '2023-07-01', 'B');

-- Analyze the tables to ensure the planner has up-to-date statistics.
ANALYZE tmpc.target;
ANALYZE source1;

\echo '\n--- Performance Monitoring: EXPLAIN the cached planner query ---'
-- Generate and immediately explain the plan. The plan output itself is silenced.
\o /dev/null
SELECT * FROM sql_saga.temporal_merge_plan(
    p_target_table      => 'tmpc.target'::regclass,
    p_source_table      => 'source1'::regclass,
    p_identity_columns        => '{id}'::text[],
    p_ephemeral_columns => '{}'::text[],
    p_mode              => 'MERGE_ENTITY_PATCH'::sql_saga.temporal_merge_mode,
    p_era_name          => 'valid'
);
\o

-- Use \gset to capture the dynamically generated EXPLAIN command into a variable.
-- This avoids echoing the command with its unstable MD5 hash.
SELECT format('EXPLAIN (COSTS OFF) EXECUTE %I;', name) as explain_command
FROM pg_prepared_statements
WHERE name LIKE 'tm_plan_%' AND statement LIKE '%FROM source1 t%'
\gset

-- Now, echo a stable placeholder for the regression test's expected output...
\echo EXPLAIN (COSTS OFF) EXECUTE tm_plan_<...>;
-- ...and then execute the actual command we captured to print it for review.
:explain_command

\echo '\n--- Verifying that the plan is optimal (no Seq Scan on target) ---'
-- Programmatically verify that the plan does not contain a sequential scan on the target table.
-- This makes the test robust against performance regressions.
DO $$
DECLARE
    plan_name TEXT;
    rec RECORD;
    has_seq_scan BOOLEAN := false;
BEGIN
    -- Find the plan name generated by the preceding call to temporal_merge_plan.
    SELECT name INTO plan_name
    FROM pg_prepared_statements
    WHERE name LIKE 'tm_plan_%' AND statement LIKE '%FROM source1 t%';

    -- If no plan is found, something is wrong. Fail fast.
    IF plan_name IS NULL THEN
        RAISE EXCEPTION 'Could not find the prepared statement for the temporal_merge_plan.';
    END IF;

    -- Loop through the EXPLAIN output and check for the inefficient scan.
    FOR rec IN EXECUTE 'EXPLAIN (COSTS OFF) EXECUTE ' || quote_ident(plan_name) LOOP
        IF rec."QUERY PLAN" LIKE '%Seq Scan on target%' THEN
            has_seq_scan := true;
            EXIT;
        END IF;
    END LOOP;

    IF has_seq_scan THEN
        RAISE EXCEPTION 'Performance regression detected: EXPLAIN plan contains a "Seq Scan on target". Check for non-SARGable query conditions.';
    END IF;
END;
$$;
\echo '--- OK: Verified that EXPLAIN plan is optimal. ---'


SET client_min_messages TO NOTICE;
ROLLBACK;
\i sql/include/test_teardown.sql
