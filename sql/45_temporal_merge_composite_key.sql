\i sql/include/test_setup.sql

BEGIN;
\echo '----------------------------------------------------------------------------'
\echo 'Test: Unified Temporal Merge with Composite & Surrogate Keys'
\echo 'This test consolidates the tests for composite and surrogate keys into'
\echo 'a single, unified suite using the new temporal_merge function.'
\echo '----------------------------------------------------------------------------'

--------------------------------------------------------------------------------
-- Test Scenarios Table of Contents
--------------------------------------------------------------------------------
--
-- Composite-Key Entity: stat_for_unit
--   - Scenario 1: `upsert_replace` with a composite key (`during` split)
--   - Scenario 2: `upsert_patch` with a composite key (`during` split)
--   - Scenario 3: `upsert_replace` with mismatched source/target columns
--
-- Surrogate-Key Entities:
--   - Scenario 4: `upsert_replace` with SERIAL surrogate key on target
--   - Scenario 5: `upsert_replace` with IDENTITY surrogate key on target
--   - Scenario 6: `upsert_patch` with SERIAL surrogate key on target
--   - Scenario 7: `upsert_patch` with IDENTITY surrogate key on target
--   - Scenario 8: `upsert_replace` with non-PK surrogate key
--
--------------------------------------------------------------------------------
SET client_min_messages TO WARNING;

-- Setup: Create necessary schema and tables for this test
CREATE SCHEMA IF NOT EXISTS tmtc;

-- Parent tables
CREATE TABLE tmtc.stat_definition (id INT PRIMARY KEY, name TEXT);
CREATE TABLE tmtc.establishment (
    id INT NOT NULL, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, PRIMARY KEY (id, valid_from)
);
SELECT sql_saga.add_era('tmtc.establishment', 'valid_from', 'valid_until');
SELECT sql_saga.add_unique_key('tmtc.establishment', ARRAY['id'], 'valid', 'tm_establishment_uk');

-- Target table: stat_for_unit (composite key)
CREATE TABLE tmtc.stat_for_unit (
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT
);
SELECT sql_saga.add_era('tmtc.stat_for_unit', 'valid_from', 'valid_until');
SELECT sql_saga.add_unique_key('tmtc.stat_for_unit', ARRAY['stat_definition_id', 'establishment_id'], 'valid', 'tm_sfu_uk');

-- Target table with SERIAL surrogate ID
CREATE TABLE tmtc.stat_for_unit_id_pk (
    id SERIAL PRIMARY KEY,
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT
);
SELECT sql_saga.add_era('tmtc.stat_for_unit_id_pk', 'valid_from', 'valid_until');
SELECT sql_saga.add_unique_key('tmtc.stat_for_unit_id_pk', ARRAY['stat_definition_id', 'establishment_id'], 'valid', 'tm_sfu_id_uk');

-- Target table with IDENTITY surrogate ID
CREATE TABLE tmtc.stat_for_unit_id_gen (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT
);
SELECT sql_saga.add_era('tmtc.stat_for_unit_id_gen', 'valid_from', 'valid_until');
SELECT sql_saga.add_unique_key('tmtc.stat_for_unit_id_gen', ARRAY['stat_definition_id', 'establishment_id'], 'valid', 'tm_sfu_identity_uk');

-- Target table with non-PK surrogate key
CREATE SEQUENCE tmtc.stat_for_unit_no_pk_id_seq;
CREATE TABLE tmtc.stat_for_unit_no_pk (
    id INT NOT NULL DEFAULT nextval('tmtc.stat_for_unit_no_pk_id_seq'),
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT,
    UNIQUE (id, valid_from)
);
SELECT sql_saga.add_era('tmtc.stat_for_unit_no_pk', 'valid_from', 'valid_until');
SELECT sql_saga.add_unique_key('tmtc.stat_for_unit_no_pk', ARRAY['stat_definition_id', 'establishment_id'], 'valid', 'tm_sfu_no_pk_uk');

-- Helper procedure to reset the target table for a new scenario
CREATE OR REPLACE PROCEDURE tmtc.reset_target() AS $$
BEGIN
    TRUNCATE tmtc.stat_definition, tmtc.establishment, tmtc.stat_for_unit, tmtc.stat_for_unit_id_pk, tmtc.stat_for_unit_id_gen, tmtc.stat_for_unit_no_pk RESTART IDENTITY CASCADE;
    -- Add parent data
    INSERT INTO tmtc.stat_definition (id, name) VALUES (10, 'Total Employees');
    INSERT INTO tmtc.establishment (id, valid_from, valid_until, name) VALUES (100, '1900-01-01', 'infinity', 'EST 100');
END;
$$ LANGUAGE plpgsql;

\set source_schema 'pg_temp'
\set ephemeral_cols '{edit_comment}'

--------------------------------------------------------------------------------
\echo 'Scenario 1: `upsert_replace` with a composite key (`during` split)'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
INSERT INTO tmtc.stat_for_unit (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment) VALUES
(10, 100, '2024-01-01', '2025-01-01', 50, 'Original Value');

CREATE TEMP TABLE temp_source_1 (
    row_id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_1 VALUES (1, 10, 100, '2024-04-01', '2024-09-01', 55, 'Corrected value for mid-year');

\echo '--- Target: Initial State (before merge) ---'
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit ORDER BY stat_definition_id, establishment_id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_1 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    p_target_table             => 'tmtc.stat_for_unit',
    p_source_table             => 'temp_source_1',
    p_identity_columns               => '{stat_definition_id, establishment_id}'::TEXT[],
    p_ephemeral_columns        => :'ephemeral_cols'::TEXT[],
    p_mode                     => 'MERGE_ENTITY_REPLACE',
    p_era_name                 => 'valid',
    p_update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'UPDATE'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-04-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-04-01'::DATE, '2024-09-01'::DATE, '{"value": 55, "edit_comment": "Corrected value for mid-year"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (1, '[{"establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (10, 100, '2024-01-01'::DATE, '2024-04-01'::DATE, 50::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-04-01'::DATE, '2024-09-01'::DATE, 55::BIGINT, 'Corrected value for mid-year'::TEXT),
    (10, 100, '2024-09-01'::DATE, '2025-01-01'::DATE, 50::BIGINT, 'Original Value'::TEXT)
) AS t (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
DROP TABLE temp_source_1;

--------------------------------------------------------------------------------
\echo 'Scenario 2: `upsert_patch` with a composite key (`during` split)'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
INSERT INTO tmtc.stat_for_unit (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment) VALUES
(10, 100, '2024-01-01', '2025-01-01', 50, 'Original Value');

CREATE TEMP TABLE temp_source_2 (
    row_id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
-- Source has a NULL value for 'edit_comment'. In patch mode, this should NOT overwrite the existing value.
INSERT INTO temp_source_2 VALUES (1, 10, 100, '2024-04-01', '2024-09-01', 55, NULL);

\echo '--- Target: Initial State (before merge) ---'
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit ORDER BY stat_definition_id, establishment_id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_2 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    p_target_table             => 'tmtc.stat_for_unit',
    p_source_table             => 'temp_source_2',
    p_identity_columns               => '{stat_definition_id, establishment_id}'::TEXT[],
    p_ephemeral_columns        => :'ephemeral_cols'::TEXT[],
    p_mode                     => 'MERGE_ENTITY_PATCH',
    p_era_name                 => 'valid',
    p_update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'UPDATE'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-04-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-04-01'::DATE, '2024-09-01'::DATE, '{"value": 55, "edit_comment": "Original Value"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (1, '[{"establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (10, 100, '2024-01-01'::DATE, '2024-04-01'::DATE, 50::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-04-01'::DATE, '2024-09-01'::DATE, 55::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-09-01'::DATE, '2025-01-01'::DATE, 50::BIGINT, 'Original Value'::TEXT)
) AS t (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
DROP TABLE temp_source_2;

--------------------------------------------------------------------------------
\echo 'Scenario 3: `upsert_replace` with mismatched source/target columns'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
INSERT INTO tmtc.stat_for_unit (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment) VALUES
(10, 100, '2024-01-01', '2025-01-01', 50, 'Original Value');

-- Source table has an extra column `source_metadata` that is not in the target.
CREATE TEMP TABLE temp_source_3 (
    row_id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT, source_metadata TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_3 VALUES (1, 10, 100, '2024-04-01', '2024-09-01', 55, 'Corrected value for mid-year', 'some extra data');

\echo '--- Target: Initial State (before merge) ---'
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit ORDER BY stat_definition_id, establishment_id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_3 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    p_target_table             => 'tmtc.stat_for_unit',
    p_source_table             => 'temp_source_3',
    p_identity_columns               => '{stat_definition_id, establishment_id}'::TEXT[],
    p_ephemeral_columns        => :'ephemeral_cols'::TEXT[],
    p_mode                     => 'MERGE_ENTITY_REPLACE',
    p_era_name                 => 'valid',
    p_update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'UPDATE'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-04-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-04-01'::DATE, '2024-09-01'::DATE, '{"value": 55, "edit_comment": "Corrected value for mid-year"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (1, '[{"establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (10, 100, '2024-01-01'::DATE, '2024-04-01'::DATE, 50::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-04-01'::DATE, '2024-09-01'::DATE, 55::BIGINT, 'Corrected value for mid-year'::TEXT),
    (10, 100, '2024-09-01'::DATE, '2025-01-01'::DATE, 50::BIGINT, 'Original Value'::TEXT)
) AS t (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
DROP TABLE temp_source_3;

--------------------------------------------------------------------------------
\echo 'Scenario 4: `upsert_replace` with SERIAL surrogate key on target'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_4 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_4 VALUES (1, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial Value');

\echo '--- Target: Initial State (before merge) ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk ORDER BY id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_4 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    p_target_table             => 'tmtc.stat_for_unit_id_pk',
    p_source_table             => 'temp_source_4',
    p_identity_columns               => '{stat_definition_id, establishment_id}'::TEXT[],
    p_ephemeral_columns        => :'ephemeral_cols'::TEXT[],
    p_mode                     => 'MERGE_ENTITY_REPLACE',
    p_era_name                 => 'valid',
    p_update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (1, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;

\echo '--- Source Table: Expected state after back-fill ---'
SELECT * FROM (VALUES (1, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Source Table: Actual state after back-fill ---'
SELECT * FROM temp_source_4 ORDER BY row_id;
DROP TABLE temp_source_4;

--------------------------------------------------------------------------------
\echo 'Scenario 5: `upsert_replace` with IDENTITY surrogate key on target'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_5 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_5 VALUES (1, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial Value');

\echo '--- Target: Initial State (before merge) ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen ORDER BY id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_5 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    p_target_table             => 'tmtc.stat_for_unit_id_gen',
    p_source_table             => 'temp_source_5',
    p_identity_columns               => '{stat_definition_id, establishment_id}'::TEXT[],
    p_ephemeral_columns        => :'ephemeral_cols'::TEXT[],
    p_mode                     => 'MERGE_ENTITY_REPLACE',
    p_era_name                 => 'valid',
    p_update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (1, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;

\echo '--- Source Table: Expected state after back-fill ---'
SELECT * FROM (VALUES (1, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Source Table: Actual state after back-fill ---'
SELECT * FROM temp_source_5 ORDER BY row_id;
DROP TABLE temp_source_5;

--------------------------------------------------------------------------------
\echo 'Scenario 6: `upsert_patch` with SERIAL surrogate key on target'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_6 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_6 VALUES (104, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial stat');

\echo '--- Target: Initial State (before merge) ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk ORDER BY id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_6 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    p_target_table             => 'tmtc.stat_for_unit_id_pk',
    p_source_table             => 'temp_source_6',
    p_identity_columns               => '{stat_definition_id, establishment_id}'::TEXT[],
    p_ephemeral_columns        => '{edit_comment}'::TEXT[],
    p_mode                     => 'MERGE_ENTITY_PATCH',
    p_era_name                 => 'valid',
    p_update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{104}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial stat"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (104, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk WHERE establishment_id = 100 and stat_definition_id = 10 ORDER BY valid_from;

\echo '--- Source Table: Expected state after back-fill ---'
SELECT * FROM (VALUES (104, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Source Table: Actual state after back-fill ---'
SELECT * FROM temp_source_6 ORDER BY row_id;
DROP TABLE temp_source_6;

--------------------------------------------------------------------------------
\echo 'Scenario 7: `upsert_patch` with IDENTITY surrogate key on target'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_7 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_7 VALUES (105, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial stat');

\echo '--- Target: Initial State (before merge) ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen ORDER BY id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_7 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    p_target_table             => 'tmtc.stat_for_unit_id_gen',
    p_source_table             => 'temp_source_7',
    p_identity_columns               => '{stat_definition_id, establishment_id}'::TEXT[],
    p_ephemeral_columns        => '{edit_comment}'::TEXT[],
    p_mode                     => 'MERGE_ENTITY_PATCH',
    p_era_name                 => 'valid',
    p_update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{105}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial stat"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (105, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen WHERE establishment_id = 100 and stat_definition_id = 10 ORDER BY valid_from;

\echo '--- Source Table: Expected state after back-fill ---'
SELECT * FROM (VALUES (105, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Source Table: Actual state after back-fill ---'
SELECT * FROM temp_source_7 ORDER BY row_id;
DROP TABLE temp_source_7;

--------------------------------------------------------------------------------
\echo 'Scenario 8: `upsert_replace` with non-PK surrogate key'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_8 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_8 VALUES (1, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial Value');

\echo '--- Target: Initial State (before merge) ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_no_pk ORDER BY id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_8 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    p_target_table             => 'tmtc.stat_for_unit_no_pk',
    p_source_table             => 'temp_source_8',
    p_identity_columns               => '{stat_definition_id, establishment_id}'::TEXT[],
    p_ephemeral_columns        => :'ephemeral_cols'::TEXT[],
    p_mode                     => 'MERGE_ENTITY_REPLACE',
    p_era_name                 => 'valid',
    p_update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (1, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_no_pk WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;

\echo '--- Source Table: Expected state after back-fill ---'
SELECT * FROM (VALUES (1, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Source Table: Actual state after back-fill ---'
SELECT * FROM temp_source_8 ORDER BY row_id;
DROP TABLE temp_source_8;


-- Final Cleanup
DROP PROCEDURE tmtc.reset_target();
DROP TABLE tmtc.stat_for_unit, tmtc.stat_for_unit_id_pk, tmtc.stat_for_unit_id_gen, tmtc.stat_for_unit_no_pk;
DROP TABLE tmtc.establishment;
DROP TABLE tmtc.stat_definition;
DROP SCHEMA tmtc CASCADE;

SET client_min_messages TO NOTICE;
ROLLBACK;
\i sql/include/test_teardown.sql
