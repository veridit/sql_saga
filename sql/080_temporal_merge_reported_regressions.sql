\i sql/include/test_setup.sql

-- This test file reproduces two distinct regressions in `temporal_merge`.
-- Each regression is tested in its own savepoint for isolation.

\set ECHO all

BEGIN;

CREATE SCHEMA saga_repro;

-- Base table definitions used by both scenarios
CREATE TABLE saga_repro.target_units_template (
    unit_ident text NOT NULL,
    name text,
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_to date,
    valid_until date
);
CREATE TABLE saga_repro.source_units_template (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    batch_seq int,
    unit_ident text,
    name text,
    sector text,
    valid_from date,
    valid_to date,
    merge_status jsonb,
    errors jsonb
);

GRANT USAGE ON SCHEMA saga_repro TO sql_saga_unprivileged_user;

--------------------------------------------------------------------------------
-- SCENARIO 1: Ordering Dependency Regression
--
-- This script demonstrates a regression where `temporal_merge` fails if its
-- source data contains complex overlapping temporal segments that are not
-- pre-sorted chronologically.
--------------------------------------------------------------------------------
SAVEPOINT scenario_ordering_dependency;

\echo '\n--- SCENARIO 1: Comparing merge strategies for out-of-order source data ---'

-- Setup for Scenario 1
CREATE TABLE saga_repro.target_units_a (LIKE saga_repro.target_units_template);
CREATE TABLE saga_repro.target_units_b (LIKE saga_repro.target_units_template);
CREATE TABLE saga_repro.target_units_c (LIKE saga_repro.target_units_template);

ALTER TABLE saga_repro.target_units_a ADD PRIMARY KEY (unit_ident, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_era('saga_repro.target_units_a', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
SELECT sql_saga.add_unique_key('saga_repro.target_units_a', ARRAY['unit_ident'], key_type => 'natural');
ALTER TABLE saga_repro.target_units_b ADD PRIMARY KEY (unit_ident, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_era('saga_repro.target_units_b', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
SELECT sql_saga.add_unique_key('saga_repro.target_units_b', ARRAY['unit_ident'], key_type => 'natural');
ALTER TABLE saga_repro.target_units_c ADD PRIMARY KEY (unit_ident, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_era('saga_repro.target_units_c', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
SELECT sql_saga.add_unique_key('saga_repro.target_units_c', ARRAY['unit_ident'], key_type => 'natural');

CREATE TABLE saga_repro.source_units_ordering (LIKE saga_repro.source_units_template INCLUDING ALL);

GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA saga_repro TO sql_saga_unprivileged_user;


INSERT INTO saga_repro.source_units_ordering (batch_seq, unit_ident, name, valid_from, valid_to) VALUES
    (1, 'unit1', 'Initial P1',   '2023-01-01', '2023-03-31'),
    (1, 'unit1', 'Initial P2',   '2023-04-01', '2023-06-30'),
    (1, 'unit1', 'Initial P3',   '2023-07-01', '2023-09-30'),
    (2, 'unit1', 'Replacing pA', '2023-02-15', '2023-05-15'),
    (2, 'unit1', 'Replacing pB', '2023-05-16', '2023-08-15'),
    (2, 'unit1', 'Replacing pC', '2023-08-16', '2023-12-01');
GRANT ALL ON saga_repro.source_units_ordering TO sql_saga_unprivileged_user;

SET ROLE TO sql_saga_unprivileged_user;

-- Strategy A: Process one row at a time (baseline for correctness)
\echo '\n--- STRATEGY A: Processing one row at a time ---\n'
CREATE TEMP TABLE source_a AS SELECT * FROM saga_repro.source_units_ordering;

-- Row 1
CREATE TEMP VIEW source_view_1 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 1;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_1', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run1');
-- Row 2
CREATE TEMP VIEW source_view_2 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 2;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_2', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run2');
-- Row 3
CREATE TEMP VIEW source_view_3 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 3;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_3', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run3');
-- Row 4
CREATE TEMP VIEW source_view_4 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 4;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_4', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run4');
-- Row 5
CREATE TEMP VIEW source_view_5 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 5;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_5', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run5');
-- Row 6
CREATE TEMP VIEW source_view_6 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 6;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_6', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run6');

-- Strategy B: Process in logical batches
CREATE TEMP TABLE source_b AS SELECT * FROM saga_repro.source_units_ordering;
CREATE TEMP VIEW source_view_b1 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_b WHERE batch_seq = 1;
CREATE TEMP VIEW source_view_b2 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_b WHERE batch_seq = 2;

\echo '\n--- STRATEGY B: Processing in logical batches ---\n'
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_b', 'source_view_b1',
    natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT',
    update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'batch1'
);
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_b', 'source_view_b2',
    natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT',
    update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'batch2'
);

-- Strategy C: Process all rows in one batch (the failing case)
CREATE TEMP TABLE source_c AS SELECT * FROM saga_repro.source_units_ordering;
CREATE TEMP VIEW source_view_c AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_c;

CALL sql_saga.temporal_merge(
    'saga_repro.target_units_c', 'source_view_c',
    natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT',
    update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run'
);


-- Final results for Scenario 1
\echo '\n\n--- FINAL COMPARISON OF FINAL STATES (SCENARIO 1) ---'
\echo '\n-- Strategy A: One-by-one Result'
SELECT unit_ident, name, valid_from, valid_to FROM saga_repro.target_units_a ORDER BY valid_from, name;
\echo '\n-- Strategy B: Batch-by-batch Result'
SELECT unit_ident, name, valid_from, valid_to FROM saga_repro.target_units_b ORDER BY valid_from, name;
\echo '\n-- Strategy C: All-in-one Result'
SELECT unit_ident, name, valid_from, valid_to FROM saga_repro.target_units_c ORDER BY valid_from, name;

\echo '\n-- Diff check of strategy results (should be empty)'
\echo '\n-- Diff A vs B:'
(TABLE saga_repro.target_units_a EXCEPT TABLE saga_repro.target_units_b)
UNION ALL
(TABLE saga_repro.target_units_b EXCEPT TABLE saga_repro.target_units_a);
\echo '\n-- Diff B vs C:'
(TABLE saga_repro.target_units_b EXCEPT TABLE saga_repro.target_units_c)
UNION ALL
(TABLE saga_repro.target_units_c EXCEPT TABLE saga_repro.target_units_b);

\echo '\n\n--- FINAL COMPARISON OF FEEDBACK (SCENARIO 1) ---'
\echo '\n-- Strategy A: One-by-one Feedback'
SELECT row_id, batch_seq, name, merge_status, errors FROM source_a ORDER BY row_id;
\echo '\n-- Strategy B: Batch-by-batch Feedback'
SELECT row_id, batch_seq, name, merge_status, errors FROM source_b ORDER BY row_id;
\echo '\n-- Strategy C: All-in-one Feedback'
SELECT row_id, batch_seq, name, merge_status, errors FROM source_c ORDER BY row_id;

ROLLBACK TO SAVEPOINT scenario_ordering_dependency;

--------------------------------------------------------------------------------
-- SCENARIO 2: Coalescing Regression
--
-- This test demonstrates a regression where `temporal_merge` fails to coalesce
-- adjacent, identical time segments when they are processed in separate batches.
--------------------------------------------------------------------------------
SAVEPOINT scenario_coalescing;
\echo '\n--- SCENARIO 2: Coalescing identical, adjacent records across batches ---'

-- Setup for Scenario 2
CREATE TABLE saga_repro.target_units_coalesce (
    LIKE saga_repro.target_units_template,
    notes text -- Add a nullable column that does not exist in the source table
);
ALTER TABLE saga_repro.target_units_coalesce ADD PRIMARY KEY (unit_ident, valid_range WITHOUT OVERLAPS);
CREATE TABLE saga_repro.source_units_coalesce (LIKE saga_repro.source_units_template INCLUDING ALL);
SELECT sql_saga.add_era('saga_repro.target_units_coalesce', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
SELECT sql_saga.add_unique_key('saga_repro.target_units_coalesce', ARRAY['unit_ident'], key_type => 'natural');
GRANT ALL ON saga_repro.target_units_coalesce TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_units_coalesce TO sql_saga_unprivileged_user;

-- Batch 1
INSERT INTO saga_repro.source_units_coalesce (unit_ident, name, valid_from, valid_to) VALUES
    ('unit1', 'Unit A', '2023-01-01', '2023-06-30');
SET ROLE TO sql_saga_unprivileged_user;
CALL sql_saga.temporal_merge('saga_repro.target_units_coalesce', 'saga_repro.source_units_coalesce', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_PATCH');
RESET ROLE;

\echo '\n--- State after Batch 1 ---'
SELECT unit_ident, name, valid_from, valid_to, notes FROM saga_repro.target_units_coalesce;

-- Batch 2 (the failing step)
TRUNCATE saga_repro.source_units_coalesce;
INSERT INTO saga_repro.source_units_coalesce (unit_ident, name, valid_from, valid_to) VALUES
    ('unit1', 'Unit A', '2023-07-01', '2023-12-31');

SET ROLE TO sql_saga_unprivileged_user;
CALL sql_saga.temporal_merge('saga_repro.target_units_coalesce', 'saga_repro.source_units_coalesce', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_PATCH');
RESET ROLE;

-- Final results for Scenario 2
\echo '\n-- Coalescing Test Final State (Bug Repro: 2 rows, Correct: 1 row)'
SELECT unit_ident, name, valid_from, valid_to, notes FROM saga_repro.target_units_coalesce ORDER BY valid_from;

ROLLBACK TO SAVEPOINT scenario_coalescing;


--------------------------------------------------------------------------------
-- SCENARIO 3: Ephemeral column handling in PATCH, UPSERT, and REPLACE modes
--
-- This scenario clarifies the semantic differences between the main merge modes
-- with respect to NULLs and ephemeral columns.
--------------------------------------------------------------------------------
SAVEPOINT scenario_ephemeral_modes;
\echo '\n--- SCENARIO 3: Ephemeral column handling in PATCH, UPSERT, and REPLACE modes ---'

CREATE TABLE saga_repro.target_units_ephemeral (
    id int GENERATED BY DEFAULT AS IDENTITY,
    unit_ident text NOT NULL,
    name text NOT NULL,
    -- Semantic naming for DEFAULT behavior testing:
    status_with_default text NOT NULL DEFAULT 'pending',                    -- NULL source → uses DEFAULT 'pending'
    priority_with_default int NOT NULL DEFAULT 1,                           -- NULL source → uses DEFAULT 1  
    created_at_with_default timestamptz NOT NULL DEFAULT '2025-01-01 10:00:00+00', -- NULL source → uses DEFAULT timestamp
    notes_nullable text,                                                     -- NULL source → NULL (no constraint)
    -- Audit columns (ephemeral, no defaults - must be provided):
    edit_at_no_default timestamptz NOT NULL,                               -- NULL source → constraint violation
    edit_by_user_id_no_default text NOT NULL,                              -- NULL source → constraint violation
    edit_comment_nullable text,                                             -- NULL source → NULL (no constraint)
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_to date,
    valid_until date
);
CREATE TABLE saga_repro.source_units_ephemeral (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    unit_ident text, name text, 
    status_with_default text, priority_with_default int, created_at_with_default timestamptz,
    notes_nullable text,
    edit_at_no_default timestamptz, edit_by_user_id_no_default text, edit_comment_nullable text,
    valid_from date, valid_to date
);
ALTER TABLE saga_repro.target_units_ephemeral ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_era('saga_repro.target_units_ephemeral', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
SELECT sql_saga.add_unique_key('saga_repro.target_units_ephemeral', ARRAY['id'], key_type => 'primary');
SELECT sql_saga.add_unique_key('saga_repro.target_units_ephemeral', ARRAY['unit_ident'], key_type => 'natural');
GRANT ALL ON saga_repro.target_units_ephemeral TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_units_ephemeral TO sql_saga_unprivileged_user;

\echo '\n-- Case 3a: MERGE_ENTITY_PATCH'
\echo '-- Expectation: NULL for `edit_comment_nullable` is ignored (PATCH mode). DEFAULT columns and audit fields are preserved.'
SAVEPOINT case_patch;
-- Initial state for this case
TRUNCATE saga_repro.target_units_ephemeral, saga_repro.source_units_ephemeral RESTART IDENTITY;
INSERT INTO saga_repro.target_units_ephemeral (unit_ident, name, notes_nullable, valid_from, valid_to, edit_at_no_default, edit_by_user_id_no_default, edit_comment_nullable)
VALUES ('unit1', 'Unit A', 'Original notes', '2023-01-01', '2023-12-31', '2025-01-01 09:00:00+00', 'admin', 'Initial version');
INSERT INTO saga_repro.source_units_ephemeral (unit_ident, name, valid_from, valid_to, edit_at_no_default, edit_by_user_id_no_default, edit_comment_nullable)
VALUES ('unit1', 'Unit A Updated', '2023-06-01', '2023-08-31', '2025-02-01 10:30:00+00', 'user123', NULL); -- `edit_comment_nullable` is NULL, other fields provided
\echo '\n--- Initial State ---'
TABLE saga_repro.target_units_ephemeral;
\echo '\n--- Source Data ---'
TABLE saga_repro.source_units_ephemeral;

SET ROLE TO sql_saga_unprivileged_user;
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_ephemeral', 'saga_repro.source_units_ephemeral',
    natural_identity_columns => ARRAY['unit_ident'],
    ephemeral_columns => ARRAY['edit_at_no_default', 'edit_by_user_id_no_default', 'edit_comment_nullable'],
    mode => 'MERGE_ENTITY_PATCH'
);
RESET ROLE;
\echo '\n--- Final State (PATCH) ---'
SELECT unit_ident, name, notes_nullable, valid_from, valid_to, edit_comment_nullable FROM saga_repro.target_units_ephemeral ORDER BY valid_from;
ROLLBACK TO SAVEPOINT case_patch;


\echo '\n-- Case 3b: MERGE_ENTITY_UPSERT'
\echo '-- Expectation: NULL DEFAULT columns use table defaults. NULL audit fields cause constraint violation.'
SAVEPOINT case_upsert;
-- Initial state for this case  
TRUNCATE saga_repro.target_units_ephemeral, saga_repro.source_units_ephemeral RESTART IDENTITY;
INSERT INTO saga_repro.target_units_ephemeral (unit_ident, name, notes_nullable, valid_from, valid_to, edit_at_no_default, edit_by_user_id_no_default, edit_comment_nullable)
VALUES ('unit1', 'Unit A', 'Original notes', '2023-01-01', '2023-12-31', '2025-01-01 09:00:00+00', 'admin', 'Initial version');
-- Source with NULL values for DEFAULT columns (should use defaults) and NULL audit fields (should cause error)
INSERT INTO saga_repro.source_units_ephemeral (unit_ident, name, status_with_default, priority_with_default, valid_from, valid_to, edit_at_no_default, edit_by_user_id_no_default, edit_comment_nullable)
VALUES ('unit1', 'Unit A Updated', NULL, NULL, '2023-06-01', '2023-08-31', NULL, NULL, NULL);
\echo '\n--- Initial State ---'
TABLE saga_repro.target_units_ephemeral;
\echo '\n--- Source Data ---'
TABLE saga_repro.source_units_ephemeral;

SET ROLE TO sql_saga_unprivileged_user;
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_ephemeral', 'saga_repro.source_units_ephemeral',
    natural_identity_columns => ARRAY['unit_ident'],
    ephemeral_columns => ARRAY['edit_at_no_default', 'edit_by_user_id_no_default', 'edit_comment_nullable'],
    mode => 'MERGE_ENTITY_UPSERT'
);
RESET ROLE;
\echo '\n--- Final State (UPSERT) ---'
SELECT unit_ident, name, notes_nullable, valid_from, valid_to, edit_comment_nullable FROM saga_repro.target_units_ephemeral ORDER BY valid_from;
ROLLBACK TO SAVEPOINT case_upsert;


\echo '\n-- Case 3c: MERGE_ENTITY_REPLACE'
\echo '-- Expectation: Source completely replaces target. NULL DEFAULT columns use table defaults. NULL audit fields cause constraint violation.'
SAVEPOINT case_replace;
-- Initial state for this case
TRUNCATE saga_repro.target_units_ephemeral, saga_repro.source_units_ephemeral RESTART IDENTITY;
INSERT INTO saga_repro.target_units_ephemeral (unit_ident, name, notes_nullable, valid_from, valid_to, edit_at_no_default, edit_by_user_id_no_default, edit_comment_nullable)
VALUES ('unit1', 'Unit A', 'Original notes', '2023-01-01', '2023-12-31', '2025-01-01 09:00:00+00', 'admin', 'Initial version');
-- Source with NULL values for DEFAULT columns (should use defaults) and NULL audit fields (should cause error)  
INSERT INTO saga_repro.source_units_ephemeral (unit_ident, name, status_with_default, priority_with_default, valid_from, valid_to, edit_at_no_default, edit_by_user_id_no_default, edit_comment_nullable)
VALUES ('unit1', 'Unit A Updated', NULL, NULL, '2023-06-01', '2023-08-31', NULL, NULL, NULL);
\echo '\n--- Initial State ---'
TABLE saga_repro.target_units_ephemeral;
\echo '\n--- Source Data ---'
TABLE saga_repro.source_units_ephemeral;

SET ROLE TO sql_saga_unprivileged_user;
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_ephemeral', 'saga_repro.source_units_ephemeral',
    natural_identity_columns => ARRAY['unit_ident'],
    ephemeral_columns => ARRAY['edit_at_no_default', 'edit_by_user_id_no_default', 'edit_comment_nullable'],
    mode => 'MERGE_ENTITY_REPLACE'
);
RESET ROLE;
\echo '\n--- Final State (REPLACE) ---'
SELECT unit_ident, name, notes_nullable, valid_from, valid_to, edit_comment_nullable FROM saga_repro.target_units_ephemeral ORDER BY valid_from;
ROLLBACK TO SAVEPOINT case_replace;


ROLLBACK TO SAVEPOINT scenario_ephemeral_modes;


--------------------------------------------------------------------------------
-- SCENARIO 4: UPSERT mode with NOT NULL DEFAULT columns
--
-- This test validates that when using MERGE_ENTITY_UPSERT, an incoming NULL
-- for a column that is defined as NOT NULL DEFAULT does not cause a NOT NULL
-- violation. Instead, the executor preserves the existing value, effectively
-- treating NULL as "no change" for this specific combination of constraints and mode.
--------------------------------------------------------------------------------
SAVEPOINT scenario_not_null_default;
\echo '\n--- SCENARIO 4: UPSERT with NOT NULL DEFAULT columns ---'

CREATE TABLE saga_repro.target_not_null_default (
    unit_ident text NOT NULL,
    name text NOT NULL,
    status text NOT NULL DEFAULT 'active',
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_to date,
    valid_until date
);
CREATE TABLE saga_repro.source_not_null_default (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    unit_ident text, name text, status text,
    valid_from date, valid_to date
);

ALTER TABLE saga_repro.target_not_null_default ADD PRIMARY KEY (unit_ident, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_era('saga_repro.target_not_null_default', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
SELECT sql_saga.add_unique_key('saga_repro.target_not_null_default', ARRAY['unit_ident'], key_type => 'natural');
GRANT ALL ON saga_repro.target_not_null_default TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_not_null_default TO sql_saga_unprivileged_user;

-- Initial state: one record with default status
INSERT INTO saga_repro.target_not_null_default (unit_ident, name, valid_from, valid_until)
VALUES ('unit1', 'Unit A', '2023-01-01', '2024-01-01');

\echo '\n--- Initial State ---'
TABLE saga_repro.target_not_null_default;

-- Source data: provides NULL for the 'status' column, which has a NOT NULL DEFAULT constraint.
INSERT INTO saga_repro.source_not_null_default (unit_ident, name, status, valid_from, valid_to)
VALUES ('unit1', 'Unit A Updated', NULL, '2023-06-01', '2023-08-31');

\echo '\n--- Source Data ---'
TABLE saga_repro.source_not_null_default;

SET ROLE TO sql_saga_unprivileged_user;
CALL sql_saga.temporal_merge(
    'saga_repro.target_not_null_default', 'saga_repro.source_not_null_default',
    natural_identity_columns => ARRAY['unit_ident'],
    mode => 'MERGE_ENTITY_UPSERT'
);
RESET ROLE;

\echo '\n--- Final State (UPSERT with NOT NULL DEFAULT) ---'
\echo '-- Expectation: The `status` remains "active" in all segments, as the incoming NULL was ignored.'
SELECT unit_ident, name, status, valid_from, valid_to FROM saga_repro.target_not_null_default ORDER BY valid_from;

ROLLBACK TO SAVEPOINT scenario_not_null_default;

--------------------------------------------------------------------------------
-- SCENARIO 5: UPDATE_FOR_PORTION_OF incorrectly merges distinct attribute values
--
-- This reproduces a critical Statbus regression where updating a non-name attribute
-- (like legal_form_id) via a FOR_PORTION_OF view incorrectly merges temporal rows
-- that have different names, losing historical name changes.
--
-- Issue: When the same entity has different attribute values across adjacent time
-- periods (e.g., name changed from "A" to "B"), updating another attribute across
-- the full timeline should preserve both distinct names, not merge them into one.
--------------------------------------------------------------------------------
SAVEPOINT scenario_update_for_portion_of_merging;

\echo '\n--- SCENARIO 5: UPDATE_FOR_PORTION_OF should preserve distinct attribute values ---'

-- Create tables mimicking Statbus legal_unit structure (simplified)
CREATE TABLE saga_repro.legal_unit (
    id int GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL,
    legal_form_id int NOT NULL DEFAULT 1,
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_until date
);

SELECT sql_saga.add_era('saga_repro.legal_unit', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
ALTER TABLE saga_repro.legal_unit ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_unique_key('saga_repro.legal_unit', ARRAY['id'], key_type => 'primary');

-- Create FOR_PORTION_OF view
SELECT sql_saga.add_for_portion_of_view('saga_repro.legal_unit', era_name => 'valid');

GRANT ALL ON saga_repro.legal_unit TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.legal_unit__for_portion_of_valid TO sql_saga_unprivileged_user;

-- Insert test data matching Statbus pattern:
-- Same entity ID, different names, adjacent time periods
INSERT INTO saga_repro.legal_unit (id, name, legal_form_id, valid_from, valid_until) VALUES
    (1, 'EQUATOR GLOBE SOLUTIONS', 1, '2023-01-01', '2024-01-01'),
    (1, 'EQUATOR GLOBE SOLUTIONS #2', 1, '2024-01-01', '2026-01-01');

\echo '\n--- Initial State: Two rows, same ID, different names ---'
SELECT id, name, legal_form_id, valid_from, valid_until 
FROM saga_repro.legal_unit 
ORDER BY valid_from;

-- Execute the problematic UPDATE via FOR_PORTION_OF view
-- This should update legal_form_id across the FULL timeline (2023-2026)
-- Expected: 2 rows with legal_form_id=2, preserving both distinct names
-- Bug: 1 merged row losing the original name "EQUATOR GLOBE SOLUTIONS"
SET ROLE TO sql_saga_unprivileged_user;
UPDATE saga_repro.legal_unit__for_portion_of_valid
SET legal_form_id = 2, valid_from = '2023-01-01', valid_until = '2026-01-01'
WHERE id = 1;
RESET ROLE;

\echo '\n--- After UPDATE FOR PORTION OF (full timeline) ---'
\echo '-- Expected: 2 rows preserving distinct names'
\echo '-- Bug: 1 row with merged name (loses "EQUATOR GLOBE SOLUTIONS")'
SELECT id, name, legal_form_id, valid_from, valid_until 
FROM saga_repro.legal_unit 
ORDER BY valid_from;

ROLLBACK TO SAVEPOINT scenario_update_for_portion_of_merging;


--------------------------------------------------------------------------------
-- SCENARIO 6: Timeline splits should preserve audit columns (edit_at, edit_by_user_id)
--
-- Issue: When temporal_merge splits a timeline segment (e.g., a PATCH_FOR_PORTION_OF
-- operation that affects the middle of an existing timeline), the audit columns
-- (edit_at, edit_by_user_id, edit_comment) should be preserved from the original
-- segment, not reset to NULL or now().
--
-- Currently: The split segments lose their audit trail, with edit_at being reset
-- to the current timestamp and edit_by_user_id potentially being nulled.
--------------------------------------------------------------------------------
SAVEPOINT scenario_audit_column_preservation;

\echo '\n--- SCENARIO 6: Timeline splits should preserve audit columns ---'

-- Create a temporal table with semantic audit columns  
CREATE TABLE saga_repro.audited_unit (
    id int GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL,
    status text NOT NULL,
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_until date,
    -- Audit columns with fixed defaults for deterministic testing - semantic naming shows expected DEFAULT behavior
    edit_at_with_default timestamptz NOT NULL DEFAULT '2024-01-01 02:00:00-08'::timestamptz,  -- NULL source → uses this DEFAULT
    edit_by_user_id_with_default int NOT NULL DEFAULT 1,                                      -- NULL source → uses this DEFAULT
    edit_comment_nullable text                                                                -- NULL source → NULL (no constraint)
);

SELECT sql_saga.add_era('saga_repro.audited_unit', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
ALTER TABLE saga_repro.audited_unit ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_unique_key('saga_repro.audited_unit', ARRAY['id'], key_type => 'primary');

-- Insert initial data: one row spanning the full year 2024 with specific audit info
INSERT INTO saga_repro.audited_unit (id, name, status, valid_from, valid_until, edit_at_with_default, edit_by_user_id_with_default, edit_comment_nullable)
VALUES (1, 'Unit Alpha', 'active', '2024-01-01', '2025-01-01', '2024-01-15 06:30:00-08', 100, 'Initial creation');

\echo '\n--- Initial State: One row spanning full year 2024 ---'
SELECT id, name, status, valid_from, valid_until, edit_at_with_default, edit_by_user_id_with_default, edit_comment_nullable
FROM saga_repro.audited_unit
ORDER BY valid_from;

-- Create a source table to update just the middle portion (April-September)
-- This should cause a 3-way split of the timeline
CREATE TEMP TABLE source_audit_split (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id int,
    status text,
    valid_from date,
    valid_until date,
    edit_at_with_default timestamptz,
    edit_by_user_id_with_default int,
    edit_comment_nullable text
);

INSERT INTO source_audit_split (id, status, valid_from, valid_until, edit_at_with_default, edit_by_user_id_with_default, edit_comment_nullable)
VALUES (1, 'suspended', '2024-04-01', '2024-10-01', '2024-04-05 09:45:00-07', 200, 'Status update for Q2-Q3');

\echo '\n--- Source: Update middle portion (April-September) with new audit info ---'
SELECT id, status, valid_from, valid_until, edit_at_with_default, edit_by_user_id_with_default, edit_comment_nullable
FROM source_audit_split;

-- Perform the merge which will split the timeline
CALL sql_saga.temporal_merge(
    'saga_repro.audited_unit', 'source_audit_split',
    primary_identity_columns => ARRAY['id'],
    ephemeral_columns => ARRAY['edit_at_with_default', 'edit_by_user_id_with_default', 'edit_comment_nullable'],
    mode => 'MERGE_ENTITY_PATCH'
);

\echo '\n--- After Timeline Split ---'
\echo '-- Expected: 3 segments with preserved audit trail'
\echo '--   Jan-Mar:  status=active,    edit_at_with_default=2024-01-15 06:30:00-08, edit_by_user_id_with_default=100 (PRESERVED from original)'
\echo '--   Apr-Sep:  status=suspended, edit_at_with_default=2024-04-05 09:45:00-07, edit_by_user_id_with_default=200 (NEW from source)'
\echo '--   Oct-Dec:  status=active,    edit_at_with_default=2024-01-15 06:30:00-08, edit_by_user_id_with_default=100 (PRESERVED from original)'
\echo '--'
\echo '-- Test verifies: Timeline splits preserve audit trail - edge segments keep original values, middle segment uses source values'
SELECT id, name, status, valid_from, valid_until, 
       edit_at_with_default, edit_by_user_id_with_default, edit_comment_nullable
FROM saga_repro.audited_unit
ORDER BY valid_from;

ROLLBACK TO SAVEPOINT scenario_audit_column_preservation;

--------------------------------------------------------------------------------
-- SCENARIO 7: Ephemeral column with NOT NULL DEFAULT missing from source
--
-- This reproduces a regression where an ephemeral column declared in the
-- temporal_merge call but MISSING from the source view causes a NOT NULL
-- violation instead of using the column's DEFAULT value.
--
-- Use case: Audit columns like `created_at` should use their DEFAULT when
-- inserting new records, even when declared as ephemeral for timeline splits.
--------------------------------------------------------------------------------
SAVEPOINT scenario_ephemeral_missing_from_source;

\echo '\n--- SCENARIO 7: Ephemeral column with NOT NULL DEFAULT missing from source ---'

CREATE TABLE saga_repro.target_with_audit (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    key_col TEXT NOT NULL,
    data_col TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT statement_timestamp(),
    valid_from DATE NOT NULL DEFAULT CURRENT_DATE,
    valid_until DATE NOT NULL DEFAULT 'infinity'::date,
    valid_range daterange NOT NULL,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);

SELECT sql_saga.add_era('saga_repro.target_with_audit', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
SELECT sql_saga.add_unique_key('saga_repro.target_with_audit', ARRAY['key_col'], key_type => 'natural');

-- Source table intentionally OMITS created_at - should use DEFAULT
CREATE TABLE saga_repro.source_without_audit (
    row_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    key_col TEXT NOT NULL,
    data_col TEXT,
    valid_from DATE NOT NULL DEFAULT CURRENT_DATE,
    valid_until DATE NOT NULL DEFAULT 'infinity'::date
);

INSERT INTO saga_repro.source_without_audit (key_col, data_col) VALUES ('test_key', 'test_data');

GRANT ALL ON saga_repro.target_with_audit TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_without_audit TO sql_saga_unprivileged_user;

CREATE VIEW saga_repro.source_without_audit_view AS
SELECT row_id, key_col, data_col, valid_from, valid_until
FROM saga_repro.source_without_audit;

GRANT SELECT ON saga_repro.source_without_audit_view TO sql_saga_unprivileged_user;

\echo '\n--- Source view (note: no created_at column) ---'
\d saga_repro.source_without_audit_view

SET ROLE TO sql_saga_unprivileged_user;

-- This should succeed - created_at should use its DEFAULT value
CALL sql_saga.temporal_merge(
    target_table => 'saga_repro.target_with_audit'::regclass,
    source_table => 'saga_repro.source_without_audit_view'::regclass,
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['key_col'],
    mode => 'MERGE_ENTITY_REPLACE'::sql_saga.temporal_merge_mode,
    ephemeral_columns => ARRAY['created_at']
);

RESET ROLE;

\echo '\n--- Result: created_at should have DEFAULT value (not NULL) ---'
SELECT id, key_col, data_col, created_at IS NOT NULL as has_created_at, valid_from, valid_until
FROM saga_repro.target_with_audit;

ROLLBACK TO SAVEPOINT scenario_ephemeral_missing_from_source;


--------------------------------------------------------------------------------
-- SCENARIO 7b: Ephemeral column with NOT NULL DEFAULT missing from source (PATCH mode)
--
-- Same as SCENARIO 7 but using MERGE_ENTITY_PATCH mode instead of REPLACE.
-- This is critical because PATCH mode has different code paths for handling
-- payload construction and may have different behavior for missing columns.
--------------------------------------------------------------------------------
SAVEPOINT scenario_ephemeral_missing_patch;

\echo '\n--- SCENARIO 7b: Ephemeral column missing from source (MERGE_ENTITY_PATCH mode) ---'

-- Reuse the tables from scenario 7 (they were rolled back)
CREATE TABLE saga_repro.target_with_audit_patch (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    key_col TEXT NOT NULL,
    data_col TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT statement_timestamp(),
    valid_from DATE NOT NULL DEFAULT CURRENT_DATE,
    valid_until DATE NOT NULL DEFAULT 'infinity'::date,
    valid_range daterange NOT NULL,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);

SELECT sql_saga.add_era('saga_repro.target_with_audit_patch', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
SELECT sql_saga.add_unique_key('saga_repro.target_with_audit_patch', ARRAY['key_col'], key_type => 'natural');

-- Source table intentionally OMITS created_at - should use DEFAULT
CREATE TABLE saga_repro.source_without_audit_patch (
    row_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    key_col TEXT NOT NULL,
    data_col TEXT,
    valid_from DATE NOT NULL DEFAULT CURRENT_DATE,
    valid_until DATE NOT NULL DEFAULT 'infinity'::date
);

INSERT INTO saga_repro.source_without_audit_patch (key_col, data_col) VALUES ('test_key_patch', 'test_data_patch');

GRANT ALL ON saga_repro.target_with_audit_patch TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_without_audit_patch TO sql_saga_unprivileged_user;

CREATE VIEW saga_repro.source_without_audit_patch_view AS
SELECT row_id, key_col, data_col, valid_from, valid_until
FROM saga_repro.source_without_audit_patch;

GRANT SELECT ON saga_repro.source_without_audit_patch_view TO sql_saga_unprivileged_user;

\echo '\n--- Source view (note: no created_at column) ---'
\d saga_repro.source_without_audit_patch_view

SET ROLE TO sql_saga_unprivileged_user;

-- This should succeed with PATCH mode - created_at should use its DEFAULT value
CALL sql_saga.temporal_merge(
    target_table => 'saga_repro.target_with_audit_patch'::regclass,
    source_table => 'saga_repro.source_without_audit_patch_view'::regclass,
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['key_col'],
    mode => 'MERGE_ENTITY_PATCH'::sql_saga.temporal_merge_mode,
    ephemeral_columns => ARRAY['created_at']
);

RESET ROLE;

\echo '\n--- Result: created_at should have DEFAULT value (not NULL) with PATCH mode ---'
SELECT id, key_col, data_col, created_at IS NOT NULL as has_created_at, valid_from, valid_until
FROM saga_repro.target_with_audit_patch;

ROLLBACK TO SAVEPOINT scenario_ephemeral_missing_patch;


--------------------------------------------------------------------------------
-- SCENARIO 7c: Multiple ephemeral columns - some present, one missing from source
--
-- This reproduces the exact STATBUS pattern where:
-- - Multiple ephemeral columns are declared: edit_by_user_id, edit_at, edit_comment, created_at
-- - Source view includes: edit_by_user_id, edit_at, edit_comment (present)
-- - Source view OMITS: created_at (missing - should use DEFAULT)
--
-- This is a critical edge case where the mix of present and missing ephemeral
-- columns may cause different behavior than when all are missing.
--------------------------------------------------------------------------------
SAVEPOINT scenario_ephemeral_mixed;

\echo '\n--- SCENARIO 7c: Multiple ephemeral columns - some present, one missing ---'

CREATE TABLE saga_repro.target_mixed_ephemeral (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    stat_definition_id INTEGER NOT NULL,
    legal_unit_id INTEGER,
    establishment_id INTEGER,
    value_int INTEGER,
    created_at TIMESTAMPTZ NOT NULL DEFAULT statement_timestamp(),
    edit_by_user_id INTEGER NOT NULL,
    edit_at TIMESTAMPTZ NOT NULL DEFAULT statement_timestamp(),
    edit_comment TEXT,
    valid_from DATE NOT NULL DEFAULT CURRENT_DATE,
    valid_until DATE NOT NULL DEFAULT 'infinity'::date,
    valid_range daterange NOT NULL,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);

SELECT sql_saga.add_era('saga_repro.target_mixed_ephemeral', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
SELECT sql_saga.add_unique_key('saga_repro.target_mixed_ephemeral', ARRAY['stat_definition_id', 'legal_unit_id', 'establishment_id'], key_type => 'natural');

-- Source table: includes edit_by_user_id, edit_at, edit_comment but OMITS created_at
CREATE TABLE saga_repro.source_mixed_ephemeral (
    row_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    stat_definition_id INTEGER NOT NULL,
    legal_unit_id INTEGER,
    establishment_id INTEGER,
    value_int INTEGER,
    -- created_at intentionally OMITTED - should use DEFAULT
    edit_by_user_id INTEGER NOT NULL,
    edit_at TIMESTAMPTZ NOT NULL,
    edit_comment TEXT,
    valid_from DATE NOT NULL DEFAULT CURRENT_DATE,
    valid_until DATE NOT NULL DEFAULT 'infinity'::date
);

INSERT INTO saga_repro.source_mixed_ephemeral 
    (stat_definition_id, legal_unit_id, establishment_id, value_int, edit_by_user_id, edit_at, edit_comment)
VALUES 
    (1, 100, NULL, 42, 999, '2025-01-15 10:00:00+00', 'Test import');

GRANT ALL ON saga_repro.target_mixed_ephemeral TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_mixed_ephemeral TO sql_saga_unprivileged_user;

CREATE VIEW saga_repro.source_mixed_ephemeral_view AS
SELECT row_id, stat_definition_id, legal_unit_id, establishment_id, value_int,
       edit_by_user_id, edit_at, edit_comment, valid_from, valid_until
FROM saga_repro.source_mixed_ephemeral;

GRANT SELECT ON saga_repro.source_mixed_ephemeral_view TO sql_saga_unprivileged_user;

\echo '\n--- Source view (note: has edit_* columns but NO created_at) ---'
\d saga_repro.source_mixed_ephemeral_view

SET ROLE TO sql_saga_unprivileged_user;

-- This should succeed - created_at should use DEFAULT, other ephemeral cols from source
CALL sql_saga.temporal_merge(
    target_table => 'saga_repro.target_mixed_ephemeral'::regclass,
    source_table => 'saga_repro.source_mixed_ephemeral_view'::regclass,
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['stat_definition_id', 'legal_unit_id', 'establishment_id'],
    mode => 'MERGE_ENTITY_REPLACE'::sql_saga.temporal_merge_mode,
    ephemeral_columns => ARRAY['edit_comment', 'edit_by_user_id', 'edit_at', 'created_at']
);

RESET ROLE;

\echo '\n--- Result: created_at should have DEFAULT, edit_* from source ---'
SELECT id, stat_definition_id, legal_unit_id, value_int,
       created_at IS NOT NULL as has_created_at,
       edit_by_user_id, edit_at, edit_comment
FROM saga_repro.target_mixed_ephemeral;

ROLLBACK TO SAVEPOINT scenario_ephemeral_mixed;


--------------------------------------------------------------------------------
-- SCENARIO 7d: Multiple source rows with ephemeral column missing from source
--
-- This tests the STATBUS pattern with multiple source rows for the same entity
-- across different time periods, all processed in one batch. The created_at
-- column is missing from source but should use DEFAULT for all inserted rows.
--------------------------------------------------------------------------------
SAVEPOINT scenario_ephemeral_batch;

\echo '\n--- SCENARIO 7d: Multiple source rows - ephemeral column missing ---'

CREATE TABLE saga_repro.target_batch_ephemeral (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    stat_definition_id INTEGER NOT NULL,
    establishment_id INTEGER NOT NULL,
    value_int INTEGER,
    created_at TIMESTAMPTZ NOT NULL DEFAULT statement_timestamp(),
    edit_by_user_id INTEGER NOT NULL,
    edit_at TIMESTAMPTZ NOT NULL DEFAULT statement_timestamp(),
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL DEFAULT 'infinity'::date,
    valid_range daterange NOT NULL,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);

SELECT sql_saga.add_era('saga_repro.target_batch_ephemeral', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
SELECT sql_saga.add_unique_key('saga_repro.target_batch_ephemeral', ARRAY['stat_definition_id', 'establishment_id'], key_type => 'natural');

-- Source with multiple rows for same entity across different time periods
-- Note: created_at is OMITTED from source
CREATE TABLE saga_repro.source_batch_ephemeral (
    row_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    stat_definition_id INTEGER NOT NULL,
    establishment_id INTEGER NOT NULL,
    value_int INTEGER,
    edit_by_user_id INTEGER NOT NULL,
    edit_at TIMESTAMPTZ NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL
);

-- Insert 3 rows with different entity keys to test batch insert without timeline overlap issues
-- Each row is for a different establishment_id, so no timeline conflicts
INSERT INTO saga_repro.source_batch_ephemeral 
    (stat_definition_id, establishment_id, value_int, edit_by_user_id, edit_at, valid_from, valid_until)
VALUES 
    (1, 101, 10, 999, '2025-01-15 10:00:00+00', '2020-01-01', 'infinity'),
    (1, 102, 20, 999, '2025-01-15 10:00:00+00', '2020-01-01', 'infinity'),
    (1, 103, 30, 999, '2025-01-15 10:00:00+00', '2020-01-01', 'infinity');

GRANT ALL ON saga_repro.target_batch_ephemeral TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_batch_ephemeral TO sql_saga_unprivileged_user;

CREATE VIEW saga_repro.source_batch_ephemeral_view AS
SELECT row_id, stat_definition_id, establishment_id, value_int,
       edit_by_user_id, edit_at, valid_from, valid_until
FROM saga_repro.source_batch_ephemeral;

GRANT SELECT ON saga_repro.source_batch_ephemeral_view TO sql_saga_unprivileged_user;

\echo '\n--- Source: 3 rows for different entities ---'
SELECT row_id, stat_definition_id, establishment_id, value_int, valid_from, valid_until 
FROM saga_repro.source_batch_ephemeral ORDER BY establishment_id;

SET ROLE TO sql_saga_unprivileged_user;

-- Process all 10 rows in one batch - created_at should use DEFAULT for all
CALL sql_saga.temporal_merge(
    target_table => 'saga_repro.target_batch_ephemeral'::regclass,
    source_table => 'saga_repro.source_batch_ephemeral_view'::regclass,
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['stat_definition_id', 'establishment_id'],
    mode => 'MERGE_ENTITY_REPLACE'::sql_saga.temporal_merge_mode,
    ephemeral_columns => ARRAY['edit_by_user_id', 'edit_at', 'created_at']
);

RESET ROLE;

\echo '\n--- Result: All rows should have created_at with DEFAULT value ---'
SELECT id, stat_definition_id, establishment_id, value_int,
       created_at IS NOT NULL as has_created_at,
       valid_from, valid_until
FROM saga_repro.target_batch_ephemeral
ORDER BY valid_from;

ROLLBACK TO SAVEPOINT scenario_ephemeral_batch;


--------------------------------------------------------------------------------
-- SCENARIO 7e: TEMP VIEW source with ephemeral column missing (STATBUS pattern)
--
-- This exactly reproduces the STATBUS pattern:
-- - Source is a TEMP VIEW (not a regular table or view)
-- - The TEMP VIEW omits created_at column
-- - created_at is declared as ephemeral
-- - created_at has NOT NULL DEFAULT statement_timestamp()
--
-- The source view introspection via pg_attribute might behave differently for
-- temp views vs regular views/tables.
--------------------------------------------------------------------------------
SAVEPOINT scenario_temp_view_source;

\echo '\n--- SCENARIO 7e: TEMP VIEW source with ephemeral column missing ---'

CREATE TABLE saga_repro.target_temp_view_test (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    stat_definition_id INTEGER NOT NULL,
    legal_unit_id INTEGER,
    establishment_id INTEGER,
    value_int INTEGER,
    created_at TIMESTAMPTZ NOT NULL DEFAULT statement_timestamp(),
    edit_by_user_id INTEGER NOT NULL,
    edit_at TIMESTAMPTZ NOT NULL DEFAULT statement_timestamp(),
    edit_comment TEXT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL DEFAULT 'infinity'::date,
    valid_range daterange NOT NULL,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);

SELECT sql_saga.add_era('saga_repro.target_temp_view_test', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
SELECT sql_saga.add_unique_key('saga_repro.target_temp_view_test', ARRAY['stat_definition_id', 'legal_unit_id', 'establishment_id'], key_type => 'natural');

GRANT ALL ON saga_repro.target_temp_view_test TO sql_saga_unprivileged_user;

-- Base table for the temp view
CREATE TEMP TABLE temp_source_data (
    row_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    founding_row_id INTEGER,
    id INTEGER,
    stat_definition_id INTEGER NOT NULL,
    legal_unit_id INTEGER,
    establishment_id INTEGER,
    value_int INTEGER,
    -- created_at intentionally OMITTED - this is the key!
    edit_by_user_id INTEGER NOT NULL,
    edit_at TIMESTAMPTZ NOT NULL,
    edit_comment TEXT,
    valid_from DATE NOT NULL,
    valid_to DATE,
    valid_until DATE NOT NULL DEFAULT 'infinity'::date,
    errors JSONB DEFAULT '{}'::jsonb,
    merge_status JSONB DEFAULT '{}'::jsonb
);

INSERT INTO temp_source_data 
    (founding_row_id, stat_definition_id, legal_unit_id, establishment_id, value_int, edit_by_user_id, edit_at, valid_from, valid_until)
VALUES 
    (1, 1, 100, NULL, 42, 999, '2025-01-15 10:00:00+00', '2020-01-01', 'infinity');

-- Create TEMP VIEW exactly like STATBUS does
CREATE OR REPLACE TEMP VIEW temp_stat_source_view AS
SELECT
    row_id,
    founding_row_id,
    id,
    legal_unit_id,
    establishment_id,
    stat_definition_id,
    value_int,
    NULL::INTEGER AS value_float,
    NULL::BOOLEAN AS value_bool,
    NULL::TEXT AS value_string,
    valid_from, valid_to, valid_until,
    NULL::INTEGER AS data_source_id,
    edit_by_user_id, edit_at, edit_comment,
    errors, merge_status
FROM temp_source_data;

-- Grant access to the temp view
GRANT SELECT ON temp_stat_source_view TO sql_saga_unprivileged_user;
GRANT ALL ON temp_source_data TO sql_saga_unprivileged_user;

\echo '\n--- TEMP VIEW columns (note: no created_at column) ---'
SELECT column_name FROM information_schema.columns 
WHERE table_name = 'temp_stat_source_view' 
ORDER BY ordinal_position;

-- NOTE: Not switching to unprivileged user because temp views have ownership issues.
-- This test focuses on the core functionality: ephemeral column handling with temp views.

-- This should succeed - created_at should use DEFAULT
CALL sql_saga.temporal_merge(
    target_table => 'saga_repro.target_temp_view_test'::regclass,
    source_table => 'temp_stat_source_view'::regclass,
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['stat_definition_id', 'legal_unit_id', 'establishment_id'],
    mode => 'MERGE_ENTITY_REPLACE'::sql_saga.temporal_merge_mode,
    row_id_column => 'row_id',
    founding_id_column => 'founding_row_id',
    update_source_with_identity => true,
    update_source_with_feedback => true,
    feedback_status_column => 'merge_status',
    feedback_status_key => 'stat_test',
    feedback_error_column => 'errors',
    feedback_error_key => 'stat_test',
    ephemeral_columns => ARRAY['edit_comment', 'edit_by_user_id', 'edit_at', 'created_at']
);

\echo '\n--- Result: created_at should have DEFAULT value ---'
SELECT id, stat_definition_id, legal_unit_id, value_int,
       created_at IS NOT NULL as has_created_at,
       edit_by_user_id, edit_at
FROM saga_repro.target_temp_view_test;

ROLLBACK TO SAVEPOINT scenario_temp_view_source;


--------------------------------------------------------------------------------
-- SCENARIO 7f: STATBUS Exact Reproduction Attempt
--
-- Attempts to reproduce the failure seen in STATBUS where:
-- - Target has created_at with DEFAULT
-- - Source is a TEMP VIEW omitting created_at
-- - founding_id_column IS USED (key difference!)
-- - Mode is MERGE_ENTITY_REPLACE
--------------------------------------------------------------------------------
SAVEPOINT scenario_statbus_repro;

\echo '\n--- SCENARIO 7f: STATBUS Exact Reproduction (Temp View + Founding ID) ---'

CREATE TABLE saga_repro.target_statbus (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    stat_definition_id INTEGER NOT NULL,
    legal_unit_id INTEGER,
    establishment_id INTEGER,
    value_int INTEGER,
    created_at TIMESTAMPTZ NOT NULL DEFAULT statement_timestamp(),
    edit_by_user_id INTEGER NOT NULL,
    edit_at TIMESTAMPTZ NOT NULL DEFAULT statement_timestamp(),
    edit_comment TEXT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL DEFAULT 'infinity'::date,
    valid_range daterange NOT NULL,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);

SELECT sql_saga.add_era('saga_repro.target_statbus', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
SELECT sql_saga.add_unique_key('saga_repro.target_statbus', ARRAY['stat_definition_id', 'legal_unit_id', 'establishment_id'], key_type => 'natural');

GRANT ALL ON saga_repro.target_statbus TO sql_saga_unprivileged_user;

-- Base table for the temp view
CREATE TEMP TABLE temp_source_data_sb (
    row_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    founding_row_id INTEGER,
    id INTEGER,
    stat_definition_id INTEGER NOT NULL,
    legal_unit_id INTEGER,
    establishment_id INTEGER,
    value_int INTEGER,
    -- created_at intentionally OMITTED
    edit_by_user_id INTEGER NOT NULL,
    edit_at TIMESTAMPTZ NOT NULL,
    edit_comment TEXT,
    valid_from DATE NOT NULL,
    valid_to DATE,
    valid_until DATE NOT NULL DEFAULT 'infinity'::date,
    errors JSONB DEFAULT '{}'::jsonb,
    merge_status JSONB DEFAULT '{}'::jsonb
);

INSERT INTO temp_source_data_sb 
    (founding_row_id, stat_definition_id, legal_unit_id, establishment_id, value_int, edit_by_user_id, edit_at, valid_from, valid_until)
VALUES 
    (1, 1, 100, NULL, 42, 999, '2025-01-15 10:00:00+00', '2020-01-01', 'infinity');

-- Create TEMP VIEW exactly like STATBUS does
CREATE OR REPLACE TEMP VIEW temp_stat_source_view_sb AS
SELECT
    row_id,
    founding_row_id,
    id,
    legal_unit_id,
    establishment_id,
    stat_definition_id,
    value_int,
    NULL::INTEGER AS value_float,
    NULL::BOOLEAN AS value_bool,
    NULL::TEXT AS value_string,
    valid_from, valid_to, valid_until,
    NULL::INTEGER AS data_source_id,
    edit_by_user_id, edit_at, edit_comment,
    errors, merge_status
FROM temp_source_data_sb;

-- Note: We run as superuser here because temp views created in the session
-- are owned by the session user. In STATBUS, the import function runs as the
-- same user who created the temp views, so permissions work.
-- This test focuses on the DEFAULT handling, not permissions.

-- This should succeed - created_at should use DEFAULT
CALL sql_saga.temporal_merge(
    target_table => 'saga_repro.target_statbus'::regclass,
    source_table => 'temp_stat_source_view_sb'::regclass,
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['stat_definition_id', 'legal_unit_id', 'establishment_id'],
    mode => 'MERGE_ENTITY_REPLACE'::sql_saga.temporal_merge_mode,
    row_id_column => 'row_id',
    founding_id_column => 'founding_row_id',
    update_source_with_identity => true,
    update_source_with_feedback => true,
    feedback_status_column => 'merge_status',
    feedback_status_key => 'stat_test',
    feedback_error_column => 'errors',
    feedback_error_key => 'stat_test',
    ephemeral_columns => ARRAY['edit_comment', 'edit_by_user_id', 'edit_at', 'created_at']
);

\echo '\n--- Result 7f: created_at should have DEFAULT value ---'
SELECT id, stat_definition_id, legal_unit_id, value_int,
       created_at IS NOT NULL as has_created_at,
       edit_by_user_id, edit_at
FROM saga_repro.target_statbus;

ROLLBACK TO SAVEPOINT scenario_statbus_repro;


--------------------------------------------------------------------------------
-- SCENARIO 7g: Step 1.3 Path - Multiple time periods for NEW entity
--
-- This reproduces a bug where temporal_merge fails when:
-- 1. A target table has a column with NOT NULL DEFAULT (e.g., created_at)
-- 2. The column is listed in ephemeral_columns
-- 3. The source omits this column
-- 4. Multiple source rows exist for the SAME NEW entity (different time periods)
--
-- The fix in commit 143c7a8 only applied COALESCE to:
-- - Stage 1.1: Founding INSERT (v_founding_all_cols_from_jsonb) 
-- - Stage 2: Non-founding INSERT for existing entities (v_all_cols_from_jsonb)
--
-- But NOT to:
-- - Step 1.3: Remaining historical slices for NEW entities (v_all_cols_select)
--
-- This test demonstrates the bug by having 3 rows for the same NEW entity.
-- Row 1 (founding_row_id=1) works via Stage 1.1.
-- Rows 2-3 fail via Step 1.3 because v_all_cols_select uses jpr_all.created_at
-- directly without COALESCE, and jsonb_populate_record returns NULL for
-- missing keys in the payload.
--------------------------------------------------------------------------------
SAVEPOINT scenario_step13_path;

\echo '\n--- SCENARIO 7g: Step 1.3 Path - Multiple time periods for NEW entity ---'

CREATE TABLE saga_repro.target_step13 (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    stat_definition_id INTEGER NOT NULL,
    establishment_id INTEGER NOT NULL,
    value_int INTEGER,
    -- THE KEY COLUMNS: NOT NULL with DEFAULT
    created_at TIMESTAMPTZ NOT NULL DEFAULT statement_timestamp(),
    edit_by_user_id INTEGER NOT NULL,
    edit_at TIMESTAMPTZ NOT NULL DEFAULT statement_timestamp(),
    -- Temporal columns
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    valid_range daterange NOT NULL,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);

SELECT sql_saga.add_era('saga_repro.target_step13', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
SELECT sql_saga.add_unique_key('saga_repro.target_step13', 
    ARRAY['stat_definition_id', 'establishment_id'], 
    key_type => 'natural');

-- Create source table - NOTE: created_at is OMITTED (not present at all)
CREATE TABLE saga_repro.source_step13 (
    row_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    founding_row_id INTEGER,
    id INTEGER,
    establishment_id INTEGER NOT NULL,
    stat_definition_id INTEGER NOT NULL,
    value_int INTEGER,
    edit_by_user_id INTEGER NOT NULL,
    edit_at TIMESTAMPTZ NOT NULL DEFAULT statement_timestamp(),
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    errors JSONB DEFAULT '{}',
    merge_status JSONB DEFAULT '{}'
);

-- Insert 3 rows for the SAME NEW entity with different time periods
-- All have founding_row_id=1 indicating they belong to the same entity
INSERT INTO saga_repro.source_step13 
    (founding_row_id, stat_definition_id, establishment_id, value_int, edit_by_user_id, valid_from, valid_until)
VALUES 
    (1, 1, 1, 10, 999, '2020-01-01', '2021-01-01'),  -- Row 1: founding row (will use Stage 1.1)
    (1, 1, 1, 20, 999, '2021-01-01', '2022-01-01'),  -- Row 2: non-founding (will use Step 1.3) 
    (1, 1, 1, 30, 999, '2022-01-01', 'infinity');    -- Row 3: non-founding (will use Step 1.3)

-- Create view without created_at column
CREATE VIEW saga_repro.source_step13_view AS
SELECT row_id, founding_row_id, id, establishment_id, stat_definition_id,
       value_int, edit_by_user_id, edit_at, valid_from, valid_until,
       errors, merge_status
FROM saga_repro.source_step13;

\echo '\n--- Source data: 3 rows for same entity (founding_row_id=1) ---'
SELECT row_id, founding_row_id, stat_definition_id, establishment_id, value_int, valid_from, valid_until
FROM saga_repro.source_step13_view
ORDER BY row_id;

-- Note: We run as superuser here because views require special permission handling
-- for updates. This test focuses on the DEFAULT handling, not permissions.

-- This should succeed - all 3 rows should get created_at via DEFAULT
-- Row 1 uses Stage 1.1 (founding insert) - already fixed
-- Rows 2-3 use Step 1.3 (historical slices) - THIS IS THE BUG PATH
CALL sql_saga.temporal_merge(
    target_table => 'saga_repro.target_step13'::regclass,
    source_table => 'saga_repro.source_step13_view'::regclass,
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['stat_definition_id', 'establishment_id'],
    mode => 'MERGE_ENTITY_REPLACE'::sql_saga.temporal_merge_mode,
    row_id_column => 'row_id',
    founding_id_column => 'founding_row_id',
    update_source_with_identity => true,
    update_source_with_feedback => true,
    feedback_status_column => 'merge_status',
    feedback_status_key => 'test_stat',
    feedback_error_column => 'errors',
    feedback_error_key => 'test_stat',
    ephemeral_columns => ARRAY['created_at', 'edit_by_user_id', 'edit_at']
);

\echo '\n--- Result 7g: All 3 rows should have created_at (has_created_at = true) ---'
SELECT id, stat_definition_id, establishment_id, value_int, 
       created_at IS NOT NULL as has_created_at,
       edit_by_user_id, valid_from, valid_until
FROM saga_repro.target_step13
ORDER BY valid_from;

ROLLBACK TO SAVEPOINT scenario_step13_path;


--------------------------------------------------------------------------------
-- SCENARIO 8: Timeline split must preserve history for defaulted columns
--
-- This reproduces a regression where timeline splits (e.g., from an update in the
-- middle of a validity range) caused columns with DEFAULT values to revert to their
-- default, instead of preserving the historical value from the original row.
--
-- Case:
-- 1. Target row has `business_col = 'PRESERVED'` (Default is 'DEFAULT').
-- 2. Source updates `other_col` for a sub-range (e.g., Apr-Dec).
-- 3. The timeline splits. The new segment must keep `business_col = 'PRESERVED'`.
--------------------------------------------------------------------------------
SAVEPOINT scenario_default_column_preservation;

\echo '\n--- SCENARIO 8: Timeline split must preserve history for defaulted columns ---'

CREATE TABLE saga_repro.target_default_preservation (
    id int GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL,
    business_col text NOT NULL DEFAULT 'default_value', 
    other_col text,
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_until date,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);

SELECT sql_saga.add_era('saga_repro.target_default_preservation', 'valid_range', 
    valid_from_column_name => 'valid_from', 
    valid_until_column_name => 'valid_until');
SELECT sql_saga.add_unique_key('saga_repro.target_default_preservation', ARRAY['name'], key_type => 'natural');

GRANT ALL ON saga_repro.target_default_preservation TO sql_saga_unprivileged_user;

-- Insert initial data (Period 1)
INSERT INTO saga_repro.target_default_preservation (name, business_col, other_col, valid_from, valid_until)
VALUES ('TestEntity', 'PRESERVED_VALUE', 'old_val', '2023-01-01', '2024-01-01');

\echo '\n--- Initial State: One row with non-default value ---'
SELECT name, business_col, other_col, valid_from, valid_until FROM saga_repro.target_default_preservation;

CREATE TABLE saga_repro.source_default_preservation (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text,
    other_col text,
    valid_from date,
    valid_until date
);

-- Update 'other_col' in the middle of the range
INSERT INTO saga_repro.source_default_preservation (name, other_col, valid_from, valid_until)
VALUES ('TestEntity', 'new_val', '2023-06-01', '2024-01-01');

GRANT ALL ON saga_repro.source_default_preservation TO sql_saga_unprivileged_user;

CREATE VIEW saga_repro.source_default_preservation_view AS 
SELECT row_id, name, other_col, valid_from, valid_until FROM saga_repro.source_default_preservation;

GRANT SELECT ON saga_repro.source_default_preservation_view TO sql_saga_unprivileged_user;

SET ROLE TO sql_saga_unprivileged_user;

-- Execute merge
-- 'business_col' is MISSING from source.
-- We verify that the split segment preserves 'PRESERVED_VALUE'.
CALL sql_saga.temporal_merge(
    'saga_repro.target_default_preservation', 
    'saga_repro.source_default_preservation_view', 
    natural_identity_columns => ARRAY['name'],
    mode => 'MERGE_ENTITY_PATCH'
);

RESET ROLE;

\echo '\n--- Final State: Split timeline, value preserved in new segment ---'
SELECT name, business_col, other_col, valid_from, valid_until 
FROM saga_repro.target_default_preservation 
ORDER BY valid_from;

ROLLBACK TO SAVEPOINT scenario_default_column_preservation;


--------------------------------------------------------------------------------
-- SCENARIO 8b: Timeline split must preserve EPHEMERAL column values
--
-- This tests YOUR HYPOTHESIS: On a split, an ephemeral column's DEFAULT
-- is being used instead of preserving the existing value from the original row.
--
-- Case:
-- 1. Target row has `created_at = '2020-01-01 00:00:00'` (a known historical value)
-- 2. `created_at` is declared as EPHEMERAL (so source doesn't provide it)
-- 3. Source updates some other value for a sub-range, causing a timeline SPLIT
-- 4. The split segments MUST preserve `created_at = '2020-01-01'`, NOT use DEFAULT
--
-- If the bug exists, the split segments would have `created_at = statement_timestamp()`
-- instead of preserving the original '2020-01-01' value.
--------------------------------------------------------------------------------
SAVEPOINT scenario_ephemeral_column_split;

\echo '\n--- SCENARIO 8b: Timeline split must preserve EPHEMERAL column values ---'

CREATE TABLE saga_repro.target_ephemeral_split (
    id int GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL,
    value_col text,
    created_at timestamptz NOT NULL DEFAULT statement_timestamp(),
    edit_by_user_id int NOT NULL,
    edit_at timestamptz NOT NULL DEFAULT statement_timestamp(),
    edit_comment text,
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_until date,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);

SELECT sql_saga.add_era('saga_repro.target_ephemeral_split', 'valid_range', 
    valid_from_column_name => 'valid_from', 
    valid_until_column_name => 'valid_until');
SELECT sql_saga.add_unique_key('saga_repro.target_ephemeral_split', ARRAY['name'], key_type => 'natural');

GRANT ALL ON saga_repro.target_ephemeral_split TO sql_saga_unprivileged_user;

-- Insert initial data with a KNOWN created_at value (not DEFAULT)
INSERT INTO saga_repro.target_ephemeral_split 
    (name, value_col, created_at, edit_by_user_id, edit_at, valid_from, valid_until)
VALUES 
    ('TestEntity', 'original', '2020-01-01 00:00:00+00', 1, '2020-01-01 00:00:00+00', '2023-01-01', '2024-01-01');

\echo '\n--- Initial State: One row with known created_at=2020-01-01 ---'
SELECT name, value_col, created_at, edit_by_user_id, valid_from, valid_until 
FROM saga_repro.target_ephemeral_split;

-- Source table: provides edit columns but NOT created_at
CREATE TABLE saga_repro.source_ephemeral_split (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text,
    value_col text,
    -- created_at intentionally OMITTED - it's ephemeral
    edit_by_user_id int NOT NULL,
    edit_at timestamptz NOT NULL,
    edit_comment text,
    valid_from date,
    valid_to date,
    valid_until date
);

-- Update 'value_col' in the MIDDLE of the range, causing a SPLIT
INSERT INTO saga_repro.source_ephemeral_split 
    (name, value_col, edit_by_user_id, edit_at, valid_from, valid_to, valid_until)
VALUES 
    ('TestEntity', 'updated', 999, '2025-01-15 10:00:00+00', '2023-06-01', '2023-08-31', '2023-09-01');

GRANT ALL ON saga_repro.source_ephemeral_split TO sql_saga_unprivileged_user;

-- Create view that matches source table structure
CREATE VIEW saga_repro.source_ephemeral_split_view AS 
SELECT row_id, name, value_col, edit_by_user_id, edit_at, edit_comment, valid_from, valid_to, valid_until
FROM saga_repro.source_ephemeral_split;

GRANT SELECT ON saga_repro.source_ephemeral_split_view TO sql_saga_unprivileged_user;

\echo '\n--- Source: Update in middle of range (should cause split) ---'
TABLE saga_repro.source_ephemeral_split;

SET ROLE TO sql_saga_unprivileged_user;

-- Execute merge with created_at as EPHEMERAL
-- The source does NOT provide created_at, so it should be preserved from existing rows
CALL sql_saga.temporal_merge(
    'saga_repro.target_ephemeral_split', 
    'saga_repro.source_ephemeral_split_view', 
    natural_identity_columns => ARRAY['name'],
    mode => 'MERGE_ENTITY_PATCH',
    ephemeral_columns => ARRAY['created_at', 'edit_by_user_id', 'edit_at', 'edit_comment']
);

RESET ROLE;

\echo '\n--- Final State: Split timeline ---'
\echo '--- CRITICAL: ALL segments must have created_at = 2020-01-01, NOT statement_timestamp() ---'
SELECT name, value_col, 
       created_at,
       (created_at = '2020-01-01 00:00:00+00'::timestamptz) as created_at_preserved,
       edit_by_user_id, 
       valid_from, valid_until 
FROM saga_repro.target_ephemeral_split 
ORDER BY valid_from;

-- Verify no segment has a DEFAULT-generated created_at
\echo '\n--- Verification: Count of rows with preserved created_at ---'
SELECT 
    count(*) as total_rows,
    count(*) FILTER (WHERE created_at = '2020-01-01 00:00:00+00'::timestamptz) as preserved_count,
    count(*) FILTER (WHERE created_at <> '2020-01-01 00:00:00+00'::timestamptz) as default_used_count
FROM saga_repro.target_ephemeral_split;

ROLLBACK TO SAVEPOINT scenario_ephemeral_column_split;


--------------------------------------------------------------------------------
-- SCENARIO 8c: Timeline split with MERGE_ENTITY_REPLACE mode
--
-- Same as 8b but using MERGE_ENTITY_REPLACE mode which STATBUS uses.
-- This mode differs from PATCH - it replaces data rather than patching.
--------------------------------------------------------------------------------
SAVEPOINT scenario_ephemeral_replace_split;

\echo '\n--- SCENARIO 8c: MERGE_ENTITY_REPLACE split must preserve EPHEMERAL column values ---'

CREATE TABLE saga_repro.target_ephemeral_replace (
    id int GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL,
    value_col text,
    created_at timestamptz NOT NULL DEFAULT statement_timestamp(),
    edit_by_user_id int NOT NULL,
    edit_at timestamptz NOT NULL DEFAULT statement_timestamp(),
    edit_comment text,
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_until date,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);

SELECT sql_saga.add_era('saga_repro.target_ephemeral_replace', 'valid_range', 
    valid_from_column_name => 'valid_from', 
    valid_until_column_name => 'valid_until');
SELECT sql_saga.add_unique_key('saga_repro.target_ephemeral_replace', ARRAY['name'], key_type => 'natural');

GRANT ALL ON saga_repro.target_ephemeral_replace TO sql_saga_unprivileged_user;

-- Insert initial data with a KNOWN created_at value (not DEFAULT)
INSERT INTO saga_repro.target_ephemeral_replace 
    (name, value_col, created_at, edit_by_user_id, edit_at, valid_from, valid_until)
VALUES 
    ('TestEntity', 'original', '2020-01-01 00:00:00+00', 1, '2020-01-01 00:00:00+00', '2023-01-01', '2024-01-01');

\echo '\n--- Initial State: One row with known created_at=2020-01-01 ---'
SELECT name, value_col, created_at, edit_by_user_id, valid_from, valid_until 
FROM saga_repro.target_ephemeral_replace;

-- Source table: provides edit columns but NOT created_at
CREATE TABLE saga_repro.source_ephemeral_replace (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text,
    value_col text,
    -- created_at intentionally OMITTED - it's ephemeral
    edit_by_user_id int NOT NULL,
    edit_at timestamptz NOT NULL,
    edit_comment text,
    valid_from date,
    valid_to date,
    valid_until date
);

-- Update 'value_col' in the MIDDLE of the range, causing a SPLIT
INSERT INTO saga_repro.source_ephemeral_replace 
    (name, value_col, edit_by_user_id, edit_at, valid_from, valid_to, valid_until)
VALUES 
    ('TestEntity', 'updated', 999, '2025-01-15 10:00:00+00', '2023-06-01', '2023-08-31', '2023-09-01');

GRANT ALL ON saga_repro.source_ephemeral_replace TO sql_saga_unprivileged_user;

CREATE VIEW saga_repro.source_ephemeral_replace_view AS 
SELECT row_id, name, value_col, edit_by_user_id, edit_at, edit_comment, valid_from, valid_to, valid_until
FROM saga_repro.source_ephemeral_replace;

GRANT SELECT ON saga_repro.source_ephemeral_replace_view TO sql_saga_unprivileged_user;

\echo '\n--- Source: Update in middle of range (should cause split) ---'
TABLE saga_repro.source_ephemeral_replace;

SET ROLE TO sql_saga_unprivileged_user;

-- Execute merge with MERGE_ENTITY_REPLACE mode (what STATBUS uses)
CALL sql_saga.temporal_merge(
    'saga_repro.target_ephemeral_replace', 
    'saga_repro.source_ephemeral_replace_view', 
    natural_identity_columns => ARRAY['name'],
    mode => 'MERGE_ENTITY_REPLACE',
    ephemeral_columns => ARRAY['created_at', 'edit_by_user_id', 'edit_at', 'edit_comment']
);

RESET ROLE;

\echo '\n--- Final State (MERGE_ENTITY_REPLACE): Split timeline ---'
\echo '--- CRITICAL: ALL segments must have created_at = 2020-01-01, NOT statement_timestamp() ---'
SELECT name, value_col, 
       created_at,
       (created_at = '2020-01-01 00:00:00+00'::timestamptz) as created_at_preserved,
       edit_by_user_id, 
       valid_from, valid_until 
FROM saga_repro.target_ephemeral_replace 
ORDER BY valid_from;

\echo '\n--- Verification: Count of rows with preserved created_at ---'
SELECT 
    count(*) as total_rows,
    count(*) FILTER (WHERE created_at = '2020-01-01 00:00:00+00'::timestamptz) as preserved_count,
    count(*) FILTER (WHERE created_at <> '2020-01-01 00:00:00+00'::timestamptz) as default_used_count
FROM saga_repro.target_ephemeral_replace;

ROLLBACK TO SAVEPOINT scenario_ephemeral_replace_split;

-- ============================================================================
-- SCENARIO 9: NULL natural key column causes lookup failure
-- ============================================================================
-- Bug: When a natural key column is NULLABLE and NULL in both source and target,
-- the join condition `source.col = target.col` evaluates to NULL (not TRUE).
-- This causes the entity lookup to fail, resulting in DELETE + INSERT instead
-- of an UPDATE that shrinks the existing range.
--
-- Reported: 2026-01-21
-- Root cause: v_source_rows_exists_join_expr used simple `=` for nullable columns.
--             Fix: Use `(a = b OR (a IS NULL AND b IS NULL))` for nullable columns.
-- ============================================================================

\echo '\n==========================================================='
\echo 'SCENARIO 9: NULL natural key column causes entity lookup failure'
\echo '==========================================================='

SAVEPOINT scenario_null_natural_key;

CREATE TABLE saga_repro.target_null_nk (
    id int GENERATED BY DEFAULT AS IDENTITY,
    legal_unit_id int,
    establishment_id int,  -- This column will be NULL in both source and target
    type text NOT NULL,
    category_id int NOT NULL,
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_to date,
    valid_until date,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);

SELECT sql_saga.add_era('saga_repro.target_null_nk', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
SELECT sql_saga.add_unique_key('saga_repro.target_null_nk', ARRAY['legal_unit_id', 'establishment_id', 'type'], key_type => 'natural');

GRANT ALL ON saga_repro.target_null_nk TO sql_saga_unprivileged_user;

-- Insert existing entity with NULL establishment_id
INSERT INTO saga_repro.target_null_nk (legal_unit_id, establishment_id, type, category_id, valid_from, valid_until)
VALUES (100, NULL, 'primary', 416, '2025-03-01', 'infinity');

\echo '\n--- Initial State: One entity from 2025-03-01 -> infinity ---'
SELECT id, legal_unit_id, establishment_id, type, category_id, valid_from, valid_until
FROM saga_repro.target_null_nk ORDER BY valid_from;

-- Source table with same natural key (including NULL establishment_id)
-- but starting AFTER the existing entity
CREATE TABLE saga_repro.source_null_nk (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id int,  -- NULL to trigger natural key lookup
    legal_unit_id int,
    establishment_id int,  -- NULL - matches target's NULL
    type text NOT NULL,
    category_id int NOT NULL,
    valid_from date NOT NULL,
    valid_to date,
    valid_until date
);

-- Source starts on 2025-03-04, AFTER the existing entity starts
-- NOTE: Using DIFFERENT category_id (999 vs 416) to force distinct time periods
-- With identical data, coalescing would produce 1 row (correct behavior)
INSERT INTO saga_repro.source_null_nk (id, legal_unit_id, establishment_id, type, category_id, valid_from, valid_until)
VALUES (NULL, 100, NULL, 'primary', 999, '2025-03-04', 'infinity');

\echo '\n--- Source: Same entity (via natural key) starting 2025-03-04 ---'
SELECT * FROM saga_repro.source_null_nk;

-- Create view for merge
CREATE VIEW saga_repro.source_null_nk_view AS SELECT * FROM saga_repro.source_null_nk;
GRANT SELECT ON saga_repro.source_null_nk_view TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_null_nk TO sql_saga_unprivileged_user;

SET ROLE TO sql_saga_unprivileged_user;

-- Execute merge - this should:
-- 1. SHRINK existing entity from [2025-03-01, infinity) to [2025-03-01, 2025-03-04)
-- 2. INSERT new entity for [2025-03-04, infinity)
-- NOT:
-- 1. DELETE existing entity
-- 2. INSERT new entity (loses history!)
CALL sql_saga.temporal_merge(
    'saga_repro.target_null_nk',
    'saga_repro.source_null_nk_view',
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],
    mode => 'MERGE_ENTITY_REPLACE'
);

RESET ROLE;

\echo '\n--- After MERGE_ENTITY_REPLACE: Expected 2 rows ---'
\echo '--- Row 1: id=1, 2025-03-01 -> 2025-03-04, category_id=416 (SHRUNK original) ---'
\echo '--- Row 2: id=1, 2025-03-04 -> infinity, category_id=999 (UPDATED from source) ---'
SELECT id, legal_unit_id, establishment_id, type, category_id, valid_from, valid_to, valid_until
FROM saga_repro.target_null_nk ORDER BY valid_from;

\echo '\n--- Verification: Must have 2 rows, original must be shrunk (not deleted) ---'
SELECT 
    count(*) as total_rows,
    count(*) FILTER (WHERE valid_from = '2025-03-01' AND valid_until = '2025-03-04' AND category_id = 416) as shrunk_original_count,
    count(*) FILTER (WHERE valid_from = '2025-03-04' AND category_id = 999) as new_segment_count
FROM saga_repro.target_null_nk;

-- Verify: The original id=1 entity should still exist (shrunk), not replaced
SELECT EXISTS (SELECT 1 FROM saga_repro.target_null_nk WHERE id = 1) as original_entity_preserved;

ROLLBACK TO SAVEPOINT scenario_null_natural_key;


ROLLBACK;

\i sql/include/test_teardown.sql
