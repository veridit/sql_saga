\i sql/include/test_setup.sql

BEGIN;

CREATE SCHEMA identity_discovery;

-- This test verifies the "convention-over-configuration" behavior of
-- temporal_merge. When identity columns are omitted, the procedure should
-- discover them from metadata and use them automatically.

-- 1. A target table with one primary key and MULTIPLE natural keys.
CREATE TABLE identity_discovery.person (
    id int GENERATED BY DEFAULT AS IDENTITY,
    employee_nr text,
    email text,
    full_name text,
    valid_from date NOT NULL,
    valid_until date
);

SELECT sql_saga.add_era('identity_discovery.person');
SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['id'], key_type => 'primary');
SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['employee_nr'], key_type => 'natural');
SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['email'], key_type => 'natural');

-- 2. The source table for data loading, with a feedback column.
CREATE TEMP TABLE source_data (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_nr text,
    email text,
    full_name text,
    valid_from date,
    valid_until date,
    feedback jsonb
) ON COMMIT DROP;

-- 3. Load initial state.
\echo '--- Loading initial state ---'
INSERT INTO source_data (employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('E101', 'alice@example.com', 'Alice Smith', '2023-01-01', '2024-01-01');
-- The key of this test: CALL temporal_merge WITHOUT specifying identity columns.
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- State after initial load ---'
SELECT id, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;

-- 4. Update via `employee_nr`. This creates a new historical record (SCD Type 2).
\echo '--- Updating via employee_nr ---'
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (employee_nr, full_name, valid_from, valid_until) VALUES
    ('E101', 'Alice Jones', '2023-06-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- State after update via employee_nr ---'
SELECT id, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;

-- 5. Update via `email`. This creates a third historical record.
\echo '--- Updating via email ---'
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (email, full_name, valid_from, valid_until) VALUES
    ('alice@example.com', 'Alice Jones-Carter', '2023-09-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- Final State after update via email ---'
SELECT id, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;

-- 6. Add a second person.
\echo '--- Adding a second person ---'
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('E102', 'bob@example.com', 'Bob Johnson', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
SELECT id, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;

-- 7. FAIL: Attempt to update with conflicting natural keys.
\echo '--- Updating with conflicting keys (expect error) ---'
TRUNCATE source_data RESTART IDENTITY;
-- This source row links Alice's employee_nr with Bob's email, creating ambiguity.
INSERT INTO source_data (employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('E101', 'bob@example.com', 'Conflict Person', '2023-10-01', '2024-01-01');
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    update_source_with_feedback => true,
    feedback_status_column => 'feedback',
    feedback_status_key => 'test'
);
\echo '--- Feedback for ambiguous row ---'
SELECT row_id, feedback->'test'->>'status' as status, feedback->'test'->>'error_message' as error_message
FROM source_data;

-- 8. FAIL: Attempt to insert a completely unidentifiable row.
\echo '--- Inserting unidentifiable row (expect error feedback) ---'
TRUNCATE source_data RESTART IDENTITY;
-- This row has NULL for all identifying columns.
INSERT INTO source_data (full_name, valid_from, valid_until) VALUES
    ('Ghost Person', '2023-11-01', '2024-01-01');
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    update_source_with_feedback => true,
    feedback_status_column => 'feedback',
    feedback_status_key => 'test'
);
\echo '--- Feedback for unidentifiable row ---'
-- The status should be ERROR with a specific message.
SELECT row_id, feedback->'test'->>'status' as status, feedback->'test'->>'error_message' as error_message
FROM source_data;

ROLLBACK;

\i sql/include/test_teardown.sql
