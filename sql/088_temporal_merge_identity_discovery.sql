\i sql/include/test_setup.sql

BEGIN;

CREATE SCHEMA identity_discovery;

-- This test verifies the "convention-over-configuration" behavior of
-- temporal_merge. When identity columns are omitted, the procedure should
-- discover them from metadata and use them automatically.

-- 1. A target table with one primary key and MULTIPLE natural keys.
CREATE TABLE identity_discovery.person (
    id int GENERATED BY DEFAULT AS IDENTITY,
    ssn text,
    employee_nr text,
    email text,
    full_name text,
    valid_from date NOT NULL,
    valid_until date
);

SELECT sql_saga.add_era('identity_discovery.person');
SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['id'], key_type => 'primary');
SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['employee_nr'], key_type => 'natural');
SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['ssn'], key_type => 'natural');

\d identity_discovery.person

-- 2. The source table for data loading, with a columns.
CREATE TEMP TABLE source_data (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id int,
    ssn text,
    employee_nr text,
    email text,
    full_name text,
    valid_from date,
    valid_until date,
    errors jsonb,
    merge_status jsonb
);

-- 3. Load initial state.
\echo '--- Loading initial state ---'
INSERT INTO source_data (employee_id, ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    (NULL, '111', 'E101', 'alice@example.com', 'Alice Smith', '2023-01-01', '2024-01-01'),
    (NULL, '111', 'E101', 'alice@example.com', 'Alice Baker', '2024-01-01', '2025-01-01'),
    (NULL, '111', 'E101', 'alice@baker.com', 'Alice Baker', '2025-01-01', 'infinity');

-- The key of this test: CALL temporal_merge WITHOUT specifying identity columns.
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');

\echo '--- State after initial load ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;

-- 4. Update via `employee_nr`. This creates a new historical record (SCD Type 2).
\echo '--- Updating via employee_nr ---'
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (employee_nr, full_name, valid_from, valid_until) VALUES
    ('E101', 'Alice Jones', '2023-06-01', '2024-01-01');

CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
    
\echo '--- State after update via employee_nr ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;

-- 5. Update via `email`. This creates a third historical record.
\echo '--- Updating via email ---'
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (email, full_name, valid_from, valid_until) VALUES
    ('alice@example.com', 'Alice Jones-Carter', '2023-09-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- Final State after update via email ---'
-- The state is unchanged because the source row was unidentifiable (email is not a natural key).
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;

-- 6. Add a second person.
\echo '--- Adding a second person ---'
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('222', 'E102', 'bob@example.com', 'Bob Johnson', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;

SAVEPOINT s7;
-- 7. FAIL: Attempt to update with conflicting natural keys.
\echo '--- Updating with conflicting keys (expect error) ---'
TRUNCATE source_data RESTART IDENTITY;
-- This source row links Alice's employee_nr with Bob's ssn, creating ambiguity.
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('222', 'E101', 'conflict@example.com', 'Conflict Person', '2023-10-01', '2024-01-01');
    
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    update_source_with_feedback => true,
    feedback_status_column => 'merge_status',
    feedback_status_key => 'test',
    feedback_error_column => 'errors',
    feedback_error_key => 'test'    
);

TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Feedback for ambiguous row ---'
SELECT row_id, merge_status, errors
FROM source_data;
ROLLBACK TO SAVEPOINT s7;

-- 8. FAIL: Attempt to insert a completely unidentifiable row.
SAVEPOINT s8;
\echo '--- Inserting unidentifiable row (expect error feedback) ---'
TRUNCATE source_data RESTART IDENTITY;
-- This row has NULL for all identifying columns.
INSERT INTO source_data (full_name, valid_from, valid_until) VALUES
    ('Ghost Person', '2023-11-01', '2024-01-01');
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    update_source_with_feedback => true,
    feedback_status_column => 'merge_status',
    feedback_status_key => 'test',
    feedback_error_column => 'errors',
    feedback_error_key => 'test'
);
\echo '--- Feedback for unidentifiable row ---'
-- The status should be ERROR with a specific message.
SELECT row_id, merge_status, errors
FROM source_data;
ROLLBACK TO SAVEPOINT s8;

-- 9. Multi-row update to a single entity
\echo '--- Scenario 9: Multi-row update to a single entity with different identity strategies ---'

TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('333', 'E103', 'charlie@example.com', 'Charlie Day', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- State after adding Charlie ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;

-- Source data with two consecutive updates for Charlie
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, full_name, valid_from, valid_until) VALUES
    -- Updates by employee_nr
    (NULL, 'E103', 'Charlie Kelly', '2023-04-01', '2023-08-01'),
    (NULL, 'E103', 'Charles Kelly', '2023-08-01', '2024-01-01'),
    -- Updates by ssn
    ('333', NULL, 'C. Day', '2023-02-01', '2023-03-01'),
    ('333', NULL, 'Chuck Day', '2023-03-01', '2023-04-01');

\echo
\echo '--- Case 9a: Multi-row update with auto-discovered keys ---'
SAVEPOINT s9;
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => NULL,
    natural_identity_columns => NULL
);
\echo '--- Final state (9a) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
ROLLBACK TO SAVEPOINT s9;

\echo
\echo '--- Case 9b: Multi-row update with explicit stable key and natural key for lookup ---'
SAVEPOINT s9;
TABLE identity_discovery.person;
TABLE source_data;

CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['employee_nr']
);
\echo '--- Final state (9b) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
ROLLBACK TO SAVEPOINT s9;

\echo
\echo '--- Case 9c: Multi-row update with explicit natural key (employee_nr only) ---'
\echo '--- This will only apply updates from source rows that have a non-NULL employee_nr. ---'
SAVEPOINT s9;
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => NULL,
    natural_identity_columns => ARRAY['employee_nr']
);
\echo '--- Final state (9c) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
ROLLBACK TO SAVEPOINT s9;

\echo
\echo '--- Case 9d: Multi-row update with explicit natural key (ssn only) ---'
\echo '--- This will only apply updates from source rows that have a non-NULL ssn. ---'
SAVEPOINT s9;


CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => NULL,
    natural_identity_columns => ARRAY['ssn']
);
\echo '--- Final state (9d) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
ROLLBACK TO SAVEPOINT s9;

\echo
\echo '--- Case 9e: Multi-row update with explicit natural key (both ssn and employee_nr) ---'
\echo '--- The planner will try both keys and should apply all updates. ---'
SAVEPOINT s9;
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => NULL,
    natural_identity_columns => NULL -- Let the planner auto-discover both ['ssn'] and ['employee_nr']
);
\echo '--- Final state (9e) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
ROLLBACK TO SAVEPOINT s9;

-- 10. Multi-row insert for a new entity using natural key
\echo '--- Scenario 10: Multi-row insert for a new entity using auto-discovered natural key ---'
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('444', 'E104', 'dennis@example.com', 'Dennis Reynolds', '2023-01-01', '2023-06-01'),
    ('444', 'E104', 'dennis@example.com', 'Dennis R. Reynolds', '2023-06-01', '2024-01-01');

\echo '--- Source for new person Dennis ---'
TABLE source_data;

CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data'
    -- No identity columns specified, should auto-discover and group by natural key
);

\echo '--- Final state after multi-row insert ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E104' ORDER BY id, valid_from;

-- 11. Multi-row insert/update of a fragmented entity (PATCH mode)
\echo '--- Scenario 11: Multi-row insert/update of a fragmented entity (PATCH mode) ---'
SAVEPOINT s11;
-- This scenario tests the planner's ability to create and update a complex history for a single entity
-- from multiple source rows with fragmented natural key and data information.

-- First, set up the complete source data for all parts of this test.
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('555', 'E105', 'dee@doe.com'    , 'Dee Doe'  , '2023-01-01', '2024-01-01'),
    ('555',  NULL , 'dee@example.com', NULL       , '2023-02-01', '2023-04-01'),
    ('555',  NULL , NULL             , 'Sweet Dee', '2023-04-01', '2023-06-01'),
    ( NULL, 'E105', 'doe@example.com', NULL       , '2023-03-01', '2023-05-01'),
    ( NULL, 'E105', NULL             , 'Sweet Doe', '2023-05-01', '2023-07-01');

\echo '--- Source for fragmented entity ---'
TABLE source_data ORDER BY row_id;

\echo
\echo '--- Case 11a: Merging all source rows in a single batch ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data', mode => 'MERGE_ENTITY_PATCH');
\echo '--- State after single-batch merge (PATCH mode) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;

\echo
\echo '--- Case 11b: Merging in two batches with MERGE_ENTITY_PATCH ---'
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
CREATE TEMP TABLE source_step1_b AS SELECT * FROM source_data WHERE row_id = 1;
CREATE TEMP TABLE source_step2_b AS SELECT * FROM source_data WHERE row_id > 1;
\echo '--- Step 1: Seeding target with first row ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step1_b', mode => 'MERGE_ENTITY_PATCH');
TABLE identity_discovery.person;
\echo '--- Step 2: Merging remaining rows ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step2_b', mode => 'MERGE_ENTITY_PATCH');
\echo '--- State after two-batch merge (PATCH mode) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;

\echo
\echo '--- Case 11c: Merging in two batches with PATCH_FOR_PORTION_OF ---'
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
CREATE TEMP TABLE source_step1_c AS SELECT * FROM source_data WHERE row_id = 1;
CREATE TEMP TABLE source_step2_c AS SELECT * FROM source_data WHERE row_id > 1;
\echo '--- Step 1: Seeding target with first row ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step1_c', mode => 'MERGE_ENTITY_PATCH');
TABLE identity_discovery.person;
\echo '--- Step 2: Merging remaining rows with PATCH_FOR_PORTION_OF ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step2_c', mode => 'PATCH_FOR_PORTION_OF');
\echo '--- State after two-batch merge (PORTION_OF mode) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;

ROLLBACK TO SAVEPOINT s11;

-- 12. Multi-row insert/update of a fragmented entity (UPSERT mode)
\echo '--- Scenario 12: Multi-row insert/update of a fragmented entity (UPSERT mode) ---'
SAVEPOINT s12;
-- This scenario uses the same fragmented source data as the PATCH test, but with
-- UPSERT mode. The key difference is that UPSERT treats NULLs in the source as
-- explicit values that should overwrite existing data.

TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('555', 'E105', 'dee@doe.com'    , 'Dee Doe'  , '2023-01-01', '2024-01-01'),
    ('555',  NULL , 'dee@example.com', NULL       , '2023-02-01', '2023-04-01'),
    ('555',  NULL , NULL             , 'Sweet Dee', '2023-04-01', '2023-06-01'),
    ( NULL, 'E105', 'doe@example.com', NULL       , '2023-03-01', '2023-05-01'),
    ( NULL, 'E105', NULL             , 'Sweet Doe', '2023-05-01', '2023-07-01');

\echo '--- Source for fragmented entity ---'
TABLE source_data ORDER BY row_id;

\echo
\echo '--- Case 12a: Merging all source rows in a single batch ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data', mode => 'MERGE_ENTITY_UPSERT');
\echo '--- State after single-batch merge (UPSERT mode) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;

\echo
\echo '--- Case 12b: Merging in two batches with MERGE_ENTITY_UPSERT ---'
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
CREATE TEMP TABLE source_step1_b_12 AS SELECT * FROM source_data WHERE row_id = 1;
CREATE TEMP TABLE source_step2_b_12 AS SELECT * FROM source_data WHERE row_id > 1;
\echo '--- Step 1: Seeding target with first row ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step1_b_12', mode => 'MERGE_ENTITY_UPSERT');
TABLE identity_discovery.person;
\echo '--- Step 2: Merging remaining rows ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step2_b_12', mode => 'MERGE_ENTITY_UPSERT');
\echo '--- State after two-batch merge (UPSERT mode) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;

\echo
\echo '--- Case 12c: Merging in two batches with UPDATE_FOR_PORTION_OF ---'
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
CREATE TEMP TABLE source_step1_c_12 AS SELECT * FROM source_data WHERE row_id = 1;
CREATE TEMP TABLE source_step2_c_12 AS SELECT * FROM source_data WHERE row_id > 1;
\echo '--- Step 1: Seeding target with first row ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step1_c_12', mode => 'MERGE_ENTITY_UPSERT');
TABLE identity_discovery.person;
\echo '--- Step 2: Merging remaining rows with UPDATE_FOR_PORTION_OF ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step2_c_12', mode => 'UPDATE_FOR_PORTION_OF');
\echo '--- State after two-batch merge (PORTION_OF mode) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;

ROLLBACK TO SAVEPOINT s12;

-- 13. Multi-row insert/update of a fragmented entity (REPLACE mode)
\echo '--- Scenario 13: Multi-row insert/update of a fragmented entity (REPLACE mode) ---'
SAVEPOINT s13;
-- This scenario uses the same fragmented source data as the PATCH/UPSERT tests,
-- but with REPLACE mode. REPLACE completely overwrites data for overlapping
-- time periods. Unlike PATCH/UPSERT, absent columns in a later source row will
-- cause data from an earlier source row to be removed.

TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('555', 'E105', 'dee@doe.com'    , 'Dee Doe'  , '2023-01-01', '2024-01-01'),
    ('555',  NULL , 'dee@example.com', NULL       , '2023-02-01', '2023-04-01'),
    ('555',  NULL , NULL             , 'Sweet Dee', '2023-04-01', '2023-06-01'),
    ( NULL, 'E105', 'doe@example.com', NULL       , '2023-03-01', '2023-05-01'),
    ( NULL, 'E105', NULL             , 'Sweet Doe', '2023-05-01', '2023-07-01');

\echo '--- Source for fragmented entity ---'
TABLE source_data ORDER BY row_id;

\echo
\echo '--- Case 13a: Merging all source rows in a single batch ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data', mode => 'MERGE_ENTITY_REPLACE');
\echo '--- State after single-batch merge (REPLACE mode) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;

\echo
\echo '--- Case 13b: Merging in two batches with MERGE_ENTITY_REPLACE ---'
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
CREATE TEMP TABLE source_step1_b_13 AS SELECT * FROM source_data WHERE row_id = 1;
CREATE TEMP TABLE source_step2_b_13 AS SELECT * FROM source_data WHERE row_id > 1;
\echo '--- Step 1: Seeding target with first row ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step1_b_13', mode => 'MERGE_ENTITY_REPLACE');
TABLE identity_discovery.person;
\echo '--- Step 2: Merging remaining rows ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step2_b_13', mode => 'MERGE_ENTITY_REPLACE');
\echo '--- State after two-batch merge (REPLACE mode) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;

\echo
\echo '--- Case 13c: Merging in two batches with REPLACE_FOR_PORTION_OF ---'
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
CREATE TEMP TABLE source_step1_c_13 AS SELECT * FROM source_data WHERE row_id = 1;
CREATE TEMP TABLE source_step2_c_13 AS SELECT * FROM source_data WHERE row_id > 1;
\echo '--- Step 1: Seeding target with first row ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step1_c_13', mode => 'MERGE_ENTITY_REPLACE');
TABLE identity_discovery.person;
\echo '--- Step 2: Merging remaining rows with REPLACE_FOR_PORTION_OF ---'
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step2_c_13', mode => 'REPLACE_FOR_PORTION_OF');
\echo '--- State after two-batch merge (PORTION_OF mode) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;

ROLLBACK TO SAVEPOINT s13;

-- 14. Multi-row update of a multi-row target
\echo '--- Scenario 14: Multi-row update of a multi-row target ---'
SAVEPOINT s14;
-- First, create the same multi-row history for Dee using PATCH mode.
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('555', 'E105', 'dee@doe.com'    , 'Dee Doe'  , '2023-01-01', '2024-01-01'),
    ('555',  NULL , 'dee@example.com', NULL       , '2023-02-01', '2023-04-01'),
    ('555',  NULL , NULL             , 'Sweet Dee', '2023-04-01', '2023-06-01'),
    ( NULL, 'E105', 'doe@example.com', NULL       , '2023-03-01', '2023-05-01'),
    ( NULL, 'E105', NULL             , 'Sweet Doe', '2023-05-01', '2023-07-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data', mode => 'MERGE_ENTITY_PATCH');

\echo '--- State after adding Dee (multi-row target) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;

-- Now, apply a multi-row update to the multi-row target
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (employee_nr, full_name, valid_from, valid_until) VALUES
    ('E105', 'Bird', '2023-02-01', '2023-05-01'),
    ('E105', 'Aluminum Monster', '2023-07-01', '2023-09-01');
\echo '--- Source for multi-row update ---'
TABLE source_data;

CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data'
);

\echo '--- Final state after multi-row update ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;

ROLLBACK TO SAVEPOINT s14;

-- 15. Multi-row update of multi-row target with pre-filled stable ID
\echo '--- Scenario 15: Multi-row update of multi-row target with pre-filled stable ID ---'
SAVEPOINT s15;
-- Reset the target state by truncating and re-populating with all previous entities
-- to ensure the IDENTITY column generates a predictable ID for the final entity.
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('111', 'E101', 'alice@example.com', 'Alice Smith', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('222', 'E102', 'bob@example.com', 'Bob Johnson', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('333', 'E103', 'charlie@example.com', 'Charlie Day', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('444', 'E104', 'dennis@example.com', 'Dennis Reynolds', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
-- Now, re-create the multi-row history for Dee. She will receive id=5.
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('555', 'E105', 'dee@example.com', 'Deandra Reynolds', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (employee_nr, full_name, valid_from, valid_until) VALUES ('E105', 'Sweet Dee', '2023-03-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- State after re-adding Dee (multi-row target) ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;

-- The source data now includes the stable `id` which was looked up ahead of time.
TRUNCATE source_data RESTART IDENTITY;
ALTER TABLE source_data ADD COLUMN id INT;
INSERT INTO source_data (id, ssn, employee_nr, full_name, valid_from, valid_until) VALUES
    (5, '555', 'E105', 'Bird', '2023-02-01', '2023-05-01'),
    (5, '555', 'E105', 'Aluminum Monster', '2023-07-01', '2023-09-01');
\echo '--- Source for multi-row update with pre-filled ID ---'
TABLE source_data;

CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['employee_nr'] -- Still provided for robust lookup
);

\echo '--- Final state after multi-row update with pre-filled ID ---'
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;

ROLLBACK TO SAVEPOINT s15;

ROLLBACK;

\i sql/include/test_teardown.sql
