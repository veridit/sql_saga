\i sql/include/test_setup.sql

BEGIN;
\echo '----------------------------------------------------------------------------'
\echo 'Test: Unified Temporal Merge with Natural & Surrogate Keys'
\echo 'This test consolidates the tests for natural and surrogate keys into'
\echo 'a single, unified suite using the new temporal_merge function.'
\echo '----------------------------------------------------------------------------'

--------------------------------------------------------------------------------
-- Test Scenarios Table of Contents
--------------------------------------------------------------------------------
--
-- Natural-Key Entity: stat_for_unit
--   - Scenario 1: `upsert_replace` with a natural key (`during` split)
--   - Scenario 2: `upsert_patch` with a natural key (`during` split)
--   - Scenario 3: `upsert_replace` with mismatched source/target columns
--
-- Surrogate-Key Entities:
--   - Scenario 4: `upsert_replace` with SERIAL surrogate key on target
--   - Scenario 5: `upsert_replace` with IDENTITY surrogate key on target
--   - Scenario 6: `upsert_patch` with SERIAL surrogate key on target
--   - Scenario 7: `upsert_patch` with IDENTITY surrogate key on target
--   - Scenario 8: `upsert_replace` with non-PK surrogate key
--   - Scenario 9: Multiple, mutually exclusive natural keys with a surrogate ID
--   - Scenario 10: Multiple, mutually exclusive natural keys without a surrogate ID
--   - Scenario 11: Natural key with NULLs using IS NOT DISTINCT FROM logic (complex XOR key)
--   - Scenario 12: Natural key with NULLs on a simple surrogate key table (known anti-pattern)
--
--------------------------------------------------------------------------------
SET client_min_messages TO WARNING;

-- Setup: Create necessary schema and tables for this test
CREATE SCHEMA IF NOT EXISTS tmtc;
CREATE TYPE tmtc.location_type AS ENUM ('visiting', 'postal', 'physical');

-- Parent tables
CREATE TABLE tmtc.stat_definition (id INT PRIMARY KEY, name TEXT);
CREATE TABLE tmtc.legal_unit (
    id INT NOT NULL, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, PRIMARY KEY (id, valid_from)
);
SELECT sql_saga.add_era('tmtc.legal_unit', 'valid_from', 'valid_until');
SELECT sql_saga.add_unique_key('tmtc.legal_unit', ARRAY['id'], 'valid', unique_key_name => 'tm_legal_unit_uk');
CREATE TABLE tmtc.establishment (
    id INT NOT NULL, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, PRIMARY KEY (id, valid_from)
);
SELECT sql_saga.add_era('tmtc.establishment', 'valid_from', 'valid_until');
SELECT sql_saga.add_unique_key('tmtc.establishment', ARRAY['id'], 'valid', unique_key_name => 'tm_establishment_uk');

-- Target table: stat_for_unit (composite key)
CREATE TABLE tmtc.stat_for_unit (
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT
);
SELECT sql_saga.add_era('tmtc.stat_for_unit', 'valid_from', 'valid_until');
SELECT sql_saga.add_unique_key('tmtc.stat_for_unit', ARRAY['stat_definition_id', 'establishment_id'], 'valid', unique_key_name => 'tm_sfu_uk');

-- Target table with SERIAL surrogate ID
CREATE TABLE tmtc.stat_for_unit_id_pk (
    id SERIAL PRIMARY KEY,
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT
);
SELECT sql_saga.add_era('tmtc.stat_for_unit_id_pk', 'valid_from', 'valid_until');
SELECT sql_saga.add_unique_key('tmtc.stat_for_unit_id_pk', ARRAY['stat_definition_id', 'establishment_id'], 'valid', unique_key_name => 'tm_sfu_id_uk');

-- Target table with IDENTITY surrogate ID
CREATE TABLE tmtc.stat_for_unit_id_gen (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT
);
SELECT sql_saga.add_era('tmtc.stat_for_unit_id_gen', 'valid_from', 'valid_until');
SELECT sql_saga.add_unique_key('tmtc.stat_for_unit_id_gen', ARRAY['stat_definition_id', 'establishment_id'], 'valid', unique_key_name => 'tm_sfu_identity_uk');

-- Target table with non-PK surrogate key
CREATE SEQUENCE tmtc.stat_for_unit_no_pk_id_seq;
CREATE TABLE tmtc.stat_for_unit_no_pk (
    id INT NOT NULL DEFAULT nextval('tmtc.stat_for_unit_no_pk_id_seq'),
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT,
    UNIQUE (id, valid_from)
);
SELECT sql_saga.add_era('tmtc.stat_for_unit_no_pk', 'valid_from', 'valid_until');
SELECT sql_saga.add_unique_key('tmtc.stat_for_unit_no_pk', ARRAY['stat_definition_id', 'establishment_id'], 'valid', unique_key_name => 'tm_sfu_no_pk_uk');

-- Target table with multiple, mutually exclusive natural keys (and surrogate ID)
CREATE TABLE tmtc.location_multi_key (
    id SERIAL NOT NULL,
    type tmtc.location_type NOT NULL,
    legal_unit_id INT,
    establishment_id INT,
    address TEXT,
    edit_comment TEXT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    CONSTRAINT location_multi_key_xor CHECK (
        (legal_unit_id IS NOT NULL AND establishment_id IS NULL) OR
        (legal_unit_id IS NULL AND establishment_id IS NOT NULL)
    ),
    PRIMARY KEY (id, valid_from)
);
SELECT sql_saga.add_era('tmtc.location_multi_key');
SELECT sql_saga.add_unique_key('tmtc.location_multi_key', ARRAY['type', 'legal_unit_id'], 'valid', key_type => 'predicated', unique_key_name => 'loc_mk_lu_uk', predicate => 'legal_unit_id IS NOT NULL');
SELECT sql_saga.add_unique_key('tmtc.location_multi_key', ARRAY['type', 'establishment_id'], 'valid', key_type => 'predicated', unique_key_name => 'loc_mk_est_uk', predicate => 'establishment_id IS NOT NULL');
SELECT sql_saga.add_foreign_key('tmtc.location_multi_key', ARRAY['legal_unit_id'], 'valid', 'tm_legal_unit_uk');
SELECT sql_saga.add_foreign_key('tmtc.location_multi_key', ARRAY['establishment_id'], 'valid', 'tm_establishment_uk');

-- Target table with multiple, mutually exclusive natural keys (NO surrogate ID)
CREATE TABLE tmtc.location_multi_key_no_id (
    type tmtc.location_type NOT NULL,
    legal_unit_id INT,
    establishment_id INT,
    address TEXT,
    edit_comment TEXT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    CONSTRAINT location_multi_key_no_id_xor CHECK (
        (legal_unit_id IS NOT NULL AND establishment_id IS NULL) OR
        (legal_unit_id IS NULL AND establishment_id IS NOT NULL)
    )
);
SELECT sql_saga.add_era('tmtc.location_multi_key_no_id');
SELECT sql_saga.add_unique_key('tmtc.location_multi_key_no_id', ARRAY['type', 'legal_unit_id'], 'valid', key_type => 'predicated', unique_key_name => 'loc_mk_noid_lu_uk', predicate => 'legal_unit_id IS NOT NULL');
SELECT sql_saga.add_unique_key('tmtc.location_multi_key_no_id', ARRAY['type', 'establishment_id'], 'valid', key_type => 'predicated', unique_key_name => 'loc_mk_noid_est_uk', predicate => 'establishment_id IS NOT NULL');
SELECT sql_saga.add_foreign_key('tmtc.location_multi_key_no_id', ARRAY['legal_unit_id'], 'valid', 'tm_legal_unit_uk');
SELECT sql_saga.add_foreign_key('tmtc.location_multi_key_no_id', ARRAY['establishment_id'], 'valid', 'tm_establishment_uk');

-- Helper procedure to reset the target table for a new scenario
CREATE OR REPLACE PROCEDURE tmtc.reset_target() AS $$
BEGIN
    TRUNCATE tmtc.stat_definition, tmtc.legal_unit, tmtc.establishment, tmtc.stat_for_unit, tmtc.stat_for_unit_id_pk, tmtc.stat_for_unit_id_gen, tmtc.stat_for_unit_no_pk, tmtc.location_multi_key, tmtc.location_multi_key_no_id RESTART IDENTITY CASCADE;
    -- Add parent data
    INSERT INTO tmtc.stat_definition (id, name) VALUES (10, 'Total Employees');
    INSERT INTO tmtc.legal_unit (id, valid_from, valid_until, name) VALUES (200, '1900-01-01', 'infinity', 'LU 200');
    INSERT INTO tmtc.establishment (id, valid_from, valid_until, name) VALUES (100, '1900-01-01', 'infinity', 'EST 100');
END;
$$ LANGUAGE plpgsql;

\set source_schema 'pg_temp'
\set ephemeral_cols '{edit_comment}'

--------------------------------------------------------------------------------
\echo 'Scenario 1: `upsert_replace` with a natural key (`during` split)'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
INSERT INTO tmtc.stat_for_unit (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment) VALUES
(10, 100, '2024-01-01', '2025-01-01', 50, 'Original Value');

CREATE TEMP TABLE temp_source_1 (
    row_id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_1 VALUES (1, 10, 100, '2024-04-01', '2024-09-01', 55, 'Corrected value for mid-year');

\echo '--- Target: Initial State (before merge) ---'
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit ORDER BY stat_definition_id, establishment_id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_1 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit',
    source_table => 'temp_source_1',
    identity_columns => NULL,
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'UPDATE'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-04-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-04-01'::DATE, '2024-09-01'::DATE, '{"value": 55, "edit_comment": "Corrected value for mid-year"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (1, '[{"establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (10, 100, '2024-01-01'::DATE, '2024-04-01'::DATE, 50::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-04-01'::DATE, '2024-09-01'::DATE, 55::BIGINT, 'Corrected value for mid-year'::TEXT),
    (10, 100, '2024-09-01'::DATE, '2025-01-01'::DATE, 50::BIGINT, 'Original Value'::TEXT)
) AS t (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
DROP TABLE temp_source_1;

--------------------------------------------------------------------------------
\echo 'Scenario 2: `upsert_patch` with a natural key (`during` split)'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
INSERT INTO tmtc.stat_for_unit (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment) VALUES
(10, 100, '2024-01-01', '2025-01-01', 50, 'Original Value');

CREATE TEMP TABLE temp_source_2 (
    row_id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
-- Source has a NULL value for 'edit_comment'. In patch mode, this should NOT overwrite the existing value.
INSERT INTO temp_source_2 VALUES (1, 10, 100, '2024-04-01', '2024-09-01', 55, NULL);

\echo '--- Target: Initial State (before merge) ---'
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit ORDER BY stat_definition_id, establishment_id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_2 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit',
    source_table => 'temp_source_2',
    identity_columns => NULL,
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid',
    update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'UPDATE'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-04-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-04-01'::DATE, '2024-09-01'::DATE, '{"value": 55, "edit_comment": "Original Value"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (1, '[{"establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (10, 100, '2024-01-01'::DATE, '2024-04-01'::DATE, 50::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-04-01'::DATE, '2024-09-01'::DATE, 55::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-09-01'::DATE, '2025-01-01'::DATE, 50::BIGINT, 'Original Value'::TEXT)
) AS t (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
DROP TABLE temp_source_2;

--------------------------------------------------------------------------------
\echo 'Scenario 3: `upsert_replace` with mismatched source/target columns'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
INSERT INTO tmtc.stat_for_unit (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment) VALUES
(10, 100, '2024-01-01', '2025-01-01', 50, 'Original Value');

-- Source table has an extra column `source_metadata` that is not in the target.
CREATE TEMP TABLE temp_source_3 (
    row_id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT, source_metadata TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_3 VALUES (1, 10, 100, '2024-04-01', '2024-09-01', 55, 'Corrected value for mid-year', 'some extra data');

\echo '--- Target: Initial State (before merge) ---'
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit ORDER BY stat_definition_id, establishment_id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_3 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit',
    source_table => 'temp_source_3',
    identity_columns => NULL,
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'UPDATE'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-04-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-04-01'::DATE, '2024-09-01'::DATE, '{"value": 55, "edit_comment": "Corrected value for mid-year"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (1, '[{"establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (10, 100, '2024-01-01'::DATE, '2024-04-01'::DATE, 50::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-04-01'::DATE, '2024-09-01'::DATE, 55::BIGINT, 'Corrected value for mid-year'::TEXT),
    (10, 100, '2024-09-01'::DATE, '2025-01-01'::DATE, 50::BIGINT, 'Original Value'::TEXT)
) AS t (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
DROP TABLE temp_source_3;

--------------------------------------------------------------------------------
\echo 'Scenario 4: `upsert_replace` with SERIAL surrogate key on target'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_4 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_4 VALUES (1, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial Value');

\echo '--- Target: Initial State (before merge) ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk ORDER BY id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_4 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_pk',
    source_table => 'temp_source_4',
    identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (1, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;

\echo '--- Source Table: Expected state after back-fill ---'
SELECT * FROM (VALUES (1, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Source Table: Actual state after back-fill ---'
SELECT * FROM temp_source_4 ORDER BY row_id;
DROP TABLE temp_source_4;

--------------------------------------------------------------------------------
\echo 'Scenario 5: `upsert_replace` with IDENTITY surrogate key on target'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_5 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_5 VALUES (1, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial Value');

\echo '--- Target: Initial State (before merge) ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen ORDER BY id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_5 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_gen',
    source_table => 'temp_source_5',
    identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (1, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;

\echo '--- Source Table: Expected state after back-fill ---'
SELECT * FROM (VALUES (1, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Source Table: Actual state after back-fill ---'
SELECT * FROM temp_source_5 ORDER BY row_id;
DROP TABLE temp_source_5;

--------------------------------------------------------------------------------
\echo 'Scenario 6: `upsert_patch` with SERIAL surrogate key on target'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_6 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_6 VALUES (104, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial stat');

\echo '--- Target: Initial State (before merge) ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk ORDER BY id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_6 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_pk',
    source_table => 'temp_source_6',
    identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => '{edit_comment}'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid',
    update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{104}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial stat"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (104, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk WHERE establishment_id = 100 and stat_definition_id = 10 ORDER BY valid_from;

\echo '--- Source Table: Expected state after back-fill ---'
SELECT * FROM (VALUES (104, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Source Table: Actual state after back-fill ---'
SELECT * FROM temp_source_6 ORDER BY row_id;
DROP TABLE temp_source_6;

--------------------------------------------------------------------------------
\echo 'Scenario 7: `upsert_patch` with IDENTITY surrogate key on target'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_7 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_7 VALUES (105, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial stat');

\echo '--- Target: Initial State (before merge) ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen ORDER BY id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_7 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_gen',
    source_table => 'temp_source_7',
    identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => '{edit_comment}'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid',
    update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{105}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial stat"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (105, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen WHERE establishment_id = 100 and stat_definition_id = 10 ORDER BY valid_from;

\echo '--- Source Table: Expected state after back-fill ---'
SELECT * FROM (VALUES (105, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Source Table: Actual state after back-fill ---'
SELECT * FROM temp_source_7 ORDER BY row_id;
DROP TABLE temp_source_7;

--------------------------------------------------------------------------------
\echo 'Scenario 8: `upsert_replace` with non-PK surrogate key'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_8 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_8 VALUES (1, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial Value');

\echo '--- Target: Initial State (before merge) ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_no_pk ORDER BY id, valid_from;
\echo '--- Source: Data to be merged ---'
SELECT * FROM temp_source_8 ORDER BY row_id;

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_no_pk',
    source_table => 'temp_source_8',
    identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);

\echo '--- Planner: Expected Plan ---'
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;

\echo '--- Orchestrator: Expected Feedback ---'
SELECT * FROM (VALUES (1, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);

\echo '--- Orchestrator: Actual Feedback ---'
SELECT * FROM pg_temp.temporal_merge_feedback;

\echo '--- Orchestrator: Expected Final State ---'
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Orchestrator: Actual Final State ---'
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_no_pk WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;

\echo '--- Source Table: Expected state after back-fill ---'
SELECT * FROM (VALUES (1, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
\echo '--- Source Table: Actual state after back-fill ---'
SELECT * FROM temp_source_8 ORDER BY row_id;
DROP TABLE temp_source_8;


SAVEPOINT scenario_9;
-- NOTE on test isolation:
-- Each scenario is wrapped in a SAVEPOINT ... RELEASE SAVEPOINT block. This ensures
-- that each test case runs in its own nested transaction. If a test succeeds, its
-- changes are committed to the main transaction when RELEASE is called. This is a
-- robust pattern for isolating successful, independent test cases.
-- For expected failures, see the different pattern used in Scenario 12.
SET client_min_messages TO NOTICE;
\echo '--------------------------------------------------------------------------------'
\echo 'Scenario 9: Multiple, mutually exclusive natural keys with a surrogate ID'
\echo '--------------------------------------------------------------------------------'
-- This scenario tests using different natural_identity_columns on the same target table.
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_9 (
    row_id INT, id INT, type tmtc.location_type, legal_unit_id INT, establishment_id INT, address TEXT, valid_from DATE, valid_until DATE, edit_comment TEXT
) ON COMMIT DROP;

-- Insert initial data into target
INSERT INTO tmtc.location_multi_key (type, legal_unit_id, address, valid_from, valid_until) VALUES
('visiting', 200, '200 Main St', '2024-01-01', 'infinity');
INSERT INTO tmtc.location_multi_key (type, establishment_id, address, valid_from, valid_until) VALUES
('visiting', 100, '100 Business Park', '2024-01-01', 'infinity');

\echo '--- Target: Initial state ---'
SELECT id, type, legal_unit_id, establishment_id, address FROM tmtc.location_multi_key ORDER BY id;

\echo '--- Case 9a: Merge using the (type, legal_unit_id) natural key. ---'
INSERT INTO temp_source_9 VALUES (1, NULL, 'visiting', 200, NULL, '201 New Main St', '2024-06-01', 'infinity', 'LU address change');
\echo '--- Source (Legal Unit location) ---'
TABLE temp_source_9;
SET sql_saga.temporal_merge.log_plan = true;
SET sql_saga.temporal_merge.log_feedback = true;
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key',
    source_table => 'temp_source_9',
    identity_columns => '{id}',
    natural_identity_columns => '{type, legal_unit_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
SET sql_saga.temporal_merge.log_plan = false;
SET sql_saga.temporal_merge.log_feedback = false;
\echo '--- Target: After merge for Legal Unit location ---'
SELECT id, type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key ORDER BY id, valid_from;
\echo '--- Source: After back-fill ---'
TABLE temp_source_9;

\echo '--- Case 9b: Merge using the (type, establishment_id) natural key. ---'
TRUNCATE temp_source_9;
INSERT INTO temp_source_9 VALUES (2, NULL, 'visiting', NULL, 100, '101 New Business Park', '2024-08-01', 'infinity', 'Est address change');
\echo '--- Source (Establishment location) ---'
TABLE temp_source_9;
SET sql_saga.temporal_merge.log_plan = true;
SET sql_saga.temporal_merge.log_feedback = true;
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key',
    source_table => 'temp_source_9',
    identity_columns => '{id}',
    natural_identity_columns => '{type, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
SET sql_saga.temporal_merge.log_plan = false;
SET sql_saga.temporal_merge.log_feedback = false;
\echo '--- Target: Final state ---'
SELECT id, type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key ORDER BY id, valid_from;
\echo '--- Source: Final after back-fill ---'
TABLE temp_source_9;
DROP TABLE temp_source_9;
RELEASE SAVEPOINT scenario_9;


SAVEPOINT scenario_10;
\echo '--------------------------------------------------------------------------------'
\echo 'Scenario 10: Multiple, mutually exclusive natural keys without a surrogate ID'
\echo '--------------------------------------------------------------------------------'
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_10 (
    row_id INT, type tmtc.location_type, legal_unit_id INT, establishment_id INT, address TEXT, valid_from DATE, valid_until DATE, edit_comment TEXT
) ON COMMIT DROP;

-- Insert initial data into target
INSERT INTO tmtc.location_multi_key_no_id (type, legal_unit_id, address, valid_from, valid_until) VALUES
('visiting', 200, '200 Main St', '2024-01-01', 'infinity');
INSERT INTO tmtc.location_multi_key_no_id (type, establishment_id, address, valid_from, valid_until) VALUES
('visiting', 100, '100 Business Park', '2024-01-01', 'infinity');

\echo '--- Target: Initial state ---'
SELECT type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key_no_id ORDER BY COALESCE(legal_unit_id, establishment_id);

\echo '--- Case 10a: Merge using the (type, legal_unit_id) natural key. ---'
INSERT INTO temp_source_10 VALUES (1, 'visiting', 200, NULL, '201 New Main St', '2024-06-01', 'infinity', 'LU address change');
\echo '--- Source (Legal Unit location) ---'
TABLE temp_source_10;
SET sql_saga.temporal_merge.log_plan = true;
SET sql_saga.temporal_merge.log_feedback = true;
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key_no_id',
    source_table => 'temp_source_10',
    identity_columns => NULL,
    natural_identity_columns => '{type, legal_unit_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => false
);
SET sql_saga.temporal_merge.log_plan = false;
SET sql_saga.temporal_merge.log_feedback = false;
\echo '--- Target: After merge for Legal Unit location ---'
SELECT type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key_no_id ORDER BY COALESCE(legal_unit_id, establishment_id), valid_from;

\echo '--- Case 10b: Merge using the (type, establishment_id) natural key. ---'
TRUNCATE temp_source_10;
INSERT INTO temp_source_10 VALUES (2, 'visiting', NULL, 100, '101 New Business Park', '2024-08-01', 'infinity', 'Est address change');
\echo '--- Source (Establishment location) ---'
TABLE temp_source_10;
SET sql_saga.temporal_merge.log_plan = true;
SET sql_saga.temporal_merge.log_feedback = true;
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key_no_id',
    source_table => 'temp_source_10',
    identity_columns => NULL,
    natural_identity_columns => '{type, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => false
);
SET sql_saga.temporal_merge.log_plan = false;
SET sql_saga.temporal_merge.log_feedback = false;
\echo '--- Target: Final state ---'
SELECT type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key_no_id ORDER BY COALESCE(legal_unit_id, establishment_id), valid_from;
DROP TABLE temp_source_10;
RELEASE SAVEPOINT scenario_10;


SAVEPOINT scenario_11;
SET client_min_messages TO NOTICE;
\echo '--------------------------------------------------------------------------------'
\echo 'Scenario 11: Natural key with NULLs using IS NOT DISTINCT FROM logic'
\echo '--------------------------------------------------------------------------------'
-- This scenario tests using a single composite natural key that contains NULLs.
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_11 (
    row_id INT, id INT, type tmtc.location_type, legal_unit_id INT, establishment_id INT, address TEXT, valid_from DATE, valid_until DATE, edit_comment TEXT
) ON COMMIT DROP;

-- Insert initial data into target
INSERT INTO tmtc.location_multi_key (type, legal_unit_id, address, valid_from, valid_until) VALUES
('visiting', 200, '200 Main St', '2024-01-01', 'infinity');
INSERT INTO tmtc.location_multi_key (type, establishment_id, address, valid_from, valid_until) VALUES
('visiting', 100, '100 Business Park', '2024-01-01', 'infinity');

\echo '--- Target: Initial state ---'
SELECT id, type, legal_unit_id, establishment_id, address FROM tmtc.location_multi_key ORDER BY id;

\echo '--- Case 11a: Update Legal Unit location using a composite key with NULL ---'
INSERT INTO temp_source_11 VALUES (1, NULL, 'visiting', 200, NULL, '201 New Main St', '2024-06-01', 'infinity', 'LU address change');
\echo '--- Source (Legal Unit location) ---'
TABLE temp_source_11;
SET sql_saga.temporal_merge.log_plan = true;
SET sql_saga.temporal_merge.log_feedback = true;
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key',
    source_table => 'temp_source_11',
    identity_columns => '{id}',
    natural_identity_columns => '{type, legal_unit_id, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
SET sql_saga.temporal_merge.log_plan = false;
SET sql_saga.temporal_merge.log_feedback = false;
\echo '--- Target: After merge for Legal Unit location ---'
SELECT id, type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key ORDER BY id, valid_from;
\echo '--- Source: After back-fill ---'
TABLE temp_source_11;

\echo '--- Case 11b: Update Establishment location using a composite key with NULL ---'
TRUNCATE temp_source_11;
INSERT INTO temp_source_11 VALUES (2, NULL, 'visiting', NULL, 100, '101 New Business Park', '2024-08-01', 'infinity', 'Est address change');
\echo '--- Source (Establishment location) ---'
TABLE temp_source_11;
SET sql_saga.temporal_merge.log_plan = true;
SET sql_saga.temporal_merge.log_feedback = true;
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key',
    source_table => 'temp_source_11',
    identity_columns => '{id}',
    natural_identity_columns => '{type, legal_unit_id, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
SET sql_saga.temporal_merge.log_plan = false;
SET sql_saga.temporal_merge.log_feedback = false;
\echo '--- Target: Final state ---'
SELECT id, type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key ORDER BY id, valid_from;
\echo '--- Source: Final after back-fill ---'
TABLE temp_source_11;
DROP TABLE temp_source_11;
RELEASE SAVEPOINT scenario_11;


SAVEPOINT scenario_12;
SET client_min_messages TO NOTICE;
\echo '--------------------------------------------------------------------------------'
\echo 'Scenario 12: Natural key with NULLs on a simple surrogate key table (known anti-pattern)'
\echo '--------------------------------------------------------------------------------'
-- on a standard table with a simple SERIAL PRIMARY KEY. This is an anti-pattern for
-- SCD Type 2 history. The test demonstrates that attempting to update an entity
-- on a table with an incompatible schema via natural key lookup correctly
-- results in an error, preventing silent data corruption.
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_12 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, value BIGINT, valid_from DATE, valid_until DATE, edit_comment TEXT
) ON COMMIT DROP;

-- Insert initial data into target, where the natural key includes a NULL
INSERT INTO tmtc.stat_for_unit_id_pk (stat_definition_id, establishment_id, value, valid_from, valid_until) VALUES
(10, NULL, 500, '2024-01-01', 'infinity');

\echo '--- Target: Initial state ---'
SELECT id, stat_definition_id, establishment_id, value, valid_from, valid_until FROM tmtc.stat_for_unit_id_pk ORDER BY id;

\echo '--- Case 12a: Update entity identified by natural key with NULL ---'
INSERT INTO temp_source_12 VALUES (1, NULL, 10, NULL, 550, '2024-07-01', 'infinity', 'Stat value update');
\echo '--- Source ---'
TABLE temp_source_12;

SAVEPOINT expect_error;
-- NOTE on testing expected failures:
-- This call is expected to raise an ERROR. By wrapping it in a SAVEPOINT and
-- then calling ROLLBACK TO SAVEPOINT, we can test the failure without aborting
-- the main transaction. This allows us to see the raw error message and then
-- continue with subsequent tests.
\echo '--- Plan and Feedback (from failing call) ---'
SET sql_saga.temporal_merge.log_plan = true;
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_pk',
    source_table => 'temp_source_12',
    identity_columns => '{id}',
    natural_identity_columns => '{stat_definition_id, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
ROLLBACK TO SAVEPOINT expect_error;
SET sql_saga.temporal_merge.log_plan = false;

\echo '--- Target: After merge (should be unchanged) ---'
SELECT id, stat_definition_id, establishment_id, value, valid_from, valid_until FROM tmtc.stat_for_unit_id_pk ORDER BY id, valid_from;
\echo '--- Source: After back-fill (should be unchanged) ---'
TABLE temp_source_12;
DROP TABLE temp_source_12;
RELEASE SAVEPOINT scenario_12;
RESET client_min_messages;

-- Final Cleanup
DROP PROCEDURE tmtc.reset_target();
DROP TABLE tmtc.stat_for_unit, tmtc.stat_for_unit_id_pk, tmtc.stat_for_unit_id_gen, tmtc.stat_for_unit_no_pk, tmtc.location_multi_key, tmtc.location_multi_key_no_id;
DROP TABLE tmtc.legal_unit, tmtc.establishment;
DROP TABLE tmtc.stat_definition;
DROP SCHEMA tmtc CASCADE;

SET client_min_messages TO NOTICE;
ROLLBACK;
\i sql/include/test_teardown.sql
