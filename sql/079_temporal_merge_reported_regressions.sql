\i sql/include/test_setup.sql

-- This test file reproduces two distinct regressions in `temporal_merge`.
-- Each regression is tested in its own savepoint for isolation.

\set ECHO all

BEGIN;

CREATE SCHEMA saga_repro;

-- Base table definitions used by both scenarios
CREATE TABLE saga_repro.target_units_template (
    unit_ident text NOT NULL,
    name text,
    valid_from date NOT NULL,
    valid_to date,
    valid_until date
);
CREATE TABLE saga_repro.source_units_template (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    batch_seq int,
    unit_ident text,
    name text,
    sector text,
    valid_from date,
    valid_to date,
    merge_status jsonb,
    errors jsonb
);

GRANT USAGE ON SCHEMA saga_repro TO sql_saga_unprivileged_user;

--------------------------------------------------------------------------------
-- SCENARIO 1: Ordering Dependency Regression
--
-- This script demonstrates a regression where `temporal_merge` fails if its
-- source data contains complex overlapping temporal segments that are not
-- pre-sorted chronologically.
--------------------------------------------------------------------------------
SAVEPOINT scenario_ordering_dependency;

\echo '\n--- SCENARIO 1: Comparing merge strategies for out-of-order source data ---'

-- Setup for Scenario 1
CREATE TABLE saga_repro.target_units_a (LIKE saga_repro.target_units_template);
CREATE TABLE saga_repro.target_units_b (LIKE saga_repro.target_units_template);
CREATE TABLE saga_repro.target_units_c (LIKE saga_repro.target_units_template);

SELECT sql_saga.add_era('saga_repro.target_units_a', synchronize_valid_to_column := 'valid_to');
SELECT sql_saga.add_unique_key('saga_repro.target_units_a', ARRAY['unit_ident'], key_type => 'natural');
SELECT sql_saga.add_era('saga_repro.target_units_b', synchronize_valid_to_column := 'valid_to');
SELECT sql_saga.add_unique_key('saga_repro.target_units_b', ARRAY['unit_ident'], key_type => 'natural');
SELECT sql_saga.add_era('saga_repro.target_units_c', synchronize_valid_to_column := 'valid_to');
SELECT sql_saga.add_unique_key('saga_repro.target_units_c', ARRAY['unit_ident'], key_type => 'natural');

CREATE TABLE saga_repro.source_units_ordering (LIKE saga_repro.source_units_template INCLUDING ALL);

GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA saga_repro TO sql_saga_unprivileged_user;


INSERT INTO saga_repro.source_units_ordering (batch_seq, unit_ident, name, valid_from, valid_to) VALUES
    (1, 'unit1', 'Initial P1',   '2023-01-01', '2023-03-31'),
    (1, 'unit1', 'Initial P2',   '2023-04-01', '2023-06-30'),
    (1, 'unit1', 'Initial P3',   '2023-07-01', '2023-09-30'),
    (2, 'unit1', 'Replacing pA', '2023-02-15', '2023-05-15'),
    (2, 'unit1', 'Replacing pB', '2023-05-16', '2023-08-15'),
    (2, 'unit1', 'Replacing pC', '2023-08-16', '2023-12-01');
GRANT ALL ON saga_repro.source_units_ordering TO sql_saga_unprivileged_user;

SET ROLE TO sql_saga_unprivileged_user;

-- Strategy A: Process one row at a time (baseline for correctness)
\echo '\n--- STRATEGY A: Processing one row at a time ---\n'
CREATE TEMP TABLE source_a AS SELECT * FROM saga_repro.source_units_ordering;

-- Row 1
CREATE TEMP VIEW source_view_1 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 1;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_1', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run1');
-- Row 2
CREATE TEMP VIEW source_view_2 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 2;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_2', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run2');
-- Row 3
CREATE TEMP VIEW source_view_3 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 3;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_3', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run3');
-- Row 4
CREATE TEMP VIEW source_view_4 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 4;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_4', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run4');
-- Row 5
CREATE TEMP VIEW source_view_5 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 5;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_5', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run5');
-- Row 6
CREATE TEMP VIEW source_view_6 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 6;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_6', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run6');

-- Strategy B: Process in logical batches
CREATE TEMP TABLE source_b AS SELECT * FROM saga_repro.source_units_ordering;
CREATE TEMP VIEW source_view_b1 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_b WHERE batch_seq = 1;
CREATE TEMP VIEW source_view_b2 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_b WHERE batch_seq = 2;

\echo '\n--- STRATEGY B: Processing in logical batches ---\n'
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_b', 'source_view_b1',
    natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT',
    update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'batch1'
);
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_b', 'source_view_b2',
    natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT',
    update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'batch2'
);

-- Strategy C: Process all rows in one batch (the failing case)
CREATE TEMP TABLE source_c AS SELECT * FROM saga_repro.source_units_ordering;
CREATE TEMP VIEW source_view_c AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_c;

CALL sql_saga.temporal_merge(
    'saga_repro.target_units_c', 'source_view_c',
    natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT',
    update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run'
);


-- Final results for Scenario 1
\echo '\n\n--- FINAL COMPARISON OF FINAL STATES (SCENARIO 1) ---'
\echo '\n-- Strategy A: One-by-one Result'
SELECT unit_ident, name, valid_from, valid_to FROM saga_repro.target_units_a ORDER BY valid_from, name;
\echo '\n-- Strategy B: Batch-by-batch Result'
SELECT unit_ident, name, valid_from, valid_to FROM saga_repro.target_units_b ORDER BY valid_from, name;
\echo '\n-- Strategy C: All-in-one Result'
SELECT unit_ident, name, valid_from, valid_to FROM saga_repro.target_units_c ORDER BY valid_from, name;

\echo '\n-- Diff check of strategy results (should be empty)'
\echo '\n-- Diff A vs B:'
(TABLE saga_repro.target_units_a EXCEPT TABLE saga_repro.target_units_b)
UNION ALL
(TABLE saga_repro.target_units_b EXCEPT TABLE saga_repro.target_units_a);
\echo '\n-- Diff B vs C:'
(TABLE saga_repro.target_units_b EXCEPT TABLE saga_repro.target_units_c)
UNION ALL
(TABLE saga_repro.target_units_c EXCEPT TABLE saga_repro.target_units_b);

\echo '\n\n--- FINAL COMPARISON OF FEEDBACK (SCENARIO 1) ---'
\echo '\n-- Strategy A: One-by-one Feedback'
SELECT row_id, batch_seq, name, merge_status, errors FROM source_a ORDER BY row_id;
\echo '\n-- Strategy B: Batch-by-batch Feedback'
SELECT row_id, batch_seq, name, merge_status, errors FROM source_b ORDER BY row_id;
\echo '\n-- Strategy C: All-in-one Feedback'
SELECT row_id, batch_seq, name, merge_status, errors FROM source_c ORDER BY row_id;

ROLLBACK TO SAVEPOINT scenario_ordering_dependency;

--------------------------------------------------------------------------------
-- SCENARIO 2: Coalescing Regression
--
-- This test demonstrates a regression where `temporal_merge` fails to coalesce
-- adjacent, identical time segments when they are processed in separate batches.
--------------------------------------------------------------------------------
SAVEPOINT scenario_coalescing;
\echo '\n--- SCENARIO 2: Coalescing identical, adjacent records ---'

-- Setup for Scenario 2
CREATE TABLE saga_repro.target_units_coalesce (LIKE saga_repro.target_units_template);
CREATE TABLE saga_repro.source_units_coalesce (LIKE saga_repro.source_units_template INCLUDING ALL);
SELECT sql_saga.add_era('saga_repro.target_units_coalesce', synchronize_valid_to_column := 'valid_to');
SELECT sql_saga.add_unique_key('saga_repro.target_units_coalesce', ARRAY['unit_ident'], key_type => 'natural');
GRANT ALL ON saga_repro.target_units_coalesce TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_units_coalesce TO sql_saga_unprivileged_user;

-- Batch 1
INSERT INTO saga_repro.source_units_coalesce (unit_ident, name, sector, valid_from, valid_to) VALUES
    ('unit1', 'Unit A', 'Manufacturing', '2023-01-01', '2023-07-01');
CALL sql_saga.temporal_merge('saga_repro.target_units_coalesce', 'saga_repro.source_units_coalesce', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT');

\echo '\n--- State after Batch 1 ---'
TABLE saga_repro.target_units_coalesce;

-- Batch 2 (the failing step)
TRUNCATE saga_repro.source_units_coalesce;
INSERT INTO saga_repro.source_units_coalesce (unit_ident, name, sector, valid_from, valid_to) VALUES
    ('unit1', 'Unit A', 'Manufacturing', '2023-07-01', '2024-01-01');

CALL sql_saga.temporal_merge('saga_repro.target_units_coalesce', 'saga_repro.source_units_coalesce', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT');

-- Final results for Scenario 2
\echo '\n-- Coalescing Test Final State (Expected: 1 row)'
SELECT unit_ident, name, valid_from, valid_to FROM saga_repro.target_units_coalesce ORDER BY valid_from;

ROLLBACK TO SAVEPOINT scenario_coalescing;


--------------------------------------------------------------------------------
-- SCENARIO 3: Ephemeral column patch regression
--
-- Root Cause Analysis: The log provided shows that two adjacent time segments
-- that should have been coalesced were not, because their `data_hash` values
-- were different. The `data_hash` is computed on the data payload *after*
-- stripping ephemeral columns. The fact that the hashes differ indicates that
-- the data payloads themselves were different, meaning some non-ephemeral data
-- changed between the segments.
--
-- The bug is that when only an ephemeral column is updated on a portion of a
-- timeline, the planner should perform an in-place update of the original
-- record. Instead, it is splitting the record, indicating a failure to
-- coalesce the segments. This test reproduces that failure.
--------------------------------------------------------------------------------
SAVEPOINT scenario_ephemeral_patch;
\echo '\n--- SCENARIO 3: Ephemeral column PATCH should not split segment ---'
CREATE TABLE saga_repro.target_units_ephemeral (
    id int GENERATED BY DEFAULT AS IDENTITY,
    unit_ident text NOT NULL,
    name text NOT NULL,
    valid_from date NOT NULL,
    valid_to date,
    valid_until date,
    edit_at timestamptz NOT NULL DEFAULT '2025-10-02 16:39:00+00', -- Use fixed timestamp for deterministic test output, would be now() in reality.
    edit_comment text NOT NULL
);
CREATE TABLE saga_repro.source_units_ephemeral (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    unit_ident text,
    name text,
    valid_from date,
    valid_to date,
    edit_at date,
    edit_comment text
);
SELECT sql_saga.add_era('saga_repro.target_units_ephemeral', synchronize_valid_to_column := 'valid_to');
SELECT sql_saga.add_unique_key('saga_repro.target_units_ephemeral', ARRAY['id'], key_type => 'primary');
SELECT sql_saga.add_unique_key('saga_repro.target_units_ephemeral', ARRAY['unit_ident'], key_type => 'natural');
GRANT ALL ON saga_repro.target_units_ephemeral TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_units_ephemeral TO sql_saga_unprivileged_user;

-- Initial state: one record
INSERT INTO saga_repro.target_units_ephemeral (unit_ident, name, valid_from, valid_to, edit_comment)
VALUES ('unit1', 'Unit A', '2023-01-01', '2023-06-01', 'Initial version');

\echo '\n--- State before merge ---'
TABLE saga_repro.target_units_ephemeral;

-- Source data: update a portion of the timeline with only an ephemeral column change.
INSERT INTO saga_repro.source_units_ephemeral (unit_ident, name, valid_from, valid_to, edit_comment) VALUES
    ('unit1', 'Unit A', '2023-06-01', '2023-12-31', 'Updated comment');

CALL sql_saga.temporal_merge(
    'saga_repro.target_units_ephemeral', 'saga_repro.source_units_ephemeral',
    natural_identity_columns => ARRAY['unit_ident'],
    ephemeral_columns => ARRAY['edit_at', 'edit_comment'],
    mode => 'MERGE_ENTITY_PATCH'
);

\echo '\n-- Ephemeral Update Test Final State (Expected: 1 row with updated comment for the whole period)'
SELECT unit_ident, name, valid_from, valid_to, edit_comment FROM saga_repro.target_units_ephemeral ORDER BY valid_from;

ROLLBACK TO SAVEPOINT scenario_ephemeral_patch;


--------------------------------------------------------------------------------
-- SCENARIO 4: Ephemeral column UPSERT regression with NOT NULL DEFAULT
--
-- This test validates that when using MERGE_ENTITY_UPSERT, an incoming NULL
-- for a column that is defined as NOT NULL DEFAULT does not cause a NOT NULL
-- violation. Instead, the executor should be smart enough to preserve the
-- existing value, effectively treating NULL as "no change" for this specific
-- combination of constraints and mode.
--------------------------------------------------------------------------------
SAVEPOINT scenario_ephemeral_upsert;
\echo '\n--- SCENARIO 4: Ephemeral column UPSERT with NOT NULL DEFAULT ---'
CREATE TABLE saga_repro.target_units_ephemeral (
    id int GENERATED BY DEFAULT AS IDENTITY,
    unit_ident text NOT NULL,
    name text NOT NULL,
    valid_from date NOT NULL,
    valid_to date,
    valid_until date,
    edit_at timestamptz NOT NULL DEFAULT '2025-10-02 16:39:00+00', -- Use fixed timestamp for deterministic test output, would be now() in reality.
    edit_comment text NOT NULL
);
CREATE TABLE saga_repro.source_units_ephemeral (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    unit_ident text,
    name text,
    valid_from date,
    valid_to date,
    edit_at date,
    edit_comment text
);
SELECT sql_saga.add_era('saga_repro.target_units_ephemeral', synchronize_valid_to_column := 'valid_to');
SELECT sql_saga.add_unique_key('saga_repro.target_units_ephemeral', ARRAY['id'], key_type => 'primary');
SELECT sql_saga.add_unique_key('saga_repro.target_units_ephemeral', ARRAY['unit_ident'], key_type => 'natural');
GRANT ALL ON saga_repro.target_units_ephemeral TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_units_ephemeral TO sql_saga_unprivileged_user;

-- Initial state: one record
INSERT INTO saga_repro.target_units_ephemeral (unit_ident, name, valid_from, valid_to, edit_comment)
VALUES ('unit1', 'Unit A', '2023-01-01', '2023-06-01', 'Initial version');

\echo '\n--- State before merge ---'
TABLE saga_repro.target_units_ephemeral;

-- Source data: update a portion of the timeline with only an ephemeral column change.
INSERT INTO saga_repro.source_units_ephemeral (unit_ident, name, valid_from, valid_to, edit_comment) VALUES
    ('unit1', 'Unit A', '2023-06-01', '2023-12-31', 'Updated comment');

CALL sql_saga.temporal_merge(
    'saga_repro.target_units_ephemeral', 'saga_repro.source_units_ephemeral',
    natural_identity_columns => ARRAY['unit_ident'],
    ephemeral_columns => ARRAY['edit_at', 'edit_comment'],
    mode => 'MERGE_ENTITY_UPSERT'
);

\echo '\n-- Ephemeral Update Test Final State (Expected: 1 row with updated comment for the whole period)'
SELECT unit_ident, name, valid_from, valid_to, edit_comment FROM saga_repro.target_units_ephemeral ORDER BY valid_from;

ROLLBACK TO SAVEPOINT scenario_ephemeral_upsert;


--------------------------------------------------------------------------------
-- SCENARIO 5: Ephemeral column REPLACE regression with NOT NULL DEFAULT
--
-- This test validates that when using MERGE_ENTITY_UPSERT, an incoming NULL
-- for a column that is defined as NOT NULL DEFAULT does not cause a NOT NULL
-- violation. Instead, the executor should be smart enough to preserve the
-- existing value, effectively treating NULL as "no change" for this specific
-- combination of constraints and mode.
--------------------------------------------------------------------------------
SAVEPOINT scenario_ephemeral_replace;
\echo '\n--- SCENARIO 4: Ephemeral column UPSERT with NOT NULL DEFAULT ---'
CREATE TABLE saga_repro.target_units_ephemeral (
    id int GENERATED BY DEFAULT AS IDENTITY,
    unit_ident text NOT NULL,
    name text NOT NULL,
    valid_from date NOT NULL,
    valid_to date,
    valid_until date,
    edit_at timestamptz NOT NULL DEFAULT '2025-10-02 16:39:00+00', -- Use fixed timestamp for deterministic test output, would be now() in reality.
    edit_comment text NOT NULL
);
CREATE TABLE saga_repro.source_units_ephemeral (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    unit_ident text,
    name text,
    valid_from date,
    valid_to date,
    edit_at date,
    edit_comment text
);
SELECT sql_saga.add_era('saga_repro.target_units_ephemeral', synchronize_valid_to_column := 'valid_to');
SELECT sql_saga.add_unique_key('saga_repro.target_units_ephemeral', ARRAY['id'], key_type => 'primary');
SELECT sql_saga.add_unique_key('saga_repro.target_units_ephemeral', ARRAY['unit_ident'], key_type => 'natural');
GRANT ALL ON saga_repro.target_units_ephemeral TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_units_ephemeral TO sql_saga_unprivileged_user;

-- Initial state: one record
INSERT INTO saga_repro.target_units_ephemeral (unit_ident, name, valid_from, valid_to, edit_comment)
VALUES ('unit1', 'Unit A', '2023-01-01', '2023-06-01', 'Initial version');

\echo '\n--- State before merge ---'
TABLE saga_repro.target_units_ephemeral;

-- Source data: update a portion of the timeline with only an ephemeral column change.
INSERT INTO saga_repro.source_units_ephemeral (unit_ident, name, valid_from, valid_to, edit_comment) VALUES
    ('unit1', 'Unit A', '2023-06-01', '2023-12-31', 'Updated comment');

CALL sql_saga.temporal_merge(
    'saga_repro.target_units_ephemeral', 'saga_repro.source_units_ephemeral',
    natural_identity_columns => ARRAY['unit_ident'],
    ephemeral_columns => ARRAY['edit_at', 'edit_comment'],
    mode => 'MERGE_ENTITY_REPLACE'
);

\echo '\n-- Ephemeral Update Test Final State (Expected: 1 row with updated comment for the whole period)'
SELECT unit_ident, name, valid_from, valid_to, edit_comment FROM saga_repro.target_units_ephemeral ORDER BY valid_from;

ROLLBACK TO SAVEPOINT scenario_ephemeral_replace;


ROLLBACK;

\i sql/include/test_teardown.sql
