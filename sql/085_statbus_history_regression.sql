\i sql/include/test_setup.sql

BEGIN;

CREATE SCHEMA repro;

-- 1. Define the target temporal table with an ephemeral column
CREATE TABLE repro.units (
    id int GENERATED BY DEFAULT AS IDENTITY,
    org_nr text NOT NULL,
    name text,
    activity_code text,
    edit_comment text, -- This is an ephemeral column
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_until date
);

SELECT sql_saga.add_era('repro.units', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
-- A composite primary key is required for SCD Type 2 history. The temporal columns
-- are added automatically by the function.
ALTER TABLE repro.units ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_unique_key('repro.units', ARRAY['id'], key_type => 'primary');
SELECT sql_saga.add_unique_key('repro.units', ARRAY['org_nr'], key_type => 'natural');

-- 2. Define the source table for data loading
CREATE TEMP TABLE source_units (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    org_nr text,
    name text,
    activity_code text,
    edit_comment text,
    -- These columns are set per-batch
    valid_from date,
    valid_until date,
    id int -- for the stable key
) ON COMMIT DROP;

-- Wrapper procedure to simplify the test loop
CREATE PROCEDURE repro.load_data(p_valid_from date, p_valid_until date)
LANGUAGE plpgsql AS $$
BEGIN
    UPDATE source_units SET valid_from = p_valid_from, valid_until = p_valid_until;
    RAISE NOTICE '--- Loading data for period [%, %) ---', p_valid_from, p_valid_until;

    CALL sql_saga.temporal_merge(
        target_table => 'repro.units',
        source_table => 'source_units',
        primary_identity_columns => ARRAY['id'],
        natural_identity_columns => ARRAY['org_nr'],
        ephemeral_columns => ARRAY['edit_comment'],
        mode => 'MERGE_ENTITY_UPSERT',
        delete_mode => 'NONE'
    );
END;
$$;

-- 3. Load 2016 data: Establishes the initial state
SAVEPOINT load_2016;
TRUNCATE source_units RESTART IDENTITY;
INSERT INTO source_units (org_nr, name, activity_code, edit_comment) VALUES
    ('111', 'Unit A', '10.0', '2016 Load'), -- Will change in 2017
    ('222', 'Unit B', '30.0', '2016 Load'), -- Will be identical in 2017
    ('333', 'Unit C', '40.0', '2016 Load'); -- Will have ephemeral change in 2017
CALL repro.load_data('2016-01-01', '2017-01-01');
\echo '--- State after 2016 load ---'
SELECT org_nr, name, activity_code, edit_comment, valid_from, valid_until
FROM repro.units ORDER BY org_nr, valid_from;
RELEASE SAVEPOINT load_2016;


-- 4. Load 2017 data: Should trigger various changes
SAVEPOINT load_2017;
TRUNCATE source_units RESTART IDENTITY;
INSERT INTO source_units (org_nr, name, activity_code, edit_comment) VALUES
    ('111', 'Unit A', '20.0', '2017 Load'), -- Data changed -> new slice
    ('222', 'Unit B', '30.0', '2017 Load'), -- Identical data -> should coalesce
    ('333', 'Unit C', '40.0', '2017 Load (comment changed)'); -- Ephemeral change -> should update in place
CALL repro.load_data('2017-01-01', '2018-01-01');
\echo '--- State after 2017 load ---'
SELECT org_nr, name, activity_code, edit_comment, valid_from, valid_until
FROM repro.units ORDER BY org_nr, valid_from;
RELEASE SAVEPOINT load_2017;


-- 5. Load 2018 data: The final, open-ended period
SAVEPOINT load_2018;
TRUNCATE source_units RESTART IDENTITY;
INSERT INTO source_units (org_nr, name, activity_code, edit_comment) VALUES
    ('111', 'Unit A', '20.0', '2018 Load'), -- Identical to 2017 -> should coalesce
    ('222', 'Unit B', '30.0', '2018 Load'), -- Identical to 2016/2017 -> should coalesce
    ('333', 'Unit C', '50.0', '2018 Load'); -- Data changed -> new slice
CALL repro.load_data('2018-01-01', 'infinity');
\echo '--- Final state after 2018 load (BUG REPRODUCED HERE) ---'
RELEASE SAVEPOINT load_2018;


-- 6. Final verification: Check the complete history
-- Expected for Unit A ('111'): 2 rows. One for 2016, one for [2017, infinity)
-- Expected for Unit B ('222'): 1 row for [2016, infinity)
-- Expected for Unit C ('333'): 2 rows. One for [2016, 2018), one for [2018, infinity)
-- The bug will likely manifest as extra, un-coalesced rows.
SELECT org_nr, name, activity_code, edit_comment, valid_from, valid_until
FROM repro.units
ORDER BY org_nr, valid_from;


ROLLBACK;

\i sql/include/test_teardown.sql
