\i sql/include/test_setup.sql

BEGIN;

SET client_min_messages TO NOTICE;

CREATE SCHEMA repro;

-- This is a minimal reproduction of the coalescing bug found in the Statbus
-- `304_test_complex_happy_path` test.
-- The bug: an adjacent timeline segment is not coalesced if the update only
-- changes ephemeral data and the entity is identified by a natural key.

-- 1. A minimal target table. The key is that `edit_comment` is ephemeral.
CREATE TABLE repro.establishment (
    id int GENERATED BY DEFAULT AS IDENTITY,
    org_nr text,
    name text,
    edit_comment text,
    valid_from date NOT NULL,
    valid_until date
);

SELECT sql_saga.add_era('repro.establishment');
SELECT sql_saga.add_unique_key('repro.establishment', ARRAY['id'], key_type => 'primary');
SELECT sql_saga.add_unique_key('repro.establishment', ARRAY['org_nr'], key_type => 'natural');

-- 2. The source table for data loading.
CREATE TEMP TABLE source_data (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    org_nr text,
    name text,
    edit_comment text,
    valid_from date,
    valid_until date
) ON COMMIT DROP;


-- 3. Load initial state for Q1.
-- The `id` column is absent from the source, forcing lookup purely by the natural key `org_nr`.
\echo '--- Loading Q1: Initial state ---'
INSERT INTO source_data (org_nr, name, edit_comment, valid_from, valid_until) VALUES
    ('111', 'Est A v1', 'Q1 Load', '2023-01-01', '2023-04-01');

-- The key of this test: CALL temporal_merge WITHOUT specifying identity columns.
-- The procedure should discover the primary key ('id') and natural key ('org_nr')
-- from the metadata.
CALL sql_saga.temporal_merge(
    target_table => 'repro.establishment',
    source_table => 'source_data',
    ephemeral_columns => ARRAY['edit_comment'],
    mode => 'MERGE_ENTITY_PATCH'
);

\echo '--- State after Q1 load ---'
SELECT id, org_nr, name, edit_comment, valid_from, valid_until
FROM repro.establishment ORDER BY id, valid_from;


-- 4. Load an update for Q2 with a real data change. This creates a new slice.
\echo '--- Loading Q2: Real data change ---'
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (org_nr, name, edit_comment, valid_from, valid_until) VALUES
    ('111', 'Est A v2', 'Q2 Load', '2023-04-01', '2023-07-01');

CALL sql_saga.temporal_merge(
    target_table => 'repro.establishment',
    source_table => 'source_data',
    ephemeral_columns => ARRAY['edit_comment'],
    mode => 'MERGE_ENTITY_PATCH'
);

\echo '--- State after Q2 load ---'
SELECT id, org_nr, name, edit_comment, valid_from, valid_until
FROM repro.establishment ORDER BY id, valid_from;


-- 5. Load an update for Q3 with only an ephemeral change.
-- This SHOULD coalesce with the previous (Q2) slice.
\echo '--- Loading Q3: Ephemeral-only change (BUG REPRODUCED HERE) ---'
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (org_nr, name, edit_comment, valid_from, valid_until) VALUES
    ('111', 'Est A v2', 'Q3 Load', '2023-07-01', '2023-10-01');

CALL sql_saga.temporal_merge(
    target_table => 'repro.establishment',
    source_table => 'source_data',
    ephemeral_columns => ARRAY['edit_comment'],
    mode => 'MERGE_ENTITY_PATCH'
);


\echo '--- Final State ---'
-- The bug manifests as an extra, un-coalesced row for Q3.
SELECT id, org_nr, name, edit_comment, valid_from, valid_until
FROM repro.establishment ORDER BY id, valid_from;

-- Expected output after Q3 load: 2 rows
-- 1. [2023-01-01, 2023-04-01) -> name: 'Est A v1'
-- 2. [2023-04-01, 2023-10-01) -> name: 'Est A v2' (coalesced from Q2 and Q3)

ROLLBACK;

\i sql/include/test_teardown.sql
