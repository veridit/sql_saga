\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
-- This test file reproduces two distinct regressions in `temporal_merge`.
-- Each regression is tested in its own savepoint for isolation.
\set ECHO all
BEGIN;
CREATE SCHEMA saga_repro;
-- Base table definitions used by both scenarios
CREATE TABLE saga_repro.target_units_template (
    unit_ident text NOT NULL,
    name text,
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_to date,
    valid_until date
);
CREATE TABLE saga_repro.source_units_template (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    batch_seq int,
    unit_ident text,
    name text,
    sector text,
    valid_from date,
    valid_to date,
    merge_status jsonb,
    errors jsonb
);
GRANT USAGE ON SCHEMA saga_repro TO sql_saga_unprivileged_user;
--------------------------------------------------------------------------------
-- SCENARIO 1: Ordering Dependency Regression
--
-- This script demonstrates a regression where `temporal_merge` fails if its
-- source data contains complex overlapping temporal segments that are not
-- pre-sorted chronologically.
--------------------------------------------------------------------------------
SAVEPOINT scenario_ordering_dependency;
\echo '\n--- SCENARIO 1: Comparing merge strategies for out-of-order source data ---'

--- SCENARIO 1: Comparing merge strategies for out-of-order source data ---
-- Setup for Scenario 1
CREATE TABLE saga_repro.target_units_a (LIKE saga_repro.target_units_template);
CREATE TABLE saga_repro.target_units_b (LIKE saga_repro.target_units_template);
CREATE TABLE saga_repro.target_units_c (LIKE saga_repro.target_units_template);
ALTER TABLE saga_repro.target_units_a ADD PRIMARY KEY (unit_ident, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_era('saga_repro.target_units_a', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
NOTICE:  sql_saga: Created trigger "target_units_a_synchronize_temporal_columns_trigger" on table saga_repro.target_units_a to synchronize columns: valid_to, valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('saga_repro.target_units_a', ARRAY['unit_ident'], key_type => 'natural');
NOTICE:  sql_saga: altering table saga_repro.target_units_a to add constraints: ADD CONSTRAINT target_units_a_unit_ident_valid_uniq UNIQUE (unit_ident, valid_range WITHOUT OVERLAPS)
         add_unique_key          
---------------------------------
 target_units_a_unit_ident_valid
(1 row)

ALTER TABLE saga_repro.target_units_b ADD PRIMARY KEY (unit_ident, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_era('saga_repro.target_units_b', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
NOTICE:  sql_saga: Created trigger "target_units_b_synchronize_temporal_columns_trigger" on table saga_repro.target_units_b to synchronize columns: valid_to, valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('saga_repro.target_units_b', ARRAY['unit_ident'], key_type => 'natural');
NOTICE:  sql_saga: altering table saga_repro.target_units_b to add constraints: ADD CONSTRAINT target_units_b_unit_ident_valid_uniq UNIQUE (unit_ident, valid_range WITHOUT OVERLAPS)
         add_unique_key          
---------------------------------
 target_units_b_unit_ident_valid
(1 row)

ALTER TABLE saga_repro.target_units_c ADD PRIMARY KEY (unit_ident, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_era('saga_repro.target_units_c', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
NOTICE:  sql_saga: Created trigger "target_units_c_synchronize_temporal_columns_trigger" on table saga_repro.target_units_c to synchronize columns: valid_to, valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('saga_repro.target_units_c', ARRAY['unit_ident'], key_type => 'natural');
NOTICE:  sql_saga: altering table saga_repro.target_units_c to add constraints: ADD CONSTRAINT target_units_c_unit_ident_valid_uniq UNIQUE (unit_ident, valid_range WITHOUT OVERLAPS)
         add_unique_key          
---------------------------------
 target_units_c_unit_ident_valid
(1 row)

CREATE TABLE saga_repro.source_units_ordering (LIKE saga_repro.source_units_template INCLUDING ALL);
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA saga_repro TO sql_saga_unprivileged_user;
INSERT INTO saga_repro.source_units_ordering (batch_seq, unit_ident, name, valid_from, valid_to) VALUES
    (1, 'unit1', 'Initial P1',   '2023-01-01', '2023-03-31'),
    (1, 'unit1', 'Initial P2',   '2023-04-01', '2023-06-30'),
    (1, 'unit1', 'Initial P3',   '2023-07-01', '2023-09-30'),
    (2, 'unit1', 'Replacing pA', '2023-02-15', '2023-05-15'),
    (2, 'unit1', 'Replacing pB', '2023-05-16', '2023-08-15'),
    (2, 'unit1', 'Replacing pC', '2023-08-16', '2023-12-01');
GRANT ALL ON saga_repro.source_units_ordering TO sql_saga_unprivileged_user;
SET ROLE TO sql_saga_unprivileged_user;
-- Strategy A: Process one row at a time (baseline for correctness)
\echo '\n--- STRATEGY A: Processing one row at a time ---\n'

--- STRATEGY A: Processing one row at a time ---

CREATE TEMP TABLE source_a AS SELECT * FROM saga_repro.source_units_ordering;
-- Row 1
CREATE TEMP VIEW source_view_1 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 1;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_1', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run1');
-- Row 2
CREATE TEMP VIEW source_view_2 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 2;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_2', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run2');
-- Row 3
CREATE TEMP VIEW source_view_3 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 3;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_3', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run3');
-- Row 4
CREATE TEMP VIEW source_view_4 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 4;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_4', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run4');
-- Row 5
CREATE TEMP VIEW source_view_5 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 5;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_5', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run5');
-- Row 6
CREATE TEMP VIEW source_view_6 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_a WHERE row_id = 6;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view_6', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run6');
-- Strategy B: Process in logical batches
CREATE TEMP TABLE source_b AS SELECT * FROM saga_repro.source_units_ordering;
CREATE TEMP VIEW source_view_b1 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_b WHERE batch_seq = 1;
CREATE TEMP VIEW source_view_b2 AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_b WHERE batch_seq = 2;
\echo '\n--- STRATEGY B: Processing in logical batches ---\n'

--- STRATEGY B: Processing in logical batches ---

CALL sql_saga.temporal_merge(
    'saga_repro.target_units_b', 'source_view_b1',
    natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT',
    update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'batch1'
);
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_b', 'source_view_b2',
    natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT',
    update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'batch2'
);
-- Strategy C: Process all rows in one batch (the failing case)
CREATE TEMP TABLE source_c AS SELECT * FROM saga_repro.source_units_ordering;
CREATE TEMP VIEW source_view_c AS SELECT row_id, unit_ident, name, valid_from, valid_to, errors, merge_status FROM source_c;
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_c', 'source_view_c',
    natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT',
    update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run'
);
-- Final results for Scenario 1
\echo '\n\n--- FINAL COMPARISON OF FINAL STATES (SCENARIO 1) ---'


--- FINAL COMPARISON OF FINAL STATES (SCENARIO 1) ---
\echo '\n-- Strategy A: One-by-one Result'

-- Strategy A: One-by-one Result
SELECT unit_ident, name, valid_from, valid_to FROM saga_repro.target_units_a ORDER BY valid_from, name;
 unit_ident |     name     | valid_from |  valid_to  
------------+--------------+------------+------------
 unit1      | Initial P1   | 2023-01-01 | 2023-02-14
 unit1      | Replacing pA | 2023-02-15 | 2023-05-15
 unit1      | Replacing pB | 2023-05-16 | 2023-08-15
 unit1      | Replacing pC | 2023-08-16 | 2023-12-01
(4 rows)

\echo '\n-- Strategy B: Batch-by-batch Result'

-- Strategy B: Batch-by-batch Result
SELECT unit_ident, name, valid_from, valid_to FROM saga_repro.target_units_b ORDER BY valid_from, name;
 unit_ident |     name     | valid_from |  valid_to  
------------+--------------+------------+------------
 unit1      | Initial P1   | 2023-01-01 | 2023-02-14
 unit1      | Replacing pA | 2023-02-15 | 2023-05-15
 unit1      | Replacing pB | 2023-05-16 | 2023-08-15
 unit1      | Replacing pC | 2023-08-16 | 2023-12-01
(4 rows)

\echo '\n-- Strategy C: All-in-one Result'

-- Strategy C: All-in-one Result
SELECT unit_ident, name, valid_from, valid_to FROM saga_repro.target_units_c ORDER BY valid_from, name;
 unit_ident |     name     | valid_from |  valid_to  
------------+--------------+------------+------------
 unit1      | Initial P1   | 2023-01-01 | 2023-02-14
 unit1      | Replacing pA | 2023-02-15 | 2023-05-15
 unit1      | Replacing pB | 2023-05-16 | 2023-08-15
 unit1      | Replacing pC | 2023-08-16 | 2023-12-01
(4 rows)

\echo '\n-- Diff check of strategy results (should be empty)'

-- Diff check of strategy results (should be empty)
\echo '\n-- Diff A vs B:'

-- Diff A vs B:
(TABLE saga_repro.target_units_a EXCEPT TABLE saga_repro.target_units_b)
UNION ALL
(TABLE saga_repro.target_units_b EXCEPT TABLE saga_repro.target_units_a);
 unit_ident | name | valid_range | valid_from | valid_to | valid_until 
------------+------+-------------+------------+----------+-------------
(0 rows)

\echo '\n-- Diff B vs C:'

-- Diff B vs C:
(TABLE saga_repro.target_units_b EXCEPT TABLE saga_repro.target_units_c)
UNION ALL
(TABLE saga_repro.target_units_c EXCEPT TABLE saga_repro.target_units_b);
 unit_ident | name | valid_range | valid_from | valid_to | valid_until 
------------+------+-------------+------------+----------+-------------
(0 rows)

\echo '\n\n--- FINAL COMPARISON OF FEEDBACK (SCENARIO 1) ---'


--- FINAL COMPARISON OF FEEDBACK (SCENARIO 1) ---
\echo '\n-- Strategy A: One-by-one Feedback'

-- Strategy A: One-by-one Feedback
SELECT row_id, batch_seq, name, merge_status, errors FROM source_a ORDER BY row_id;
 row_id | batch_seq |     name     |    merge_status     | errors 
--------+-----------+--------------+---------------------+--------
      1 |         1 | Initial P1   | {"run1": "APPLIED"} | 
      2 |         1 | Initial P2   | {"run2": "APPLIED"} | 
      3 |         1 | Initial P3   | {"run3": "APPLIED"} | 
      4 |         2 | Replacing pA | {"run4": "APPLIED"} | 
      5 |         2 | Replacing pB | {"run5": "APPLIED"} | 
      6 |         2 | Replacing pC | {"run6": "APPLIED"} | 
(6 rows)

\echo '\n-- Strategy B: Batch-by-batch Feedback'

-- Strategy B: Batch-by-batch Feedback
SELECT row_id, batch_seq, name, merge_status, errors FROM source_b ORDER BY row_id;
 row_id | batch_seq |     name     |     merge_status      | errors 
--------+-----------+--------------+-----------------------+--------
      1 |         1 | Initial P1   | {"batch1": "APPLIED"} | 
      2 |         1 | Initial P2   | {"batch1": "APPLIED"} | 
      3 |         1 | Initial P3   | {"batch1": "APPLIED"} | 
      4 |         2 | Replacing pA | {"batch2": "APPLIED"} | 
      5 |         2 | Replacing pB | {"batch2": "APPLIED"} | 
      6 |         2 | Replacing pC | {"batch2": "APPLIED"} | 
(6 rows)

\echo '\n-- Strategy C: All-in-one Feedback'

-- Strategy C: All-in-one Feedback
SELECT row_id, batch_seq, name, merge_status, errors FROM source_c ORDER BY row_id;
 row_id | batch_seq |     name     |        merge_status         | errors 
--------+-----------+--------------+-----------------------------+--------
      1 |         1 | Initial P1   | {"run": "APPLIED"}          | 
      2 |         1 | Initial P2   | {"run": "SKIPPED_ECLIPSED"} | 
      3 |         1 | Initial P3   | {"run": "SKIPPED_ECLIPSED"} | 
      4 |         2 | Replacing pA | {"run": "APPLIED"}          | 
      5 |         2 | Replacing pB | {"run": "APPLIED"}          | 
      6 |         2 | Replacing pC | {"run": "APPLIED"}          | 
(6 rows)

ROLLBACK TO SAVEPOINT scenario_ordering_dependency;
--------------------------------------------------------------------------------
-- SCENARIO 2: Coalescing Regression
--
-- This test demonstrates a regression where `temporal_merge` fails to coalesce
-- adjacent, identical time segments when they are processed in separate batches.
--------------------------------------------------------------------------------
SAVEPOINT scenario_coalescing;
\echo '\n--- SCENARIO 2: Coalescing identical, adjacent records across batches ---'

--- SCENARIO 2: Coalescing identical, adjacent records across batches ---
-- Setup for Scenario 2
CREATE TABLE saga_repro.target_units_coalesce (
    LIKE saga_repro.target_units_template,
    notes text -- Add a nullable column that does not exist in the source table
);
ALTER TABLE saga_repro.target_units_coalesce ADD PRIMARY KEY (unit_ident, valid_range WITHOUT OVERLAPS);
CREATE TABLE saga_repro.source_units_coalesce (LIKE saga_repro.source_units_template INCLUDING ALL);
SELECT sql_saga.add_era('saga_repro.target_units_coalesce', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
NOTICE:  sql_saga: Created trigger "target_units_coalesce_synchronize_temporal_columns_trigger" on table saga_repro.target_units_coalesce to synchronize columns: valid_to, valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('saga_repro.target_units_coalesce', ARRAY['unit_ident'], key_type => 'natural');
NOTICE:  sql_saga: altering table saga_repro.target_units_coalesce to add constraints: ADD CONSTRAINT target_units_coalesce_unit_ident_valid_uniq UNIQUE (unit_ident, valid_range WITHOUT OVERLAPS)
             add_unique_key             
----------------------------------------
 target_units_coalesce_unit_ident_valid
(1 row)

GRANT ALL ON saga_repro.target_units_coalesce TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_units_coalesce TO sql_saga_unprivileged_user;
-- Batch 1
INSERT INTO saga_repro.source_units_coalesce (unit_ident, name, valid_from, valid_to) VALUES
    ('unit1', 'Unit A', '2023-01-01', '2023-06-30');
SET ROLE TO sql_saga_unprivileged_user;
CALL sql_saga.temporal_merge('saga_repro.target_units_coalesce', 'saga_repro.source_units_coalesce', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_PATCH');
RESET ROLE;
\echo '\n--- State after Batch 1 ---'

--- State after Batch 1 ---
SELECT unit_ident, name, valid_from, valid_to, notes FROM saga_repro.target_units_coalesce;
 unit_ident |  name  | valid_from |  valid_to  | notes 
------------+--------+------------+------------+-------
 unit1      | Unit A | 2023-01-01 | 2023-06-30 | 
(1 row)

-- Batch 2 (the failing step)
TRUNCATE saga_repro.source_units_coalesce;
INSERT INTO saga_repro.source_units_coalesce (unit_ident, name, valid_from, valid_to) VALUES
    ('unit1', 'Unit A', '2023-07-01', '2023-12-31');
SET ROLE TO sql_saga_unprivileged_user;
CALL sql_saga.temporal_merge('saga_repro.target_units_coalesce', 'saga_repro.source_units_coalesce', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_PATCH');
RESET ROLE;
-- Final results for Scenario 2
\echo '\n-- Coalescing Test Final State (Bug Repro: 2 rows, Correct: 1 row)'

-- Coalescing Test Final State (Bug Repro: 2 rows, Correct: 1 row)
SELECT unit_ident, name, valid_from, valid_to, notes FROM saga_repro.target_units_coalesce ORDER BY valid_from;
 unit_ident |  name  | valid_from |  valid_to  | notes 
------------+--------+------------+------------+-------
 unit1      | Unit A | 2023-01-01 | 2023-12-31 | 
(1 row)

ROLLBACK TO SAVEPOINT scenario_coalescing;
--------------------------------------------------------------------------------
-- SCENARIO 3: Ephemeral column handling in PATCH, UPSERT, and REPLACE modes
--
-- This scenario clarifies the semantic differences between the main merge modes
-- with respect to NULLs and ephemeral columns.
--------------------------------------------------------------------------------
SAVEPOINT scenario_ephemeral_modes;
\echo '\n--- SCENARIO 3: Ephemeral column handling in PATCH, UPSERT, and REPLACE modes ---'

--- SCENARIO 3: Ephemeral column handling in PATCH, UPSERT, and REPLACE modes ---
CREATE TABLE saga_repro.target_units_ephemeral (
    id int GENERATED BY DEFAULT AS IDENTITY,
    unit_ident text NOT NULL,
    name text NOT NULL,
    notes text,
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_to date,
    valid_until date,
    -- NOTE: Use a fixed timestamp for `edit_at` to ensure deterministic test results.
    -- Using `now()` or `clock_timestamp()` would cause the output to change on every run.
    edit_at timestamptz NOT NULL DEFAULT '2025-10-03 12:00:00+00',
    edit_comment text
);
CREATE TABLE saga_repro.source_units_ephemeral (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    unit_ident text, name text, notes text,
    valid_from date, valid_to date,
    edit_at timestamptz, edit_comment text
);
ALTER TABLE saga_repro.target_units_ephemeral ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_era('saga_repro.target_units_ephemeral', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
NOTICE:  sql_saga: Created trigger "target_units_ephemeral_synchronize_temporal_columns_trigger" on table saga_repro.target_units_ephemeral to synchronize columns: valid_to, valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('saga_repro.target_units_ephemeral', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table saga_repro.target_units_ephemeral to add constraints: ALTER COLUMN id SET NOT NULL
         add_unique_key          
---------------------------------
 target_units_ephemeral_id_valid
(1 row)

SELECT sql_saga.add_unique_key('saga_repro.target_units_ephemeral', ARRAY['unit_ident'], key_type => 'natural');
NOTICE:  sql_saga: altering table saga_repro.target_units_ephemeral to add constraints: ADD CONSTRAINT target_units_ephemeral_unit_ident_valid_uniq UNIQUE (unit_ident, valid_range WITHOUT OVERLAPS), ADD CONSTRAINT target_units_ephemeral_unit_ident_valid_pk_consistency_excl EXCLUDE USING gist (unit_ident WITH =, id WITH <>)
             add_unique_key              
-----------------------------------------
 target_units_ephemeral_unit_ident_valid
(1 row)

GRANT ALL ON saga_repro.target_units_ephemeral TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_units_ephemeral TO sql_saga_unprivileged_user;
\echo '\n-- Case 3a: MERGE_ENTITY_PATCH'

-- Case 3a: MERGE_ENTITY_PATCH
\echo '-- Expectation: The NULL for `edit_comment` is ignored, and the original value is preserved. `notes` is inherited.'
-- Expectation: The NULL for `edit_comment` is ignored, and the original value is preserved. `notes` is inherited.
SAVEPOINT case_patch;
-- Initial state for this case
TRUNCATE saga_repro.target_units_ephemeral, saga_repro.source_units_ephemeral RESTART IDENTITY;
INSERT INTO saga_repro.target_units_ephemeral (unit_ident, name, notes, valid_from, valid_to, edit_comment)
VALUES ('unit1', 'Unit A', 'Original notes', '2023-01-01', '2023-12-31', 'Initial version');
INSERT INTO saga_repro.source_units_ephemeral (unit_ident, name, valid_from, valid_to, edit_comment)
VALUES ('unit1', 'Unit A Updated', '2023-06-01', '2023-08-31', NULL); -- `edit_comment` is NULL, `notes` is absent
\echo '\n--- Initial State ---'

--- Initial State ---
TABLE saga_repro.target_units_ephemeral;
 id | unit_ident |  name  |     notes      |       valid_range       | valid_from |  valid_to  | valid_until |        edit_at         |  edit_comment   
----+------------+--------+----------------+-------------------------+------------+------------+-------------+------------------------+-----------------
  1 | unit1      | Unit A | Original notes | [2023-01-01,2024-01-01) | 2023-01-01 | 2023-12-31 | 2024-01-01  | 2025-10-03 05:00:00-07 | Initial version
(1 row)

\echo '\n--- Source Data ---'

--- Source Data ---
TABLE saga_repro.source_units_ephemeral;
 row_id | unit_ident |      name      | notes | valid_from |  valid_to  | edit_at | edit_comment 
--------+------------+----------------+-------+------------+------------+---------+--------------
      1 | unit1      | Unit A Updated |       | 2023-06-01 | 2023-08-31 |         | 
(1 row)

SET ROLE TO sql_saga_unprivileged_user;
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_ephemeral', 'saga_repro.source_units_ephemeral',
    natural_identity_columns => ARRAY['unit_ident'],
    ephemeral_columns => ARRAY['edit_at', 'edit_comment'],
    mode => 'MERGE_ENTITY_PATCH'
);
RESET ROLE;
\echo '\n--- Final State (PATCH) ---'

--- Final State (PATCH) ---
SELECT unit_ident, name, notes, valid_from, valid_to, edit_comment FROM saga_repro.target_units_ephemeral ORDER BY valid_from;
 unit_ident |      name      |     notes      | valid_from |  valid_to  |  edit_comment   
------------+----------------+----------------+------------+------------+-----------------
 unit1      | Unit A         | Original notes | 2023-01-01 | 2023-05-31 | Initial version
 unit1      | Unit A Updated | Original notes | 2023-06-01 | 2023-08-31 | Initial version
 unit1      | Unit A         | Original notes | 2023-09-01 | 2023-12-31 | Initial version
(3 rows)

ROLLBACK TO SAVEPOINT case_patch;
\echo '\n-- Case 3b: MERGE_ENTITY_UPSERT'

-- Case 3b: MERGE_ENTITY_UPSERT
\echo '-- Expectation: The NULL for `edit_comment` overwrites the original value. `notes` is also overwritten with NULL as it is absent from the source INSERT, but present as a column in the source table.'
-- Expectation: The NULL for `edit_comment` overwrites the original value. `notes` is also overwritten with NULL as it is absent from the source INSERT, but present as a column in the source table.
SAVEPOINT case_upsert;
-- Initial state for this case
TRUNCATE saga_repro.target_units_ephemeral, saga_repro.source_units_ephemeral RESTART IDENTITY;
INSERT INTO saga_repro.target_units_ephemeral (unit_ident, name, notes, valid_from, valid_to, edit_comment)
VALUES ('unit1', 'Unit A', 'Original notes', '2023-01-01', '2023-12-31', 'Initial version');
INSERT INTO saga_repro.source_units_ephemeral (unit_ident, name, valid_from, valid_to, edit_comment)
VALUES ('unit1', 'Unit A Updated', '2023-06-01', '2023-08-31', NULL); -- `edit_comment` is NULL, `notes` is absent
\echo '\n--- Initial State ---'

--- Initial State ---
TABLE saga_repro.target_units_ephemeral;
 id | unit_ident |  name  |     notes      |       valid_range       | valid_from |  valid_to  | valid_until |        edit_at         |  edit_comment   
----+------------+--------+----------------+-------------------------+------------+------------+-------------+------------------------+-----------------
  1 | unit1      | Unit A | Original notes | [2023-01-01,2024-01-01) | 2023-01-01 | 2023-12-31 | 2024-01-01  | 2025-10-03 05:00:00-07 | Initial version
(1 row)

\echo '\n--- Source Data ---'

--- Source Data ---
TABLE saga_repro.source_units_ephemeral;
 row_id | unit_ident |      name      | notes | valid_from |  valid_to  | edit_at | edit_comment 
--------+------------+----------------+-------+------------+------------+---------+--------------
      1 | unit1      | Unit A Updated |       | 2023-06-01 | 2023-08-31 |         | 
(1 row)

SET ROLE TO sql_saga_unprivileged_user;
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_ephemeral', 'saga_repro.source_units_ephemeral',
    natural_identity_columns => ARRAY['unit_ident'],
    ephemeral_columns => ARRAY['edit_at', 'edit_comment'],
    mode => 'MERGE_ENTITY_UPSERT'
);
RESET ROLE;
\echo '\n--- Final State (UPSERT) ---'

--- Final State (UPSERT) ---
SELECT unit_ident, name, notes, valid_from, valid_to, edit_comment FROM saga_repro.target_units_ephemeral ORDER BY valid_from;
 unit_ident |      name      |     notes      | valid_from |  valid_to  |  edit_comment   
------------+----------------+----------------+------------+------------+-----------------
 unit1      | Unit A         | Original notes | 2023-01-01 | 2023-05-31 | Initial version
 unit1      | Unit A Updated |                | 2023-06-01 | 2023-08-31 | 
 unit1      | Unit A         | Original notes | 2023-09-01 | 2023-12-31 | Initial version
(3 rows)

ROLLBACK TO SAVEPOINT case_upsert;
\echo '\n-- Case 3c: MERGE_ENTITY_REPLACE'

-- Case 3c: MERGE_ENTITY_REPLACE
\echo '-- Expectation: The source payload completely replaces the target. `notes` is set to NULL because it is absent from the source INSERT, but present as a column in the source table.'
-- Expectation: The source payload completely replaces the target. `notes` is set to NULL because it is absent from the source INSERT, but present as a column in the source table.
SAVEPOINT case_replace;
-- Initial state for this case
TRUNCATE saga_repro.target_units_ephemeral, saga_repro.source_units_ephemeral RESTART IDENTITY;
INSERT INTO saga_repro.target_units_ephemeral (unit_ident, name, notes, valid_from, valid_to, edit_comment)
VALUES ('unit1', 'Unit A', 'Original notes', '2023-01-01', '2023-12-31', 'Initial version');
INSERT INTO saga_repro.source_units_ephemeral (unit_ident, name, valid_from, valid_to, edit_comment)
VALUES ('unit1', 'Unit A Updated', '2023-06-01', '2023-08-31', NULL); -- `edit_comment` is NULL, `notes` is absent
\echo '\n--- Initial State ---'

--- Initial State ---
TABLE saga_repro.target_units_ephemeral;
 id | unit_ident |  name  |     notes      |       valid_range       | valid_from |  valid_to  | valid_until |        edit_at         |  edit_comment   
----+------------+--------+----------------+-------------------------+------------+------------+-------------+------------------------+-----------------
  1 | unit1      | Unit A | Original notes | [2023-01-01,2024-01-01) | 2023-01-01 | 2023-12-31 | 2024-01-01  | 2025-10-03 05:00:00-07 | Initial version
(1 row)

\echo '\n--- Source Data ---'

--- Source Data ---
TABLE saga_repro.source_units_ephemeral;
 row_id | unit_ident |      name      | notes | valid_from |  valid_to  | edit_at | edit_comment 
--------+------------+----------------+-------+------------+------------+---------+--------------
      1 | unit1      | Unit A Updated |       | 2023-06-01 | 2023-08-31 |         | 
(1 row)

SET ROLE TO sql_saga_unprivileged_user;
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_ephemeral', 'saga_repro.source_units_ephemeral',
    natural_identity_columns => ARRAY['unit_ident'],
    ephemeral_columns => ARRAY['edit_at', 'edit_comment'],
    mode => 'MERGE_ENTITY_REPLACE'
);
RESET ROLE;
\echo '\n--- Final State (REPLACE) ---'

--- Final State (REPLACE) ---
SELECT unit_ident, name, notes, valid_from, valid_to, edit_comment FROM saga_repro.target_units_ephemeral ORDER BY valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK TO SAVEPOINT case_replace;
ROLLBACK TO SAVEPOINT scenario_ephemeral_modes;
--------------------------------------------------------------------------------
-- SCENARIO 4: UPSERT mode with NOT NULL DEFAULT columns
--
-- This test validates that when using MERGE_ENTITY_UPSERT, an incoming NULL
-- for a column that is defined as NOT NULL DEFAULT does not cause a NOT NULL
-- violation. Instead, the executor preserves the existing value, effectively
-- treating NULL as "no change" for this specific combination of constraints and mode.
--------------------------------------------------------------------------------
SAVEPOINT scenario_not_null_default;
\echo '\n--- SCENARIO 4: UPSERT with NOT NULL DEFAULT columns ---'

--- SCENARIO 4: UPSERT with NOT NULL DEFAULT columns ---
CREATE TABLE saga_repro.target_not_null_default (
    unit_ident text NOT NULL,
    name text NOT NULL,
    status text NOT NULL DEFAULT 'active',
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_to date,
    valid_until date
);
CREATE TABLE saga_repro.source_not_null_default (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    unit_ident text, name text, status text,
    valid_from date, valid_to date
);
ALTER TABLE saga_repro.target_not_null_default ADD PRIMARY KEY (unit_ident, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_era('saga_repro.target_not_null_default', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
NOTICE:  sql_saga: Created trigger "target_not_null_default_synchronize_temporal_columns_trigger" on table saga_repro.target_not_null_default to synchronize columns: valid_to, valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('saga_repro.target_not_null_default', ARRAY['unit_ident'], key_type => 'natural');
NOTICE:  sql_saga: altering table saga_repro.target_not_null_default to add constraints: ADD CONSTRAINT target_not_null_default_unit_ident_valid_uniq UNIQUE (unit_ident, valid_range WITHOUT OVERLAPS)
              add_unique_key              
------------------------------------------
 target_not_null_default_unit_ident_valid
(1 row)

GRANT ALL ON saga_repro.target_not_null_default TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_not_null_default TO sql_saga_unprivileged_user;
-- Initial state: one record with default status
INSERT INTO saga_repro.target_not_null_default (unit_ident, name, valid_from, valid_until)
VALUES ('unit1', 'Unit A', '2023-01-01', '2024-01-01');
\echo '\n--- Initial State ---'

--- Initial State ---
TABLE saga_repro.target_not_null_default;
 unit_ident |  name  | status |       valid_range       | valid_from |  valid_to  | valid_until 
------------+--------+--------+-------------------------+------------+------------+-------------
 unit1      | Unit A | active | [2023-01-01,2024-01-01) | 2023-01-01 | 2023-12-31 | 2024-01-01
(1 row)

-- Source data: provides NULL for the 'status' column, which has a NOT NULL DEFAULT constraint.
INSERT INTO saga_repro.source_not_null_default (unit_ident, name, status, valid_from, valid_to)
VALUES ('unit1', 'Unit A Updated', NULL, '2023-06-01', '2023-08-31');
\echo '\n--- Source Data ---'

--- Source Data ---
TABLE saga_repro.source_not_null_default;
 row_id | unit_ident |      name      | status | valid_from |  valid_to  
--------+------------+----------------+--------+------------+------------
      1 | unit1      | Unit A Updated |        | 2023-06-01 | 2023-08-31
(1 row)

SET ROLE TO sql_saga_unprivileged_user;
CALL sql_saga.temporal_merge(
    'saga_repro.target_not_null_default', 'saga_repro.source_not_null_default',
    natural_identity_columns => ARRAY['unit_ident'],
    mode => 'MERGE_ENTITY_UPSERT'
);
RESET ROLE;
\echo '\n--- Final State (UPSERT with NOT NULL DEFAULT) ---'

--- Final State (UPSERT with NOT NULL DEFAULT) ---
\echo '-- Expectation: The `status` remains "active" in all segments, as the incoming NULL was ignored.'
-- Expectation: The `status` remains "active" in all segments, as the incoming NULL was ignored.
SELECT unit_ident, name, status, valid_from, valid_to FROM saga_repro.target_not_null_default ORDER BY valid_from;
 unit_ident |      name      | status | valid_from |  valid_to  
------------+----------------+--------+------------+------------
 unit1      | Unit A         | active | 2023-01-01 | 2023-05-31
 unit1      | Unit A Updated | active | 2023-06-01 | 2023-08-31
 unit1      | Unit A         | active | 2023-09-01 | 2023-12-31
(3 rows)

ROLLBACK TO SAVEPOINT scenario_not_null_default;
--------------------------------------------------------------------------------
-- SCENARIO 5: UPDATE_FOR_PORTION_OF incorrectly merges distinct attribute values
--
-- This reproduces a critical Statbus regression where updating a non-name attribute
-- (like legal_form_id) via a FOR_PORTION_OF view incorrectly merges temporal rows
-- that have different names, losing historical name changes.
--
-- Issue: When the same entity has different attribute values across adjacent time
-- periods (e.g., name changed from "A" to "B"), updating another attribute across
-- the full timeline should preserve both distinct names, not merge them into one.
--------------------------------------------------------------------------------
SAVEPOINT scenario_update_for_portion_of_merging;
\echo '\n--- SCENARIO 5: UPDATE_FOR_PORTION_OF should preserve distinct attribute values ---'

--- SCENARIO 5: UPDATE_FOR_PORTION_OF should preserve distinct attribute values ---
-- Create tables mimicking Statbus legal_unit structure (simplified)
CREATE TABLE saga_repro.legal_unit (
    id int GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL,
    legal_form_id int NOT NULL DEFAULT 1,
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_until date
);
SELECT sql_saga.add_era('saga_repro.legal_unit', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "legal_unit_synchronize_temporal_columns_trigger" on table saga_repro.legal_unit to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

ALTER TABLE saga_repro.legal_unit ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_unique_key('saga_repro.legal_unit', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table saga_repro.legal_unit to add constraints: ALTER COLUMN id SET NOT NULL
   add_unique_key    
---------------------
 legal_unit_id_valid
(1 row)

-- Create FOR_PORTION_OF view
SELECT sql_saga.add_for_portion_of_view('saga_repro.legal_unit', era_name => 'valid');
 add_for_portion_of_view 
-------------------------
 t
(1 row)

GRANT ALL ON saga_repro.legal_unit TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.legal_unit__for_portion_of_valid TO sql_saga_unprivileged_user;
-- Insert test data matching Statbus pattern:
-- Same entity ID, different names, adjacent time periods
INSERT INTO saga_repro.legal_unit (id, name, legal_form_id, valid_from, valid_until) VALUES
    (1, 'EQUATOR GLOBE SOLUTIONS', 1, '2023-01-01', '2024-01-01'),
    (1, 'EQUATOR GLOBE SOLUTIONS #2', 1, '2024-01-01', '2026-01-01');
\echo '\n--- Initial State: Two rows, same ID, different names ---'

--- Initial State: Two rows, same ID, different names ---
SELECT id, name, legal_form_id, valid_from, valid_until 
FROM saga_repro.legal_unit 
ORDER BY valid_from;
 id |            name            | legal_form_id | valid_from | valid_until 
----+----------------------------+---------------+------------+-------------
  1 | EQUATOR GLOBE SOLUTIONS    |             1 | 2023-01-01 | 2024-01-01
  1 | EQUATOR GLOBE SOLUTIONS #2 |             1 | 2024-01-01 | 2026-01-01
(2 rows)

-- Execute the problematic UPDATE via FOR_PORTION_OF view
-- This should update legal_form_id across the FULL timeline (2023-2026)
-- Expected: 2 rows with legal_form_id=2, preserving both distinct names
-- Bug: 1 merged row losing the original name "EQUATOR GLOBE SOLUTIONS"
SET ROLE TO sql_saga_unprivileged_user;
UPDATE saga_repro.legal_unit__for_portion_of_valid
SET legal_form_id = 2, valid_from = '2023-01-01', valid_until = '2026-01-01'
WHERE id = 1;
RESET ROLE;
\echo '\n--- After UPDATE FOR PORTION OF (full timeline) ---'

--- After UPDATE FOR PORTION OF (full timeline) ---
\echo '-- Expected: 2 rows preserving distinct names'
-- Expected: 2 rows preserving distinct names
\echo '-- Bug: 1 row with merged name (loses "EQUATOR GLOBE SOLUTIONS")'
-- Bug: 1 row with merged name (loses "EQUATOR GLOBE SOLUTIONS")
SELECT id, name, legal_form_id, valid_from, valid_until 
FROM saga_repro.legal_unit 
ORDER BY valid_from;
 id |            name            | legal_form_id | valid_from | valid_until 
----+----------------------------+---------------+------------+-------------
  1 | EQUATOR GLOBE SOLUTIONS    |             2 | 2023-01-01 | 2024-01-01
  1 | EQUATOR GLOBE SOLUTIONS #2 |             2 | 2024-01-01 | 2026-01-01
(2 rows)

ROLLBACK TO SAVEPOINT scenario_update_for_portion_of_merging;
--------------------------------------------------------------------------------
-- SCENARIO 6: Timeline splits should preserve audit columns (edit_at, edit_by_user_id)
--
-- Issue: When temporal_merge splits a timeline segment (e.g., a PATCH_FOR_PORTION_OF
-- operation that affects the middle of an existing timeline), the audit columns
-- (edit_at, edit_by_user_id, edit_comment) should be preserved from the original
-- segment, not reset to NULL or now().
--
-- Currently: The split segments lose their audit trail, with edit_at being reset
-- to the current timestamp and edit_by_user_id potentially being nulled.
--------------------------------------------------------------------------------
SAVEPOINT scenario_audit_column_preservation;
\echo '\n--- SCENARIO 6: Timeline splits should preserve audit columns ---'

--- SCENARIO 6: Timeline splits should preserve audit columns ---
-- Create a temporal table with audit columns
CREATE TABLE saga_repro.audited_unit (
    id int GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL,
    status text NOT NULL,
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_until date,
    -- Audit columns with fixed defaults for deterministic testing
    edit_at timestamptz NOT NULL DEFAULT '2024-01-01 10:00:00+00'::timestamptz,
    edit_by_user_id int NOT NULL DEFAULT 1,
    edit_comment text
);
SELECT sql_saga.add_era('saga_repro.audited_unit', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "audited_unit_synchronize_temporal_columns_trigger" on table saga_repro.audited_unit to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

ALTER TABLE saga_repro.audited_unit ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_unique_key('saga_repro.audited_unit', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table saga_repro.audited_unit to add constraints: ALTER COLUMN id SET NOT NULL
    add_unique_key     
-----------------------
 audited_unit_id_valid
(1 row)

-- Insert initial data: one row spanning the full year 2024 with specific audit info
INSERT INTO saga_repro.audited_unit (id, name, status, valid_from, valid_until, edit_at, edit_by_user_id, edit_comment)
VALUES (1, 'Unit Alpha', 'active', '2024-01-01', '2025-01-01', '2024-01-15 14:30:00+00', 100, 'Initial creation');
\echo '\n--- Initial State: One row spanning full year 2024 ---'

--- Initial State: One row spanning full year 2024 ---
SELECT id, name, status, valid_from, valid_until, edit_at, edit_by_user_id, edit_comment
FROM saga_repro.audited_unit
ORDER BY valid_from;
 id |    name    | status | valid_from | valid_until |        edit_at         | edit_by_user_id |   edit_comment   
----+------------+--------+------------+-------------+------------------------+-----------------+------------------
  1 | Unit Alpha | active | 2024-01-01 | 2025-01-01  | 2024-01-15 06:30:00-08 |             100 | Initial creation
(1 row)

-- Create a source table to update just the middle portion (April-September)
-- This should cause a 3-way split of the timeline
CREATE TEMP TABLE source_audit_split (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id int,
    status text,
    valid_from date,
    valid_until date,
    edit_at timestamptz,
    edit_by_user_id int,
    edit_comment text
);
INSERT INTO source_audit_split (id, status, valid_from, valid_until, edit_at, edit_by_user_id, edit_comment)
VALUES (1, 'suspended', '2024-04-01', '2024-10-01', '2024-04-05 16:45:00+00', 200, 'Status update for Q2-Q3');
\echo '\n--- Source: Update middle portion (April-September) with new audit info ---'

--- Source: Update middle portion (April-September) with new audit info ---
SELECT id, status, valid_from, valid_until, edit_at, edit_by_user_id, edit_comment
FROM source_audit_split;
 id |  status   | valid_from | valid_until |        edit_at         | edit_by_user_id |      edit_comment       
----+-----------+------------+-------------+------------------------+-----------------+-------------------------
  1 | suspended | 2024-04-01 | 2024-10-01  | 2024-04-05 09:45:00-07 |             200 | Status update for Q2-Q3
(1 row)

-- Perform the merge which will split the timeline
CALL sql_saga.temporal_merge(
    'saga_repro.audited_unit', 'source_audit_split',
    primary_identity_columns => ARRAY['id'],
    ephemeral_columns => ARRAY['edit_at', 'edit_by_user_id', 'edit_comment'],
    mode => 'MERGE_ENTITY_PATCH'
);
\echo '\n--- After Timeline Split ---'

--- After Timeline Split ---
\echo '-- Expected: 3 segments'
-- Expected: 3 segments
\echo '--   Jan-Mar:  status=active,    edit_at=2024-01-15 (PRESERVED from original)'
--   Jan-Mar:  status=active,    edit_at=2024-01-15 (PRESERVED from original)
\echo '--   Apr-Sep:  status=suspended, edit_at=2024-04-05 (NEW from source)'
--   Apr-Sep:  status=suspended, edit_at=2024-04-05 (NEW from source)
\echo '--   Oct-Dec:  status=active,    edit_at=2024-01-15 (PRESERVED from original)'
--   Oct-Dec:  status=active,    edit_at=2024-01-15 (PRESERVED from original)
\echo '--'
--
\echo '-- Bug: Segments before/after might have:'
-- Bug: Segments before/after might have:
\echo '--   - edit_at reset to now() instead of preserved'
--   - edit_at reset to now() instead of preserved
\echo '--   - edit_by_user_id reset to NULL or default'
--   - edit_by_user_id reset to NULL or default
\echo '--   - edit_comment lost'
--   - edit_comment lost
SELECT id, name, status, valid_from, valid_until, 
       edit_at, edit_by_user_id, edit_comment
FROM saga_repro.audited_unit
ORDER BY valid_from;
 id |    name    |  status   | valid_from | valid_until |        edit_at         | edit_by_user_id |      edit_comment       
----+------------+-----------+------------+-------------+------------------------+-----------------+-------------------------
  1 | Unit Alpha | active    | 2024-01-01 | 2024-04-01  | 2024-01-15 06:30:00-08 |             100 | Initial creation
  1 | Unit Alpha | suspended | 2024-04-01 | 2024-10-01  | 2024-01-01 02:00:00-08 |               1 | Status update for Q2-Q3
  1 | Unit Alpha | active    | 2024-10-01 | 2025-01-01  | 2024-01-01 02:00:00-08 |               1 | Initial creation
(3 rows)

ROLLBACK TO SAVEPOINT scenario_audit_column_preservation;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
