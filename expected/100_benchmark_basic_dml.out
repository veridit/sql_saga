\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
SET ROLE TO sql_saga_unprivileged_user;
\i sql/include/benchmark_setup.sql
CREATE TEMPORARY TABLE benchmark (
  seq_id BIGINT GENERATED ALWAYS AS IDENTITY,
  timestamp TIMESTAMPTZ DEFAULT clock_timestamp(),
  event TEXT,
  row_count INTEGER,
  is_performance_benchmark BOOLEAN NOT NULL
);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('BEGIN', 0, false);
-- Enable detailed temporal_merge index logging for this benchmark session.
--SET sql_saga.temporal_merge.log_index_checks = true;
CREATE TABLE legal_unit (id INTEGER, valid_from date, valid_until date, name varchar NOT NULL, PRIMARY KEY (id, valid_from));
CREATE TABLE establishment (id INTEGER, valid_from date, valid_until date, legal_unit_id INTEGER NOT NULL, postal_place TEXT NOT NULL, PRIMARY KEY (id, valid_from));
CREATE TABLE projects (id serial primary key, name text, legal_unit_id int);
\echo '--- Populating tables ---'
--- Populating tables ---
INSERT INTO legal_unit SELECT i, '2015-01-01', 'infinity', 'Company ' || i FROM generate_series(1, 20000) i;
-- Establishments only for the first 10,000 legal units
INSERT INTO establishment SELECT i, '2015-01-01', 'infinity', i, 'Shop ' || i FROM generate_series(1, 10000) i;
INSERT INTO projects (name, legal_unit_id) SELECT 'Project ' || i, i FROM generate_series(1, 10000) i;
ANALYZE legal_unit;
ANALYZE establishment;
ANALYZE projects;
--------------------------------------------------------------------------------
\echo '--- DML on Plain Tables (No sql_saga constraints) ---'
--- DML on Plain Tables (No sql_saga constraints) ---
--------------------------------------------------------------------------------
-- Parent DML
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent INSERT (Plain)', 0, false);
INSERT INTO legal_unit SELECT i, '2015-01-01', 'infinity', 'New Company ' || i FROM generate_series(20001, 21000) i;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent INSERT (Plain) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent UPDATE Key (Plain)', 0, false);
UPDATE legal_unit SET valid_from = '2014-01-01' WHERE id BETWEEN 1 AND 1000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent UPDATE Key (Plain) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent UPDATE Non-Key (Plain)', 0, false);
UPDATE legal_unit SET name = 'Updated Company' WHERE id BETWEEN 1001 AND 2000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent UPDATE Non-Key (Plain) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent DELETE (Plain)', 0, false);
DELETE FROM legal_unit WHERE id BETWEEN 15001 AND 16000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent DELETE (Plain) end', 1000, true);
-- Child DML
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child INSERT (Plain)', 0, false);
INSERT INTO establishment SELECT i, '2015-01-01', 'infinity', i, 'New Shop ' || i FROM generate_series(10001, 11000) i;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child INSERT (Plain) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child UPDATE Key (Plain)', 0, false);
UPDATE establishment SET valid_from = '2014-01-01' WHERE id BETWEEN 1 AND 1000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child UPDATE Key (Plain) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child UPDATE Non-Key (Plain)', 0, false);
UPDATE establishment SET postal_place = 'New Place' WHERE id BETWEEN 1001 AND 2000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child UPDATE Non-Key (Plain) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child DELETE (Plain)', 0, false);
DELETE FROM establishment WHERE id BETWEEN 9001 AND 10000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child DELETE (Plain) end', 1000, true);
-- Regular Table DML
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular INSERT (Plain)', 0, false);
INSERT INTO projects (name, legal_unit_id) SELECT 'New Project ' || i, i FROM generate_series(10001, 11000) i;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular INSERT (Plain) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular UPDATE (Plain)', 0, false);
UPDATE projects SET name = 'Updated Project' WHERE id BETWEEN 1 AND 1000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular UPDATE (Plain) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular DELETE (Plain)', 0, false);
DELETE FROM projects WHERE id BETWEEN 9001 AND 10000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular DELETE (Plain) end', 1000, true);
\echo '--- Resetting tables and enabling sql_saga constraints ---'
--- Resetting tables and enabling sql_saga constraints ---
TRUNCATE legal_unit, establishment, projects;
INSERT INTO legal_unit SELECT i, '2015-01-01', 'infinity', 'Company ' || i FROM generate_series(1, 20000) i;
INSERT INTO establishment SELECT i, '2015-01-01', 'infinity', i, 'Shop ' || i FROM generate_series(1, 10000) i;
INSERT INTO projects (name, legal_unit_id) SELECT 'Project ' || i, i FROM generate_series(1, 10000) i;
ANALYZE legal_unit;
ANALYZE establishment;
ANALYZE projects;
-- Enable sql_saga constraints
SELECT sql_saga.add_era('legal_unit'::regclass);
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_era('establishment'::regclass);
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('legal_unit'::regclass, column_names => ARRAY['id'], unique_key_name => 'legal_unit_id_valid');
NOTICE:  sql_saga: altering table public.legal_unit to add constraints: ADD CONSTRAINT legal_unit_id_valid_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT legal_unit_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE, ADD CONSTRAINT legal_unit_id_valid_pk_consistency_excl EXCLUDE USING gist (id WITH =, id WITH <>)
   add_unique_key    
---------------------
 legal_unit_id_valid
(1 row)

SELECT sql_saga.add_unique_key('establishment'::regclass, column_names => ARRAY['id']);
NOTICE:  sql_saga: altering table public.establishment to add constraints: ADD CONSTRAINT establishment_id_valid_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT establishment_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE, ADD CONSTRAINT establishment_id_valid_pk_consistency_excl EXCLUDE USING gist (id WITH =, id WITH <>)
     add_unique_key     
------------------------
 establishment_id_valid
(1 row)

SELECT sql_saga.add_foreign_key('establishment'::regclass, ARRAY['legal_unit_id'], 'legal_unit'::regclass, ARRAY['id'], fk_era_name => 'valid', create_index => false);
WARNING:  No index found on table establishment for foreign key columns ({legal_unit_id}). Performance may be poor.
HINT:  Consider creating this index: CREATE INDEX establishment_legal_unit_id_valid_gist_idx ON establishment USING GIST (legal_unit_id, daterange(valid_from, valid_until))
          add_foreign_key          
-----------------------------------
 establishment_legal_unit_id_valid
(1 row)

SELECT sql_saga.add_foreign_key('projects', ARRAY['legal_unit_id'], 'legal_unit', ARRAY['id']);
NOTICE:  No compatible index found for foreign key on table projects. Creating new index: CREATE INDEX projects_legal_unit_id_idx ON projects USING BTREE (legal_unit_id)
       add_foreign_key       
-----------------------------
 projects_legal_unit_id_fkey
(1 row)

--------------------------------------------------------------------------------
\echo '--- DML on sql_saga Tables (No Performance Index) ---'
--- DML on sql_saga Tables (No Performance Index) ---
--------------------------------------------------------------------------------
-- Parent DML (fires uk_*_triggers)
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent INSERT (No Index)', 0, false);
INSERT INTO legal_unit SELECT i, '2015-01-01', 'infinity', 'New Company ' || i FROM generate_series(20001, 21000) i;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent INSERT (No Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent UPDATE Key (No Index)', 0, false);
UPDATE legal_unit SET valid_from = '2014-01-01' WHERE id BETWEEN 1 AND 1000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent UPDATE Key (No Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent UPDATE Non-Key (No Index)', 0, false);
UPDATE legal_unit SET name = 'Updated Company' WHERE id BETWEEN 1001 AND 2000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent UPDATE Non-Key (No Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent DELETE (No Index)', 0, false);
DELETE FROM legal_unit WHERE id BETWEEN 15001 AND 16000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent DELETE (No Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent DELETE (Check Only, No Index)', 0, false);
-- Delete a batch of parent rows that have no children; exercises FK check path without violations.
DELETE FROM legal_unit WHERE id BETWEEN 20001 AND 21000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent DELETE (Check Only, No Index) end', 1000, true);
-- Child DML (fires fk_*_triggers)
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child INSERT (No Index)', 0, false);
INSERT INTO establishment SELECT i, '2015-01-01', 'infinity', i, 'New Shop ' || i FROM generate_series(10001, 11000) i;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child INSERT (No Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child UPDATE Key (No Index)', 0, false);
UPDATE establishment SET valid_from = '2014-01-01' WHERE id BETWEEN 1 AND 1000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child UPDATE Key (No Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child UPDATE Non-Key (No Index)', 0, false);
UPDATE establishment SET postal_place = 'New Place' WHERE id BETWEEN 1001 AND 2000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child UPDATE Non-Key (No Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child DELETE (No Index)', 0, false);
DELETE FROM establishment WHERE id BETWEEN 9001 AND 10000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child DELETE (No Index) end', 1000, true);
-- Regular Table DML (fires CHECK constraint)
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular INSERT (No Index)', 0, false);
INSERT INTO projects (name, legal_unit_id) SELECT 'New Project ' || i, i FROM generate_series(10001, 11000) i;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular INSERT (No Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular UPDATE (No Index)', 0, false);
UPDATE projects SET legal_unit_id = id + 1 WHERE id BETWEEN 1 AND 1000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular UPDATE (No Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular DELETE (No Index)', 0, false);
DELETE FROM projects WHERE id BETWEEN 9001 AND 10000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular DELETE (No Index) end', 1000, true);
\echo '--- Adding performance index to child table ---'
--- Adding performance index to child table ---
CREATE INDEX ON establishment USING GIST (legal_unit_id, daterange(valid_from, valid_until));
--------------------------------------------------------------------------------
\echo '--- DML on sql_saga Tables (With Performance Index) ---'
--- DML on sql_saga Tables (With Performance Index) ---
--------------------------------------------------------------------------------
-- Parent DML (fires uk_*_triggers, now with index)
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent INSERT (With Index)', 0, false);
INSERT INTO legal_unit SELECT i, '2015-01-01', 'infinity', 'New Company ' || i FROM generate_series(21001, 22000) i;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent INSERT (With Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent UPDATE Key (With Index)', 0, false);
UPDATE legal_unit SET valid_from = '2013-01-01' WHERE id BETWEEN 2001 AND 3000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent UPDATE Key (With Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent UPDATE Non-Key (With Index)', 0, false);
UPDATE legal_unit SET name = 'Updated Again Company' WHERE id BETWEEN 3001 AND 4000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent UPDATE Non-Key (With Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent DELETE (With Index)', 0, false);
DELETE FROM legal_unit WHERE id BETWEEN 16001 AND 17000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent DELETE (With Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent DELETE (Check Only, With Index)', 0, false);
-- Delete a batch of parent rows that have no children; exercises FK check path without violations.
DELETE FROM legal_unit WHERE id BETWEEN 21001 AND 22000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Parent DELETE (Check Only, With Index) end', 1000, true);
-- Child DML (fires fk_*_triggers, should be unaffected by index on parent)
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child INSERT (With Index)', 0, false);
INSERT INTO establishment SELECT i, '2015-01-01', 'infinity', i, 'New Shop ' || i FROM generate_series(11001, 12000) i;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child INSERT (With Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child UPDATE Key (With Index)', 0, false);
UPDATE establishment SET valid_from = '2013-01-01' WHERE id BETWEEN 2001 AND 3000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child UPDATE Key (With Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child UPDATE Non-Key (With Index)', 0, false);
UPDATE establishment SET postal_place = 'New Place Again' WHERE id BETWEEN 3001 AND 4000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child UPDATE Non-Key (With Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child DELETE (With Index)', 0, false);
DELETE FROM establishment WHERE id BETWEEN 8001 AND 9000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Child DELETE (With Index) end', 1000, true);
-- Regular Table DML (fires CHECK constraint)
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular INSERT (With Index)', 0, false);
INSERT INTO projects (name, legal_unit_id) SELECT 'New Project ' || i, i FROM generate_series(11001, 12000) i;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular INSERT (With Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular UPDATE (With Index)', 0, false);
UPDATE projects SET legal_unit_id = id + 2 WHERE id BETWEEN 1001 AND 2000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular UPDATE (With Index) end', 1000, true);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular DELETE (With Index)', 0, false);
DELETE FROM projects WHERE id BETWEEN 8001 AND 9000;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Regular DELETE (With Index) end', 1000, true);
--------------------------------------------------------------------------------
\echo '--- temporal_merge on sql_saga Tables (With Performance Index) ---'
--- temporal_merge on sql_saga Tables (With Performance Index) ---
--------------------------------------------------------------------------------
-- Prepare recommended indices by temporal_merge
CREATE INDEX ON legal_unit USING GIST (daterange(valid_from, valid_until, '[)'));
CREATE INDEX ON establishment USING GIST (daterange(valid_from, valid_until, '[)'));
-- Parent table merge
CREATE TEMP TABLE legal_unit_source (row_id int, id int, valid_from date, valid_until date, name varchar);
INSERT INTO legal_unit_source SELECT i, i, '2015-01-01', 'infinity', 'Updated via Merge ' || i FROM generate_series(4001, 5000) AS i;
CREATE INDEX ON legal_unit_source(id);
CREATE INDEX ON legal_unit_source USING GIST (daterange(valid_from, valid_until, '[)'));
ANALYZE legal_unit_source;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('temporal_merge Parent (With Index)', 0, false);
CALL sql_saga.temporal_merge('legal_unit'::regclass, 'legal_unit_source'::regclass, ARRAY['id']);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('temporal_merge Parent (With Index) end', 1000, true);
-- Child table merge
CREATE TEMP TABLE establishment_source (row_id int, id int, valid_from date, valid_until date, legal_unit_id int, postal_place text);
INSERT INTO establishment_source SELECT i, i, '2015-01-01', 'infinity', i, 'Updated via Merge ' || i FROM generate_series(4001, 5000) AS i;
CREATE INDEX ON establishment_source(id);
CREATE INDEX ON establishment_source USING GIST (daterange(valid_from, valid_until, '[)'));
ANALYZE establishment_source;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('temporal_merge Child (With Index)', 0, false);
CALL sql_saga.temporal_merge('establishment'::regclass, 'establishment_source'::regclass, ARRAY['id']);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('temporal_merge Child (With Index) end', 1000, true);
-- Teardown sql_saga constraints
SELECT sql_saga.drop_foreign_key('projects', ARRAY['legal_unit_id']);
NOTICE:  Dropping automatically created index "projects_legal_unit_id_idx" for foreign key "projects_legal_unit_id_fkey"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_foreign_key('establishment'::regclass, ARRAY['legal_unit_id'], 'valid');
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_unique_key('establishment'::regclass, ARRAY['id'], 'valid');
NOTICE:  sql_saga: dropping constraint: ALTER TABLE public.establishment DROP CONSTRAINT establishment_id_valid_pk_consistency_excl
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('establishment'::regclass, cleanup => true);
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_unique_key('legal_unit'::regclass, ARRAY['id'], 'valid');
NOTICE:  sql_saga: dropping constraint: ALTER TABLE public.legal_unit DROP CONSTRAINT legal_unit_id_valid_pk_consistency_excl
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('legal_unit'::regclass, cleanup => true);
 drop_era 
----------
 t
(1 row)

DROP TABLE establishment;
DROP TABLE legal_unit;
DROP TABLE projects;
-- Verify the benchmark events and row counts, but exclude volatile timing data
-- from the regression test output to ensure stability.
SELECT event, row_count FROM benchmark ORDER BY seq_id;
                   event                    | row_count 
--------------------------------------------+-----------
 BEGIN                                      |         0
 Parent INSERT (Plain)                      |         0
 Parent INSERT (Plain) end                  |      1000
 Parent UPDATE Key (Plain)                  |         0
 Parent UPDATE Key (Plain) end              |      1000
 Parent UPDATE Non-Key (Plain)              |         0
 Parent UPDATE Non-Key (Plain) end          |      1000
 Parent DELETE (Plain)                      |         0
 Parent DELETE (Plain) end                  |      1000
 Child INSERT (Plain)                       |         0
 Child INSERT (Plain) end                   |      1000
 Child UPDATE Key (Plain)                   |         0
 Child UPDATE Key (Plain) end               |      1000
 Child UPDATE Non-Key (Plain)               |         0
 Child UPDATE Non-Key (Plain) end           |      1000
 Child DELETE (Plain)                       |         0
 Child DELETE (Plain) end                   |      1000
 Regular INSERT (Plain)                     |         0
 Regular INSERT (Plain) end                 |      1000
 Regular UPDATE (Plain)                     |         0
 Regular UPDATE (Plain) end                 |      1000
 Regular DELETE (Plain)                     |         0
 Regular DELETE (Plain) end                 |      1000
 Parent INSERT (No Index)                   |         0
 Parent INSERT (No Index) end               |      1000
 Parent UPDATE Key (No Index)               |         0
 Parent UPDATE Key (No Index) end           |      1000
 Parent UPDATE Non-Key (No Index)           |         0
 Parent UPDATE Non-Key (No Index) end       |      1000
 Parent DELETE (No Index)                   |         0
 Parent DELETE (No Index) end               |      1000
 Parent DELETE (Check Only, No Index)       |         0
 Parent DELETE (Check Only, No Index) end   |      1000
 Child INSERT (No Index)                    |         0
 Child INSERT (No Index) end                |      1000
 Child UPDATE Key (No Index)                |         0
 Child UPDATE Key (No Index) end            |      1000
 Child UPDATE Non-Key (No Index)            |         0
 Child UPDATE Non-Key (No Index) end        |      1000
 Child DELETE (No Index)                    |         0
 Child DELETE (No Index) end                |      1000
 Regular INSERT (No Index)                  |         0
 Regular INSERT (No Index) end              |      1000
 Regular UPDATE (No Index)                  |         0
 Regular UPDATE (No Index) end              |      1000
 Regular DELETE (No Index)                  |         0
 Regular DELETE (No Index) end              |      1000
 Parent INSERT (With Index)                 |         0
 Parent INSERT (With Index) end             |      1000
 Parent UPDATE Key (With Index)             |         0
 Parent UPDATE Key (With Index) end         |      1000
 Parent UPDATE Non-Key (With Index)         |         0
 Parent UPDATE Non-Key (With Index) end     |      1000
 Parent DELETE (With Index)                 |         0
 Parent DELETE (With Index) end             |      1000
 Parent DELETE (Check Only, With Index)     |         0
 Parent DELETE (Check Only, With Index) end |      1000
 Child INSERT (With Index)                  |         0
 Child INSERT (With Index) end              |      1000
 Child UPDATE Key (With Index)              |         0
 Child UPDATE Key (With Index) end          |      1000
 Child UPDATE Non-Key (With Index)          |         0
 Child UPDATE Non-Key (With Index) end      |      1000
 Child DELETE (With Index)                  |         0
 Child DELETE (With Index) end              |      1000
 Regular INSERT (With Index)                |         0
 Regular INSERT (With Index) end            |      1000
 Regular UPDATE (With Index)                |         0
 Regular UPDATE (With Index) end            |      1000
 Regular DELETE (With Index)                |         0
 Regular DELETE (With Index) end            |      1000
 temporal_merge Parent (With Index)         |         0
 temporal_merge Parent (With Index) end     |      1000
 temporal_merge Child (With Index)          |         0
 temporal_merge Child (With Index) end      |      1000
(75 rows)

-- Capture performance metrics to a separate file for manual review.
\o expected/100_benchmark_basic_dml_performance.out
\i sql/include/benchmark_report.sql
-- Calculate rows per second
CREATE OR REPLACE FUNCTION format_duration(p_interval interval) RETURNS TEXT AS $$
BEGIN
    IF p_interval IS NULL THEN RETURN ''; END IF;
    IF EXTRACT(EPOCH FROM p_interval) >= 1 THEN
        RETURN ROUND(EXTRACT(EPOCH FROM p_interval))::numeric || ' secs';
    ELSE
        RETURN ROUND(EXTRACT(EPOCH FROM p_interval) * 1000)::numeric || ' ms';
    END IF;
END;
$$ LANGUAGE plpgsql;
WITH benchmark_events AS (
  SELECT
    seq_id,
    timestamp,
    event,
    row_count,
    is_performance_benchmark,
    regexp_replace(event, ' (start|end)$', '') AS operation,
    CASE
      WHEN event LIKE '% start' THEN 'start'
      WHEN event LIKE '% end' THEN 'end'
      ELSE 'milestone'
    END AS phase,
    FIRST_VALUE(timestamp) OVER (ORDER BY seq_id) as benchmark_start_time,
    LAG(timestamp) OVER (ORDER BY seq_id) as prev_event_time
  FROM
    benchmark
),
benchmark_durations AS (
  SELECT
    *,
    LAG(timestamp) OVER (PARTITION BY operation ORDER BY seq_id) AS operation_start_time
  FROM
    benchmark_events
)
SELECT
  CASE WHEN phase = 'end' THEN operation ELSE event END AS event,
  row_count,
  format_duration(timestamp - benchmark_start_time) AS time_from_start,
  CASE
    WHEN phase = 'end' THEN format_duration(timestamp - operation_start_time)
    WHEN phase = 'milestone' THEN format_duration(timestamp - prev_event_time)
    ELSE ''
  END AS time_from_prev,
  row_count || ' rows' AS row_count,
  CASE
    WHEN is_performance_benchmark AND phase = 'end' THEN
        '~' ||
            CASE
            WHEN EXTRACT(EPOCH FROM (timestamp - operation_start_time)) > 0.001 THEN
                ROUND(row_count::FLOAT8 / EXTRACT(EPOCH FROM (timestamp - operation_start_time)))::text
            ELSE
                '0'
            END
        || ' rows/s'
    ELSE
        ''
  END AS rows_per_second
FROM
  benchmark_durations
WHERE phase <> 'start'
ORDER BY
  seq_id;
-- Stop redirecting output
\o
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
