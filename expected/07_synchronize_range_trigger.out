\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
SET ROLE TO sql_saga_unprivileged_user;
SET client_min_messages TO NOTICE;
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo 'Test: Automatic range column synchronization via add_era'
Test: Automatic range column synchronization via add_era
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo '--- 1. Test default behavior: DATE range ---'
--- 1. Test default behavior: DATE range ---
SAVEPOINT test_1;
CREATE TABLE sync_range_default (id int, valid_from date, valid_until date, validity daterange);
SELECT sql_saga.add_era('sync_range_default', p_synchronize_range_column := 'validity');
NOTICE:  sql_saga: Created trigger "sync_range_default_synchronize_temporal_columns_trigger" on table sync_range_default to synchronize columns: validity
 add_era 
---------
 t
(1 row)

\d sync_range_default
            Table "public.sync_range_default"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 valid_from  | date      |           | not null | 
 valid_until | date      |           | not null | 
 validity    | daterange |           | not null | 
Check constraints:
    "sync_range_default_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)
Triggers:
    sync_range_default_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_from, valid_until, validity ON sync_range_default FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_from', 'valid_until', 'null', 'validity', 'date', 't')

-- 1a. INSERT with bounds, range is auto-populated
INSERT INTO sync_range_default (id, valid_from, valid_until) VALUES (1, '2024-01-01', '2025-01-01');
SELECT id, valid_from, valid_until, validity FROM sync_range_default;
 id | valid_from | valid_until |        validity         
----+------------+-------------+-------------------------
  1 | 2024-01-01 | 2025-01-01  | [2024-01-01,2025-01-01)
(1 row)

-- 1b. INSERT with range, bounds are auto-populated
INSERT INTO sync_range_default (id, validity) VALUES (2, '[2024-02-01, 2025-02-01)');
SELECT id, valid_from, valid_until, validity FROM sync_range_default WHERE id = 2;
 id | valid_from | valid_until |        validity         
----+------------+-------------+-------------------------
  2 | 2024-02-01 | 2025-02-01  | [2024-02-01,2025-02-01)
(1 row)

-- 1c. UPDATE bounds, range is auto-updated
UPDATE sync_range_default SET valid_from = '2026-01-01', valid_until = '2027-01-01' WHERE id = 1;
SELECT id, valid_from, valid_until, validity FROM sync_range_default WHERE id = 1;
 id | valid_from | valid_until |        validity         
----+------------+-------------+-------------------------
  1 | 2026-01-01 | 2027-01-01  | [2026-01-01,2027-01-01)
(1 row)

-- 1d. UPDATE range, bounds are auto-updated
UPDATE sync_range_default SET validity = '[2027-01-01, 2028-01-01)' WHERE id = 1;
SELECT id, valid_from, valid_until, validity FROM sync_range_default WHERE id = 1;
 id | valid_from | valid_until |        validity         
----+------------+-------------+-------------------------
  1 | 2027-01-01 | 2028-01-01  | [2027-01-01,2028-01-01)
(1 row)

ROLLBACK TO SAVEPOINT test_1;
\echo '--- 2. Test disabling the feature with NULL ---'
--- 2. Test disabling the feature with NULL ---
SAVEPOINT test_2;
CREATE TABLE sync_range_disabled (id int, valid_from date, valid_until date, validity daterange);
SELECT sql_saga.add_era('sync_range_disabled');
 add_era 
---------
 t
(1 row)

\d sync_range_disabled
                Table "public.sync_range_disabled"
   Column    |   Type    | Collation | Nullable |     Default      
-------------+-----------+-----------+----------+------------------
 id          | integer   |           |          | 
 valid_from  | date      |           | not null | 
 valid_until | date      |           | not null | 'infinity'::date
 validity    | daterange |           |          | 
Check constraints:
    "sync_range_disabled_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

-- This will succeed with inconsistent data, proving the trigger was not created.
INSERT INTO sync_range_disabled (id, valid_from, valid_until, validity) VALUES (1, '2024-01-01', '2025-01-01', '[2099-01-01, 2099-12-31)');
SELECT id, valid_from, valid_until, validity FROM sync_range_disabled;
 id | valid_from | valid_until |        validity         
----+------------+-------------+-------------------------
  1 | 2024-01-01 | 2025-01-01  | [2099-01-01,2099-12-31)
(1 row)

ROLLBACK TO SAVEPOINT test_2;
\echo '--- 3. Test with a custom column name and INT4RANGE (a discrete type) ---'
--- 3. Test with a custom column name and INT4RANGE (a discrete type) ---
SAVEPOINT test_3;
CREATE TABLE sync_range_custom (id int, start_num int, until_num int, num_range int4range, to_num int);
SELECT sql_saga.add_era('sync_range_custom', 'start_num', 'until_num', p_synchronize_valid_to_column := 'to_num', p_synchronize_range_column := 'num_range');
NOTICE:  sql_saga: Created trigger "sync_range_custom_synchronize_temporal_columns_trigger" on table sync_range_custom to synchronize columns: to_num, num_range
 add_era 
---------
 t
(1 row)

\d sync_range_custom
            Table "public.sync_range_custom"
  Column   |   Type    | Collation | Nullable | Default 
-----------+-----------+-----------+----------+---------
 id        | integer   |           |          | 
 start_num | integer   |           | not null | 
 until_num | integer   |           | not null | 
 num_range | int4range |           | not null | 
 to_num    | integer   |           | not null | 
Check constraints:
    "sync_range_custom_valid_check" CHECK (start_num < until_num)
Triggers:
    sync_range_custom_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF start_num, until_num, to_num, num_range ON sync_range_custom FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('start_num', 'until_num', 'to_num', 'num_range', 'integer', 'f')

INSERT INTO sync_range_custom (id, num_range) VALUES (1, '[100, 200)');
SELECT id, start_num, until_num, num_range, to_num FROM sync_range_custom;
 id | start_num | until_num | num_range | to_num 
----+-----------+-----------+-----------+--------
  1 |       100 |       200 | [100,200) |    199
(1 row)

ROLLBACK TO SAVEPOINT test_3;
\echo '--- 4. Test error case: inconsistent data on INSERT ---'
--- 4. Test error case: inconsistent data on INSERT ---
SAVEPOINT test_4;
CREATE TABLE sync_range_error (id int, valid_from date, valid_until date, validity daterange);
SELECT sql_saga.add_era('sync_range_error', p_synchronize_range_column := 'validity');
NOTICE:  sql_saga: Created trigger "sync_range_error_synchronize_temporal_columns_trigger" on table sync_range_error to synchronize columns: validity
 add_era 
---------
 t
(1 row)

-- This should fail due to inconsistency between the bounds and the range.
DO $$
BEGIN
    INSERT INTO sync_range_error (id, valid_from, valid_until, validity) VALUES (1, '2024-01-01', '2025-01-01', '[2099-01-01, 2099-12-31)');
EXCEPTION WHEN others THEN
    RAISE NOTICE 'Caught expected error: %', SQLERRM;
END;
$$;
NOTICE:  Caught expected error: Inconsistent values: "valid_from" is 2024-01-01, but is derived as 2099-01-01 from other inputs.
-- This should succeed because the bounds and range are consistent.
INSERT INTO sync_range_error (id, valid_from, valid_until, validity) VALUES (2, '2023-01-01', '2024-01-01', '[2023-01-01, 2024-01-01)');
SELECT * FROM sync_range_error;
 id | valid_from | valid_until |        validity         
----+------------+-------------+-------------------------
  2 | 2023-01-01 | 2024-01-01  | [2023-01-01,2024-01-01)
(1 row)

ROLLBACK TO SAVEPOINT test_4;
\echo '--- 5. Test error case: inclusive-upper bound range is rejected ---'
--- 5. Test error case: inclusive-upper bound range is rejected ---
SAVEPOINT test_5;
CREATE TABLE sync_range_bounds (id int, valid_from date, valid_until date, validity daterange);
SELECT sql_saga.add_era('sync_range_bounds', p_synchronize_range_column := 'validity');
NOTICE:  sql_saga: Created trigger "sync_range_bounds_synchronize_temporal_columns_trigger" on table sync_range_bounds to synchronize columns: validity
 add_era 
---------
 t
(1 row)

-- This should fail because the range is '[ , ]' not '[ , )'
DO $$
BEGIN
    INSERT INTO sync_range_bounds (id, validity) VALUES (1, daterange('2024-01-01', '2024-12-31', '[]'));
EXCEPTION WHEN others THEN
    RAISE NOTICE 'Caught expected error: %', SQLERRM;
END;
$$;
ROLLBACK TO SAVEPOINT test_5;
\echo '--- 6. Test edge case: generated column is skipped ---'
--- 6. Test edge case: generated column is skipped ---
SAVEPOINT test_6;
CREATE TABLE sync_range_generated (id int, valid_from date, valid_until date, validity daterange GENERATED ALWAYS AS (daterange(valid_from, valid_until, '[)')) STORED);
SELECT sql_saga.add_era('sync_range_generated', p_synchronize_range_column := 'validity');
NOTICE:  sql_saga: Created trigger "sync_range_generated_synchronize_temporal_columns_trigger" on table sync_range_generated to synchronize columns: validity
 add_era 
---------
 t
(1 row)

\d sync_range_generated
                                             Table "public.sync_range_generated"
   Column    |   Type    | Collation | Nullable |                                   Default                                   
-------------+-----------+-----------+----------+-----------------------------------------------------------------------------
 id          | integer   |           |          | 
 valid_from  | date      |           | not null | 
 valid_until | date      |           | not null | 
 validity    | daterange |           | not null | generated always as (daterange(valid_from, valid_until, '[)'::text)) stored
Check constraints:
    "sync_range_generated_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)
Triggers:
    sync_range_generated_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_from, valid_until, validity ON sync_range_generated FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_from', 'valid_until', 'null', 'validity', 'date', 't')

-- This will succeed, proving no trigger was created.
INSERT INTO sync_range_generated (id, valid_from, valid_until) VALUES (1, '2024-01-01', '2025-01-01');
SELECT id, valid_from, valid_until, validity FROM sync_range_generated;
 id | valid_from | valid_until |        validity         
----+------------+-------------+-------------------------
  1 | 2024-01-01 | 2025-01-01  | [2024-01-01,2025-01-01)
(1 row)

ROLLBACK TO SAVEPOINT test_6;
\echo '--- 7. Test interaction between both synchronization triggers ---'
--- 7. Test interaction between both synchronization triggers ---
SAVEPOINT test_7;
CREATE TABLE sync_both (id int, valid_from date, valid_to date, valid_until date, validity daterange);
-- Enable both triggers
SELECT sql_saga.add_era('sync_both', p_synchronize_valid_to_column := 'valid_to', p_synchronize_range_column := 'validity', p_add_defaults := false);
NOTICE:  sql_saga: Created trigger "sync_both_synchronize_temporal_columns_trigger" on table sync_both to synchronize columns: valid_to, validity
 add_era 
---------
 t
(1 row)

\d sync_both
                 Table "public.sync_both"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 valid_from  | date      |           | not null | 
 valid_to    | date      |           | not null | 
 valid_until | date      |           | not null | 
 validity    | daterange |           | not null | 
Check constraints:
    "sync_both_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)
Triggers:
    sync_both_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_from, valid_until, valid_to, validity ON sync_both FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_from', 'valid_until', 'valid_to', 'validity', 'date', 'f')

-- 7a. INSERT with range, other columns are auto-populated
INSERT INTO sync_both (id, validity) VALUES (1, '[2024-01-01, 2025-01-01)');
SELECT id, valid_from, valid_until, valid_to, validity FROM sync_both WHERE id=1;
 id | valid_from | valid_until |  valid_to  |        validity         
----+------------+-------------+------------+-------------------------
  1 | 2024-01-01 | 2025-01-01  | 2024-12-31 | [2024-01-01,2025-01-01)
(1 row)

-- 7b. INSERT with valid_to, other columns are auto-populated
INSERT INTO sync_both (id, valid_from, valid_to) VALUES (2, '2026-01-01', '2026-12-31');
SELECT id, valid_from, valid_until, valid_to, validity FROM sync_both WHERE id=2;
 id | valid_from | valid_until |  valid_to  |        validity         
----+------------+-------------+------------+-------------------------
  2 | 2026-01-01 | 2027-01-01  | 2026-12-31 | [2026-01-01,2027-01-01)
(1 row)

-- 7c. INSERT with valid_until, other columns are auto-populated
INSERT INTO sync_both (id, valid_from, valid_until) VALUES (3, '2028-01-01', '2029-01-01');
SELECT id, valid_from, valid_until, valid_to, validity FROM sync_both WHERE id=3;
 id | valid_from | valid_until |  valid_to  |        validity         
----+------------+-------------+------------+-------------------------
  3 | 2028-01-01 | 2029-01-01  | 2028-12-31 | [2028-01-01,2029-01-01)
(1 row)

-- 7c2. INSERT with NULL valid_until, should get default from trigger
SAVEPOINT with_defaults_test;
-- To test this, we must re-add the era with defaults enabled.
SELECT sql_saga.drop_era('sync_both');
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.add_era('sync_both', p_synchronize_valid_to_column := 'valid_to', p_synchronize_range_column := 'validity', p_add_defaults := true);
NOTICE:  sql_saga: Created trigger "sync_both_synchronize_temporal_columns_trigger" on table sync_both to synchronize columns: valid_to, validity
 add_era 
---------
 t
(1 row)

\d sync_both
                 Table "public.sync_both"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 valid_from  | date      |           | not null | 
 valid_to    | date      |           | not null | 
 valid_until | date      |           | not null | 
 validity    | daterange |           | not null | 
Check constraints:
    "sync_both_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)
Triggers:
    sync_both_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_from, valid_until, valid_to, validity ON sync_both FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_from', 'valid_until', 'valid_to', 'validity', 'date', 't')

INSERT INTO sync_both (id, valid_from, valid_until) VALUES (4, '2028-01-01', NULL);
SELECT * FROM sync_both WHERE id = 4;
 id | valid_from | valid_to | valid_until |       validity        
----+------------+----------+-------------+-----------------------
  4 | 2028-01-01 | infinity | infinity    | [2028-01-01,infinity)
(1 row)

ROLLBACK TO with_defaults_test;
-- The era should be back to its previous state (no defaults).
\d sync_both
                 Table "public.sync_both"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 valid_from  | date      |           | not null | 
 valid_to    | date      |           | not null | 
 valid_until | date      |           | not null | 
 validity    | daterange |           | not null | 
Check constraints:
    "sync_both_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)
Triggers:
    sync_both_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_from, valid_until, valid_to, validity ON sync_both FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_from', 'valid_until', 'valid_to', 'validity', 'date', 'f')

-- 7d. INSERT with CONSISTENT multiple representations (valid_to and range)
\echo '--- 7d. Test consistent multiple inputs ---'
--- 7d. Test consistent multiple inputs ---
INSERT INTO sync_both (id, valid_from, valid_to, validity) VALUES (5, '2030-01-01', '2030-12-31', '[2030-01-01, 2031-01-01)');
SELECT id, valid_from, valid_until, valid_to, validity FROM sync_both WHERE id=5;
 id | valid_from | valid_until |  valid_to  |        validity         
----+------------+-------------+------------+-------------------------
  5 | 2030-01-01 | 2031-01-01  | 2030-12-31 | [2030-01-01,2031-01-01)
(1 row)

-- 7e. INSERT with INCONSISTENT multiple representations (valid_to and range)
\echo '--- 7e. Test inconsistent multiple inputs ---'
--- 7e. Test inconsistent multiple inputs ---
DO $$
BEGIN
    INSERT INTO sync_both (id, valid_from, valid_to, validity) VALUES (6, '2030-01-01', '2030-12-31', '[2099-01-01, 2100-01-01)');
EXCEPTION WHEN others THEN
    RAISE NOTICE 'Caught expected error: %', SQLERRM;
END;
$$;
NOTICE:  Caught expected error: Inconsistent values: "valid_from" is 2030-01-01, but is derived as 2099-01-01 from other inputs.
-- 7f. UPDATE with INCONSISTENT multiple representations
\echo '--- 7f. Test inconsistent update ---'
--- 7f. Test inconsistent update ---
DO $$
BEGIN
    UPDATE sync_both SET valid_to = '2025-12-31', validity = '[2099-01-01, 2100-01-01)' WHERE id = 1;
EXCEPTION WHEN others THEN
    RAISE NOTICE 'Caught expected error: %', SQLERRM;
END;
$$;
NOTICE:  Caught expected error: Inconsistent values: "valid_to" is 2025-12-31, but is derived as 2099-12-31 from other inputs.
ROLLBACK TO SAVEPOINT test_7;
\echo '--- 8. Test continuous types disable valid_to sync ---'
--- 8. Test continuous types disable valid_to sync ---
SAVEPOINT test_8a;
\echo '--- 8a. timestamptz ---'
--- 8a. timestamptz ---
CREATE TABLE sync_continuous_tstz (id int, valid_from timestamptz, valid_to timestamptz, valid_until timestamptz);
SELECT sql_saga.add_era('sync_continuous_tstz', p_synchronize_valid_to_column := 'valid_to');
WARNING:  sql_saga: "valid_to" synchronization is only supported for discrete types (date, integer, bigint). Disabling for column "valid_to" on non-discrete era for table sync_continuous_tstz.
 add_era 
---------
 t
(1 row)

\d sync_continuous_tstz
                   Table "public.sync_continuous_tstz"
   Column    |           Type           | Collation | Nullable | Default 
-------------+--------------------------+-----------+----------+---------
 id          | integer                  |           |          | 
 valid_from  | timestamp with time zone |           | not null | 
 valid_to    | timestamp with time zone |           |          | 
 valid_until | timestamp with time zone |           | not null | 
Check constraints:
    "sync_continuous_tstz_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::timestamp with time zone)

INSERT INTO sync_continuous_tstz (id, valid_from, valid_until, valid_to) VALUES (1, '2024-01-01', '2025-01-01', '2099-12-31');
SELECT * FROM sync_continuous_tstz;
 id |       valid_from       |        valid_to        |      valid_until       
----+------------------------+------------------------+------------------------
  1 | 2024-01-01 00:00:00-08 | 2099-12-31 00:00:00-08 | 2025-01-01 00:00:00-08
(1 row)

ROLLBACK TO SAVEPOINT test_8a;
SAVEPOINT test_8b;
\echo '--- 8b. timestamp ---'
--- 8b. timestamp ---
CREATE TABLE sync_continuous_ts (id int, valid_from timestamp, valid_to timestamp, valid_until timestamp);
SELECT sql_saga.add_era('sync_continuous_ts', p_synchronize_valid_to_column := 'valid_to');
WARNING:  sql_saga: "valid_to" synchronization is only supported for discrete types (date, integer, bigint). Disabling for column "valid_to" on non-discrete era for table sync_continuous_ts.
 add_era 
---------
 t
(1 row)

\d sync_continuous_ts
                     Table "public.sync_continuous_ts"
   Column    |            Type             | Collation | Nullable | Default 
-------------+-----------------------------+-----------+----------+---------
 id          | integer                     |           |          | 
 valid_from  | timestamp without time zone |           | not null | 
 valid_to    | timestamp without time zone |           |          | 
 valid_until | timestamp without time zone |           | not null | 
Check constraints:
    "sync_continuous_ts_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::timestamp without time zone)

INSERT INTO sync_continuous_ts (id, valid_from, valid_until, valid_to) VALUES (1, '2024-01-01', '2025-01-01', '2099-12-31');
SELECT * FROM sync_continuous_ts;
 id |     valid_from      |      valid_to       |     valid_until     
----+---------------------+---------------------+---------------------
  1 | 2024-01-01 00:00:00 | 2099-12-31 00:00:00 | 2025-01-01 00:00:00
(1 row)

ROLLBACK TO SAVEPOINT test_8b;
SAVEPOINT test_8c;
\echo '--- 8c. numeric ---'
--- 8c. numeric ---
CREATE TABLE sync_continuous_numeric (id int, valid_from numeric, valid_to numeric, valid_until numeric);
SELECT sql_saga.add_era('sync_continuous_numeric', p_synchronize_valid_to_column := 'valid_to');
WARNING:  sql_saga: "valid_to" synchronization is only supported for discrete types (date, integer, bigint). Disabling for column "valid_to" on non-discrete era for table sync_continuous_numeric.
 add_era 
---------
 t
(1 row)

\d sync_continuous_numeric
         Table "public.sync_continuous_numeric"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 id          | integer |           |          | 
 valid_from  | numeric |           | not null | 
 valid_to    | numeric |           |          | 
 valid_until | numeric |           | not null | 
Check constraints:
    "sync_continuous_numeric_valid_check" CHECK (valid_from < valid_until AND valid_from > '-Infinity'::numeric)

INSERT INTO sync_continuous_numeric (id, valid_from, valid_until, valid_to) VALUES (1, 100.5, 200.5, 999.9);
SELECT * FROM sync_continuous_numeric;
 id | valid_from | valid_to | valid_until 
----+------------+----------+-------------
  1 |      100.5 |    999.9 |       200.5
(1 row)

ROLLBACK TO SAVEPOINT test_8c;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
