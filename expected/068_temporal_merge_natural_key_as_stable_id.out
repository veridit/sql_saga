\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
-- Scenario: Test temporal_merge with a composite natural key that also
-- serves as a temporal foreign key.
--
-- The table `unit_employment` tracks the number of employees for a given
-- legal unit and establishment. The combination of (legal_unit_id, establishment_id)
-- is the natural key for an employment record over time.
-- Parent table 1: legal_unit
CREATE TABLE nk_legal_unit (
    legal_unit_id int,
    name text,
    valid_range daterange,
    valid_from date,
    valid_until date,
    PRIMARY KEY (legal_unit_id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('nk_legal_unit'::regclass, 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "nk_legal_unit_synchronize_temporal_columns_trigger" on table nk_legal_unit to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('nk_legal_unit'::regclass, ARRAY['legal_unit_id']);
NOTICE:  sql_saga: altering table public.nk_legal_unit to add constraints: ADD CONSTRAINT nk_legal_unit_legal_unit_id_valid_uniq UNIQUE (legal_unit_id, valid_range WITHOUT OVERLAPS)
          add_unique_key           
-----------------------------------
 nk_legal_unit_legal_unit_id_valid
(1 row)

INSERT INTO nk_legal_unit (legal_unit_id, name, valid_from, valid_until) VALUES (1, 'Global Corp', '2020-01-01', 'infinity');
-- Parent table 2: establishment
CREATE TABLE nk_establishment (
    establishment_id int,
    address text,
    valid_range daterange,
    valid_from date,
    valid_until date,
    PRIMARY KEY (establishment_id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('nk_establishment'::regclass, 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "nk_establishment_synchronize_temporal_columns_trigger" on table nk_establishment to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('nk_establishment'::regclass, ARRAY['establishment_id']);
NOTICE:  sql_saga: altering table public.nk_establishment to add constraints: ADD CONSTRAINT nk_establishment_establishment_id_valid_uniq UNIQUE (establishment_id, valid_range WITHOUT OVERLAPS)
             add_unique_key              
-----------------------------------------
 nk_establishment_establishment_id_valid
(1 row)

INSERT INTO nk_establishment (establishment_id, address, valid_from, valid_until) VALUES (101, 'Main St Office', '2020-01-01', 'infinity');
INSERT INTO nk_establishment (establishment_id, address, valid_from, valid_until) VALUES (102, 'Side St Office', '2022-01-01', 'infinity');
-- Child table with a surrogate key (`employment_id`) but which will be managed
-- using its composite natural key (`legal_unit_id`, `establishment_id`).
CREATE TABLE nk_unit_employment (
    employment_id serial,
    legal_unit_id int,
    establishment_id int,
    num_employees int,
    valid_range daterange,
    valid_from date,
    valid_until date,
    PRIMARY KEY (employment_id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('nk_unit_employment'::regclass, 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "nk_unit_employment_synchronize_temporal_columns_trigger" on table nk_unit_employment to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

-- The unique key on the natural key is what allows `temporal_merge` to
-- identify a unique entity over time using these columns.
SELECT sql_saga.add_unique_key('nk_unit_employment'::regclass, ARRAY['legal_unit_id', 'establishment_id']);
NOTICE:  sql_saga: altering table public.nk_unit_employment to add constraints: ADD CONSTRAINT nk_unit_employment_legal_unit_id_establishment_id_valid_uniq UNIQUE (legal_unit_id, establishment_id, valid_range WITHOUT OVERLAPS), ADD CONSTRAINT nk_unit_employment_legal_unit_id_establishment_id_valid_pk_cons EXCLUDE USING gist (legal_unit_id WITH =, establishment_id WITH =, employment_id WITH <>)
                     add_unique_key                      
---------------------------------------------------------
 nk_unit_employment_legal_unit_id_establishment_id_valid
(1 row)

-- Foreign keys from the natural key columns to their respective parent tables.
SELECT sql_saga.add_temporal_foreign_key(
    'nk_unit_employment'::regclass, ARRAY['legal_unit_id'], 'valid', 'nk_legal_unit_legal_unit_id_valid'
);
        add_temporal_foreign_key        
----------------------------------------
 nk_unit_employment_legal_unit_id_valid
(1 row)

SELECT sql_saga.add_temporal_foreign_key(
    'nk_unit_employment'::regclass, ARRAY['establishment_id'], 'valid', 'nk_establishment_establishment_id_valid'
);
NOTICE:  No compatible index found for foreign key on table nk_unit_employment. Creating new index: CREATE INDEX nk_unit_employment_establishment_id_valid_gist_idx ON nk_unit_employment USING GIST (establishment_id, valid_range)
         add_temporal_foreign_key          
-------------------------------------------
 nk_unit_employment_establishment_id_valid
(1 row)

-- Source table for the merge operation
CREATE TEMP TABLE nk_source (
    row_id int,
    legal_unit_id int,
    establishment_id int,
    num_employees int,
    valid_from date,
    valid_until date,
    feedback jsonb
);
-- Step 1: INSERT a new employment record.
INSERT INTO nk_source (row_id, legal_unit_id, establishment_id, num_employees, valid_from, valid_until)
VALUES (1, 1, 101, 50, '2021-01-01', 'infinity');
CALL sql_saga.temporal_merge(
    target_table => 'nk_unit_employment'::regclass,
    source_table => 'nk_source'::regclass,
    primary_identity_columns => ARRAY['legal_unit_id', 'establishment_id'],
    ephemeral_columns => '{}'::text[],
    mode => 'MERGE_ENTITY_REPLACE'::sql_saga.temporal_merge_mode,
    update_source_with_feedback => true,
    feedback_status_column => 'feedback',
    feedback_status_key => 'tm_status'
);
\echo '--- INSERT: Expected Final State ---'
--- INSERT: Expected Final State ---
-- We expect one row to be inserted, with a generated employment_id of 1.
SELECT * FROM (VALUES
    (1, 1, 101, 50, '2021-01-01'::date, 'infinity'::date)
) AS t(employment_id, legal_unit_id, establishment_id, num_employees, valid_from, valid_until);
 employment_id | legal_unit_id | establishment_id | num_employees | valid_from | valid_until 
---------------+---------------+------------------+---------------+------------+-------------
             1 |             1 |              101 |            50 | 2021-01-01 | infinity
(1 row)

\echo '--- INSERT: Actual Final State ---'
--- INSERT: Actual Final State ---
TABLE nk_unit_employment;
 employment_id | legal_unit_id | establishment_id | num_employees |      valid_range      | valid_from | valid_until 
---------------+---------------+------------------+---------------+-----------------------+------------+-------------
             1 |             1 |              101 |            50 | [2021-01-01,infinity) | 2021-01-01 | infinity
(1 row)

\echo '--- INSERT: Feedback ---'
--- INSERT: Feedback ---
SELECT row_id, feedback->>'tm_status' as status FROM nk_source ORDER BY row_id;
 row_id | status  
--------+---------
      1 | APPLIED
(1 row)

-- Step 2: UPDATE the employment record.
TRUNCATE nk_source;
-- Update: The number of employees changed in 2023.
INSERT INTO nk_source (row_id, legal_unit_id, establishment_id, num_employees, valid_from, valid_until)
VALUES (2, 1, 101, 75, '2023-01-01', 'infinity');
CALL sql_saga.temporal_merge(
    target_table => 'nk_unit_employment'::regclass,
    source_table => 'nk_source'::regclass,
    primary_identity_columns => ARRAY['legal_unit_id', 'establishment_id'],
    ephemeral_columns => '{}'::text[],
    mode => 'MERGE_ENTITY_REPLACE'::sql_saga.temporal_merge_mode,
    update_source_with_feedback => true,
    feedback_status_column => 'feedback',
    feedback_status_key => 'tm_status'
);
\echo '--- UPDATE: Expected Final State ---'
--- UPDATE: Expected Final State ---
-- The original row is end-dated and a new one is created.
-- Both rows must have the same employment_id (1).
SELECT * FROM (VALUES
    (1, 1, 101, 50, '2021-01-01'::date, '2023-01-01'::date),
    (1, 1, 101, 75, '2023-01-01'::date, 'infinity'::date)
) AS t(employment_id, legal_unit_id, establishment_id, num_employees, valid_from, valid_until);
 employment_id | legal_unit_id | establishment_id | num_employees | valid_from | valid_until 
---------------+---------------+------------------+---------------+------------+-------------
             1 |             1 |              101 |            50 | 2021-01-01 | 2023-01-01
             1 |             1 |              101 |            75 | 2023-01-01 | infinity
(2 rows)

\echo '--- UPDATE: Actual Final State ---'
--- UPDATE: Actual Final State ---
TABLE nk_unit_employment ORDER BY valid_from;
 employment_id | legal_unit_id | establishment_id | num_employees |       valid_range       | valid_from | valid_until 
---------------+---------------+------------------+---------------+-------------------------+------------+-------------
             1 |             1 |              101 |            50 | [2021-01-01,2023-01-01) | 2021-01-01 | 2023-01-01
             1 |             1 |              101 |            75 | [2023-01-01,infinity)   | 2023-01-01 | infinity
(2 rows)

\echo '--- UPDATE: Feedback ---'
--- UPDATE: Feedback ---
SELECT row_id, feedback->>'tm_status' as status FROM nk_source ORDER BY row_id;
 row_id | status  
--------+---------
      2 | APPLIED
(1 row)

-- Step 3: Idempotency check.
TRUNCATE nk_source;
-- This source data exactly matches a slice of the existing target data.
-- No change should occur, and the feedback should be SKIPPED_IDENTICAL.
INSERT INTO nk_source (row_id, legal_unit_id, establishment_id, num_employees, valid_from, valid_until)
VALUES (3, 1, 101, 75, '2023-01-01', 'infinity');
CALL sql_saga.temporal_merge(
    target_table => 'nk_unit_employment'::regclass,
    source_table => 'nk_source'::regclass,
    primary_identity_columns => ARRAY['legal_unit_id', 'establishment_id'],
    ephemeral_columns => '{}'::text[],
    mode => 'MERGE_ENTITY_REPLACE'::sql_saga.temporal_merge_mode,
    update_source_with_feedback => true,
    feedback_status_column => 'feedback',
    feedback_status_key => 'tm_status'
);
\echo '--- IDEMPOTENCY: Expected Final State (No Change) ---'
--- IDEMPOTENCY: Expected Final State (No Change) ---
-- The final state should be identical to the state after Step 2.
SELECT * FROM (VALUES
    (1, 1, 101, 50, '2021-01-01'::date, '2023-01-01'::date),
    (1, 1, 101, 75, '2023-01-01'::date, 'infinity'::date)
) AS t(employment_id, legal_unit_id, establishment_id, num_employees, valid_from, valid_until);
 employment_id | legal_unit_id | establishment_id | num_employees | valid_from | valid_until 
---------------+---------------+------------------+---------------+------------+-------------
             1 |             1 |              101 |            50 | 2021-01-01 | 2023-01-01
             1 |             1 |              101 |            75 | 2023-01-01 | infinity
(2 rows)

\echo '--- IDEMPOTENCY: Actual Final State ---'
--- IDEMPOTENCY: Actual Final State ---
TABLE nk_unit_employment ORDER BY valid_from;
 employment_id | legal_unit_id | establishment_id | num_employees |       valid_range       | valid_from | valid_until 
---------------+---------------+------------------+---------------+-------------------------+------------+-------------
             1 |             1 |              101 |            50 | [2021-01-01,2023-01-01) | 2021-01-01 | 2023-01-01
             1 |             1 |              101 |            75 | [2023-01-01,infinity)   | 2023-01-01 | infinity
(2 rows)

\echo '--- IDEMPOTENCY: Feedback ---'
--- IDEMPOTENCY: Feedback ---
SELECT row_id, feedback->>'tm_status' as status FROM nk_source ORDER BY row_id;
 row_id |      status       
--------+-------------------
      3 | SKIPPED_IDENTICAL
(1 row)

ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
