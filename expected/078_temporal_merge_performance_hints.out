\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
CREATE TABLE target_table (
    id INT,
    value TEXT,
    valid_from DATE,
    valid_until DATE
);
SELECT sql_saga.add_era('target_table');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('target_table', ARRAY['id']);
NOTICE:  sql_saga: altering table public.target_table to add constraints: ADD CONSTRAINT target_table_id_valid_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT target_table_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    add_unique_key     
-----------------------
 target_table_id_valid
(1 row)

-- Also add an updatable view to ensure it doesn't interfere.
SELECT sql_saga.add_current_view('target_table');
 add_current_view 
------------------
 t
(1 row)

-- Scenario 1: No GIST index on source table.
CREATE TEMP TABLE source_table_no_index (
    row_id SERIAL,
    id INT,
    value TEXT,
    valid_from DATE,
    valid_until DATE
);
\echo

\echo '# Scenario 1a: Small table (< 512 rows) without index. Expect NO warning.'
# Scenario 1a: Small table (< 512 rows) without index. Expect NO warning.
\echo

INSERT INTO source_table_no_index (id, value, valid_from, valid_until) VALUES (1, 'A', '2023-01-01', 'infinity');
ANALYZE source_table_no_index;
-- No warning should be emitted here.
CALL sql_saga.temporal_merge(
    'target_table',
    'source_table_no_index',
    identity_columns => ARRAY['id']
);
\echo

\echo '# Scenario 1b: Large table (>= 512 rows) without index. Expect a WARNING and HINT.'
# Scenario 1b: Large table (>= 512 rows) without index. Expect a WARNING and HINT.
\echo

-- Insert enough rows to cross the threshold.
INSERT INTO source_table_no_index (id, value, valid_from, valid_until)
SELECT g, 'A', '2023-01-01', 'infinity' FROM generate_series(2, 600) g;
ANALYZE source_table_no_index;
-- The warning should be emitted here.
CALL sql_saga.temporal_merge(
    'target_table',
    'source_table_no_index',
    identity_columns => ARRAY['id']
);
WARNING:  Performance warning: The source relation source_table_no_index lacks a GIST index on its temporal columns.
HINT:  For better performance, consider creating an index, e.g., CREATE INDEX ON source_table_no_index USING GIST (daterange(valid_from, valid_until, '[)'));
-- Scenario 2: GIST index exists on source table, should be silent.
CREATE TEMP TABLE source_table_with_index (
    row_id SERIAL,
    id INT,
    value TEXT,
    valid_from DATE,
    valid_until DATE
);
-- The recommended index
CREATE INDEX ON source_table_with_index USING GIST (daterange(valid_from, valid_until, '[)'));
-- Insert enough rows to cross the threshold; warning should still be suppressed by the index.
INSERT INTO source_table_with_index (id, value, valid_from, valid_until)
SELECT g, 'B', '2024-01-01', 'infinity' FROM generate_series(1, 600) g;
ANALYZE source_table_with_index;
\echo

\echo '# Scenario 2: Large table with index. Expect no warning.'
# Scenario 2: Large table with index. Expect no warning.
\echo

-- This call should NOT produce a warning.
CALL sql_saga.temporal_merge(
    'target_table',
    'source_table_with_index',
    identity_columns => ARRAY['id']
);
-- Scenario 3: Source is a VIEW. Check if index on underlying table is detected.
\echo

\echo '# Scenario 3: Source is a VIEW. Check if index on underlying table is detected.'
# Scenario 3: Source is a VIEW. Check if index on underlying table is detected.
\echo

-- Base table for the view
CREATE TEMP TABLE source_table_for_view (
    row_id SERIAL,
    id INT,
    value TEXT,
    valid_from DATE,
    valid_until DATE
);
-- The view itself
CREATE TEMP VIEW source_view AS
SELECT * FROM source_table_for_view;
\echo

\echo '# Scenario 3a: View over small table with NO index. Expect NO warning.'
# Scenario 3a: View over small table with NO index. Expect NO warning.
\echo

INSERT INTO source_table_for_view (id, value, valid_from, valid_until) VALUES (2, 'C', '2025-01-01', 'infinity');
ANALYZE source_table_for_view;
CALL sql_saga.temporal_merge(
    'target_table',
    'source_view'::regclass,
    identity_columns => ARRAY['id']
);
\echo

\echo '# Scenario 3b: View over large table with NO index. Expect a WARNING.'
# Scenario 3b: View over large table with NO index. Expect a WARNING.
\echo

-- Insert enough rows to cross the threshold.
INSERT INTO source_table_for_view (id, value, valid_from, valid_until)
SELECT g, 'C', '2025-01-01', 'infinity' FROM generate_series(1000, 1600) g;
ANALYZE source_table_for_view;
CALL sql_saga.temporal_merge(
    'target_table',
    'source_view'::regclass,
    identity_columns => ARRAY['id']
);
WARNING:  Performance warning: The source relation source_view lacks a GIST index on its temporal columns.
HINT:  For better performance, consider creating an index, e.g., CREATE INDEX ON source_table_for_view USING GIST (daterange(valid_from, valid_until, '[)'));
-- Add the recommended index to the *base table*
CREATE INDEX ON source_table_for_view USING GIST (daterange(valid_from, valid_until, '[)'));
-- Manually truncate the internal cache to ensure the new index is detected in the next call.
-- This is necessary because the cache is session-local and this entire test runs in a single transaction.
TRUNCATE pg_temp.temporal_merge_cache;
\echo

\echo '# Scenario 3c: View over large table WITH index. Expect NO warning.'
# Scenario 3c: View over large table WITH index. Expect NO warning.
\echo

-- The table is already large and now has an index.
INSERT INTO source_table_for_view (id, value, valid_from, valid_until) VALUES (2, 'D', '2026-01-01', 'infinity');
ANALYZE source_table_for_view;
CALL sql_saga.temporal_merge(
    'target_table',
    'source_view'::regclass,
    identity_columns => ARRAY['id']
);
-- Verify final state of target table to ensure merge worked
SELECT COUNT(*) FROM target_table;
 count 
-------
  1803
(1 row)

\echo

\echo '# Verify final state of the current view'
# Verify final state of the current view
\echo

SELECT count(*) FROM target_table__current_valid;
 count 
-------
  1201
(1 row)

ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
