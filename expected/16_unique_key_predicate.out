\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
-- Test Scenario 1: Add constraint to an empty table, then insert data.
-- ====================================================================
CREATE TABLE employees (
    id int,
    name text,
    department_id int,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('employees', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

-- Add a unique key with a predicate.
SELECT sql_saga.add_unique_key(
    table_oid => 'employees',
    column_names => ARRAY['name'],
    key_type => 'predicated',
    predicate => 'department_id IS NOT NULL',
    unique_key_name => 'employees_name_if_department_valid'
);
           add_unique_key           
------------------------------------
 employees_name_if_department_valid
(1 row)

\d employees
                     Table "public.employees"
    Column     |  Type   | Collation | Nullable |     Default      
---------------+---------+-----------+----------+------------------
 id            | integer |           |          | 
 name          | text    |           |          | 
 department_id | integer |           |          | 
 valid_from    | date    |           | not null | 
 valid_until   | date    |           | not null | 'infinity'::date
Indexes:
    "employees_name_idx" btree (name)
    "employees_name_if_department_valid_excl" EXCLUDE USING gist (name WITH =, daterange(valid_from, valid_until) WITH &&) WHERE (department_id IS NOT NULL) DEFERRABLE
    "employees_name_if_department_valid_idx" UNIQUE, btree (name, valid_from, valid_until) WHERE department_id IS NOT NULL
Check constraints:
    "employees_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

-- 1. Inserts that should PASS
-- Two employees with same name, but NULL department (outside predicate)
INSERT INTO employees VALUES (1, 'Alice', NULL, '2020-01-01', 'infinity');
INSERT INTO employees VALUES (2, 'Alice', NULL, '2021-01-01', 'infinity');
-- Two employees with different names in the same department
INSERT INTO employees VALUES (3, 'Bob', 101, '2020-01-01', 'infinity');
INSERT INTO employees VALUES (4, 'Charlie', 101, '2021-01-01', 'infinity');
-- 2. Inserts that should FAIL (due to temporal overlap)
-- Overlapping period for an existing employee in a department
INSERT INTO employees VALUES (5, 'Bob', 101, '2020-06-01', '2021-06-01');
ERROR:  conflicting key value violates exclusion constraint "employees_name_if_department_valid_excl"
DETAIL:  Key (name, daterange(valid_from, valid_until))=(Bob, [2020-06-01,2021-06-01)) conflicts with existing key (name, daterange(valid_from, valid_until))=(Bob, [2020-01-01,infinity)).
-- 3. Inserts that should FAIL (due to exact duplicate record)
INSERT INTO employees VALUES (6, 'Charlie', 101, '2021-01-01', 'infinity');
ERROR:  duplicate key value violates unique constraint "employees_name_if_department_valid_idx"
DETAIL:  Key (name, valid_from, valid_until)=(Charlie, 2021-01-01, infinity) already exists.
SELECT id, name, department_id, valid_from, valid_until FROM employees ORDER BY id;
 id |  name   | department_id | valid_from | valid_until 
----+---------+---------------+------------+-------------
  1 | Alice   |               | 2020-01-01 | infinity
  2 | Alice   |               | 2021-01-01 | infinity
  3 | Bob     |           101 | 2020-01-01 | infinity
  4 | Charlie |           101 | 2021-01-01 | infinity
(4 rows)

-- 4. Drop the predicated unique key
SELECT sql_saga.drop_unique_key('employees'::regclass, ARRAY['name']::name[], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

-- Verify that the unique key and its constraints/indexes are gone
SELECT unique_key_name FROM sql_saga.unique_keys WHERE table_schema = 'public' AND table_name = 'employees';
 unique_key_name 
-----------------
(0 rows)

\d employees
                     Table "public.employees"
    Column     |  Type   | Collation | Nullable |     Default      
---------------+---------+-----------+----------+------------------
 id            | integer |           |          | 
 name          | text    |           |          | 
 department_id | integer |           |          | 
 valid_from    | date    |           | not null | 
 valid_until   | date    |           | not null | 'infinity'::date
Indexes:
    "employees_name_idx" btree (name)
Check constraints:
    "employees_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

-- Test Scenario 2: Add constraint to a table with existing data.
-- ===============================================================
CREATE TABLE contractors (
    id int,
    name text,
    agency_id int,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('contractors', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

-- Insert initial data, including data that will violate the future constraint.
-- Two 'David' records in agency 202 have overlapping periods.
INSERT INTO contractors VALUES (101, 'David', 202, '2020-01-01', '2022-01-01');
INSERT INTO contractors VALUES (102, 'David', 202, '2021-01-01', '2023-01-01');
-- This is fine, NULL agency is outside predicate.
INSERT INTO contractors VALUES (103, 'Eve', NULL, '2020-01-01', 'infinity');
INSERT INTO contractors VALUES (104, 'Eve', NULL, '2021-01-01', 'infinity');
-- Attempt to add the unique key. This should fail due to the overlapping 'David' records.
SELECT sql_saga.add_unique_key(
    table_oid => 'contractors',
    column_names => ARRAY['name'],
    key_type => 'predicated',
    predicate => 'agency_id IS NOT NULL'
);
ERROR:  could not create exclusion constraint "contractors_name_valid_excl"
DETAIL:  Key (name, daterange(valid_from, valid_until))=(David, [2020-01-01,2022-01-01)) conflicts with key (name, daterange(valid_from, valid_until))=(David, [2021-01-01,2023-01-01)).
CONTEXT:  SQL statement "ALTER TABLE public.contractors ADD CONSTRAINT contractors_name_valid_excl EXCLUDE USING gist (name WITH =, daterange(valid_from, valid_until) WITH &&) WHERE (agency_id IS NOT NULL) DEFERRABLE"
PL/pgSQL function sql_saga.add_unique_key(regclass,name[],name,sql_saga.unique_key_type,name,name,name,text) line 301 at EXECUTE
-- Correct the data by deleting one of the conflicting records.
DELETE FROM contractors WHERE id = 102;
-- Try adding the unique key again. This should now succeed.
SELECT sql_saga.add_unique_key(
    table_oid => 'contractors',
    column_names => ARRAY['name'],
    key_type => 'predicated',
    predicate => 'agency_id IS NOT NULL',
    unique_key_name => 'contractors_name_if_agency_valid'
);
          add_unique_key          
----------------------------------
 contractors_name_if_agency_valid
(1 row)

-- Test the new constraint with an insert that should fail.
INSERT INTO contractors VALUES (105, 'David', 202, '2021-01-01', '2023-01-01');
ERROR:  conflicting key value violates exclusion constraint "contractors_name_if_agency_valid_excl"
DETAIL:  Key (name, daterange(valid_from, valid_until))=(David, [2021-01-01,2023-01-01)) conflicts with existing key (name, daterange(valid_from, valid_until))=(David, [2020-01-01,2022-01-01)).
SELECT id, name, agency_id, valid_from, valid_until FROM contractors ORDER BY id;
 id  | name  | agency_id | valid_from | valid_until 
-----+-------+-----------+------------+-------------
 101 | David |       202 | 2020-01-01 | 2022-01-01
 103 | Eve   |           | 2020-01-01 | infinity
 104 | Eve   |           | 2021-01-01 | infinity
(3 rows)

DROP TABLE employees;
DROP TABLE contractors;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
