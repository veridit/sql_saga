\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
\i sql/include/benchmark_setup.sql
\set ECHO none
-- Helper function to check trigger status. Must be created before SET ROLE.
CREATE SCHEMA mtt;
CREATE OR REPLACE FUNCTION mtt.get_trigger_status(p_table_oid regclass)
RETURNS TABLE(trigger_name name, is_enabled text) AS $$
    SELECT tgname,
           CASE tgenabled
               WHEN 'O' THEN 'enabled' -- Origin and local
               WHEN 'R' THEN 'enabled' -- Replica
               WHEN 'A' THEN 'enabled' -- Always
               WHEN 'D' THEN 'disabled'
           END
    FROM pg_trigger
    WHERE tgrelid = p_table_oid
      AND NOT tgisinternal
    ORDER BY tgname;
$$ LANGUAGE sql;
GRANT USAGE ON SCHEMA mtt TO sql_saga_unprivileged_user;
GRANT EXECUTE ON FUNCTION mtt.get_trigger_status(regclass) TO sql_saga_unprivileged_user;
SET ROLE TO sql_saga_unprivileged_user;
CREATE TABLE legal_unit_tm_bs_on (id INTEGER, valid_range daterange NOT NULL, name varchar NOT NULL);
CREATE TABLE establishment_tm_bs_on (id INTEGER, valid_range daterange NOT NULL, legal_unit_id INTEGER NOT NULL, postal_place TEXT NOT NULL);
SELECT sql_saga.add_era('legal_unit_tm_bs_on'::regclass, 'valid_range', 'valid');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_era('establishment_tm_bs_on'::regclass, 'valid_range', 'valid');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'legal_unit_tm_bs_on', column_names => ARRAY['id'], era_name => 'valid');
NOTICE:  sql_saga: Added constraints to table legal_unit_tm_bs_on: ADD CONSTRAINT legal_unit_tm_bs_on_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
        add_unique_key        
------------------------------
 legal_unit_tm_bs_on_id_valid
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'establishment_tm_bs_on', column_names => ARRAY['id'], era_name => 'valid');
NOTICE:  sql_saga: Added constraints to table establishment_tm_bs_on: ADD CONSTRAINT establishment_tm_bs_on_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
         add_unique_key          
---------------------------------
 establishment_tm_bs_on_id_valid
(1 row)

SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'establishment_tm_bs_on',
    fk_column_names => ARRAY['legal_unit_id'],
    pk_table_oid => 'legal_unit_tm_bs_on',
    pk_column_names => ARRAY['id'],
    fk_era_name => 'valid',
    create_index => true
);
NOTICE:  sql_saga: No compatible index found for foreign key on table establishment_tm_bs_on. Creating new index: CREATE INDEX establishment_tm_bs_on_legal_unit_id_valid_gist_idx ON establishment_tm_bs_on USING GIST (legal_unit_id, valid_range)
              add_foreign_key               
--------------------------------------------
 establishment_tm_bs_on_legal_unit_id_valid
(1 row)

CREATE TABLE legal_unit_tm_bs_off (id INTEGER, valid_range daterange NOT NULL, name varchar NOT NULL);
CREATE TABLE establishment_tm_bs_off (id INTEGER, valid_range daterange NOT NULL, legal_unit_id INTEGER NOT NULL, postal_place TEXT NOT NULL);
-- This is the critical index for temporal_merge performance on the target tables.
CREATE INDEX ON legal_unit_tm_bs_off USING GIST (valid_range);
CREATE INDEX ON establishment_tm_bs_off USING GIST (valid_range);
SELECT sql_saga.add_era('legal_unit_tm_bs_off'::regclass, 'valid_range', 'valid');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_era('establishment_tm_bs_off'::regclass, 'valid_range', 'valid');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'legal_unit_tm_bs_off', column_names => ARRAY['id'], era_name => 'valid');
NOTICE:  sql_saga: Added constraints to table legal_unit_tm_bs_off: ADD CONSTRAINT legal_unit_tm_bs_off_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
        add_unique_key         
-------------------------------
 legal_unit_tm_bs_off_id_valid
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'establishment_tm_bs_off', column_names => ARRAY['id'], era_name => 'valid');
NOTICE:  sql_saga: Added constraints to table establishment_tm_bs_off: ADD CONSTRAINT establishment_tm_bs_off_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
          add_unique_key          
----------------------------------
 establishment_tm_bs_off_id_valid
(1 row)

SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'establishment_tm_bs_off',
    fk_column_names => ARRAY['legal_unit_id'],
    pk_table_oid => 'legal_unit_tm_bs_off',
    pk_column_names => ARRAY['id'],
    fk_era_name => 'valid',
    create_index => true
);
NOTICE:  sql_saga: No compatible index found for foreign key on table establishment_tm_bs_off. Creating new index: CREATE INDEX establishment_tm_bs_off_legal_unit_id_valid_gist_idx ON establishment_tm_bs_off USING GIST (legal_unit_id, valid_range)
               add_foreign_key               
---------------------------------------------
 establishment_tm_bs_off_legal_unit_id_valid
(1 row)

CREATE TEMP TABLE trigger_log (event text, table_name text, trigger_name name, is_enabled text);
DO $$
DECLARE
    v_first_run_logged boolean := false;
    v_batch_sizes int[] := ARRAY[100, 1000, 10000, 20000];
    v_modes text[] := ARRAY['MERGE_ENTITY_UPSERT', 'UPDATE_FOR_PORTION_OF'];
    v_mode text;
    v_batch_size int;
    v_total_rows int;
    v_start_id int;
    v_end_id int;
    v_loop_iter int;
BEGIN
    CREATE TEMPORARY TABLE legal_unit_source_bs (row_id int, id int, valid_range daterange, name varchar);
    CREATE INDEX ON legal_unit_source_bs USING GIST (id, valid_range);
    CREATE INDEX ON legal_unit_source_bs USING BTREE (id);
    CREATE INDEX ON legal_unit_source_bs USING GIST (valid_range);
    CREATE TEMPORARY TABLE establishment_source_bs (row_id int, id int, valid_range daterange, legal_unit_id int, postal_place text);
    CREATE INDEX ON establishment_source_bs USING GIST (id, valid_range) ;
    CREATE INDEX ON establishment_source_bs USING BTREE (id) ;
    CREATE INDEX ON establishment_source_bs USING GIST (valid_range);

    FOREACH v_batch_size IN ARRAY v_batch_sizes
    LOOP
        v_total_rows := LEAST(4000, v_batch_size * 2);
        FOREACH v_mode IN ARRAY v_modes
        LOOP

        -- Triggers OFF
        TRUNCATE legal_unit_tm_bs_off, establishment_tm_bs_off;

        IF NOT v_first_run_logged THEN
            INSERT INTO trigger_log SELECT 'before disable', 'legal_unit_tm_bs_off', s.* FROM mtt.get_trigger_status('legal_unit_tm_bs_off') s;
            INSERT INTO trigger_log SELECT 'before disable', 'establishment_tm_bs_off', s.* FROM mtt.get_trigger_status('establishment_tm_bs_off') s;
        END IF;
        CALL sql_saga.disable_temporal_triggers('legal_unit_tm_bs_off', 'establishment_tm_bs_off');
        IF NOT v_first_run_logged THEN
            INSERT INTO trigger_log SELECT 'after disable', 'legal_unit_tm_bs_off', s.* FROM mtt.get_trigger_status('legal_unit_tm_bs_off') s;
            INSERT INTO trigger_log SELECT 'after disable', 'establishment_tm_bs_off', s.* FROM mtt.get_trigger_status('establishment_tm_bs_off') s;
        END IF;

        v_loop_iter := 1;
        v_start_id := 1;
        WHILE v_start_id <= v_total_rows LOOP
            v_end_id := v_start_id + v_batch_size - 1;
            IF v_end_id > v_total_rows THEN v_end_id := v_total_rows; END IF;

            TRUNCATE legal_unit_source_bs, establishment_source_bs;
            INSERT INTO legal_unit_source_bs SELECT i, i, daterange('2015-01-01', 'infinity', '[)'), 'Company ' || i FROM generate_series(v_start_id, v_end_id) AS i;
            INSERT INTO establishment_source_bs SELECT i, i, daterange('2015-01-01', 'infinity', '[)'), i, 'Shop ' || i FROM generate_series(v_start_id, v_end_id) AS i;

            ANALYZE legal_unit_source_bs;
            ANALYZE establishment_source_bs;

            INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES (format('tm_loop, batch %s / %s Parent (Triggers OFF) iter %s', v_batch_size, v_mode, v_loop_iter), 0, false);
            CALL sql_saga.benchmark_reset();
            CALL sql_saga.temporal_merge('legal_unit_tm_bs_off'::regclass, 'legal_unit_source_bs'::regclass, ARRAY['id'], mode => v_mode::sql_saga.temporal_merge_mode, ephemeral_columns => ARRAY[]::text[]);
            CALL sql_saga.benchmark_log_and_reset(format('tm_loop, batch %s / %s Parent (Triggers OFF) iter %s', v_batch_size, v_mode, v_loop_iter));
            INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES (format('tm_loop, batch %s / %s Parent (Triggers OFF) iter %s end', v_batch_size, v_mode, v_loop_iter), v_end_id - v_start_id + 1, true);

            INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES (format('tm_loop, batch %s / %s Child (Triggers OFF) iter %s', v_batch_size, v_mode, v_loop_iter), 0, false);
            CALL sql_saga.benchmark_reset();
            CALL sql_saga.temporal_merge('establishment_tm_bs_off'::regclass, 'establishment_source_bs'::regclass, ARRAY['id'], mode => v_mode::sql_saga.temporal_merge_mode, ephemeral_columns => ARRAY[]::text[]);
            CALL sql_saga.benchmark_log_and_reset(format('tm_loop, batch %s / %s Child (Triggers OFF) iter %s', v_batch_size, v_mode, v_loop_iter));
            INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES (format('tm_loop, batch %s / %s Child (Triggers OFF) iter %s end', v_batch_size, v_mode, v_loop_iter), v_end_id - v_start_id + 1, true);

            v_start_id := v_end_id + 1;
            v_loop_iter := v_loop_iter + 1;
        END LOOP;

        CALL sql_saga.enable_temporal_triggers('legal_unit_tm_bs_off', 'establishment_tm_bs_off');
        IF NOT v_first_run_logged THEN
            INSERT INTO trigger_log SELECT 'after enable', 'legal_unit_tm_bs_off', s.* FROM mtt.get_trigger_status('legal_unit_tm_bs_off') s;
            INSERT INTO trigger_log SELECT 'after enable', 'establishment_tm_bs_off', s.* FROM mtt.get_trigger_status('establishment_tm_bs_off') s;
            v_first_run_logged := true;
        END IF;

        -- Triggers ON
        TRUNCATE legal_unit_tm_bs_on, establishment_tm_bs_on;
        v_loop_iter := 1;
        v_start_id := 1;
        WHILE v_start_id <= v_total_rows LOOP
            v_end_id := v_start_id + v_batch_size - 1;
            IF v_end_id > v_total_rows THEN v_end_id := v_total_rows; END IF;

            TRUNCATE legal_unit_source_bs, establishment_source_bs;
            INSERT INTO legal_unit_source_bs SELECT i, i, daterange('2015-01-01', 'infinity', '[)'), 'Company ' || i FROM generate_series(v_start_id, v_end_id) AS i;
            INSERT INTO establishment_source_bs SELECT i, i, daterange('2015-01-01', 'infinity', '[)'), i, 'Shop ' || i FROM generate_series(v_start_id, v_end_id) AS i;

            ANALYZE legal_unit_source_bs;
            ANALYZE establishment_source_bs;

            INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES (format('tm_loop, batch %s / %s Parent (Triggers ON) iter %s', v_batch_size, v_mode, v_loop_iter), 0, false);
            CALL sql_saga.benchmark_reset();
            CALL sql_saga.temporal_merge('legal_unit_tm_bs_on'::regclass, 'legal_unit_source_bs'::regclass, ARRAY['id'], mode => v_mode::sql_saga.temporal_merge_mode, ephemeral_columns => ARRAY[]::text[]);
            CALL sql_saga.benchmark_log_and_reset(format('tm_loop, batch %s / %s Parent (Triggers ON) iter %s', v_batch_size, v_mode, v_loop_iter));
            INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES (format('tm_loop, batch %s / %s Parent (Triggers ON) iter %s end', v_batch_size, v_mode, v_loop_iter), v_end_id - v_start_id + 1, true);

            INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES (format('tm_loop, batch %s / %s Child (Triggers ON) iter %s', v_batch_size, v_mode, v_loop_iter), 0, false);
            CALL sql_saga.benchmark_reset();
            CALL sql_saga.temporal_merge('establishment_tm_bs_on'::regclass, 'establishment_source_bs'::regclass, ARRAY['id'], mode => v_mode::sql_saga.temporal_merge_mode, ephemeral_columns => ARRAY[]::text[]);
            CALL sql_saga.benchmark_log_and_reset(format('tm_loop, batch %s / %s Child (Triggers ON) iter %s', v_batch_size, v_mode, v_loop_iter));
            INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES (format('tm_loop, batch %s / %s Child (Triggers ON) iter %s end', v_batch_size, v_mode, v_loop_iter), v_end_id - v_start_id + 1, true);

            v_start_id := v_end_id + 1;
            v_loop_iter := v_loop_iter + 1;
        END LOOP;
        END LOOP;
    END LOOP;
END;
$$;
\echo '-- Trigger status log from benchmark --'
-- Trigger status log from benchmark --
SELECT * FROM trigger_log ORDER BY event, table_name, trigger_name;
 event | table_name | trigger_name | is_enabled 
-------+------------+--------------+------------
(0 rows)

SELECT 'legal_unit_tm_bs_on' AS type, COUNT(*) AS count FROM legal_unit_tm_bs_on
UNION ALL
SELECT 'establishment_tm_bs_on' AS type, COUNT(*) AS count FROM establishment_tm_bs_on
UNION ALL
SELECT 'legal_unit_tm_bs_off' AS type, COUNT(*) AS count FROM legal_unit_tm_bs_off
UNION ALL
SELECT 'establishment_tm_bs_off' AS type, COUNT(*) AS count FROM establishment_tm_bs_off;
          type           | count 
-------------------------+-------
 legal_unit_tm_bs_on     |     0
 establishment_tm_bs_on  |     0
 legal_unit_tm_bs_off    |     0
 establishment_tm_bs_off |     0
(4 rows)

\echo '-- Performance log from pg_stat_monitor --'
-- Performance log from pg_stat_monitor --
\set monitor_log_filename expected/performance/102_benchmark_temporal_merge_batch_sizes_benchmark_monitor.csv
\i sql/include/benchmark_monitor_csv.sql
\set ECHO none
 monitor_log_has_rows 
----------------------
 t
(1 row)

-- Teardown for batch size benchmark tables
SELECT sql_saga.drop_foreign_key('establishment_tm_bs_on', ARRAY['legal_unit_id'], 'valid');
NOTICE:  sql_saga: Dropping automatically created index "establishment_tm_bs_on_legal_unit_id_valid_gist_idx" for foreign key "establishment_tm_bs_on_legal_unit_id_valid"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_unique_key('establishment_tm_bs_on', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('establishment_tm_bs_on', cleanup => true);
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_unique_key('legal_unit_tm_bs_on', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('legal_unit_tm_bs_on', cleanup => true);
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_foreign_key('establishment_tm_bs_off', ARRAY['legal_unit_id'], 'valid');
NOTICE:  sql_saga: Dropping automatically created index "establishment_tm_bs_off_legal_unit_id_valid_gist_idx" for foreign key "establishment_tm_bs_off_legal_unit_id_valid"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_unique_key('establishment_tm_bs_off', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('establishment_tm_bs_off', cleanup => true);
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_unique_key('legal_unit_tm_bs_off', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('legal_unit_tm_bs_off', cleanup => true);
 drop_era 
----------
 t
(1 row)

RESET ROLE;
DROP SCHEMA mtt CASCADE;
NOTICE:  drop cascades to function mtt.get_trigger_status(regclass)
DROP TABLE establishment_tm_bs_on;
DROP TABLE legal_unit_tm_bs_on;
DROP TABLE establishment_tm_bs_off;
DROP TABLE legal_unit_tm_bs_off;
-- Verify the benchmark events and row counts, but exclude volatile timing data
-- from the regression test output to ensure stability.
SELECT event, row_count FROM benchmark ORDER BY seq_id;
                                     event                                     | row_count 
-------------------------------------------------------------------------------+-----------
 BEGIN                                                                         |         0
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Parent (Triggers OFF) iter 1         |         0
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Parent (Triggers OFF) iter 1 end     |       100
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Child (Triggers OFF) iter 1          |         0
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Child (Triggers OFF) iter 1 end      |       100
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Parent (Triggers OFF) iter 2         |         0
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Parent (Triggers OFF) iter 2 end     |       100
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Child (Triggers OFF) iter 2          |         0
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Child (Triggers OFF) iter 2 end      |       100
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Parent (Triggers ON) iter 1          |         0
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Parent (Triggers ON) iter 1 end      |       100
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Child (Triggers ON) iter 1           |         0
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Child (Triggers ON) iter 1 end       |       100
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Parent (Triggers ON) iter 2          |         0
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Parent (Triggers ON) iter 2 end      |       100
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Child (Triggers ON) iter 2           |         0
 tm_loop, batch 100 / MERGE_ENTITY_UPSERT Child (Triggers ON) iter 2 end       |       100
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Parent (Triggers OFF) iter 1       |         0
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Parent (Triggers OFF) iter 1 end   |       100
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Child (Triggers OFF) iter 1        |         0
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Child (Triggers OFF) iter 1 end    |       100
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Parent (Triggers OFF) iter 2       |         0
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Parent (Triggers OFF) iter 2 end   |       100
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Child (Triggers OFF) iter 2        |         0
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Child (Triggers OFF) iter 2 end    |       100
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Parent (Triggers ON) iter 1        |         0
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Parent (Triggers ON) iter 1 end    |       100
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Child (Triggers ON) iter 1         |         0
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Child (Triggers ON) iter 1 end     |       100
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Parent (Triggers ON) iter 2        |         0
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Parent (Triggers ON) iter 2 end    |       100
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Child (Triggers ON) iter 2         |         0
 tm_loop, batch 100 / UPDATE_FOR_PORTION_OF Child (Triggers ON) iter 2 end     |       100
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Parent (Triggers OFF) iter 1        |         0
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Parent (Triggers OFF) iter 1 end    |      1000
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Child (Triggers OFF) iter 1         |         0
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Child (Triggers OFF) iter 1 end     |      1000
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Parent (Triggers OFF) iter 2        |         0
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Parent (Triggers OFF) iter 2 end    |      1000
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Child (Triggers OFF) iter 2         |         0
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Child (Triggers OFF) iter 2 end     |      1000
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Parent (Triggers ON) iter 1         |         0
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Parent (Triggers ON) iter 1 end     |      1000
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Child (Triggers ON) iter 1          |         0
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Child (Triggers ON) iter 1 end      |      1000
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Parent (Triggers ON) iter 2         |         0
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Parent (Triggers ON) iter 2 end     |      1000
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Child (Triggers ON) iter 2          |         0
 tm_loop, batch 1000 / MERGE_ENTITY_UPSERT Child (Triggers ON) iter 2 end      |      1000
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Parent (Triggers OFF) iter 1      |         0
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Parent (Triggers OFF) iter 1 end  |      1000
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Child (Triggers OFF) iter 1       |         0
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Child (Triggers OFF) iter 1 end   |      1000
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Parent (Triggers OFF) iter 2      |         0
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Parent (Triggers OFF) iter 2 end  |      1000
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Child (Triggers OFF) iter 2       |         0
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Child (Triggers OFF) iter 2 end   |      1000
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Parent (Triggers ON) iter 1       |         0
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Parent (Triggers ON) iter 1 end   |      1000
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Child (Triggers ON) iter 1        |         0
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Child (Triggers ON) iter 1 end    |      1000
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Parent (Triggers ON) iter 2       |         0
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Parent (Triggers ON) iter 2 end   |      1000
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Child (Triggers ON) iter 2        |         0
 tm_loop, batch 1000 / UPDATE_FOR_PORTION_OF Child (Triggers ON) iter 2 end    |      1000
 tm_loop, batch 10000 / MERGE_ENTITY_UPSERT Parent (Triggers OFF) iter 1       |         0
 tm_loop, batch 10000 / MERGE_ENTITY_UPSERT Parent (Triggers OFF) iter 1 end   |      4000
 tm_loop, batch 10000 / MERGE_ENTITY_UPSERT Child (Triggers OFF) iter 1        |         0
 tm_loop, batch 10000 / MERGE_ENTITY_UPSERT Child (Triggers OFF) iter 1 end    |      4000
 tm_loop, batch 10000 / MERGE_ENTITY_UPSERT Parent (Triggers ON) iter 1        |         0
 tm_loop, batch 10000 / MERGE_ENTITY_UPSERT Parent (Triggers ON) iter 1 end    |      4000
 tm_loop, batch 10000 / MERGE_ENTITY_UPSERT Child (Triggers ON) iter 1         |         0
 tm_loop, batch 10000 / MERGE_ENTITY_UPSERT Child (Triggers ON) iter 1 end     |      4000
 tm_loop, batch 10000 / UPDATE_FOR_PORTION_OF Parent (Triggers OFF) iter 1     |         0
 tm_loop, batch 10000 / UPDATE_FOR_PORTION_OF Parent (Triggers OFF) iter 1 end |      4000
 tm_loop, batch 10000 / UPDATE_FOR_PORTION_OF Child (Triggers OFF) iter 1      |         0
 tm_loop, batch 10000 / UPDATE_FOR_PORTION_OF Child (Triggers OFF) iter 1 end  |      4000
 tm_loop, batch 10000 / UPDATE_FOR_PORTION_OF Parent (Triggers ON) iter 1      |         0
 tm_loop, batch 10000 / UPDATE_FOR_PORTION_OF Parent (Triggers ON) iter 1 end  |      4000
 tm_loop, batch 10000 / UPDATE_FOR_PORTION_OF Child (Triggers ON) iter 1       |         0
 tm_loop, batch 10000 / UPDATE_FOR_PORTION_OF Child (Triggers ON) iter 1 end   |      4000
 tm_loop, batch 20000 / MERGE_ENTITY_UPSERT Parent (Triggers OFF) iter 1       |         0
 tm_loop, batch 20000 / MERGE_ENTITY_UPSERT Parent (Triggers OFF) iter 1 end   |      4000
 tm_loop, batch 20000 / MERGE_ENTITY_UPSERT Child (Triggers OFF) iter 1        |         0
 tm_loop, batch 20000 / MERGE_ENTITY_UPSERT Child (Triggers OFF) iter 1 end    |      4000
 tm_loop, batch 20000 / MERGE_ENTITY_UPSERT Parent (Triggers ON) iter 1        |         0
 tm_loop, batch 20000 / MERGE_ENTITY_UPSERT Parent (Triggers ON) iter 1 end    |      4000
 tm_loop, batch 20000 / MERGE_ENTITY_UPSERT Child (Triggers ON) iter 1         |         0
 tm_loop, batch 20000 / MERGE_ENTITY_UPSERT Child (Triggers ON) iter 1 end     |      4000
 tm_loop, batch 20000 / UPDATE_FOR_PORTION_OF Parent (Triggers OFF) iter 1     |         0
 tm_loop, batch 20000 / UPDATE_FOR_PORTION_OF Parent (Triggers OFF) iter 1 end |      4000
 tm_loop, batch 20000 / UPDATE_FOR_PORTION_OF Child (Triggers OFF) iter 1      |         0
 tm_loop, batch 20000 / UPDATE_FOR_PORTION_OF Child (Triggers OFF) iter 1 end  |      4000
 tm_loop, batch 20000 / UPDATE_FOR_PORTION_OF Parent (Triggers ON) iter 1      |         0
 tm_loop, batch 20000 / UPDATE_FOR_PORTION_OF Parent (Triggers ON) iter 1 end  |      4000
 tm_loop, batch 20000 / UPDATE_FOR_PORTION_OF Child (Triggers ON) iter 1       |         0
 tm_loop, batch 20000 / UPDATE_FOR_PORTION_OF Child (Triggers ON) iter 1 end   |      4000
(97 rows)

-- Capture performance metrics to a separate file for manual review.
\set benchmark_log_filename expected/performance/102_benchmark_temporal_merge_batch_sizes_benchmark_report.log
\i sql/include/benchmark_report_log.sql
\set ECHO none
\i sql/include/benchmark_teardown.sql
\set ECHO none
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
psql:sql/include/test_teardown.sql:14: NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to index legal_unit_source_bs_id_valid_range_idx
drop cascades to index establishment_source_bs_id_valid_range_idx
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
