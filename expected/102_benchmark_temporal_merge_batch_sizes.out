\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
SET ROLE TO sql_saga_unprivileged_user;
\i sql/include/benchmark_setup.sql
CREATE TEMPORARY TABLE benchmark (
  seq_id BIGINT GENERATED ALWAYS AS IDENTITY,
  timestamp TIMESTAMPTZ DEFAULT clock_timestamp(),
  event TEXT,
  row_count INTEGER
);
INSERT INTO benchmark (event, row_count) VALUES ('BEGIN', 0);
CREATE TABLE legal_unit_tm_bs_on (id INTEGER, valid_from date, valid_until date, name varchar NOT NULL);
CREATE TABLE establishment_tm_bs_on (id INTEGER, valid_from date, valid_until date, legal_unit_id INTEGER NOT NULL, postal_place TEXT NOT NULL);
SELECT sql_saga.add_era(table_oid => 'legal_unit_tm_bs_on', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_era(table_oid => 'establishment_tm_bs_on', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'legal_unit_tm_bs_on', column_names => ARRAY['id'], era_name => 'valid');
        add_unique_key        
------------------------------
 legal_unit_tm_bs_on_id_valid
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'establishment_tm_bs_on', column_names => ARRAY['id'], era_name => 'valid');
         add_unique_key          
---------------------------------
 establishment_tm_bs_on_id_valid
(1 row)

SELECT sql_saga.add_temporal_foreign_key(
    fk_table_oid => 'establishment_tm_bs_on',
    fk_column_names => ARRAY['legal_unit_id'],
    fk_era_name => 'valid',
    unique_key_name => 'legal_unit_tm_bs_on_id_valid'
);
          add_temporal_foreign_key          
--------------------------------------------
 establishment_tm_bs_on_legal_unit_id_valid
(1 row)

CREATE TABLE legal_unit_tm_bs_off (id INTEGER, valid_from date, valid_until date, name varchar NOT NULL);
CREATE TABLE establishment_tm_bs_off (id INTEGER, valid_from date, valid_until date, legal_unit_id INTEGER NOT NULL, postal_place TEXT NOT NULL);
SELECT sql_saga.add_era(table_oid => 'legal_unit_tm_bs_off', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_era(table_oid => 'establishment_tm_bs_off', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'legal_unit_tm_bs_off', column_names => ARRAY['id'], era_name => 'valid');
        add_unique_key         
-------------------------------
 legal_unit_tm_bs_off_id_valid
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'establishment_tm_bs_off', column_names => ARRAY['id'], era_name => 'valid');
          add_unique_key          
----------------------------------
 establishment_tm_bs_off_id_valid
(1 row)

SELECT sql_saga.add_temporal_foreign_key(
    fk_table_oid => 'establishment_tm_bs_off',
    fk_column_names => ARRAY['legal_unit_id'],
    fk_era_name => 'valid',
    unique_key_name => 'legal_unit_tm_bs_off_id_valid'
);
          add_temporal_foreign_key           
---------------------------------------------
 establishment_tm_bs_off_legal_unit_id_valid
(1 row)

DO $$
DECLARE
    v_batch_sizes int[] := ARRAY[100, 1000, 10000];
    v_modes text[] := ARRAY['MERGE_ENTITY_PATCH', 'MERGE_ENTITY_REPLACE'];
    v_mode text;
    v_batch_size int;
    v_total_rows int := 2000;
    v_start_id int;
    v_end_id int;
BEGIN
    CREATE TEMPORARY TABLE legal_unit_source_bs (row_id int, id int, valid_from date, valid_until date, name varchar);
    CREATE TEMPORARY TABLE establishment_source_bs (row_id int, id int, valid_from date, valid_until date, legal_unit_id int, postal_place text);

    FOREACH v_batch_size IN ARRAY v_batch_sizes
    LOOP
        FOREACH v_mode IN ARRAY v_modes
        LOOP
            -- Triggers ON
            TRUNCATE legal_unit_tm_bs_on, establishment_tm_bs_on;
            INSERT INTO benchmark (event, row_count) VALUES (format('tm_loop, batch %s / %s (Triggers ON) start', v_batch_size, v_mode), 0);
        v_start_id := 1;
        WHILE v_start_id <= v_total_rows LOOP
            v_end_id := v_start_id + v_batch_size - 1;
            IF v_end_id > v_total_rows THEN v_end_id := v_total_rows; END IF;

            TRUNCATE legal_unit_source_bs, establishment_source_bs;
            INSERT INTO legal_unit_source_bs SELECT i, i, '2015-01-01', 'infinity', 'Company ' || i FROM generate_series(v_start_id, v_end_id) AS i;
            INSERT INTO establishment_source_bs SELECT i, i, '2015-01-01', 'infinity', i, 'Shop ' || i FROM generate_series(v_start_id, v_end_id) AS i;

            CALL sql_saga.temporal_merge('legal_unit_tm_bs_on'::regclass, 'legal_unit_source_bs'::regclass, ARRAY['id'], mode => v_mode::sql_saga.temporal_merge_mode, ephemeral_columns => ARRAY[]::text[]);
            CALL sql_saga.temporal_merge('establishment_tm_bs_on'::regclass, 'establishment_source_bs'::regclass, ARRAY['id'], mode => v_mode::sql_saga.temporal_merge_mode, ephemeral_columns => ARRAY[]::text[]);
            v_start_id := v_end_id + 1;
        END LOOP;
        INSERT INTO benchmark (event, row_count) VALUES (format('tm_loop, batch %s / %s (Triggers ON) end', v_batch_size, v_mode), v_total_rows * 2);

        -- Triggers OFF
        TRUNCATE legal_unit_tm_bs_off, establishment_tm_bs_off;
        INSERT INTO benchmark (event, row_count) VALUES (format('tm_loop, batch %s / %s (Triggers OFF) start', v_batch_size, v_mode), 0);
        v_start_id := 1;
        WHILE v_start_id <= v_total_rows LOOP
            v_end_id := v_start_id + v_batch_size - 1;
            IF v_end_id > v_total_rows THEN v_end_id := v_total_rows; END IF;

            TRUNCATE legal_unit_source_bs, establishment_source_bs;
            INSERT INTO legal_unit_source_bs SELECT i, i, '2015-01-01', 'infinity', 'Company ' || i FROM generate_series(v_start_id, v_end_id) AS i;
            INSERT INTO establishment_source_bs SELECT i, i, '2015-01-01', 'infinity', i, 'Shop ' || i FROM generate_series(v_start_id, v_end_id) AS i;

            CALL sql_saga.disable_temporal_triggers('legal_unit_tm_bs_off', 'establishment_tm_bs_off');
            CALL sql_saga.temporal_merge('legal_unit_tm_bs_off'::regclass, 'legal_unit_source_bs'::regclass, ARRAY['id'], mode => v_mode::sql_saga.temporal_merge_mode, ephemeral_columns => ARRAY[]::text[]);
            CALL sql_saga.temporal_merge('establishment_tm_bs_off'::regclass, 'establishment_source_bs'::regclass, ARRAY['id'], mode => v_mode::sql_saga.temporal_merge_mode, ephemeral_columns => ARRAY[]::text[]);
            CALL sql_saga.enable_temporal_triggers('legal_unit_tm_bs_off', 'establishment_tm_bs_off');
            v_start_id := v_end_id + 1;
        END LOOP;
        INSERT INTO benchmark (event, row_count) VALUES (format('tm_loop, batch %s / %s (Triggers OFF) end', v_batch_size, v_mode), v_total_rows * 2);
        END LOOP;
    END LOOP;
END;
$$;
SELECT 'legal_unit_tm_bs_on' AS type, COUNT(*) AS count FROM legal_unit_tm_bs_on
UNION ALL
SELECT 'establishment_tm_bs_on' AS type, COUNT(*) AS count FROM establishment_tm_bs_on
UNION ALL
SELECT 'legal_unit_tm_bs_off' AS type, COUNT(*) AS count FROM legal_unit_tm_bs_off
UNION ALL
SELECT 'establishment_tm_bs_off' AS type, COUNT(*) AS count FROM establishment_tm_bs_off;
          type           | count 
-------------------------+-------
 legal_unit_tm_bs_on     |  2000
 establishment_tm_bs_on  |  2000
 legal_unit_tm_bs_off    |  2000
 establishment_tm_bs_off |  2000
(4 rows)

-- Teardown for batch size benchmark tables
SELECT sql_saga.drop_foreign_key('establishment_tm_bs_on', ARRAY['legal_unit_id'], 'valid');
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_unique_key('establishment_tm_bs_on', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('establishment_tm_bs_on', cleanup => true);
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_unique_key('legal_unit_tm_bs_on', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('legal_unit_tm_bs_on', cleanup => true);
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_foreign_key('establishment_tm_bs_off', ARRAY['legal_unit_id'], 'valid');
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_unique_key('establishment_tm_bs_off', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('establishment_tm_bs_off', cleanup => true);
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_unique_key('legal_unit_tm_bs_off', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('legal_unit_tm_bs_off', cleanup => true);
 drop_era 
----------
 t
(1 row)

INSERT INTO benchmark (event, row_count) VALUES ('Constraints disabled', 0);
DROP TABLE establishment_tm_bs_on;
DROP TABLE legal_unit_tm_bs_on;
DROP TABLE establishment_tm_bs_off;
DROP TABLE legal_unit_tm_bs_off;
INSERT INTO benchmark (event, row_count) VALUES ('Tear down complete', 0);
-- Verify the benchmark events and row counts, but exclude volatile timing data
-- from the regression test output to ensure stability.
SELECT event, row_count FROM benchmark ORDER BY seq_id;
                              event                               | row_count 
------------------------------------------------------------------+-----------
 BEGIN                                                            |         0
 tm_loop, batch 100 / MERGE_ENTITY_PATCH (Triggers ON) start      |         0
 tm_loop, batch 100 / MERGE_ENTITY_PATCH (Triggers ON) end        |      4000
 tm_loop, batch 100 / MERGE_ENTITY_PATCH (Triggers OFF) start     |         0
 tm_loop, batch 100 / MERGE_ENTITY_PATCH (Triggers OFF) end       |      4000
 tm_loop, batch 100 / MERGE_ENTITY_REPLACE (Triggers ON) start    |         0
 tm_loop, batch 100 / MERGE_ENTITY_REPLACE (Triggers ON) end      |      4000
 tm_loop, batch 100 / MERGE_ENTITY_REPLACE (Triggers OFF) start   |         0
 tm_loop, batch 100 / MERGE_ENTITY_REPLACE (Triggers OFF) end     |      4000
 tm_loop, batch 1000 / MERGE_ENTITY_PATCH (Triggers ON) start     |         0
 tm_loop, batch 1000 / MERGE_ENTITY_PATCH (Triggers ON) end       |      4000
 tm_loop, batch 1000 / MERGE_ENTITY_PATCH (Triggers OFF) start    |         0
 tm_loop, batch 1000 / MERGE_ENTITY_PATCH (Triggers OFF) end      |      4000
 tm_loop, batch 1000 / MERGE_ENTITY_REPLACE (Triggers ON) start   |         0
 tm_loop, batch 1000 / MERGE_ENTITY_REPLACE (Triggers ON) end     |      4000
 tm_loop, batch 1000 / MERGE_ENTITY_REPLACE (Triggers OFF) start  |         0
 tm_loop, batch 1000 / MERGE_ENTITY_REPLACE (Triggers OFF) end    |      4000
 tm_loop, batch 10000 / MERGE_ENTITY_PATCH (Triggers ON) start    |         0
 tm_loop, batch 10000 / MERGE_ENTITY_PATCH (Triggers ON) end      |      4000
 tm_loop, batch 10000 / MERGE_ENTITY_PATCH (Triggers OFF) start   |         0
 tm_loop, batch 10000 / MERGE_ENTITY_PATCH (Triggers OFF) end     |      4000
 tm_loop, batch 10000 / MERGE_ENTITY_REPLACE (Triggers ON) start  |         0
 tm_loop, batch 10000 / MERGE_ENTITY_REPLACE (Triggers ON) end    |      4000
 tm_loop, batch 10000 / MERGE_ENTITY_REPLACE (Triggers OFF) start |         0
 tm_loop, batch 10000 / MERGE_ENTITY_REPLACE (Triggers OFF) end   |      4000
 Constraints disabled                                             |         0
 Tear down complete                                               |         0
(27 rows)

-- Capture performance metrics to a separate file for manual review.
\o expected/102_benchmark_temporal_merge_batch_sizes_performance.out
\i sql/include/benchmark_report.sql
-- Calculate rows per second
CREATE OR REPLACE FUNCTION format_duration(p_interval interval) RETURNS TEXT AS $$
BEGIN
    IF p_interval IS NULL THEN RETURN ''; END IF;
    IF EXTRACT(EPOCH FROM p_interval) >= 1 THEN
        RETURN ROUND(EXTRACT(EPOCH FROM p_interval))::numeric || ' secs';
    ELSE
        RETURN ROUND(EXTRACT(EPOCH FROM p_interval) * 1000)::numeric || ' ms';
    END IF;
END;
$$ LANGUAGE plpgsql;
WITH benchmark_events AS (
  SELECT
    seq_id,
    timestamp,
    event,
    row_count,
    regexp_replace(event, ' (start|end)$', '') AS operation,
    CASE
      WHEN event LIKE '% start' THEN 'start'
      WHEN event LIKE '% end' THEN 'end'
      ELSE 'milestone'
    END AS phase,
    FIRST_VALUE(timestamp) OVER (ORDER BY seq_id) as benchmark_start_time,
    LAG(timestamp) OVER (ORDER BY seq_id) as prev_event_time
  FROM
    benchmark
),
benchmark_durations AS (
  SELECT
    *,
    LAG(timestamp) OVER (PARTITION BY operation ORDER BY seq_id) AS operation_start_time
  FROM
    benchmark_events
)
SELECT
  CASE WHEN phase = 'end' THEN operation ELSE event END AS event,
  row_count,
  format_duration(timestamp - benchmark_start_time) AS time_from_start,
  CASE
    WHEN phase = 'end' THEN format_duration(timestamp - operation_start_time)
    WHEN phase = 'milestone' THEN format_duration(timestamp - prev_event_time)
    ELSE ''
  END AS time_from_prev,
  row_count || ' rows' AS row_count,
  '~' ||
    CASE
      WHEN phase = 'end' AND EXTRACT(EPOCH FROM (timestamp - operation_start_time)) > 0.001 THEN
        ROUND(row_count::FLOAT8 / EXTRACT(EPOCH FROM (timestamp - operation_start_time)))::text
      WHEN phase = 'milestone' AND EXTRACT(EPOCH FROM (timestamp - prev_event_time)) > 0.001 AND row_count > 0 THEN
        ROUND(row_count::FLOAT8 / EXTRACT(EPOCH FROM (timestamp - prev_event_time)))::text
      ELSE
        '0'
    END
  || ' rows/s' AS rows_per_second
FROM
  benchmark_durations
WHERE phase <> 'start'
ORDER BY
  seq_id;
-- Stop redirecting output
\o
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
