-- =============================================================================
-- Test Suite: `sql_saga.temporal_merge` (Single Key)
--
-- Description:
--   This test suite provides comprehensive validation for the unified
--   `temporal_merge_plan` and `temporal_merge` functions for entities with
--   a single-column primary key.
--
-- Table of Contents:
--   - Setup
--   - Scenario 1: Initial Data Load (Empty Target)
--   - Scenarios for `upsert_patch` mode (Allen's Interval Algebra)
--     - Scenario 2: `starts`
--     - Scenario 3: `finishes`
--     - Scenario 4: `during` / `contains`
--     - Scenario 5: `overlaps`
--     - Scenario 6: `overlapped by`
--     - Scenario 7: `meets`
--     - Scenario 8: `met by`
--     - Scenario 9: `before`
--     - Scenario 10: `after`
--     - Scenario 11: `equals`
--   - Scenarios for `upsert_replace` mode
--     - Scenario 12: `starts`
--     - Scenario 13: `finishes`
--     - Scenario 14: `during` / `contains`
--     - Scenario 15: `overlaps`
--     - Scenario 16: `equals`
--     - Scenario 17: `replace` with NULL source value
--   - Scenarios for `_only` modes (Filtering Behavior)
--     - Scenario 18: `patch_only` on non-existent entity
--     - Scenario 19: `replace_only` on non-existent entity
--   - Scenarios for NULL handling in `patch` mode
--     - Scenario 20: `upsert_patch` with NULL source value
--     - Scenario 21: `patch_only` with NULL source value
--   - Scenarios for Ephemeral Columns
--     - Scenario 22: `equals` with different ephemeral data
--     - Scenario 23: `equals` with identical data (should be SKIPPED)
--   - Scenarios for Multi-Row Source Data
--     - Scenario 24: Multiple disjoint source rows
--     - Scenario 25: Multiple overlapping source rows
--     - Scenario 26: Multiple source rows creating a hole
--   - Scenarios for `sql_saga` Integration
--     - Scenario 27: `starts` with deferred foreign key
--   - Scenarios for `insert_defaulted_columns`
--     - Scenario 28: Initial INSERT with default columns
--   - Scenarios for SAVEPOINT and Transactional Correctness
--     - Scenario 29: Test `meets` relation
--     - Scenario 30: Test `starts` relation
--     - Scenario 31: Test `during` relation
--     - Scenario 32: Test `overlaps` relation
--     - Scenario 33: Test `finishes` relation
--     - Scenario 34: Test `equals` relation
--   - Scenarios for Batch-Level Feedback
--     - Scenario 35: `patch_only` with mixed valid/invalid entities
--   - Scenarios for Merging and Coalescing
--     - Scenario 36: `upsert_patch` with two consecutive, identical source rows
--     - Scenario 37: `upsert_patch` with three consecutive, identical source rows
--     - Scenario 38: `upsert_patch` with two consecutive but DIFFERENT source rows
--     - Scenario 39: `upsert_patch` where source row is consecutive with existing target row
--   - Scenarios for `insert_defaulted_columns`
--     - Scenario 40: `INSERT` with `created_at` defaulted
--   - Final Cleanup
-- =============================================================================
\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
-- Test schema
CREATE SCHEMA temporal_merge_test;
-- Sequences for auto-generated IDs
CREATE SEQUENCE temporal_merge_test.legal_unit_id_seq;
CREATE SEQUENCE temporal_merge_test.establishment_id_seq;
-- Target tables (simplified versions for testing)
CREATE TABLE temporal_merge_test.legal_unit (
    id INT PRIMARY KEY,
    name TEXT
);
CREATE TABLE temporal_merge_test.establishment (
    id INT NOT NULL,
    legal_unit_id INT NOT NULL,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    name TEXT,
    employees INT,
    edit_comment TEXT,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('temporal_merge_test.establishment', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "establishment_synchronize_temporal_columns_trigger" on table temporal_merge_test.establishment to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

CREATE INDEX ON temporal_merge_test.establishment USING GIST (valid_range);
-- Helper procedure to reset target table state between scenarios
CREATE PROCEDURE temporal_merge_test.reset_target() LANGUAGE plpgsql AS $$
BEGIN
    TRUNCATE temporal_merge_test.establishment;
    TRUNCATE temporal_merge_test.legal_unit;
    -- Seed with a legal unit for FK constraints
    INSERT INTO temporal_merge_test.legal_unit (id, name) VALUES (1, 'Test LU');
    ALTER SEQUENCE temporal_merge_test.establishment_id_seq RESTART WITH 1;
END;
$$;
-- psql variables for the test
\set target_schema 'temporal_merge_test'
\set target_table 'temporal_merge_test.establishment'
\set source_schema 'pg_temp'
\set entity_id_cols '{id}'
\set ephemeral_cols '{edit_comment}'
--------------------------------------------------------------------------------
-- Scenarios for MERGE_ENTITY_PATCH (`insert_or_update`)
--------------------------------------------------------------------------------
\echo '================================================================================'
================================================================================
\echo 'Begin Scenarios for MERGE_ENTITY_PATCH mode'
Begin Scenarios for MERGE_ENTITY_PATCH mode
\echo '================================================================================'
================================================================================
--------------------------------------------------------------------------------
\echo 'Scenario 1: Initial Insert of a new entity'
Scenario 1: Initial Insert of a new entity
\echo 'Mode: MERGE_ENTITY_PATCH'
Mode: MERGE_ENTITY_PATCH
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
CREATE TEMP TABLE temp_source_1 (
    row_id INT, legal_unit_id INT, id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_1 VALUES (101, 1, nextval('temporal_merge_test.establishment_id_seq'), '2024-01-01', '2025-01-01', 'New EST', 10, 'Initial Insert');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_1 ORDER BY row_id;
 row_id | legal_unit_id | id | valid_from | valid_until |  name   | employees |  edit_comment  
--------+---------------+----+------------+-------------+---------+-----------+----------------
    101 |             1 |  1 | 2024-01-01 | 2025-01-01  | New EST |        10 | Initial Insert
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_1',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                            data                                            | feedback | trace | grouping_key  
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+--------------------------------------------------------------------------------------------+----------+-------+---------------
           1 |             1 | {101}   | INSERT    |               | 101       | t             | {"id": 1}   | {"id": 1}     | {}          |              |              |                |                 | 2024-01-01     | 2025-01-01      | {"name": "New EST", "employees": 10, "edit_comment": "Initial Insert", "legal_unit_id": 1} |          |       | new_entity__1
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           101 | [{"id": 1}]        | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'New EST'::TEXT, 10, 'Initial Insert'::TEXT)
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |  name   | employees |  edit_comment  
----+---------------+------------+-------------+---------+-----------+----------------
  1 |             1 | 2024-01-01 | 2025-01-01  | New EST |        10 | Initial Insert
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 1 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |  name   | employees |  edit_comment  
----+---------------+------------+-------------+---------+-----------+----------------
  1 |             1 | 2024-01-01 | 2025-01-01  | New EST |        10 | Initial Insert
(1 row)

DROP TABLE temp_source_1;
--------------------------------------------------------------------------------
\echo 'Scenario 2: `MERGE_ENTITY_PATCH` with `starts` relation'
Scenario 2: `MERGE_ENTITY_PATCH` with `starts` relation
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (2, 1, '2024-01-01', '2026-01-01', 'Original', 20, 'Original slice');
CREATE TEMP TABLE temp_source_2 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT, edit_comment TEXT ) ON COMMIT DROP;
CREATE INDEX ON temp_source_2 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_2 VALUES (102, 2, 1, '2024-01-01', '2025-01-01', 'Patched', 25, 'Starts patch');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  2 |             1 | 2024-01-01 | 2026-01-01  | Original |        20 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_2 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |  name   | employees | edit_comment 
--------+----+---------------+------------+-------------+---------+-----------+--------------
    102 |  2 |             1 | 2024-01-01 | 2025-01-01  | Patched |        25 | Starts patch
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_2',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                            data                                             | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+---------------------------------------------------------------------------------------------+----------+-------+--------------------
           1 |             1 | {102}   | UPDATE    | SHRINK        | 102       | f             | {"id": 2}   | {"id": 2}     | {}          | starts       | started_by   | 2024-01-01     | 2026-01-01      | 2024-01-01     | 2025-01-01      | {"name": "Patched", "employees": 25, "edit_comment": "Starts patch", "legal_unit_id": 1}    |          |       | existing_entity__2
           2 |             2 | {102}   | INSERT    |               | 102       | f             | {"id": 2}   | {"id": 2}     | {}          | starts       | finished_by  | 2024-01-01     | 2026-01-01      | 2025-01-01     | 2026-01-01      | {"name": "Original", "employees": 20, "edit_comment": "Original slice", "legal_unit_id": 1} |          |       | existing_entity__2
(2 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           102 | [{"id": 2}]        | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (2, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Patched', 25, 'Starts patch'),
    (2, 1, '2025-01-01'::DATE, '2026-01-01'::DATE, 'Original', 20, 'Original slice')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  2 |             1 | 2024-01-01 | 2025-01-01  | Patched  |        25 | Starts patch
  2 |             1 | 2025-01-01 | 2026-01-01  | Original |        20 | Original slice
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 2 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  2 |             1 | 2024-01-01 | 2025-01-01  | Patched  |        25 | Starts patch
  2 |             1 | 2025-01-01 | 2026-01-01  | Original |        20 | Original slice
(2 rows)

DROP TABLE temp_source_2;
--------------------------------------------------------------------------------
\echo 'Scenario 3: `MERGE_ENTITY_PATCH` with `finishes` relation'
Scenario 3: `MERGE_ENTITY_PATCH` with `finishes` relation
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (3, 1, '2024-01-01', '2026-01-01', 'Original', 30, 'Original slice');
CREATE TEMP TABLE temp_source_3 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT, edit_comment TEXT) ON COMMIT DROP;
CREATE INDEX ON temp_source_3 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_3 VALUES (103, 3, 1, '2025-01-01', '2026-01-01', 'Patched', 35, 'Finishes patch');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  3 |             1 | 2024-01-01 | 2026-01-01  | Original |        30 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_3 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |  name   | employees |  edit_comment  
--------+----+---------------+------------+-------------+---------+-----------+----------------
    103 |  3 |             1 | 2025-01-01 | 2026-01-01  | Patched |        35 | Finishes patch
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_3',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                            data                                             | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+---------------------------------------------------------------------------------------------+----------+-------+--------------------
           1 |             1 | {103}   | UPDATE    | SHRINK        | 103       | f             | {"id": 3}   | {"id": 3}     | {}          | finishes     | started_by   | 2024-01-01     | 2026-01-01      | 2024-01-01     | 2025-01-01      | {"name": "Original", "employees": 30, "edit_comment": "Original slice", "legal_unit_id": 1} |          |       | existing_entity__3
           2 |             2 | {103}   | INSERT    |               | 103       | f             | {"id": 3}   | {"id": 3}     | {}          | finishes     | finished_by  | 2024-01-01     | 2026-01-01      | 2025-01-01     | 2026-01-01      | {"name": "Patched", "employees": 35, "edit_comment": "Finishes patch", "legal_unit_id": 1}  |          |       | existing_entity__3
(2 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           103 | [{"id": 3}]        | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (3, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Original', 30, 'Original slice'),
    (3, 1, '2025-01-01'::DATE, '2026-01-01'::DATE, 'Patched', 35, 'Finishes patch')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  3 |             1 | 2024-01-01 | 2025-01-01  | Original |        30 | Original slice
  3 |             1 | 2025-01-01 | 2026-01-01  | Patched  |        35 | Finishes patch
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 3 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  3 |             1 | 2024-01-01 | 2025-01-01  | Original |        30 | Original slice
  3 |             1 | 2025-01-01 | 2026-01-01  | Patched  |        35 | Finishes patch
(2 rows)

DROP TABLE temp_source_3;
--------------------------------------------------------------------------------
\echo 'Scenario 4: `MERGE_ENTITY_PATCH` with `during` relation'
Scenario 4: `MERGE_ENTITY_PATCH` with `during` relation
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (4, 1, '2024-01-01', '2026-01-01', 'Original', 40, 'Original slice');
CREATE TEMP TABLE temp_source_4 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT, edit_comment TEXT) ON COMMIT DROP;
CREATE INDEX ON temp_source_4 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_4 VALUES (104, 4, 1, '2024-07-01', '2025-01-01', 'Patched', 45, 'During patch');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  4 |             1 | 2024-01-01 | 2026-01-01  | Original |        40 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_4 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |  name   | employees | edit_comment 
--------+----+---------------+------------+-------------+---------+-----------+--------------
    104 |  4 |             1 | 2024-07-01 | 2025-01-01  | Patched |        45 | During patch
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_4',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                            data                                             | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+---------------------------------------------------------------------------------------------+----------+-------+--------------------
           1 |             1 | {104}   | UPDATE    | SHRINK        | 104       | f             | {"id": 4}   | {"id": 4}     | {}          | during       | started_by   | 2024-01-01     | 2026-01-01      | 2024-01-01     | 2024-07-01      | {"name": "Original", "employees": 40, "edit_comment": "Original slice", "legal_unit_id": 1} |          |       | existing_entity__4
           2 |             2 | {104}   | INSERT    |               | 104       | f             | {"id": 4}   | {"id": 4}     | {}          | during       | contains     | 2024-01-01     | 2026-01-01      | 2024-07-01     | 2025-01-01      | {"name": "Patched", "employees": 45, "edit_comment": "During patch", "legal_unit_id": 1}    |          |       | existing_entity__4
           3 |             2 | {104}   | INSERT    |               | 104       | f             | {"id": 4}   | {"id": 4}     | {}          | during       | finished_by  | 2024-01-01     | 2026-01-01      | 2025-01-01     | 2026-01-01      | {"name": "Original", "employees": 40, "edit_comment": "Original slice", "legal_unit_id": 1} |          |       | existing_entity__4
(3 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           104 | [{"id": 4}]        | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (4, 1, '2024-01-01'::DATE, '2024-07-01'::DATE, 'Original', 40, 'Original slice'),
    (4, 1, '2024-07-01'::DATE, '2025-01-01'::DATE, 'Patched', 45, 'During patch'),
    (4, 1, '2025-01-01'::DATE, '2026-01-01'::DATE, 'Original', 40, 'Original slice')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  4 |             1 | 2024-01-01 | 2024-07-01  | Original |        40 | Original slice
  4 |             1 | 2024-07-01 | 2025-01-01  | Patched  |        45 | During patch
  4 |             1 | 2025-01-01 | 2026-01-01  | Original |        40 | Original slice
(3 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 4 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  4 |             1 | 2024-01-01 | 2024-07-01  | Original |        40 | Original slice
  4 |             1 | 2024-07-01 | 2025-01-01  | Patched  |        45 | During patch
  4 |             1 | 2025-01-01 | 2026-01-01  | Original |        40 | Original slice
(3 rows)

DROP TABLE temp_source_4;
--------------------------------------------------------------------------------
\echo 'Scenario 5: `MERGE_ENTITY_PATCH` with `overlaps` relation'
Scenario 5: `MERGE_ENTITY_PATCH` with `overlaps` relation
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (5, 1, '2024-01-01', '2025-01-01', 'Original', 50, 'Original slice');
CREATE TEMP TABLE temp_source_5 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT, edit_comment TEXT) ON COMMIT DROP;
CREATE INDEX ON temp_source_5 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_5 VALUES (105, 5, 1, '2024-07-01', '2025-07-01', 'Patched', 55, 'Overlaps patch');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  5 |             1 | 2024-01-01 | 2025-01-01  | Original |        50 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_5 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |  name   | employees |  edit_comment  
--------+----+---------------+------------+-------------+---------+-----------+----------------
    105 |  5 |             1 | 2024-07-01 | 2025-07-01  | Patched |        55 | Overlaps patch
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_5',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation  | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                            data                                             | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+---------------+--------------+----------------+-----------------+----------------+-----------------+---------------------------------------------------------------------------------------------+----------+-------+--------------------
           1 |             1 | {105}   | UPDATE    | SHRINK        | 105       | f             | {"id": 5}   | {"id": 5}     | {}          | overlapped_by | started_by   | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2024-07-01      | {"name": "Original", "employees": 50, "edit_comment": "Original slice", "legal_unit_id": 1} |          |       | existing_entity__5
           2 |             2 | {105}   | INSERT    |               | 105       | f             | {"id": 5}   | {"id": 5}     | {}          | overlapped_by | overlaps     | 2024-01-01     | 2025-01-01      | 2024-07-01     | 2025-07-01      | {"name": "Patched", "employees": 55, "edit_comment": "Overlaps patch", "legal_unit_id": 1}  |          |       | existing_entity__5
(2 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           105 | [{"id": 5}]        | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (5, 1, '2024-01-01'::DATE, '2024-07-01'::DATE, 'Original', 50, 'Original slice'),
    (5, 1, '2024-07-01'::DATE, '2025-07-01'::DATE, 'Patched', 55, 'Overlaps patch')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  5 |             1 | 2024-01-01 | 2024-07-01  | Original |        50 | Original slice
  5 |             1 | 2024-07-01 | 2025-07-01  | Patched  |        55 | Overlaps patch
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 5 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  5 |             1 | 2024-01-01 | 2024-07-01  | Original |        50 | Original slice
  5 |             1 | 2024-07-01 | 2025-07-01  | Patched  |        55 | Overlaps patch
(2 rows)

DROP TABLE temp_source_5;
--------------------------------------------------------------------------------
\echo 'Scenario 6: `MERGE_ENTITY_PATCH` with `overlapped by` relation'
Scenario 6: `MERGE_ENTITY_PATCH` with `overlapped by` relation
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (6, 1, '2024-07-01', '2025-07-01', 'Original', 60, 'Original slice');
CREATE TEMP TABLE temp_source_6 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT, edit_comment TEXT) ON COMMIT DROP;
CREATE INDEX ON temp_source_6 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_6 VALUES (106, 6, 1, '2024-01-01', '2025-01-01', 'Patched', 65, 'Overlapped by patch');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  6 |             1 | 2024-07-01 | 2025-07-01  | Original |        60 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_6 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |  name   | employees |    edit_comment     
--------+----+---------------+------------+-------------+---------+-----------+---------------------
    106 |  6 |             1 | 2024-01-01 | 2025-01-01  | Patched |        65 | Overlapped by patch
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_6',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation  | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                              data                                               | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+---------------+----------------+-----------------+----------------+-----------------+-------------------------------------------------------------------------------------------------+----------+-------+--------------------
           1 |             1 | {106}   | UPDATE    | SHRINK        | 106       | f             | {"id": 6}   | {"id": 6}     | {}          | overlaps     | finished_by   | 2024-07-01     | 2025-07-01      | 2025-01-01     | 2025-07-01      | {"name": "Original", "employees": 60, "edit_comment": "Original slice", "legal_unit_id": 1}     |          |       | existing_entity__6
           2 |             2 | {106}   | INSERT    |               | 106       | f             | {"id": 6}   | {"id": 6}     | {}          | overlaps     | overlapped_by | 2024-07-01     | 2025-07-01      | 2024-01-01     | 2025-01-01      | {"name": "Patched", "employees": 65, "edit_comment": "Overlapped by patch", "legal_unit_id": 1} |          |       | existing_entity__6
(2 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           106 | [{"id": 6}]        | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (6, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Patched', 65, 'Overlapped by patch'),
    (6, 1, '2025-01-01'::DATE, '2025-07-01'::DATE, 'Original', 60, 'Original slice')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |    edit_comment     
----+---------------+------------+-------------+----------+-----------+---------------------
  6 |             1 | 2024-01-01 | 2025-01-01  | Patched  |        65 | Overlapped by patch
  6 |             1 | 2025-01-01 | 2025-07-01  | Original |        60 | Original slice
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 6 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |    edit_comment     
----+---------------+------------+-------------+----------+-----------+---------------------
  6 |             1 | 2024-01-01 | 2025-01-01  | Patched  |        65 | Overlapped by patch
  6 |             1 | 2025-01-01 | 2025-07-01  | Original |        60 | Original slice
(2 rows)

DROP TABLE temp_source_6;
--------------------------------------------------------------------------------
\echo 'Scenario 7: `MERGE_ENTITY_PATCH` with `meets` relation'
Scenario 7: `MERGE_ENTITY_PATCH` with `meets` relation
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (7, 1, '2025-01-01', '2026-01-01', 'Original', 70, 'Original slice');
CREATE TEMP TABLE temp_source_7 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT, edit_comment TEXT) ON COMMIT DROP;
CREATE INDEX ON temp_source_7 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_7 VALUES (107, 7, 1, '2024-01-01', '2025-01-01', 'Patched', 75, 'Meets patch');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  7 |             1 | 2025-01-01 | 2026-01-01  | Original |        70 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_7 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |  name   | employees | edit_comment 
--------+----+---------------+------------+-------------+---------+-----------+--------------
    107 |  7 |             1 | 2024-01-01 | 2025-01-01  | Patched |        75 | Meets patch
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_7',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                          data                                           | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-----------------------------------------------------------------------------------------+----------+-------+--------------------
           1 |             1 | {107}   | INSERT    |               | 107       | f             | {"id": 7}   | {"id": 7}     | {}          |              |              |                |                 | 2024-01-01     | 2025-01-01      | {"name": "Patched", "employees": 75, "edit_comment": "Meets patch", "legal_unit_id": 1} |          |       | existing_entity__7
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           107 | [{"id": 7}]        | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (7, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Patched', 75, 'Meets patch'),
    (7, 1, '2025-01-01'::DATE, '2026-01-01'::DATE, 'Original', 70, 'Original slice')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  7 |             1 | 2024-01-01 | 2025-01-01  | Patched  |        75 | Meets patch
  7 |             1 | 2025-01-01 | 2026-01-01  | Original |        70 | Original slice
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 7 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  7 |             1 | 2024-01-01 | 2025-01-01  | Patched  |        75 | Meets patch
  7 |             1 | 2025-01-01 | 2026-01-01  | Original |        70 | Original slice
(2 rows)

DROP TABLE temp_source_7;
--------------------------------------------------------------------------------
\echo 'Scenario 8: `MERGE_ENTITY_PATCH` with `met by` relation'
Scenario 8: `MERGE_ENTITY_PATCH` with `met by` relation
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (8, 1, '2024-01-01', '2025-01-01', 'Original', 80, 'Original slice');
CREATE TEMP TABLE temp_source_8 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT, edit_comment TEXT) ON COMMIT DROP;
CREATE INDEX ON temp_source_8 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_8 VALUES (108, 8, 1, '2025-01-01', '2026-01-01', 'Patched', 85, 'Met by patch');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  8 |             1 | 2024-01-01 | 2025-01-01  | Original |        80 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_8 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |  name   | employees | edit_comment 
--------+----+---------------+------------+-------------+---------+-----------+--------------
    108 |  8 |             1 | 2025-01-01 | 2026-01-01  | Patched |        85 | Met by patch
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_8',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                           data                                           | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+------------------------------------------------------------------------------------------+----------+-------+--------------------
           1 |             1 | {108}   | INSERT    |               | 108       | f             | {"id": 8}   | {"id": 8}     | {}          |              |              |                |                 | 2025-01-01     | 2026-01-01      | {"name": "Patched", "employees": 85, "edit_comment": "Met by patch", "legal_unit_id": 1} |          |       | existing_entity__8
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           108 | [{"id": 8}]        | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (8, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Original', 80, 'Original slice'),
    (8, 1, '2025-01-01'::DATE, '2026-01-01'::DATE, 'Patched', 85, 'Met by patch')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  8 |             1 | 2024-01-01 | 2025-01-01  | Original |        80 | Original slice
  8 |             1 | 2025-01-01 | 2026-01-01  | Patched  |        85 | Met by patch
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 8 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  8 |             1 | 2024-01-01 | 2025-01-01  | Original |        80 | Original slice
  8 |             1 | 2025-01-01 | 2026-01-01  | Patched  |        85 | Met by patch
(2 rows)

DROP TABLE temp_source_8;
--------------------------------------------------------------------------------
\echo 'Scenario 9: `MERGE_ENTITY_PATCH` with `before` relation (non-contiguous)'
Scenario 9: `MERGE_ENTITY_PATCH` with `before` relation (non-contiguous)
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (9, 1, '2026-01-01', '2027-01-01', 'Original', 90, 'Original slice');
CREATE TEMP TABLE temp_source_9 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT, edit_comment TEXT) ON COMMIT DROP;
CREATE INDEX ON temp_source_9 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_9 VALUES (109, 9, 1, '2024-01-01', '2025-01-01', 'Patched', 95, 'Before patch');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  9 |             1 | 2026-01-01 | 2027-01-01  | Original |        90 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_9 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |  name   | employees | edit_comment 
--------+----+---------------+------------+-------------+---------+-----------+--------------
    109 |  9 |             1 | 2024-01-01 | 2025-01-01  | Patched |        95 | Before patch
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_9',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                           data                                           | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+------------------------------------------------------------------------------------------+----------+-------+--------------------
           1 |             1 | {109}   | INSERT    |               | 109       | f             | {"id": 9}   | {"id": 9}     | {}          |              |              |                |                 | 2024-01-01     | 2025-01-01      | {"name": "Patched", "employees": 95, "edit_comment": "Before patch", "legal_unit_id": 1} |          |       | existing_entity__9
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           109 | [{"id": 9}]        | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (9, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Patched', 95, 'Before patch'),
    (9, 1, '2026-01-01'::DATE, '2027-01-01'::DATE, 'Original', 90, 'Original slice')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  9 |             1 | 2024-01-01 | 2025-01-01  | Patched  |        95 | Before patch
  9 |             1 | 2026-01-01 | 2027-01-01  | Original |        90 | Original slice
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 9 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
  9 |             1 | 2024-01-01 | 2025-01-01  | Patched  |        95 | Before patch
  9 |             1 | 2026-01-01 | 2027-01-01  | Original |        90 | Original slice
(2 rows)

DROP TABLE temp_source_9;
--------------------------------------------------------------------------------
\echo 'Scenario 10: `MERGE_ENTITY_PATCH` with `after` relation (non-contiguous)'
Scenario 10: `MERGE_ENTITY_PATCH` with `after` relation (non-contiguous)
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (10, 1, '2024-01-01', '2025-01-01', 'Original', 100, 'Original slice');
CREATE TEMP TABLE temp_source_10 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT, edit_comment TEXT) ON COMMIT DROP;
CREATE INDEX ON temp_source_10 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_10 VALUES (110, 10, 1, '2025-01-02', '2026-01-01', 'Patched', 105, 'After patch');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 10 |             1 | 2024-01-01 | 2025-01-01  | Original |       100 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_10 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |  name   | employees | edit_comment 
--------+----+---------------+------------+-------------+---------+-----------+--------------
    110 | 10 |             1 | 2025-01-02 | 2026-01-01  | Patched |       105 | After patch
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_10',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                           data                                           | feedback | trace |    grouping_key     
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+------------------------------------------------------------------------------------------+----------+-------+---------------------
           1 |             1 | {110}   | INSERT    |               | 110       | f             | {"id": 10}  | {"id": 10}    | {}          |              |              |                |                 | 2025-01-02     | 2026-01-01      | {"name": "Patched", "employees": 105, "edit_comment": "After patch", "legal_unit_id": 1} |          |       | existing_entity__10
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           110 | [{"id": 10}]       | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (10, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Original', 100, 'Original slice'),
    (10, 1, '2025-01-02'::DATE, '2026-01-01'::DATE, 'Patched', 105, 'After patch')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 10 |             1 | 2024-01-01 | 2025-01-01  | Original |       100 | Original slice
 10 |             1 | 2025-01-02 | 2026-01-01  | Patched  |       105 | After patch
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 10 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 10 |             1 | 2024-01-01 | 2025-01-01  | Original |       100 | Original slice
 10 |             1 | 2025-01-02 | 2026-01-01  | Patched  |       105 | After patch
(2 rows)

DROP TABLE temp_source_10;
--------------------------------------------------------------------------------
\echo 'Scenario 11: `MERGE_ENTITY_PATCH` with `equals` relation'
Scenario 11: `MERGE_ENTITY_PATCH` with `equals` relation
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (11, 1, '2024-01-01', '2025-01-01', 'Original', 110, 'Original slice');
CREATE TEMP TABLE temp_source_11 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT, edit_comment TEXT) ON COMMIT DROP;
CREATE INDEX ON temp_source_11 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_11 VALUES (111, 11, 1, '2024-01-01', '2025-01-01', 'Patched', 115, 'Equals patch');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 11 |             1 | 2024-01-01 | 2025-01-01  | Original |       110 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_11 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |  name   | employees | edit_comment 
--------+----+---------------+------------+-------------+---------+-----------+--------------
    111 | 11 |             1 | 2024-01-01 | 2025-01-01  | Patched |       115 | Equals patch
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_11',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                           data                                            | feedback | trace |    grouping_key     
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------------------------------------------------------------------------+----------+-------+---------------------
           1 |             1 | {111}   | UPDATE    | NONE          | 111       | f             | {"id": 11}  | {"id": 11}    | {}          | equals       | equals       | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2025-01-01      | {"name": "Patched", "employees": 115, "edit_comment": "Equals patch", "legal_unit_id": 1} |          |       | existing_entity__11
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           111 | [{"id": 11}]       | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (11, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Patched', 115, 'Equals patch')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |  name   | employees | edit_comment 
----+---------------+------------+-------------+---------+-----------+--------------
 11 |             1 | 2024-01-01 | 2025-01-01  | Patched |       115 | Equals patch
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 11 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |  name   | employees | edit_comment 
----+---------------+------------+-------------+---------+-----------+--------------
 11 |             1 | 2024-01-01 | 2025-01-01  | Patched |       115 | Equals patch
(1 row)

DROP TABLE temp_source_11;
--------------------------------------------------------------------------------
\echo '================================================================================'
================================================================================
\echo 'Begin Scenarios for MERGE_ENTITY_REPLACE mode'
Begin Scenarios for MERGE_ENTITY_REPLACE mode
\echo '================================================================================'
================================================================================
--------------------------------------------------------------------------------
\echo 'Scenario 12: MERGE_ENTITY_REPLACE with starts relation'
Scenario 12: MERGE_ENTITY_REPLACE with starts relation
\echo 'Mode: MERGE_ENTITY_REPLACE'
Mode: MERGE_ENTITY_REPLACE
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (12, 1, '2024-01-01', '2026-01-01', 'Original', 20, 'Original slice');
-- Source data
CREATE TEMP TABLE temp_source_12 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE, valid_until DATE, name TEXT, employees INT, edit_comment TEXT ) ON COMMIT DROP;
CREATE INDEX ON temp_source_12 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_12 VALUES (112, 12, 1, '2024-01-01', '2025-01-01', 'Replaced', 25, 'Starts replace');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 12 |             1 | 2024-01-01 | 2026-01-01  | Original |        20 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_12 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
--------+----+---------------+------------+-------------+----------+-----------+----------------
    112 | 12 |             1 | 2024-01-01 | 2025-01-01  | Replaced |        25 | Starts replace
(1 row)

-- Run merge
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_12',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid'
);
-- Verify plan
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                            data                                             | feedback | trace |    grouping_key     
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+---------------------------------------------------------------------------------------------+----------+-------+---------------------
           1 |             1 | {112}   | UPDATE    | SHRINK        | 112       | f             | {"id": 12}  | {"id": 12}    | {}          | starts       | started_by   | 2024-01-01     | 2026-01-01      | 2024-01-01     | 2025-01-01      | {"name": "Replaced", "employees": 25, "edit_comment": "Starts replace", "legal_unit_id": 1} |          |       | existing_entity__12
           2 |             2 | {112}   | INSERT    |               | 112       | f             | {"id": 12}  | {"id": 12}    | {}          | starts       | finished_by  | 2024-01-01     | 2026-01-01      | 2025-01-01     | 2026-01-01      | {"name": "Original", "employees": 20, "edit_comment": "Original slice", "legal_unit_id": 1} |          |       | existing_entity__12
(2 rows)

-- Verify feedback
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           112 | [{"id": 12}]       | APPLIED | 
(1 row)

-- Verify final state
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (12, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Replaced', 25, 'Starts replace'),
    (12, 1, '2025-01-01'::DATE, '2026-01-01'::DATE, 'Original', 20, 'Original slice')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 12 |             1 | 2024-01-01 | 2025-01-01  | Replaced |        25 | Starts replace
 12 |             1 | 2025-01-01 | 2026-01-01  | Original |        20 | Original slice
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 12 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 12 |             1 | 2024-01-01 | 2025-01-01  | Replaced |        25 | Starts replace
 12 |             1 | 2025-01-01 | 2026-01-01  | Original |        20 | Original slice
(2 rows)

DROP TABLE temp_source_12;
--------------------------------------------------------------------------------
\echo 'Scenario 13: MERGE_ENTITY_REPLACE with finishes relation'
Scenario 13: MERGE_ENTITY_REPLACE with finishes relation
\echo 'Mode: MERGE_ENTITY_REPLACE'
Mode: MERGE_ENTITY_REPLACE
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (13, 1, '2024-01-01', '2026-01-01', 'Original', 30, 'Original slice');
-- Source data
CREATE TEMP TABLE temp_source_13 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE, valid_until DATE, name TEXT, employees INT, edit_comment TEXT ) ON COMMIT DROP;
CREATE INDEX ON temp_source_13 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_13 VALUES (113, 13, 1, '2025-01-01', '2026-01-01', 'Replaced', 35, 'Finishes replace');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 13 |             1 | 2024-01-01 | 2026-01-01  | Original |        30 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_13 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |   name   | employees |   edit_comment   
--------+----+---------------+------------+-------------+----------+-----------+------------------
    113 | 13 |             1 | 2025-01-01 | 2026-01-01  | Replaced |        35 | Finishes replace
(1 row)

-- Run merge
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_13',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid'
);
-- Verify plan
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                             data                                              | feedback | trace |    grouping_key     
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-----------------------------------------------------------------------------------------------+----------+-------+---------------------
           1 |             1 | {113}   | UPDATE    | SHRINK        | 113       | f             | {"id": 13}  | {"id": 13}    | {}          | finishes     | started_by   | 2024-01-01     | 2026-01-01      | 2024-01-01     | 2025-01-01      | {"name": "Original", "employees": 30, "edit_comment": "Original slice", "legal_unit_id": 1}   |          |       | existing_entity__13
           2 |             2 | {113}   | INSERT    |               | 113       | f             | {"id": 13}  | {"id": 13}    | {}          | finishes     | finished_by  | 2024-01-01     | 2026-01-01      | 2025-01-01     | 2026-01-01      | {"name": "Replaced", "employees": 35, "edit_comment": "Finishes replace", "legal_unit_id": 1} |          |       | existing_entity__13
(2 rows)

-- Verify feedback
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           113 | [{"id": 13}]       | APPLIED | 
(1 row)

-- Verify final state
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (13, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Original', 30, 'Original slice'),
    (13, 1, '2025-01-01'::DATE, '2026-01-01'::DATE, 'Replaced', 35, 'Finishes replace')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |   edit_comment   
----+---------------+------------+-------------+----------+-----------+------------------
 13 |             1 | 2024-01-01 | 2025-01-01  | Original |        30 | Original slice
 13 |             1 | 2025-01-01 | 2026-01-01  | Replaced |        35 | Finishes replace
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 13 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |   edit_comment   
----+---------------+------------+-------------+----------+-----------+------------------
 13 |             1 | 2024-01-01 | 2025-01-01  | Original |        30 | Original slice
 13 |             1 | 2025-01-01 | 2026-01-01  | Replaced |        35 | Finishes replace
(2 rows)

DROP TABLE temp_source_13;
--------------------------------------------------------------------------------
\echo 'Scenario 14: MERGE_ENTITY_REPLACE with during relation'
Scenario 14: MERGE_ENTITY_REPLACE with during relation
\echo 'Mode: MERGE_ENTITY_REPLACE'
Mode: MERGE_ENTITY_REPLACE
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (14, 1, '2024-01-01', '2026-01-01', 'Original', 40, 'Original slice');
-- Source data
CREATE TEMP TABLE temp_source_14 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE, valid_until DATE, name TEXT, employees INT, edit_comment TEXT ) ON COMMIT DROP;
CREATE INDEX ON temp_source_14 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_14 VALUES (114, 14, 1, '2024-07-01', '2025-01-01', 'Replaced', 45, 'During replace');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 14 |             1 | 2024-01-01 | 2026-01-01  | Original |        40 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_14 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
--------+----+---------------+------------+-------------+----------+-----------+----------------
    114 | 14 |             1 | 2024-07-01 | 2025-01-01  | Replaced |        45 | During replace
(1 row)

-- Run merge
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_14',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid'
);
-- Verify plan
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                            data                                             | feedback | trace |    grouping_key     
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+---------------------------------------------------------------------------------------------+----------+-------+---------------------
           1 |             1 | {114}   | UPDATE    | SHRINK        | 114       | f             | {"id": 14}  | {"id": 14}    | {}          | during       | started_by   | 2024-01-01     | 2026-01-01      | 2024-01-01     | 2024-07-01      | {"name": "Original", "employees": 40, "edit_comment": "Original slice", "legal_unit_id": 1} |          |       | existing_entity__14
           2 |             2 | {114}   | INSERT    |               | 114       | f             | {"id": 14}  | {"id": 14}    | {}          | during       | contains     | 2024-01-01     | 2026-01-01      | 2024-07-01     | 2025-01-01      | {"name": "Replaced", "employees": 45, "edit_comment": "During replace", "legal_unit_id": 1} |          |       | existing_entity__14
           3 |             2 | {114}   | INSERT    |               | 114       | f             | {"id": 14}  | {"id": 14}    | {}          | during       | finished_by  | 2024-01-01     | 2026-01-01      | 2025-01-01     | 2026-01-01      | {"name": "Original", "employees": 40, "edit_comment": "Original slice", "legal_unit_id": 1} |          |       | existing_entity__14
(3 rows)

-- Verify feedback
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           114 | [{"id": 14}]       | APPLIED | 
(1 row)

-- Verify final state
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (14, 1, '2024-01-01'::DATE, '2024-07-01'::DATE, 'Original', 40, 'Original slice'),
    (14, 1, '2024-07-01'::DATE, '2025-01-01'::DATE, 'Replaced', 45, 'During replace'),
    (14, 1, '2025-01-01'::DATE, '2026-01-01'::DATE, 'Original', 40, 'Original slice')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 14 |             1 | 2024-01-01 | 2024-07-01  | Original |        40 | Original slice
 14 |             1 | 2024-07-01 | 2025-01-01  | Replaced |        45 | During replace
 14 |             1 | 2025-01-01 | 2026-01-01  | Original |        40 | Original slice
(3 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 14 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 14 |             1 | 2024-01-01 | 2024-07-01  | Original |        40 | Original slice
 14 |             1 | 2024-07-01 | 2025-01-01  | Replaced |        45 | During replace
 14 |             1 | 2025-01-01 | 2026-01-01  | Original |        40 | Original slice
(3 rows)

DROP TABLE temp_source_14;
--------------------------------------------------------------------------------
\echo 'Scenario 15: MERGE_ENTITY_REPLACE with overlaps relation'
Scenario 15: MERGE_ENTITY_REPLACE with overlaps relation
\echo 'Mode: MERGE_ENTITY_REPLACE'
Mode: MERGE_ENTITY_REPLACE
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (15, 1, '2024-01-01', '2025-01-01', 'Original', 50, 'Original slice');
-- Source data
CREATE TEMP TABLE temp_source_15 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE, valid_until DATE, name TEXT, employees INT, edit_comment TEXT ) ON COMMIT DROP;
CREATE INDEX ON temp_source_15 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_15 VALUES (115, 15, 1, '2024-07-01', '2025-07-01', 'Replaced', 55, 'Overlaps replace');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 15 |             1 | 2024-01-01 | 2025-01-01  | Original |        50 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_15 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |   name   | employees |   edit_comment   
--------+----+---------------+------------+-------------+----------+-----------+------------------
    115 | 15 |             1 | 2024-07-01 | 2025-07-01  | Replaced |        55 | Overlaps replace
(1 row)

-- Run merge
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_15',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid'
);
-- Verify plan
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation  | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                             data                                              | feedback | trace |    grouping_key     
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+---------------+--------------+----------------+-----------------+----------------+-----------------+-----------------------------------------------------------------------------------------------+----------+-------+---------------------
           1 |             1 | {115}   | UPDATE    | SHRINK        | 115       | f             | {"id": 15}  | {"id": 15}    | {}          | overlapped_by | started_by   | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2024-07-01      | {"name": "Original", "employees": 50, "edit_comment": "Original slice", "legal_unit_id": 1}   |          |       | existing_entity__15
           2 |             2 | {115}   | INSERT    |               | 115       | f             | {"id": 15}  | {"id": 15}    | {}          | overlapped_by | overlaps     | 2024-01-01     | 2025-01-01      | 2024-07-01     | 2025-07-01      | {"name": "Replaced", "employees": 55, "edit_comment": "Overlaps replace", "legal_unit_id": 1} |          |       | existing_entity__15
(2 rows)

-- Verify feedback
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           115 | [{"id": 15}]       | APPLIED | 
(1 row)

-- Verify final state
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (15, 1, '2024-01-01'::DATE, '2024-07-01'::DATE, 'Original', 50, 'Original slice'),
    (15, 1, '2024-07-01'::DATE, '2025-07-01'::DATE, 'Replaced', 55, 'Overlaps replace')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |   edit_comment   
----+---------------+------------+-------------+----------+-----------+------------------
 15 |             1 | 2024-01-01 | 2024-07-01  | Original |        50 | Original slice
 15 |             1 | 2024-07-01 | 2025-07-01  | Replaced |        55 | Overlaps replace
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 15 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |   edit_comment   
----+---------------+------------+-------------+----------+-----------+------------------
 15 |             1 | 2024-01-01 | 2024-07-01  | Original |        50 | Original slice
 15 |             1 | 2024-07-01 | 2025-07-01  | Replaced |        55 | Overlaps replace
(2 rows)

DROP TABLE temp_source_15;
--------------------------------------------------------------------------------
\echo 'Scenario 16: MERGE_ENTITY_REPLACE with equals relation'
Scenario 16: MERGE_ENTITY_REPLACE with equals relation
\echo 'Mode: MERGE_ENTITY_REPLACE'
Mode: MERGE_ENTITY_REPLACE
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (16, 1, '2024-01-01', '2025-01-01', 'Original', 110, 'Original slice');
-- Source data
CREATE TEMP TABLE temp_source_16 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE, valid_until DATE, name TEXT, employees INT, edit_comment TEXT ) ON COMMIT DROP;
CREATE INDEX ON temp_source_16 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_16 VALUES (116, 16, 1, '2024-01-01', '2025-01-01', 'Replaced', 115, 'Equals replace');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 16 |             1 | 2024-01-01 | 2025-01-01  | Original |       110 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_16 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
--------+----+---------------+------------+-------------+----------+-----------+----------------
    116 | 16 |             1 | 2024-01-01 | 2025-01-01  | Replaced |       115 | Equals replace
(1 row)

-- Run merge
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_16',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid'
);
-- Verify plan
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                             data                                             | feedback | trace |    grouping_key     
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+----------------------------------------------------------------------------------------------+----------+-------+---------------------
           1 |             1 | {116}   | UPDATE    | NONE          | 116       | f             | {"id": 16}  | {"id": 16}    | {}          | equals       | equals       | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2025-01-01      | {"name": "Replaced", "employees": 115, "edit_comment": "Equals replace", "legal_unit_id": 1} |          |       | existing_entity__16
(1 row)

-- Verify feedback
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           116 | [{"id": 16}]       | APPLIED | 
(1 row)

-- Verify final state
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (16, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Replaced', 115, 'Equals replace')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 16 |             1 | 2024-01-01 | 2025-01-01  | Replaced |       115 | Equals replace
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 16 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 16 |             1 | 2024-01-01 | 2025-01-01  | Replaced |       115 | Equals replace
(1 row)

DROP TABLE temp_source_16;
\echo 'Scenario 17: `MERGE_ENTITY_REPLACE` with `equals` relation (Source NULL replaces existing value)'
Scenario 17: `MERGE_ENTITY_REPLACE` with `equals` relation (Source NULL replaces existing value)
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (17, 1, '2024-01-01', '2025-01-01', 'Old Name', 10, 'Old Comment');
CREATE TEMP TABLE temp_source_17 (
    row_id INT, id INT, legal_unit_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, edit_comment TEXT, employees INT
) ON COMMIT DROP;
INSERT INTO temp_source_17 VALUES (117, 17, 1, '2024-01-01', '2025-01-01', NULL, 'Replaced with NULL', NULL);
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees | edit_comment 
----+---------------+------------+-------------+----------+-----------+--------------
 17 |             1 | 2024-01-01 | 2025-01-01  | Old Name |        10 | Old Comment
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_17 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until | name |    edit_comment    | employees 
--------+----+---------------+------------+-------------+------+--------------------+-----------
    117 | 17 |             1 | 2024-01-01 | 2025-01-01  |      | Replaced with NULL |          
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_17',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                            data                                             | feedback | trace |    grouping_key     
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+---------------------------------------------------------------------------------------------+----------+-------+---------------------
           1 |             1 | {117}   | UPDATE    | NONE          | 117       | f             | {"id": 17}  | {"id": 17}    | {}          | equals       | equals       | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2025-01-01      | {"name": null, "employees": null, "edit_comment": "Replaced with NULL", "legal_unit_id": 1} |          |       | existing_entity__17
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           117 | [{"id": 17}]       | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (17, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, NULL::TEXT, NULL::INT, 'Replaced with NULL'::TEXT)
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until | name | employees |    edit_comment    
----+---------------+------------+-------------+------+-----------+--------------------
 17 |             1 | 2024-01-01 | 2025-01-01  |      |           | Replaced with NULL
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 17 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees |    edit_comment    
----+---------------+------------+-------------+------+-----------+--------------------
 17 |             1 | 2024-01-01 | 2025-01-01  |      |           | Replaced with NULL
(1 row)

DROP TABLE temp_source_17;
--------------------------------------------------------------------------------
\echo 'Begin Scenarios for _only modes (Filtering Behavior)'
Begin Scenarios for _only modes (Filtering Behavior)
--------------------------------------------------------------------------------
\echo 'Scenario 18: `PATCH_FOR_PORTION_OF` on non-existent entity'
Scenario 18: `PATCH_FOR_PORTION_OF` on non-existent entity
\echo 'Mode: PATCH_FOR_PORTION_OF'
Mode: PATCH_FOR_PORTION_OF
--------------------------------------------------------------------------------
-- Reset state
CALL temporal_merge_test.reset_target();
-- Source data
CREATE TEMP TABLE temp_source_18 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE, valid_until DATE, name TEXT, employees INT, edit_comment TEXT ) ON COMMIT DROP;
CREATE INDEX ON temp_source_18 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_18 VALUES (118, 18, 1, '2024-01-01', '2025-01-01', 'Should not be inserted', 10, 'Patch only comment');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_18 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |          name          | employees |    edit_comment    
--------+----+---------------+------------+-------------+------------------------+-----------+--------------------
    118 | 18 |             1 | 2024-01-01 | 2025-01-01  | Should not be inserted |        10 | Patch only comment
(1 row)

-- Run merge
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_18',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'PATCH_FOR_PORTION_OF',
    era_name => 'valid'
);
-- Verify plan
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids |   operation    | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until | data |                                                 feedback                                                 | trace |  grouping_key   
-------------+---------------+---------+----------------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+------+----------------------------------------------------------------------------------------------------------+-------+-----------------
           1 |             1 | {118}   | SKIP_NO_TARGET |               | 118       | t             | {"id": 18}  | {"id": 18}    | {}          |              |              |                |                 |                |                 |      | {"info": "Source row was correctly filtered by the mode's logic and did not result in a DML operation."} |       | new_entity__118
(1 row)

-- Verify feedback
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys |      status       | error_message 
---------------+--------------------+-------------------+---------------
           118 | [{"id": 18}]       | SKIPPED_NO_TARGET | 
(1 row)

-- Verify final state
\echo '--- Orchestrator: Expected Final State (empty) ---'
--- Orchestrator: Expected Final State (empty) ---
\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
(0 rows)

DROP TABLE temp_source_18;
--------------------------------------------------------------------------------
\echo 'Scenario 19: `REPLACE_FOR_PORTION_OF` on non-existent entity'
Scenario 19: `REPLACE_FOR_PORTION_OF` on non-existent entity
\echo 'Mode: REPLACE_FOR_PORTION_OF'
Mode: REPLACE_FOR_PORTION_OF
--------------------------------------------------------------------------------
-- Reset state
CALL temporal_merge_test.reset_target();
-- Source data
CREATE TEMP TABLE temp_source_19 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE, valid_until DATE, name TEXT, employees INT, edit_comment TEXT ) ON COMMIT DROP;
CREATE INDEX ON temp_source_19 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_19 VALUES (119, 19, 1, '2024-01-01', '2025-01-01', 'Should not be inserted', 10, 'Replace only comment');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_19 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |          name          | employees |     edit_comment     
--------+----+---------------+------------+-------------+------------------------+-----------+----------------------
    119 | 19 |             1 | 2024-01-01 | 2025-01-01  | Should not be inserted |        10 | Replace only comment
(1 row)

-- Run merge
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_19',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'REPLACE_FOR_PORTION_OF',
    era_name => 'valid'
);
-- Verify plan
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids |   operation    | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until | data |                                                 feedback                                                 | trace |  grouping_key   
-------------+---------------+---------+----------------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+------+----------------------------------------------------------------------------------------------------------+-------+-----------------
           1 |             1 | {119}   | SKIP_NO_TARGET |               | 119       | t             | {"id": 19}  | {"id": 19}    | {}          |              |              |                |                 |                |                 |      | {"info": "Source row was correctly filtered by the mode's logic and did not result in a DML operation."} |       | new_entity__119
(1 row)

-- Verify feedback
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys |      status       | error_message 
---------------+--------------------+-------------------+---------------
           119 | [{"id": 19}]       | SKIPPED_NO_TARGET | 
(1 row)

-- Verify final state
\echo '--- Orchestrator: Expected Final State (empty) ---'
--- Orchestrator: Expected Final State (empty) ---
\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
(0 rows)

DROP TABLE temp_source_19;
--------------------------------------------------------------------------------
\echo 'Begin Scenarios for NULL handling in patch mode'
Begin Scenarios for NULL handling in patch mode
--------------------------------------------------------------------------------
\echo 'Scenario 20: MERGE_ENTITY_PATCH with NULL source value (should NOT overwrite)'
Scenario 20: MERGE_ENTITY_PATCH with NULL source value (should NOT overwrite)
\echo 'Mode: MERGE_ENTITY_PATCH'
Mode: MERGE_ENTITY_PATCH
--------------------------------------------------------------------------------
-- Reset state
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (20, 1, '2024-01-01', '2025-01-01', 'Original Name', 10, 'Original Comment');
-- Source data
CREATE TEMP TABLE temp_source_20 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE, valid_until DATE, name TEXT, employees INT, edit_comment TEXT ) ON COMMIT DROP;
CREATE INDEX ON temp_source_20 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_20 VALUES (120, 20, 1, '2024-01-01', '2025-01-01', NULL, 15, 'Patch with NULL');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |     name      | employees |   edit_comment   
----+---------------+------------+-------------+---------------+-----------+------------------
 20 |             1 | 2024-01-01 | 2025-01-01  | Original Name |        10 | Original Comment
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_20 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until | name | employees |  edit_comment   
--------+----+---------------+------------+-------------+------+-----------+-----------------
    120 | 20 |             1 | 2024-01-01 | 2025-01-01  |      |        15 | Patch with NULL
(1 row)

-- Run merge
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_20',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
-- Verify plan
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                               data                                                | feedback | trace |    grouping_key     
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+---------------------------------------------------------------------------------------------------+----------+-------+---------------------
           1 |             1 | {120}   | UPDATE    | NONE          | 120       | f             | {"id": 20}  | {"id": 20}    | {}          | equals       | equals       | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2025-01-01      | {"name": "Original Name", "employees": 15, "edit_comment": "Patch with NULL", "legal_unit_id": 1} |          |       | existing_entity__20
(1 row)

-- Verify feedback
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           120 | [{"id": 20}]       | APPLIED | 
(1 row)

-- Verify final state
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (20, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Original Name', 15, 'Patch with NULL')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |     name      | employees |  edit_comment   
----+---------------+------------+-------------+---------------+-----------+-----------------
 20 |             1 | 2024-01-01 | 2025-01-01  | Original Name |        15 | Patch with NULL
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 20 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |     name      | employees |  edit_comment   
----+---------------+------------+-------------+---------------+-----------+-----------------
 20 |             1 | 2024-01-01 | 2025-01-01  | Original Name |        15 | Patch with NULL
(1 row)

DROP TABLE temp_source_20;
--------------------------------------------------------------------------------
\echo 'Scenario 21: `PATCH_FOR_PORTION_OF` with NULL source value (should NOT overwrite)'
Scenario 21: `PATCH_FOR_PORTION_OF` with NULL source value (should NOT overwrite)
\echo 'Mode: PATCH_FOR_PORTION_OF'
Mode: PATCH_FOR_PORTION_OF
--------------------------------------------------------------------------------
-- Reset state
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (21, 1, '2024-01-01', '2025-01-01', 'Original Name', 10, 'Original Comment');
-- Source data
CREATE TEMP TABLE temp_source_21 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE, valid_until DATE, name TEXT, employees INT, edit_comment TEXT ) ON COMMIT DROP;
CREATE INDEX ON temp_source_21 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_21 VALUES (121, 21, 1, '2024-01-01', '2025-01-01', NULL, 15, 'Patch with NULL');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |     name      | employees |   edit_comment   
----+---------------+------------+-------------+---------------+-----------+------------------
 21 |             1 | 2024-01-01 | 2025-01-01  | Original Name |        10 | Original Comment
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_21 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until | name | employees |  edit_comment   
--------+----+---------------+------------+-------------+------+-----------+-----------------
    121 | 21 |             1 | 2024-01-01 | 2025-01-01  |      |        15 | Patch with NULL
(1 row)

-- Run merge
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_21',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'PATCH_FOR_PORTION_OF',
    era_name => 'valid'
);
-- Verify plan
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                               data                                                | feedback | trace |    grouping_key     
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+---------------------------------------------------------------------------------------------------+----------+-------+---------------------
           1 |             1 | {121}   | UPDATE    | NONE          | 121       | f             | {"id": 21}  | {"id": 21}    | {}          | equals       | equals       | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2025-01-01      | {"name": "Original Name", "employees": 15, "edit_comment": "Patch with NULL", "legal_unit_id": 1} |          |       | existing_entity__21
(1 row)

-- Verify feedback
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           121 | [{"id": 21}]       | APPLIED | 
(1 row)

-- Verify final state
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (21, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Original Name', 15, 'Patch with NULL')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |     name      | employees |  edit_comment   
----+---------------+------------+-------------+---------------+-----------+-----------------
 21 |             1 | 2024-01-01 | 2025-01-01  | Original Name |        15 | Patch with NULL
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 21 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |     name      | employees |  edit_comment   
----+---------------+------------+-------------+---------------+-----------+-----------------
 21 |             1 | 2024-01-01 | 2025-01-01  | Original Name |        15 | Patch with NULL
(1 row)

DROP TABLE temp_source_21;
--------------------------------------------------------------------------------
\echo 'Begin Scenarios for Ephemeral Columns'
Begin Scenarios for Ephemeral Columns
--------------------------------------------------------------------------------
\echo 'Scenario 22: MERGE_ENTITY_PATCH with different ephemeral data (should be APPLIED)'
Scenario 22: MERGE_ENTITY_PATCH with different ephemeral data (should be APPLIED)
\echo 'Mode: MERGE_ENTITY_PATCH'
Mode: MERGE_ENTITY_PATCH
--------------------------------------------------------------------------------
-- Reset state
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (22, 1, '2024-01-01', '2025-01-01', 'Same', 10, 'Old Comment');
-- Source data
CREATE TEMP TABLE temp_source_22 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE, valid_until DATE, name TEXT, employees INT, edit_comment TEXT ) ON COMMIT DROP;
CREATE INDEX ON temp_source_22 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_22 VALUES (122, 22, 1, '2024-01-01', '2025-01-01', 'Same', 10, 'New Comment');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
 22 |             1 | 2024-01-01 | 2025-01-01  | Same |        10 | Old Comment
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_22 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
--------+----+---------------+------------+-------------+------+-----------+--------------
    122 | 22 |             1 | 2024-01-01 | 2025-01-01  | Same |        10 | New Comment
(1 row)

-- Run merge
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_22',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
-- Verify plan
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                         data                                         | feedback | trace |    grouping_key     
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+--------------------------------------------------------------------------------------+----------+-------+---------------------
           1 |             1 | {122}   | UPDATE    | NONE          | 122       | f             | {"id": 22}  | {"id": 22}    | {}          | equals       | equals       | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2025-01-01      | {"name": "Same", "employees": 10, "edit_comment": "New Comment", "legal_unit_id": 1} |          |       | existing_entity__22
(1 row)

-- Verify feedback
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           122 | [{"id": 22}]       | APPLIED | 
(1 row)

-- Verify final state
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (22, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Same', 10, 'New Comment')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
 22 |             1 | 2024-01-01 | 2025-01-01  | Same |        10 | New Comment
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 22 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
 22 |             1 | 2024-01-01 | 2025-01-01  | Same |        10 | New Comment
(1 row)

DROP TABLE temp_source_22;
--------------------------------------------------------------------------------
\echo 'Scenario 23: MERGE_ENTITY_PATCH with identical data including ephemeral (should be SKIPPED)'
Scenario 23: MERGE_ENTITY_PATCH with identical data including ephemeral (should be SKIPPED)
\echo 'Mode: MERGE_ENTITY_PATCH'
Mode: MERGE_ENTITY_PATCH
--------------------------------------------------------------------------------
-- Reset state
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (23, 1, '2024-01-01', '2025-01-01', 'Same', 10, 'Same Comment');
-- Source data
CREATE TEMP TABLE temp_source_23 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE, valid_until DATE, name TEXT, employees INT, edit_comment TEXT ) ON COMMIT DROP;
CREATE INDEX ON temp_source_23 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_23 VALUES (123, 23, 1, '2024-01-01', '2025-01-01', 'Same', 10, 'Same Comment');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
 23 |             1 | 2024-01-01 | 2025-01-01  | Same |        10 | Same Comment
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_23 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
--------+----+---------------+------------+-------------+------+-----------+--------------
    123 | 23 |             1 | 2024-01-01 | 2025-01-01  | Same |        10 | Same Comment
(1 row)

-- Run merge
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_23',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
-- Verify plan
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids |   operation    | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                         data                                          | feedback | trace |    grouping_key     
-------------+---------------+---------+----------------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+---------------------------------------------------------------------------------------+----------+-------+---------------------
           1 |             1 | {123}   | SKIP_IDENTICAL |               | 123       | f             | {"id": 23}  | {"id": 23}    | {}          | equals       | equals       | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2025-01-01      | {"name": "Same", "employees": 10, "edit_comment": "Same Comment", "legal_unit_id": 1} |          |       | existing_entity__23
(1 row)

-- Verify feedback
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys |      status       | error_message 
---------------+--------------------+-------------------+---------------
           123 | [{"id": 23}]       | SKIPPED_IDENTICAL | 
(1 row)

-- Verify final state
\echo '--- Orchestrator: Expected Final State (unchanged) ---'
--- Orchestrator: Expected Final State (unchanged) ---
SELECT * FROM (VALUES
    (23, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Same', 10, 'Same Comment')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
 23 |             1 | 2024-01-01 | 2025-01-01  | Same |        10 | Same Comment
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 23 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
 23 |             1 | 2024-01-01 | 2025-01-01  | Same |        10 | Same Comment
(1 row)

DROP TABLE temp_source_23;
--------------------------------------------------------------------------------
\echo 'Begin Scenarios for Multi-Row Source Data'
Begin Scenarios for Multi-Row Source Data
--------------------------------------------------------------------------------
\echo 'Scenario 24: MERGE_ENTITY_PATCH with multiple disjoint source rows'
Scenario 24: MERGE_ENTITY_PATCH with multiple disjoint source rows
\echo 'Mode: MERGE_ENTITY_PATCH'
Mode: MERGE_ENTITY_PATCH
--------------------------------------------------------------------------------
-- Reset state
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) VALUES (24, 1, '2024-01-01', '2028-01-01', 'Original', 10, 'Original slice');
-- Source data: two separate, non-contiguous patches
CREATE TEMP TABLE temp_source_24 ( row_id INT, id INT, legal_unit_id INT, valid_from DATE, valid_until DATE, name TEXT, employees INT, edit_comment TEXT ) ON COMMIT DROP;
CREATE INDEX ON temp_source_24 USING GIST (daterange(valid_from, valid_until, '[)'));
INSERT INTO temp_source_24 VALUES
(124, 24, 1, '2025-01-01', '2026-01-01', 'Patch 1', 15, 'First patch'),
(125, 24, 1, '2027-01-01', '2028-01-01', 'Patch 2', 20, 'Second patch');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 24 |             1 | 2024-01-01 | 2028-01-01  | Original |        10 | Original slice
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_24 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |  name   | employees | edit_comment 
--------+----+---------------+------------+-------------+---------+-----------+--------------
    124 | 24 |             1 | 2025-01-01 | 2026-01-01  | Patch 1 |        15 | First patch
    125 | 24 |             1 | 2027-01-01 | 2028-01-01  | Patch 2 |        20 | Second patch
(2 rows)

-- Run merge
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_24',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
-- Verify plan
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                            data                                             | feedback | trace |    grouping_key     
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+---------------------------------------------------------------------------------------------+----------+-------+---------------------
           1 |             1 | {124}   | UPDATE    | SHRINK        | 124       | f             | {"id": 24}  | {"id": 24}    | {}          | during       | started_by   | 2024-01-01     | 2028-01-01      | 2024-01-01     | 2025-01-01      | {"name": "Original", "employees": 10, "edit_comment": "Original slice", "legal_unit_id": 1} |          |       | existing_entity__24
           2 |             2 | {124}   | INSERT    |               | 124       | f             | {"id": 24}  | {"id": 24}    | {}          | during       | contains     | 2024-01-01     | 2028-01-01      | 2025-01-01     | 2026-01-01      | {"name": "Patch 1", "employees": 15, "edit_comment": "First patch", "legal_unit_id": 1}     |          |       | existing_entity__24
           3 |             2 | {124}   | INSERT    |               | 124       | f             | {"id": 24}  | {"id": 24}    | {}          | during       | contains     | 2024-01-01     | 2028-01-01      | 2026-01-01     | 2027-01-01      | {"name": "Original", "employees": 10, "edit_comment": "Original slice", "legal_unit_id": 1} |          |       | existing_entity__24
           4 |             2 | {125}   | INSERT    |               | 124       | f             | {"id": 24}  | {"id": 24}    | {}          | finishes     | finished_by  | 2024-01-01     | 2028-01-01      | 2027-01-01     | 2028-01-01      | {"name": "Patch 2", "employees": 20, "edit_comment": "Second patch", "legal_unit_id": 1}    |          |       | existing_entity__24
(4 rows)

-- Verify feedback
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           124 | [{"id": 24}]       | APPLIED | 
           125 | [{"id": 24}]       | APPLIED | 
(2 rows)

-- Verify final state
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (24, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Original', 10, 'Original slice'),
    (24, 1, '2025-01-01'::DATE, '2026-01-01'::DATE, 'Patch 1', 15, 'First patch'),
    (24, 1, '2026-01-01'::DATE, '2027-01-01'::DATE, 'Original', 10, 'Original slice'),
    (24, 1, '2027-01-01'::DATE, '2028-01-01'::DATE, 'Patch 2', 20, 'Second patch')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 24 |             1 | 2024-01-01 | 2025-01-01  | Original |        10 | Original slice
 24 |             1 | 2025-01-01 | 2026-01-01  | Patch 1  |        15 | First patch
 24 |             1 | 2026-01-01 | 2027-01-01  | Original |        10 | Original slice
 24 |             1 | 2027-01-01 | 2028-01-01  | Patch 2  |        20 | Second patch
(4 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 24 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |   name   | employees |  edit_comment  
----+---------------+------------+-------------+----------+-----------+----------------
 24 |             1 | 2024-01-01 | 2025-01-01  | Original |        10 | Original slice
 24 |             1 | 2025-01-01 | 2026-01-01  | Patch 1  |        15 | First patch
 24 |             1 | 2026-01-01 | 2027-01-01  | Original |        10 | Original slice
 24 |             1 | 2027-01-01 | 2028-01-01  | Patch 2  |        20 | Second patch
(4 rows)

DROP TABLE temp_source_24;
--------------------------------------------------------------------------------
\echo 'Scenario 35: `SAVEPOINT` test demonstrating necessity of `process_*` call ordering'
Scenario 35: `SAVEPOINT` test demonstrating necessity of `process_*` call ordering
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
CREATE TEMP TABLE temp_source_35 ( row_id INT, legal_unit_id INT, id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT, edit_comment TEXT ) ON COMMIT DROP;
CREATE INDEX ON temp_source_35 USING GIST (daterange(valid_from, valid_until, '[)'));
SAVEPOINT before_wrong_order;
\echo '--- Stage 1: Prove that `patch_only` before `MERGE_ENTITY_PATCH` is a non-operative action ---'
--- Stage 1: Prove that `patch_only` before `MERGE_ENTITY_PATCH` is a non-operative action ---
INSERT INTO temp_source_35 VALUES (301, 1, 3, '2022-01-01', '2023-01-01', 'NewCo UPDATE', 15, 'Should not be inserted');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_35 ORDER BY row_id;
 row_id | legal_unit_id | id | valid_from | valid_until |     name     | employees |      edit_comment      
--------+---------------+----+------------+-------------+--------------+-----------+------------------------
    301 |             1 |  3 | 2022-01-01 | 2023-01-01  | NewCo UPDATE |        15 | Should not be inserted
(1 row)

\echo '--- Orchestrator: Calling with `patch_only` on non-existent entity... ---'
--- Orchestrator: Calling with `patch_only` on non-existent entity... ---
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_35',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'PATCH_FOR_PORTION_OF',
    era_name => 'valid'
);
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys |      status       | error_message 
---------------+--------------------+-------------------+---------------
           301 | [{"id": 3}]        | SKIPPED_NO_TARGET | 
(1 row)

\echo '--- Orchestrator: Final state of target table (expected empty, proving data loss) ---'
--- Orchestrator: Final state of target table (expected empty, proving data loss) ---
SELECT 0 as row_count WHERE NOT EXISTS (SELECT 1 FROM temporal_merge_test.establishment WHERE id = 3);
 row_count 
-----------
         0
(1 row)

\echo '--- Orchestrator: Actual state of target table ---'
--- Orchestrator: Actual state of target table ---
SELECT count(*) as row_count FROM temporal_merge_test.establishment WHERE id = 3;
 row_count 
-----------
         0
(1 row)

ROLLBACK TO SAVEPOINT before_wrong_order;
\echo '--- Stage 2: Prove that `MERGE_ENTITY_PATCH`-then-`patch_only` succeeds ---'
--- Stage 2: Prove that `MERGE_ENTITY_PATCH`-then-`patch_only` succeeds ---
\echo '--- Orchestrator: Calling with `MERGE_ENTITY_PATCH`... ---'
--- Orchestrator: Calling with `MERGE_ENTITY_PATCH`... ---
TRUNCATE temp_source_35;
INSERT INTO temp_source_35 VALUES (301, 1, 3, '2021-01-01', '2022-01-01', 'NewCo INSERT', 10, 'Initial Insert');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_35 ORDER BY row_id;
 row_id | legal_unit_id | id | valid_from | valid_until |     name     | employees |  edit_comment  
--------+---------------+----+------------+-------------+--------------+-----------+----------------
    301 |             1 |  3 | 2021-01-01 | 2022-01-01  | NewCo INSERT |        10 | Initial Insert
(1 row)

CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_35',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           301 | [{"id": 3}]        | APPLIED | 
(1 row)

\echo '--- Orchestrator: Calling with `MERGE_ENTITY_PATCH` to extend the timeline... ---'
--- Orchestrator: Calling with `MERGE_ENTITY_PATCH` to extend the timeline... ---
TRUNCATE temp_source_35;
INSERT INTO temp_source_35 VALUES (302, 1, 3, '2022-01-01', '2023-01-01', NULL, 15, 'Successful Update');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |     name     | employees |  edit_comment  
----+---------------+------------+-------------+--------------+-----------+----------------
  3 |             1 | 2021-01-01 | 2022-01-01  | NewCo INSERT |        10 | Initial Insert
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_35 ORDER BY row_id;
 row_id | legal_unit_id | id | valid_from | valid_until | name | employees |   edit_comment    
--------+---------------+----+------------+-------------+------+-----------+-------------------
    302 |             1 |  3 | 2022-01-01 | 2023-01-01  |      |        15 | Successful Update
(1 row)

CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_35',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           302 | [{"id": 3}]        | APPLIED | 
(1 row)

\echo '--- Orchestrator: Final state of target table (expected complete history) ---'
--- Orchestrator: Final state of target table (expected complete history) ---
-- NOTE: The `name` column for the second row is now NULL. This is the correct, expected
-- behavior of the new stateless PATCH logic. It does not "carry forward" values from
-- previous time segments. The source data for this segment had a NULL name, which is
-- stripped by PATCH, resulting in a final NULL value as there is no target data to inherit from.
SELECT * FROM (VALUES
    (3, 1, '2021-01-01'::DATE, '2022-01-01'::DATE, 'NewCo INSERT'::TEXT, 10, 'Initial Insert'::TEXT),
    (3, 1, '2022-01-01'::DATE, '2023-01-01'::DATE, NULL::TEXT, 15, 'Successful Update'::TEXT)
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |     name     | employees |   edit_comment    
----+---------------+------------+-------------+--------------+-----------+-------------------
  3 |             1 | 2021-01-01 | 2022-01-01  | NewCo INSERT |        10 | Initial Insert
  3 |             1 | 2022-01-01 | 2023-01-01  |              |        15 | Successful Update
(2 rows)

\echo '--- Orchestrator: Actual state of target table ---'
--- Orchestrator: Actual state of target table ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 3 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |     name     | employees |   edit_comment    
----+---------------+------------+-------------+--------------+-----------+-------------------
  3 |             1 | 2021-01-01 | 2022-01-01  | NewCo INSERT |        10 | Initial Insert
  3 |             1 | 2022-01-01 | 2023-01-01  |              |        15 | Successful Update
(2 rows)

RELEASE SAVEPOINT before_wrong_order;
DROP TABLE temp_source_35;
\echo '--- Orchestrator: Expected Final State (after successful run) ---'
--- Orchestrator: Expected Final State (after successful run) ---
SELECT 2 AS row_count;
 row_count 
-----------
         2
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT count(*) AS row_count FROM temporal_merge_test.establishment WHERE id = 3;
 row_count 
-----------
         2
(1 row)

--------------------------------------------------------------------------------
-- Scenarios for Merging and Coalescing
--------------------------------------------------------------------------------
\echo '================================================================================'
================================================================================
\echo 'Begin Scenarios for Merging and Coalescing'
Begin Scenarios for Merging and Coalescing
\echo '================================================================================'
================================================================================
--------------------------------------------------------------------------------
\echo 'Scenario 36: `MERGE_ENTITY_PATCH` with consecutive, identical source rows (should merge into one operation)'
Scenario 36: `MERGE_ENTITY_PATCH` with consecutive, identical source rows (should merge into one operation)
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
CREATE TEMP TABLE temp_source_36 (
    row_id INT, legal_unit_id INT, id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT
) ON COMMIT DROP;
-- Two source rows, contiguous in time, with identical data.
INSERT INTO temp_source_36 VALUES
(401, 1, 4, '2023-01-02', '2023-07-01', 'Continuous Op', 20),
(402, 1, 4, '2023-07-01', '2024-01-01', 'Continuous Op', 20);
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_36 ORDER BY row_id;
 row_id | legal_unit_id | id | valid_from | valid_until |     name      | employees 
--------+---------------+----+------------+-------------+---------------+-----------
    401 |             1 |  4 | 2023-01-02 | 2023-07-01  | Continuous Op |        20
    402 |             1 |  4 | 2023-07-01 | 2024-01-01  | Continuous Op |        20
(2 rows)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_36',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq |  row_ids  | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                              data                              | feedback | trace | grouping_key  
-------------+---------------+-----------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+----------------------------------------------------------------+----------+-------+---------------
           1 |             1 | {401,402} | INSERT    |               | 401       | t             | {"id": 4}   | {"id": 4}     | {}          |              |              |                |                 | 2023-01-02     | 2024-01-01      | {"name": "Continuous Op", "employees": 20, "legal_unit_id": 1} |          |       | new_entity__4
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           401 | [{"id": 4}]        | APPLIED | 
           402 | [{"id": 4}]        | APPLIED | 
(2 rows)

\echo '--- Orchestrator: Expected Final State (A single merged row) ---'
--- Orchestrator: Expected Final State (A single merged row) ---
SELECT * FROM (VALUES
    (4, 1, '2023-01-02'::DATE, '2024-01-01'::DATE, 'Continuous Op'::TEXT, 20, NULL::TEXT)
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |     name      | employees | edit_comment 
----+---------------+------------+-------------+---------------+-----------+--------------
  4 |             1 | 2023-01-02 | 2024-01-01  | Continuous Op |        20 | 
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 4 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |     name      | employees | edit_comment 
----+---------------+------------+-------------+---------------+-----------+--------------
  4 |             1 | 2023-01-02 | 2024-01-01  | Continuous Op |        20 | 
(1 row)

DROP TABLE temp_source_36;
--------------------------------------------------------------------------------
\echo 'Scenario 37: `MERGE_ENTITY_PATCH` with three consecutive, identical source rows (should merge)'
Scenario 37: `MERGE_ENTITY_PATCH` with three consecutive, identical source rows (should merge)
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
CREATE TEMP TABLE temp_source_37 (
    row_id INT, legal_unit_id INT, id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT
) ON COMMIT DROP;
INSERT INTO temp_source_37 VALUES
(501, 1, 5, '2023-01-02', '2023-04-01', 'Three-part Op', 30),
(502, 1, 5, '2023-04-01', '2023-07-01', 'Three-part Op', 30),
(503, 1, 5, '2023-07-01', '2023-10-01', 'Three-part Op', 30);
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_37 ORDER BY row_id;
 row_id | legal_unit_id | id | valid_from | valid_until |     name      | employees 
--------+---------------+----+------------+-------------+---------------+-----------
    501 |             1 |  5 | 2023-01-02 | 2023-04-01  | Three-part Op |        30
    502 |             1 |  5 | 2023-04-01 | 2023-07-01  | Three-part Op |        30
    503 |             1 |  5 | 2023-07-01 | 2023-10-01  | Three-part Op |        30
(3 rows)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_37',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq |    row_ids    | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                              data                              | feedback | trace | grouping_key  
-------------+---------------+---------------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+----------------------------------------------------------------+----------+-------+---------------
           1 |             1 | {501,502,503} | INSERT    |               | 501       | t             | {"id": 5}   | {"id": 5}     | {}          |              |              |                |                 | 2023-01-02     | 2023-10-01      | {"name": "Three-part Op", "employees": 30, "legal_unit_id": 1} |          |       | new_entity__5
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           501 | [{"id": 5}]        | APPLIED | 
           502 | [{"id": 5}]        | APPLIED | 
           503 | [{"id": 5}]        | APPLIED | 
(3 rows)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (5, 1, '2023-01-02'::DATE, '2023-10-01'::DATE, 'Three-part Op'::TEXT, 30, NULL::TEXT)
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |     name      | employees | edit_comment 
----+---------------+------------+-------------+---------------+-----------+--------------
  5 |             1 | 2023-01-02 | 2023-10-01  | Three-part Op |        30 | 
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 5 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |     name      | employees | edit_comment 
----+---------------+------------+-------------+---------------+-----------+--------------
  5 |             1 | 2023-01-02 | 2023-10-01  | Three-part Op |        30 | 
(1 row)

DROP TABLE temp_source_37;
--------------------------------------------------------------------------------
\echo 'Scenario 38: `MERGE_ENTITY_PATCH` with two consecutive but DIFFERENT source rows (should NOT merge)'
Scenario 38: `MERGE_ENTITY_PATCH` with two consecutive but DIFFERENT source rows (should NOT merge)
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
CREATE TEMP TABLE temp_source_38 (
    row_id INT, legal_unit_id INT, id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT
) ON COMMIT DROP;
INSERT INTO temp_source_38 VALUES
(601, 1, 6, '2023-01-02', '2023-07-01', 'First Part', 40),
(602, 1, 6, '2023-07-01', '2024-01-01', 'Second Part', 50);
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_38 ORDER BY row_id;
 row_id | legal_unit_id | id | valid_from | valid_until |    name     | employees 
--------+---------------+----+------------+-------------+-------------+-----------
    601 |             1 |  6 | 2023-01-02 | 2023-07-01  | First Part  |        40
    602 |             1 |  6 | 2023-07-01 | 2024-01-01  | Second Part |        50
(2 rows)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_38',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                             data                             | feedback | trace | grouping_key  
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+--------------------------------------------------------------+----------+-------+---------------
           1 |             1 | {601}   | INSERT    |               | 601       | t             | {"id": 6}   | {"id": 6}     | {}          |              |              |                |                 | 2023-01-02     | 2023-07-01      | {"name": "First Part", "employees": 40, "legal_unit_id": 1}  |          |       | new_entity__6
           2 |             1 | {602}   | INSERT    |               | 602       | t             | {"id": 6}   | {"id": 6}     | {}          |              |              |                |                 | 2023-07-01     | 2024-01-01      | {"name": "Second Part", "employees": 50, "legal_unit_id": 1} |          |       | new_entity__6
(2 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           601 | [{"id": 6}]        | APPLIED | 
           602 | [{"id": 6}]        | APPLIED | 
(2 rows)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (6, 1, '2023-01-02'::DATE, '2023-07-01'::DATE, 'First Part'::TEXT, 40, NULL),
    (6, 1, '2023-07-01'::DATE, '2024-01-01'::DATE, 'Second Part'::TEXT, 50, NULL)
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |    name     | employees | edit_comment 
----+---------------+------------+-------------+-------------+-----------+--------------
  6 |             1 | 2023-01-02 | 2023-07-01  | First Part  |        40 | 
  6 |             1 | 2023-07-01 | 2024-01-01  | Second Part |        50 | 
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 6 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |    name     | employees | edit_comment 
----+---------------+------------+-------------+-------------+-----------+--------------
  6 |             1 | 2023-01-02 | 2023-07-01  | First Part  |        40 | 
  6 |             1 | 2023-07-01 | 2024-01-01  | Second Part |        50 | 
(2 rows)

DROP TABLE temp_source_38;
--------------------------------------------------------------------------------
\echo 'Scenario 39: `MERGE_ENTITY_PATCH` where source row is consecutive with existing target row (should merge/extend)'
Scenario 39: `MERGE_ENTITY_PATCH` where source row is consecutive with existing target row (should merge/extend)
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
INSERT INTO temporal_merge_test.establishment (id, legal_unit_id, valid_from, valid_until, name, employees) VALUES (7, 1, '2023-01-01', '2023-07-01', 'Existing Op', 60);
CREATE TEMP TABLE temp_source_39 (
    row_id INT, legal_unit_id INT, id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT
) ON COMMIT DROP;
-- This source row meets the existing target row, with identical data.
INSERT INTO temp_source_39 VALUES (701, 1, 7, '2023-07-01', '2024-01-01', 'Existing Op', 60);
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |    name     | employees | edit_comment 
----+---------------+------------+-------------+-------------+-----------+--------------
  7 |             1 | 2023-01-01 | 2023-07-01  | Existing Op |        60 | 
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_39 ORDER BY row_id;
 row_id | legal_unit_id | id | valid_from | valid_until |    name     | employees 
--------+---------------+----+------------+-------------+-------------+-----------
    701 |             1 |  7 | 2023-07-01 | 2024-01-01  | Existing Op |        60
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_39',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                             data                             | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+--------------------------------------------------------------+----------+-------+--------------------
           1 |             1 | {701}   | UPDATE    | GROW          | 701       | f             | {"id": 7}   | {"id": 7}     | {}          |              | starts       | 2023-01-01     | 2023-07-01      | 2023-01-01     | 2024-01-01      | {"name": "Existing Op", "employees": 60, "legal_unit_id": 1} |          |       | existing_entity__7
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           701 | [{"id": 7}]        | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State (A single merged row) ---'
--- Orchestrator: Expected Final State (A single merged row) ---
SELECT * FROM (VALUES
    (7, 1, '2023-01-01'::DATE, '2024-01-01'::DATE, 'Existing Op'::TEXT, 60, NULL::TEXT)
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment);
 id | legal_unit_id | valid_from | valid_until |    name     | employees | edit_comment 
----+---------------+------------+-------------+-------------+-----------+--------------
  7 |             1 | 2023-01-01 | 2024-01-01  | Existing Op |        60 | 
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment WHERE id = 7 ORDER BY valid_from;
 id | legal_unit_id | valid_from | valid_until |    name     | employees | edit_comment 
----+---------------+------------+-------------+-------------+-----------+--------------
  7 |             1 | 2023-01-01 | 2024-01-01  | Existing Op |        60 | 
(1 row)

DROP TABLE temp_source_39;
-- Final Cleanup before independent tests.
DROP PROCEDURE temporal_merge_test.reset_target();
DROP TABLE temporal_merge_test.establishment;
DROP TABLE temporal_merge_test.legal_unit;
DROP SEQUENCE temporal_merge_test.establishment_id_seq;
DROP SEQUENCE temporal_merge_test.legal_unit_id_seq;
DROP SCHEMA temporal_merge_test CASCADE;
ROLLBACK;
BEGIN;
-- Test schema
CREATE SCHEMA temporal_merge_test;
-- Sequences for auto-generated IDs
CREATE SEQUENCE temporal_merge_test.legal_unit_id_seq;
CREATE SEQUENCE temporal_merge_test.establishment_id_seq;
-- Target tables (simplified versions for testing)
CREATE TABLE temporal_merge_test.legal_unit (
    id INT PRIMARY KEY,
    name TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE TABLE temporal_merge_test.establishment (
    id INT NOT NULL,
    legal_unit_id INT NOT NULL,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    name TEXT,
    employees INT,
    edit_comment TEXT,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('temporal_merge_test.establishment', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "establishment_synchronize_temporal_columns_trigger" on table temporal_merge_test.establishment to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

CREATE INDEX ON temporal_merge_test.establishment USING GIST (valid_range);
-- Helper procedure to reset target table state between scenarios
CREATE PROCEDURE temporal_merge_test.reset_target() LANGUAGE plpgsql AS $$
BEGIN
    TRUNCATE temporal_merge_test.establishment;
    TRUNCATE temporal_merge_test.legal_unit;
    -- Seed with a legal unit for FK constraints
    INSERT INTO temporal_merge_test.legal_unit (id, name) VALUES (1, 'Test LU');
    ALTER SEQUENCE temporal_merge_test.establishment_id_seq RESTART WITH 1;
END;
$$;
-- psql variables for the test
\set target_schema 'temporal_merge_test'
\set target_table 'temporal_merge_test.establishment'
\set source_schema 'pg_temp'
\set entity_id_cols '{id}'
\set ephemeral_cols '{edit_comment}'
--------------------------------------------------------------------------------
\echo 'Scenario 40: `INSERT` with `created_at` defaulted'
Scenario 40: `INSERT` with `created_at` defaulted
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
CREATE TEMP TABLE temp_source_40 (
    row_id INT, legal_unit_id INT, id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_40 VALUES (801, 1, 40, '2024-01-01', '2025-01-01', 'Default Test', 10, 'Default Insert');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_40 ORDER BY row_id;
 row_id | legal_unit_id | id | valid_from | valid_until |     name     | employees |  edit_comment  
--------+---------------+----+------------+-------------+--------------+-----------+----------------
    801 |             1 | 40 | 2024-01-01 | 2025-01-01  | Default Test |        10 | Default Insert
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_40',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                              data                                               | feedback | trace |  grouping_key  
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------------------------------------------------------------------------------+----------+-------+----------------
           1 |             1 | {801}   | INSERT    |               | 801       | t             | {"id": 40}  | {"id": 40}    | {}          |              |              |                |                 | 2024-01-01     | 2025-01-01      | {"name": "Default Test", "employees": 10, "edit_comment": "Default Insert", "legal_unit_id": 1} |          |       | new_entity__40
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           801 | [{"id": 40}]       | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State (created_at should NOT be null) ---'
--- Orchestrator: Expected Final State (created_at should NOT be null) ---
-- We only check that created_at is not null, as the exact time is non-deterministic.
SELECT 1 AS row_count WHERE EXISTS (SELECT 1 FROM temporal_merge_test.establishment WHERE id = 40 AND created_at IS NOT NULL);
 row_count 
-----------
         1
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT count(*)::INT AS row_count FROM temporal_merge_test.establishment WHERE id = 40 AND created_at IS NOT NULL;
 row_count 
-----------
         1
(1 row)

DROP TABLE temp_source_40;
-- Final Cleanup
DROP PROCEDURE temporal_merge_test.reset_target();
DROP TABLE temporal_merge_test.establishment;
DROP TABLE temporal_merge_test.legal_unit;
DROP SEQUENCE temporal_merge_test.establishment_id_seq;
DROP SEQUENCE temporal_merge_test.legal_unit_id_seq;
DROP SCHEMA temporal_merge_test CASCADE;
ROLLBACK;
BEGIN;
CREATE SCHEMA temporal_merge_test_vt;
-- Target table with valid_to and a trigger to sync valid_until
CREATE TABLE temporal_merge_test_vt.test_target (
    id INT NOT NULL,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_to DATE, -- Inclusive end date
    valid_until DATE NOT NULL,
    name TEXT,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('temporal_merge_test_vt.test_target', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
NOTICE:  sql_saga: Created trigger "test_target_synchronize_temporal_columns_trigger" on table temporal_merge_test_vt.test_target to synchronize columns: valid_to, valid_from, valid_until
 add_era 
---------
 t
(1 row)

CREATE INDEX ON temporal_merge_test_vt.test_target USING GIST (valid_range);
-- Helper procedure
CREATE PROCEDURE temporal_merge_test_vt.reset_target() LANGUAGE plpgsql AS $$
BEGIN
    TRUNCATE temporal_merge_test_vt.test_target;
END;
$$;
-- psql variables
\set target_schema 'temporal_merge_test_vt'
\set target_table 'temporal_merge_test_vt.test_target'
\set source_schema 'pg_temp'
\set entity_id_cols '{id}'
\set ephemeral_cols '{}'
--------------------------------------------------------------------------------
\echo 'Scenario 41: `MERGE_ENTITY_PATCH` on a table using `synchronize_valid_to_until` trigger'
Scenario 41: `MERGE_ENTITY_PATCH` on a table using `synchronize_valid_to_until` trigger
--------------------------------------------------------------------------------
CALL temporal_merge_test_vt.reset_target();
-- Initial data in target. `valid_until` is set by the trigger.
INSERT INTO temporal_merge_test_vt.test_target (id, valid_from, valid_to, name) VALUES (1, '2024-01-01', '2025-12-31', 'Original');
CREATE TEMP TABLE temp_source_41 (
    row_id INT, id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, valid_to DATE, name TEXT
) ON COMMIT DROP;
-- Source data for the merge. valid_until must be provided to the planner.
INSERT INTO temp_source_41 VALUES (901, 1, '2024-01-01', '2025-01-01', '2024-12-31', 'Patched');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, valid_from, valid_to, valid_until, name FROM temporal_merge_test_vt.test_target ORDER BY id, valid_from;
 id | valid_from |  valid_to  | valid_until |   name   
----+------------+------------+-------------+----------
  1 | 2024-01-01 | 2025-12-31 | 2026-01-01  | Original
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_41 ORDER BY row_id;
 row_id | id | valid_from | valid_until |  valid_to  |  name   
--------+----+------------+-------------+------------+---------
    901 |  1 | 2024-01-01 | 2025-01-01  | 2024-12-31 | Patched
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_41',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                      data                      | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+------------------------------------------------+----------+-------+--------------------
           1 |             1 | {901}   | UPDATE    | SHRINK        | 901       | f             | {"id": 1}   | {"id": 1}     | {}          | starts       | started_by   | 2024-01-01     | 2026-01-01      | 2024-01-01     | 2025-01-01      | {"name": "Patched", "valid_to": "2024-12-31"}  |          |       | existing_entity__1
           2 |             2 | {901}   | INSERT    |               | 901       | f             | {"id": 1}   | {"id": 1}     | {}          | starts       | finished_by  | 2024-01-01     | 2026-01-01      | 2025-01-01     | 2026-01-01      | {"name": "Original", "valid_to": "2025-12-31"} |          |       | existing_entity__1
(2 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           901 | [{"id": 1}]        | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State (valid_until should be correct for both segments) ---'
--- Orchestrator: Expected Final State (valid_until should be correct for both segments) ---
SELECT * FROM (VALUES
    (1, '2024-01-01'::DATE, '2024-12-31'::DATE, '2025-01-01'::DATE, 'Patched'),
    (1, '2025-01-01'::DATE, '2025-12-31'::DATE, '2026-01-01'::DATE, 'Original')
) AS t (id, valid_from, valid_to, valid_until, name);
 id | valid_from |  valid_to  | valid_until |   name   
----+------------+------------+-------------+----------
  1 | 2024-01-01 | 2024-12-31 | 2025-01-01  | Patched
  1 | 2025-01-01 | 2025-12-31 | 2026-01-01  | Original
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, valid_from, valid_to, valid_until, name FROM temporal_merge_test_vt.test_target WHERE id = 1 ORDER BY valid_from;
 id | valid_from |  valid_to  | valid_until |   name   
----+------------+------------+-------------+----------
  1 | 2024-01-01 | 2024-12-31 | 2025-01-01  | Patched
  1 | 2025-01-01 | 2025-12-31 | 2026-01-01  | Original
(2 rows)

DROP TABLE temp_source_41;
-- Final Cleanup
DROP PROCEDURE temporal_merge_test_vt.reset_target();
DROP TABLE temporal_merge_test_vt.test_target;
DROP SCHEMA temporal_merge_test_vt CASCADE;
ROLLBACK;
BEGIN;
-- Test schema for multi-entity batch test
CREATE SCHEMA temporal_merge_test_me;
-- Target table
CREATE TABLE temporal_merge_test_me.test_target (
    id INT NOT NULL,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    status TEXT,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('temporal_merge_test_me.test_target', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "test_target_synchronize_temporal_columns_trigger" on table temporal_merge_test_me.test_target to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

CREATE INDEX ON temporal_merge_test_me.test_target USING GIST (valid_range);
-- Helper procedure
CREATE PROCEDURE temporal_merge_test_me.reset_target() LANGUAGE plpgsql AS $$
BEGIN
    TRUNCATE temporal_merge_test_me.test_target;
END;
$$;
-- psql variables
\set target_schema 'temporal_merge_test_me'
\set target_table 'temporal_merge_test_me.test_target'
\set source_schema 'pg_temp'
\set entity_id_cols '{id}'
\set ephemeral_cols '{}'
--------------------------------------------------------------------------------
\echo 'Scenario 42: Multi-entity batch with status change (Bug Reproduction for #106)'
Scenario 42: Multi-entity batch with status change (Bug Reproduction for #106)
--------------------------------------------------------------------------------
CREATE TEMP TABLE temp_source_42 (
    row_id INT, id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, status TEXT
) ON COMMIT DROP;
-- Entity 1 ("Oslo"): single continuous record
INSERT INTO temp_source_42 VALUES (101, 1, '2010-01-01', 'infinity', 'active');
-- Entity 2 ("Omegn"): contiguous records with a status change
INSERT INTO temp_source_42 VALUES (102, 2, '2010-01-01', '2011-01-01', 'active');
INSERT INTO temp_source_42 VALUES (103, 2, '2011-01-01', 'infinity', 'passive');
-- Run the orchestrator and store its feedback
CALL temporal_merge_test_me.reset_target();
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, valid_from, valid_until, status FROM temporal_merge_test_me.test_target ORDER BY id, valid_from;
 id | valid_from | valid_until | status 
----+------------+-------------+--------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_42 ORDER BY row_id;
 row_id | id | valid_from | valid_until | status  
--------+----+------------+-------------+---------
    101 |  1 | 2010-01-01 | infinity    | active
    102 |  2 | 2010-01-01 | 2011-01-01  | active
    103 |  2 | 2011-01-01 | infinity    | passive
(3 rows)

CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_42',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY (entity_keys->>'id')::INT, new_valid_from;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |         data          | feedback | trace | grouping_key  
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-----------------------+----------+-------+---------------
           1 |             1 | {101}   | INSERT    |               | 101       | t             | {"id": 1}   | {"id": 1}     | {}          |              |              |                |                 | 2010-01-01     | infinity        | {"status": "active"}  |          |       | new_entity__1
           2 |             1 | {102}   | INSERT    |               | 102       | t             | {"id": 2}   | {"id": 2}     | {}          |              |              |                |                 | 2010-01-01     | 2011-01-01      | {"status": "active"}  |          |       | new_entity__2
           3 |             1 | {103}   | INSERT    |               | 103       | t             | {"id": 2}   | {"id": 2}     | {}          |              |              |                |                 | 2011-01-01     | infinity        | {"status": "passive"} |          |       | new_entity__2
(3 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           101 | [{"id": 1}]        | APPLIED | 
           102 | [{"id": 2}]        | APPLIED | 
           103 | [{"id": 2}]        | APPLIED | 
(3 rows)

\echo '--- Orchestrator: Expected Final State (Entity 1 should NOT be split) ---'
--- Orchestrator: Expected Final State (Entity 1 should NOT be split) ---
SELECT * FROM (VALUES
    (1, '2010-01-01'::DATE, 'infinity'::DATE, 'active'),
    (2, '2010-01-01'::DATE, '2011-01-01'::DATE, 'active'),
    (2, '2011-01-01'::DATE, 'infinity'::DATE, 'passive')
) AS t (id, valid_from, valid_until, status) ORDER BY id, valid_from;
 id | valid_from | valid_until | status  
----+------------+-------------+---------
  1 | 2010-01-01 | infinity    | active
  2 | 2010-01-01 | 2011-01-01  | active
  2 | 2011-01-01 | infinity    | passive
(3 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, valid_from, valid_until, status FROM temporal_merge_test_me.test_target ORDER BY id, valid_from;
 id | valid_from | valid_until | status  
----+------------+-------------+---------
  1 | 2010-01-01 | infinity    | active
  2 | 2010-01-01 | 2011-01-01  | active
  2 | 2011-01-01 | infinity    | passive
(3 rows)

DROP TABLE temp_source_42;
DROP PROCEDURE temporal_merge_test_me.reset_target();
DROP TABLE temporal_merge_test_me.test_target;
DROP SCHEMA temporal_merge_test_me CASCADE;
ROLLBACK;
BEGIN;
-- Test schema
CREATE SCHEMA temporal_merge_test;
-- Sequences for auto-generated IDs
CREATE SEQUENCE temporal_merge_test.legal_unit_id_seq;
CREATE SEQUENCE temporal_merge_test.establishment_id_seq;
-- Target tables (simplified versions for testing)
CREATE TABLE temporal_merge_test.legal_unit (
    id INT PRIMARY KEY,
    name TEXT
);
CREATE TABLE temporal_merge_test.establishment (
    id INT NOT NULL,
    legal_unit_id INT NOT NULL,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    name TEXT,
    employees INT,
    edit_comment TEXT,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('temporal_merge_test.establishment', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "establishment_synchronize_temporal_columns_trigger" on table temporal_merge_test.establishment to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

CREATE INDEX ON temporal_merge_test.establishment USING GIST (valid_range);
-- Helper procedure to reset target table state between scenarios
CREATE PROCEDURE temporal_merge_test.reset_target() LANGUAGE plpgsql AS $$
BEGIN
    TRUNCATE temporal_merge_test.establishment;
    TRUNCATE temporal_merge_test.legal_unit;
    -- Seed with a legal unit for FK constraints
    INSERT INTO temporal_merge_test.legal_unit (id, name) VALUES (1, 'Test LU');
    ALTER SEQUENCE temporal_merge_test.establishment_id_seq RESTART WITH 1;
END;
$$;
-- psql variables for the test
\set target_schema 'temporal_merge_test'
\set target_table 'temporal_merge_test.establishment'
\set source_schema 'pg_temp'
\set entity_id_cols '{id}'
\set ephemeral_cols '{edit_comment}'
--------------------------------------------------------------------------------
\echo 'Scenario 43: Multi-entity batch with data change (Realistic reproduction of #106)'
Scenario 43: Multi-entity batch with data change (Realistic reproduction of #106)
--------------------------------------------------------------------------------
CALL temporal_merge_test.reset_target();
CREATE TEMP TABLE temp_source_43 (
    row_id INT, id INT, legal_unit_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, employees INT, edit_comment TEXT
) ON COMMIT DROP;
-- Entity 10 ("Continuous"): single continuous record
INSERT INTO temp_source_43 VALUES (1001, 10, 1, '2010-01-01', 'infinity', 'Continuous', 50, 'comment');
-- Entity 20 ("Changes"): contiguous records with a data change
INSERT INTO temp_source_43 VALUES (1002, 20, 1, '2010-01-01', '2011-01-01', 'Changes', 100, 'comment');
INSERT INTO temp_source_43 VALUES (1003, 20, 1, '2011-01-01', 'infinity',   'Changes', 150, 'comment');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until | name | employees | edit_comment 
----+---------------+------------+-------------+------+-----------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_43 ORDER BY row_id;
 row_id | id | legal_unit_id | valid_from | valid_until |    name    | employees | edit_comment 
--------+----+---------------+------------+-------------+------------+-----------+--------------
   1001 | 10 |             1 | 2010-01-01 | infinity    | Continuous |        50 | comment
   1002 | 20 |             1 | 2010-01-01 | 2011-01-01  | Changes    |       100 | comment
   1003 | 20 |             1 | 2011-01-01 | infinity    | Changes    |       150 | comment
(3 rows)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_43',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid'
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY (entity_keys->>'id')::INT, new_valid_from;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                          data                                          | feedback | trace |  grouping_key  
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+----------------------------------------------------------------------------------------+----------+-------+----------------
           1 |             1 | {1001}  | INSERT    |               | 1001      | t             | {"id": 10}  | {"id": 10}    | {}          |              |              |                |                 | 2010-01-01     | infinity        | {"name": "Continuous", "employees": 50, "edit_comment": "comment", "legal_unit_id": 1} |          |       | new_entity__10
           2 |             1 | {1002}  | INSERT    |               | 1002      | t             | {"id": 20}  | {"id": 20}    | {}          |              |              |                |                 | 2010-01-01     | 2011-01-01      | {"name": "Changes", "employees": 100, "edit_comment": "comment", "legal_unit_id": 1}   |          |       | new_entity__20
           3 |             1 | {1003}  | INSERT    |               | 1003      | t             | {"id": 20}  | {"id": 20}    | {}          |              |              |                |                 | 2011-01-01     | infinity        | {"name": "Changes", "employees": 150, "edit_comment": "comment", "legal_unit_id": 1}   |          |       | new_entity__20
(3 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
          1001 | [{"id": 10}]       | APPLIED | 
          1002 | [{"id": 20}]       | APPLIED | 
          1003 | [{"id": 20}]       | APPLIED | 
(3 rows)

\echo '--- Orchestrator: Expected Final State (Entity 10 should NOT be split) ---'
--- Orchestrator: Expected Final State (Entity 10 should NOT be split) ---
SELECT * FROM (VALUES
    (10, 1, '2010-01-01'::DATE, 'infinity'::DATE,   'Continuous', 50, 'comment'),
    (20, 1, '2010-01-01'::DATE, '2011-01-01'::DATE, 'Changes',    100, 'comment'),
    (20, 1, '2011-01-01'::DATE, 'infinity'::DATE,   'Changes',    150, 'comment')
) AS t (id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment) ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |    name    | employees | edit_comment 
----+---------------+------------+-------------+------------+-----------+--------------
 10 |             1 | 2010-01-01 | infinity    | Continuous |        50 | comment
 20 |             1 | 2010-01-01 | 2011-01-01  | Changes    |       100 | comment
 20 |             1 | 2011-01-01 | infinity    | Changes    |       150 | comment
(3 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, legal_unit_id, valid_from, valid_until, name, employees, edit_comment FROM temporal_merge_test.establishment ORDER BY id, valid_from;
 id | legal_unit_id | valid_from | valid_until |    name    | employees | edit_comment 
----+---------------+------------+-------------+------------+-----------+--------------
 10 |             1 | 2010-01-01 | infinity    | Continuous |        50 | comment
 20 |             1 | 2010-01-01 | 2011-01-01  | Changes    |       100 | comment
 20 |             1 | 2011-01-01 | infinity    | Changes    |       150 | comment
(3 rows)

DROP TABLE temp_source_43;
-- Final Cleanup
DROP PROCEDURE temporal_merge_test.reset_target();
DROP TABLE temporal_merge_test.establishment;
DROP TABLE temporal_merge_test.legal_unit;
DROP SEQUENCE temporal_merge_test.establishment_id_seq;
DROP SEQUENCE temporal_merge_test.legal_unit_id_seq;
DROP SCHEMA temporal_merge_test CASCADE;
ROLLBACK;
BEGIN;
-- Test schema
CREATE SCHEMA temporal_merge_test_serial;
-- Target table with SERIAL surrogate key
CREATE TABLE temporal_merge_test_serial.test_target (
    id SERIAL NOT NULL,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    name TEXT,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('temporal_merge_test_serial.test_target', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "test_target_synchronize_temporal_columns_trigger" on table temporal_merge_test_serial.test_target to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

CREATE INDEX ON temporal_merge_test_serial.test_target USING GIST (valid_range);
-- psql variables for the test
\set target_schema 'temporal_merge_test_serial'
\set target_table 'temporal_merge_test_serial.test_target'
\set source_schema 'pg_temp'
\set entity_id_cols '{id}'
\set ephemeral_cols '{}'
--------------------------------------------------------------------------------
\echo 'Scenario 44: `INSERT` with SERIAL surrogate key should return the generated ID'
Scenario 44: `INSERT` with SERIAL surrogate key should return the generated ID
--------------------------------------------------------------------------------
CREATE TEMP TABLE temp_source_44 (
    row_id INT, id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT
) ON COMMIT DROP;
-- ID is NULL, to be generated by the database
INSERT INTO temp_source_44 VALUES (1001, NULL, '2024-01-01', '2025-01-01', 'Serial Widget');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, valid_from, valid_until, name FROM temporal_merge_test_serial.test_target ORDER BY id, valid_from;
 id | valid_from | valid_until | name 
----+------------+-------------+------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_44 ORDER BY row_id;
 row_id | id | valid_from | valid_until |     name      
--------+----+------------+-------------+---------------
   1001 |    | 2024-01-01 | 2025-01-01  | Serial Widget
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_44',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |           data            | feedback | trace |   grouping_key   
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+---------------------------+----------+-------+------------------
           1 |             1 | {1001}  | INSERT    |               | 1001      | t             | {"id": 1}   | {"id": null}  | {}          |              |              |                |                 | 2024-01-01     | 2025-01-01      | {"name": "Serial Widget"} |          |       | new_entity__1001
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
          1001 | [{"id": 1}]        | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Serial Widget'::TEXT)
) AS t (id, valid_from, valid_until, name);
 id | valid_from | valid_until |     name      
----+------------+-------------+---------------
  1 | 2024-01-01 | 2025-01-01  | Serial Widget
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, valid_from, valid_until, name FROM temporal_merge_test_serial.test_target WHERE id = 1 ORDER BY valid_from;
 id | valid_from | valid_until |     name      
----+------------+-------------+---------------
  1 | 2024-01-01 | 2025-01-01  | Serial Widget
(1 row)

\echo '--- Source Table: Expected state after back-fill ---'
--- Source Table: Expected state after back-fill ---
SELECT * FROM (VALUES (1001, 1, '2024-01-01'::DATE, '2025-01-01'::DATE, 'Serial Widget')) t(row_id, id, valid_from, valid_until, name);
 row_id | id | valid_from | valid_until |     name      
--------+----+------------+-------------+---------------
   1001 |  1 | 2024-01-01 | 2025-01-01  | Serial Widget
(1 row)

\echo '--- Source Table: Actual state after back-fill ---'
--- Source Table: Actual state after back-fill ---
SELECT row_id, id, valid_from, valid_until, name FROM temp_source_44 ORDER BY row_id;
 row_id | id | valid_from | valid_until |     name      
--------+----+------------+-------------+---------------
   1001 |  1 | 2024-01-01 | 2025-01-01  | Serial Widget
(1 row)

DROP TABLE temp_source_44;
-- Final Cleanup
DROP TABLE temporal_merge_test_serial.test_target;
DROP SCHEMA temporal_merge_test_serial CASCADE;
ROLLBACK;
BEGIN;
-- Use the same schema as Scenario 44 for simplicity
CREATE SCHEMA temporal_merge_test_multi_insert;
CREATE TABLE temporal_merge_test_multi_insert.test_target (
    id SERIAL NOT NULL,
    name TEXT,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('temporal_merge_test_multi_insert.test_target', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "test_target_synchronize_temporal_columns_trigger" on table temporal_merge_test_multi_insert.test_target to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

CREATE INDEX ON temporal_merge_test_multi_insert.test_target USING GIST (valid_range);
\set target_schema 'temporal_merge_test_multi_insert'
\set target_table 'temporal_merge_test_multi_insert.test_target'
\set source_schema 'pg_temp'
\set entity_id_cols '{id}'
--------------------------------------------------------------------------------
\echo 'Scenario 45: Batch INSERT of multiple new entities'
Scenario 45: Batch INSERT of multiple new entities
--------------------------------------------------------------------------------
CREATE TEMP TABLE temp_source_45 (
    row_id INT, id INT, name TEXT, valid_from DATE NOT NULL, valid_until DATE NOT NULL
) ON COMMIT DROP;
-- Source contains two distinct new entities
INSERT INTO temp_source_45 VALUES
(2001, NULL, 'Entity One', '2024-01-01', '2025-01-01'),
(2002, NULL, 'Entity Two', '2024-01-01', '2025-01-01');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, name, valid_from, valid_until FROM temporal_merge_test_multi_insert.test_target ORDER BY id;
 id | name | valid_from | valid_until 
----+------+------------+-------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_45 ORDER BY row_id;
 row_id | id |    name    | valid_from | valid_until 
--------+----+------------+------------+-------------
   2001 |    | Entity One | 2024-01-01 | 2025-01-01
   2002 |    | Entity Two | 2024-01-01 | 2025-01-01
(2 rows)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => :'target_table'::regclass,
    source_table => 'temp_source_45',
    primary_identity_columns => :'entity_id_cols'::TEXT[],
    ephemeral_columns => '{}'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |          data          | feedback | trace |   grouping_key   
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+------------------------+----------+-------+------------------
           1 |             1 | {2001}  | INSERT    |               | 2001      | t             | {"id": 1}   | {"id": null}  | {}          |              |              |                |                 | 2024-01-01     | 2025-01-01      | {"name": "Entity One"} |          |       | new_entity__2001
           2 |             1 | {2002}  | INSERT    |               | 2002      | t             | {"id": 2}   | {"id": null}  | {}          |              |              |                |                 | 2024-01-01     | 2025-01-01      | {"name": "Entity Two"} |          |       | new_entity__2002
(2 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
          2001 | [{"id": 1}]        | APPLIED | 
          2002 | [{"id": 2}]        | APPLIED | 
(2 rows)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, 'Entity One', '2024-01-01'::DATE, '2025-01-01'::DATE),
    (2, 'Entity Two', '2024-01-01'::DATE, '2025-01-01'::DATE)
) AS t (id, name, valid_from, valid_until);
 id |    name    | valid_from | valid_until 
----+------------+------------+-------------
  1 | Entity One | 2024-01-01 | 2025-01-01
  2 | Entity Two | 2024-01-01 | 2025-01-01
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, name, valid_from, valid_until FROM temporal_merge_test_multi_insert.test_target ORDER BY id;
 id |    name    | valid_from | valid_until 
----+------------+------------+-------------
  1 | Entity One | 2024-01-01 | 2025-01-01
  2 | Entity Two | 2024-01-01 | 2025-01-01
(2 rows)

\echo '--- Source Table: Expected state after back-fill ---'
--- Source Table: Expected state after back-fill ---
SELECT * FROM (VALUES
    (2001, 1, 'Entity One', '2024-01-01'::DATE, '2025-01-01'::DATE),
    (2002, 2, 'Entity Two', '2024-01-01'::DATE, '2025-01-01'::DATE)
) t(row_id, id, name, valid_from, valid_until) ORDER BY row_id;
 row_id | id |    name    | valid_from | valid_until 
--------+----+------------+------------+-------------
   2001 |  1 | Entity One | 2024-01-01 | 2025-01-01
   2002 |  2 | Entity Two | 2024-01-01 | 2025-01-01
(2 rows)

\echo '--- Source Table: Actual state after back-fill ---'
--- Source Table: Actual state after back-fill ---
SELECT * FROM temp_source_45 ORDER BY row_id;
 row_id | id |    name    | valid_from | valid_until 
--------+----+------------+------------+-------------
   2001 |  1 | Entity One | 2024-01-01 | 2025-01-01
   2002 |  2 | Entity Two | 2024-01-01 | 2025-01-01
(2 rows)

DROP TABLE temp_source_45;
--------------------------------------------------------------------------------
\echo 'Scenario 46: `MERGE_ENTITY_PATCH` correctly carries over NOT NULL columns when splitting'
Scenario 46: `MERGE_ENTITY_PATCH` correctly carries over NOT NULL columns when splitting
--------------------------------------------------------------------------------
-- This test is a variant of the bug found in `PATCH_FOR_PORTION_OF`.
-- It ensures that `MERGE_ENTITY_PATCH` also correctly inherits values for
-- columns that are NOT NULL on the target but absent from the source when
-- a new historical slice is created.
SAVEPOINT s46;
-- Setup a simple temporal table with a NOT NULL column in a separate schema
CREATE SCHEMA tm_44_not_null_test;
CREATE TABLE tm_44_not_null_test.test_unit (
    id int,
    name text NOT NULL,
    value int,
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('tm_44_not_null_test.test_unit', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "test_unit_synchronize_temporal_columns_trigger" on table tm_44_not_null_test.test_unit to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

CREATE INDEX ON tm_44_not_null_test.test_unit USING GIST (valid_range);
SELECT sql_saga.add_unique_key('tm_44_not_null_test.test_unit'::regclass, ARRAY['id']);
NOTICE:  sql_saga: altering table tm_44_not_null_test.test_unit to add constraints: ADD CONSTRAINT test_unit_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
   add_unique_key   
--------------------
 test_unit_id_valid
(1 row)

-- Insert an initial record
INSERT INTO tm_44_not_null_test.test_unit (id, name, value, valid_from, valid_until)
VALUES (1, 'Initial Name', 100, '2024-01-01', 'infinity');
-- Create a source table for the patch. It's missing the `name` column.
CREATE TEMP TABLE source_46 (
    row_id int generated by default as identity,
    id int,
    value int,
    valid_from date,
    valid_until date
) ON COMMIT DROP;
INSERT INTO source_46 (id, value, valid_from, valid_until) VALUES (1, 200, '2024-06-01', 'infinity');
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
TABLE tm_44_not_null_test.test_unit;
 id |     name     | value |      valid_range      | valid_from | valid_until 
----+--------------+-------+-----------------------+------------+-------------
  1 | Initial Name |   100 | [2024-01-01,infinity) | 2024-01-01 | infinity
(1 row)

\echo '--- Source: Data to merge (missing "name" column) ---'
--- Source: Data to merge (missing "name" column) ---
TABLE source_46;
 row_id | id | value | valid_from | valid_until 
--------+----+-------+------------+-------------
      1 |  1 |   200 | 2024-06-01 | infinity
(1 row)

CALL sql_saga.temporal_merge(
  target_table => 'tm_44_not_null_test.test_unit'::regclass,
  source_table => 'source_46'::regclass,
  primary_identity_columns => ARRAY['id'],
  ephemeral_columns => ARRAY[]::TEXT[],
  mode => 'MERGE_ENTITY_PATCH'::sql_saga.temporal_merge_mode,
  row_id_column => 'row_id'
);
\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                  data                  | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+----------------------------------------+----------+-------+--------------------
           1 |             1 | {1}     | UPDATE    | SHRINK        | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | finishes     | started_by   | 2024-01-01     | infinity        | 2024-01-01     | 2024-06-01      | {"name": "Initial Name", "value": 100} |          |       | existing_entity__1
           2 |             2 | {1}     | INSERT    |               | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | finishes     | finished_by  | 2024-01-01     | infinity        | 2024-06-01     | infinity        | {"name": "Initial Name", "value": 200} |          |       | existing_entity__1
(2 rows)

\echo '--- Executor: Actual Feedback ---'
--- Executor: Actual Feedback ---
TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
             1 | [{"id": 1}]        | APPLIED | 
(1 row)

\echo '--- Target: Expected Final State ---'
--- Target: Expected Final State ---
SELECT * FROM (VALUES
    (1, 'Initial Name', 100, '2024-01-01'::date, '2024-06-01'::date),
    (1, 'Initial Name', 200, '2024-06-01'::date, 'infinity'::date)
) AS v(id, name, value, valid_from, valid_until) ORDER BY id, valid_from;
 id |     name     | value | valid_from | valid_until 
----+--------------+-------+------------+-------------
  1 | Initial Name |   100 | 2024-01-01 | 2024-06-01
  1 | Initial Name |   200 | 2024-06-01 | infinity
(2 rows)

\echo '--- Target: Final State ---'
--- Target: Final State ---
TABLE tm_44_not_null_test.test_unit ORDER BY id, valid_from;
 id |     name     | value |       valid_range       | valid_from | valid_until 
----+--------------+-------+-------------------------+------------+-------------
  1 | Initial Name |   100 | [2024-01-01,2024-06-01) | 2024-01-01 | 2024-06-01
  1 | Initial Name |   200 | [2024-06-01,infinity)   | 2024-06-01 | infinity
(2 rows)

ROLLBACK TO SAVEPOINT s46;
--------------------------------------------------------------------------------
\echo 'Scenario 47: `PATCH_FOR_PORTION_OF` performs a surgical update on an existing slice'
Scenario 47: `PATCH_FOR_PORTION_OF` performs a surgical update on an existing slice
--------------------------------------------------------------------------------
-- This test validates the corrected "clipping" behavior of PATCH_FOR_PORTION_OF.
-- The source data only partially overlaps with the target, and it only contains
-- a value for `employees`. The expected outcome is that the target is split
-- into three pieces, with the `name` correctly inherited from the original
-- target data for the patched segment.
SAVEPOINT s47;
-- Setup a simple temporal table
CREATE SCHEMA tm_47_surgical_patch;
CREATE TABLE tm_47_surgical_patch.test_target (
    id int,
    name text,
    employees int,
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('tm_47_surgical_patch.test_target', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "test_target_synchronize_temporal_columns_trigger" on table tm_47_surgical_patch.test_target to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

CREATE INDEX ON tm_47_surgical_patch.test_target USING GIST (valid_range);
SELECT sql_saga.add_unique_key('tm_47_surgical_patch.test_target'::regclass, ARRAY['id']);
NOTICE:  sql_saga: altering table tm_47_surgical_patch.test_target to add constraints: ADD CONSTRAINT test_target_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
    add_unique_key    
----------------------
 test_target_id_valid
(1 row)

-- Insert an initial record
INSERT INTO tm_47_surgical_patch.test_target (id, name, employees, valid_from, valid_until)
VALUES (1, 'Surgical Inc.', 10, '2024-01-01', '2025-01-01');
-- Create a source table for the patch. It contains an explicit NULL for `name`.
CREATE TEMP TABLE source_47 (
    row_id int,
    id int,
    name text,
    employees int,
    valid_from date,
    valid_until date
) ON COMMIT DROP;
INSERT INTO source_47 (row_id, id, name, employees, valid_from, valid_until) VALUES (1, 1, NULL, 15, '2024-06-01', '2024-09-01');
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
TABLE tm_47_surgical_patch.test_target;
 id |     name      | employees |       valid_range       | valid_from | valid_until 
----+---------------+-----------+-------------------------+------------+-------------
  1 | Surgical Inc. |        10 | [2024-01-01,2025-01-01) | 2024-01-01 | 2025-01-01
(1 row)

\echo '--- Source: Data to merge (only updates employees for a portion of time) ---'
--- Source: Data to merge (only updates employees for a portion of time) ---
TABLE source_47;
 row_id | id | name | employees | valid_from | valid_until 
--------+----+------+-----------+------------+-------------
      1 |  1 |      |        15 | 2024-06-01 | 2024-09-01
(1 row)

CALL sql_saga.temporal_merge(
  target_table => 'tm_47_surgical_patch.test_target'::regclass,
  source_table => 'source_47'::regclass,
  primary_identity_columns => ARRAY['id'],
  mode => 'PATCH_FOR_PORTION_OF'::sql_saga.temporal_merge_mode,
  row_id_column => 'row_id'
);
\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                    data                    | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+--------------------------------------------+----------+-------+--------------------
           1 |             1 | {1}     | UPDATE    | SHRINK        | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | started_by   | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2024-06-01      | {"name": "Surgical Inc.", "employees": 10} |          |       | existing_entity__1
           2 |             2 | {1}     | INSERT    |               | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | contains     | 2024-01-01     | 2025-01-01      | 2024-06-01     | 2024-09-01      | {"name": "Surgical Inc.", "employees": 15} |          |       | existing_entity__1
           3 |             2 | {1}     | INSERT    |               | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | finished_by  | 2024-01-01     | 2025-01-01      | 2024-09-01     | 2025-01-01      | {"name": "Surgical Inc.", "employees": 10} |          |       | existing_entity__1
(3 rows)

\echo '--- Executor: Actual Feedback ---'
--- Executor: Actual Feedback ---
TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
             1 | [{"id": 1}]        | APPLIED | 
(1 row)

\echo '--- Target: Expected Final State (timeline is split, name is inherited) ---'
--- Target: Expected Final State (timeline is split, name is inherited) ---
SELECT * FROM (VALUES
    (1, 'Surgical Inc.', 10, '2024-01-01'::date, '2024-06-01'::date),
    (1, 'Surgical Inc.', 15, '2024-06-01'::date, '2024-09-01'::date),
    (1, 'Surgical Inc.', 10, '2024-09-01'::date, '2025-01-01'::date)
) AS v(id, name, value, valid_from, valid_until) ORDER BY id, valid_from;
 id |     name      | value | valid_from | valid_until 
----+---------------+-------+------------+-------------
  1 | Surgical Inc. |    10 | 2024-01-01 | 2024-06-01
  1 | Surgical Inc. |    15 | 2024-06-01 | 2024-09-01
  1 | Surgical Inc. |    10 | 2024-09-01 | 2025-01-01
(3 rows)

\echo '--- Target: Final State ---'
--- Target: Final State ---
TABLE tm_47_surgical_patch.test_target ORDER BY id, valid_from;
 id |     name      | employees |       valid_range       | valid_from | valid_until 
----+---------------+-----------+-------------------------+------------+-------------
  1 | Surgical Inc. |        10 | [2024-01-01,2024-06-01) | 2024-01-01 | 2024-06-01
  1 | Surgical Inc. |        15 | [2024-06-01,2024-09-01) | 2024-06-01 | 2024-09-01
  1 | Surgical Inc. |        10 | [2024-09-01,2025-01-01) | 2024-09-01 | 2025-01-01
(3 rows)

ROLLBACK TO SAVEPOINT s47;
-- Final Cleanup
DROP TABLE temporal_merge_test_multi_insert.test_target;
DROP SCHEMA temporal_merge_test_multi_insert CASCADE;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
