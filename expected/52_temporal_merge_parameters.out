\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
SAVEPOINT scenario_1;
-- This test reproduces a bug where temporal_merge_plan generates
-- a syntactically incorrect query when called from a trigger.
CREATE TABLE tm_bug_target (
    id int,
    value text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('tm_bug_target', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tm_bug_target', ARRAY['id']);
     add_unique_key     
------------------------
 tm_bug_target_id_valid
(1 row)

CREATE TEMP TABLE tm_bug_source (
    row_id int,
    id int,
    value text,
    valid_from date,
    valid_until date
);
INSERT INTO tm_bug_source VALUES (1, 1, 'new value', '2024-01-01', 'infinity');
-- This call mimics a pure-insert scenario and should fail, then succeed after the fix.
-- Using an empty p_id_columns array is the key to reproducing the bug.
CALL sql_saga.temporal_merge(
    p_target_table      := 'tm_bug_target'::regclass,
    p_source_table      := 'tm_bug_source'::regclass,
    p_id_columns        := '{}'::text[],
    p_ephemeral_columns := '{}'::text[],
    p_mode              := 'insert_only'::sql_saga.temporal_merge_mode
);
-- Verify the merge was successful
TABLE tm_bug_target;
 id |   value   | valid_from | valid_until 
----+-----------+------------+-------------
  1 | new value | 2024-01-01 | infinity
(1 row)

ROLLBACK TO SAVEPOINT scenario_1;
-- TODO: Add more tests for parameter edge cases.
--
-- Future Scenarios to Test:
--
-- 1. Non-default `p_source_row_id_column`:
--    - Create a source table where the unique row identifier is named something
--      other than 'row_id' (e.g., 'source_pk').
--    - Call temporal_merge, passing 'source_pk' to `p_source_row_id_column`.
--    - Verify that feedback is correctly joined back to the source table.
--
-- 2. `p_founding_id_column` behavior:
--    - Scenario 2a (New Entity): Create a source table with multiple rows that share
--      the same `founding_id` but have different data and contiguous time periods.
--      Verify that they are correctly merged into a single new entity with
--      multiple historical slices.
--    - Scenario 2b (Existing Entity): Create a target entity. Create a source table
--      with a `founding_id` and data that updates the existing entity. Verify
--      that `founding_id` is correctly ignored and the operation proceeds as a
--      normal update.
--
-- 3. Table structure variations:
--    - Scenario 3a (Target table with no data columns): Test a merge into a target
--      table that only has ID columns and temporal columns.
--    - Scenario 3b (Source table with extra columns): Test a merge where the source
--      table has additional columns not present in the target. These should be
--      safely ignored.
--
-- 4. Parameter combinations:
--    - Scenario 4a: Test `p_update_source_with_assigned_entity_ids = true` in
--      conjunction with a multi-row `p_founding_id_column` scenario to ensure
--      the generated surrogate key is correctly back-filled to all source rows
--      sharing the founding_id.
--
-- 5. Generated Columns
--    - Create a target table with a `GENERATED ALWAYS AS ... STORED` column.
--    - Call `temporal_merge` to insert data.
--    - Verify that the call succeeds and the generated column has the correct value,
--      proving that the introspection logic correctly excluded it from the `INSERT` list.
SAVEPOINT scenario_6;
-- Scenario 5: Test `temporal_merge` with `GENERATED ALWAYS` columns
CREATE TABLE tm_gen_col_target (
    id int,
    value int,
    value_x2 int GENERATED ALWAYS AS (value * 2) STORED,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('tm_gen_col_target', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tm_gen_col_target', ARRAY['id']);
       add_unique_key       
----------------------------
 tm_gen_col_target_id_valid
(1 row)

CREATE TEMP TABLE tm_gen_col_source (
    row_id int,
    id int,
    value int,
    valid_from date,
    valid_until date
);
INSERT INTO tm_gen_col_source VALUES (1, 1, 100, '2024-01-01', 'infinity');
CALL sql_saga.temporal_merge(
    p_target_table      := 'tm_gen_col_target'::regclass,
    p_source_table      := 'tm_gen_col_source'::regclass,
    p_id_columns        := ARRAY['id']::text[],
    p_ephemeral_columns := '{}'::text[],
    p_mode              := 'insert_only'::sql_saga.temporal_merge_mode
);
-- Verify that the generated column was computed correctly.
TABLE tm_gen_col_target;
 id | value | value_x2 | valid_from | valid_until 
----+-------+----------+------------+-------------
  1 |   100 |      200 | 2024-01-01 | infinity
(1 row)

ROLLBACK TO SAVEPOINT scenario_6;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
