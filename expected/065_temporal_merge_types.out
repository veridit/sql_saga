\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo 'Test Suite: `sql_saga.temporal_merge` Data Type Support'
Test Suite: `sql_saga.temporal_merge` Data Type Support
\echo 'Description:'
Description:
\echo '  This test suite verifies that `temporal_merge` works correctly with all'
  This test suite verifies that `temporal_merge` works correctly with all
\echo '  supported range types for temporal eras.'
  supported range types for temporal eras.
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
SET client_min_messages TO NOTICE;
CREATE SCHEMA tmt; -- Temporal Merge Types
--------------------------------------------------------------------------------
\echo 'Test Type: INTEGER'
Test Type: INTEGER
--------------------------------------------------------------------------------
CREATE TABLE tmt.target_int (id int, valid_from int, valid_until int, value text);
SELECT sql_saga.add_era('tmt.target_int', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

INSERT INTO tmt.target_int VALUES (1, 10, 20, 'Original');
CREATE TEMP TABLE source_int (row_id int, id int, valid_from int, valid_until int, value text);
INSERT INTO source_int VALUES
    (101, 1, 15, 18, 'Patched'), -- Update
    (102, 2, 10, 20, 'New');     -- Insert
CALL sql_saga.temporal_merge(
    target_table => 'tmt.target_int'::regclass,
    source_table => 'source_int'::regclass,
    primary_identity_columns => '{id}'::text[]
);
\echo '--- Expected Final State ---'
--- Expected Final State ---
SELECT * FROM (VALUES
    (1, 10, 15, 'Original'),
    (1, 15, 18, 'Patched'),
    (1, 18, 20, 'Original'),
    (2, 10, 20, 'New')
) t(id, valid_from, valid_until, value) ORDER BY id, valid_from;
 id | valid_from | valid_until |  value   
----+------------+-------------+----------
  1 |         10 |          15 | Original
  1 |         15 |          18 | Patched
  1 |         18 |          20 | Original
  2 |         10 |          20 | New
(4 rows)

\echo '--- Actual Final State ---'
--- Actual Final State ---
SELECT * FROM tmt.target_int ORDER BY id, valid_from;
 id | valid_from | valid_until |  value   
----+------------+-------------+----------
  1 |         10 |          15 | Original
  1 |         15 |          18 | Patched
  1 |         18 |          20 | Original
  2 |         10 |          20 | New
(4 rows)

--------------------------------------------------------------------------------
\echo 'Test Type: BIGINT'
Test Type: BIGINT
--------------------------------------------------------------------------------
CREATE TABLE tmt.target_bigint (id int, valid_from bigint, valid_until bigint, value text);
SELECT sql_saga.add_era('tmt.target_bigint', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

INSERT INTO tmt.target_bigint VALUES (1, 10, 20, 'Original');
CREATE TEMP TABLE source_bigint (row_id int, id int, valid_from bigint, valid_until bigint, value text);
INSERT INTO source_bigint VALUES
    (101, 1, 15, 18, 'Patched'), -- Update
    (102, 2, 10, 20, 'New');     -- Insert
CALL sql_saga.temporal_merge(
    target_table => 'tmt.target_bigint'::regclass,
    source_table => 'source_bigint'::regclass,
    primary_identity_columns => '{id}'::text[]
);
\echo '--- Expected Final State ---'
--- Expected Final State ---
SELECT * FROM (VALUES
    (1, 10::bigint, 15::bigint, 'Original'),
    (1, 15::bigint, 18::bigint, 'Patched'),
    (1, 18::bigint, 20::bigint, 'Original'),
    (2, 10::bigint, 20::bigint, 'New')
) t(id, valid_from, valid_until, value) ORDER BY id, valid_from;
 id | valid_from | valid_until |  value   
----+------------+-------------+----------
  1 |         10 |          15 | Original
  1 |         15 |          18 | Patched
  1 |         18 |          20 | Original
  2 |         10 |          20 | New
(4 rows)

\echo '--- Actual Final State ---'
--- Actual Final State ---
SELECT * FROM tmt.target_bigint ORDER BY id, valid_from;
 id | valid_from | valid_until |  value   
----+------------+-------------+----------
  1 |         10 |          15 | Original
  1 |         15 |          18 | Patched
  1 |         18 |          20 | Original
  2 |         10 |          20 | New
(4 rows)

--------------------------------------------------------------------------------
\echo 'Test Type: NUMERIC'
Test Type: NUMERIC
--------------------------------------------------------------------------------
CREATE TABLE tmt.target_numeric (id int, valid_from numeric, valid_until numeric, value text);
SELECT sql_saga.add_era('tmt.target_numeric', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

INSERT INTO tmt.target_numeric VALUES (1, 10.0, 20.0, 'Original');
CREATE TEMP TABLE source_numeric (row_id int, id int, valid_from numeric, valid_until numeric, value text);
INSERT INTO source_numeric VALUES
    (101, 1, 15.5, 18.5, 'Patched'), -- Update
    (102, 2, 10.0, 20.0, 'New');     -- Insert
CALL sql_saga.temporal_merge(
    target_table => 'tmt.target_numeric'::regclass,
    source_table => 'source_numeric'::regclass,
    primary_identity_columns => '{id}'::text[]
);
\echo '--- Expected Final State ---'
--- Expected Final State ---
SELECT * FROM (VALUES
    (1, 10.0::numeric, 15.5::numeric, 'Original'),
    (1, 15.5::numeric, 18.5::numeric, 'Patched'),
    (1, 18.5::numeric, 20.0::numeric, 'Original'),
    (2, 10.0::numeric, 20.0::numeric, 'New')
) t(id, valid_from, valid_until, value) ORDER BY id, valid_from;
 id | valid_from | valid_until |  value   
----+------------+-------------+----------
  1 |       10.0 |        15.5 | Original
  1 |       15.5 |        18.5 | Patched
  1 |       18.5 |        20.0 | Original
  2 |       10.0 |        20.0 | New
(4 rows)

\echo '--- Actual Final State ---'
--- Actual Final State ---
SELECT * FROM tmt.target_numeric ORDER BY id, valid_from;
 id | valid_from | valid_until |  value   
----+------------+-------------+----------
  1 |       10.0 |        15.5 | Original
  1 |       15.5 |        18.5 | Patched
  1 |       18.5 |        20.0 | Original
  2 |       10.0 |        20.0 | New
(4 rows)

--------------------------------------------------------------------------------
\echo 'Test Type: TIMESTAMP'
Test Type: TIMESTAMP
--------------------------------------------------------------------------------
CREATE TABLE tmt.target_timestamp (id int, valid_from timestamp, valid_until timestamp, value text);
SELECT sql_saga.add_era('tmt.target_timestamp', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

INSERT INTO tmt.target_timestamp VALUES (1, '2024-01-01 10:00', '2024-01-01 20:00', 'Original');
CREATE TEMP TABLE source_timestamp (row_id int, id int, valid_from timestamp, valid_until timestamp, value text);
INSERT INTO source_timestamp VALUES
    (101, 1, '2024-01-01 15:00', '2024-01-01 18:00', 'Patched'), -- Update
    (102, 2, '2024-01-01 10:00', '2024-01-01 20:00', 'New');     -- Insert
CALL sql_saga.temporal_merge(
    target_table => 'tmt.target_timestamp'::regclass,
    source_table => 'source_timestamp'::regclass,
    primary_identity_columns => '{id}'::text[]
);
\echo '--- Expected Final State ---'
--- Expected Final State ---
SELECT * FROM (VALUES
    (1, '2024-01-01 10:00'::timestamp, '2024-01-01 15:00'::timestamp, 'Original'),
    (1, '2024-01-01 15:00'::timestamp, '2024-01-01 18:00'::timestamp, 'Patched'),
    (1, '2024-01-01 18:00'::timestamp, '2024-01-01 20:00'::timestamp, 'Original'),
    (2, '2024-01-01 10:00'::timestamp, '2024-01-01 20:00'::timestamp, 'New')
) t(id, valid_from, valid_until, value) ORDER BY id, valid_from;
 id |     valid_from      |     valid_until     |  value   
----+---------------------+---------------------+----------
  1 | 2024-01-01 10:00:00 | 2024-01-01 15:00:00 | Original
  1 | 2024-01-01 15:00:00 | 2024-01-01 18:00:00 | Patched
  1 | 2024-01-01 18:00:00 | 2024-01-01 20:00:00 | Original
  2 | 2024-01-01 10:00:00 | 2024-01-01 20:00:00 | New
(4 rows)

\echo '--- Actual Final State ---'
--- Actual Final State ---
SELECT * FROM tmt.target_timestamp ORDER BY id, valid_from;
 id |     valid_from      |     valid_until     |  value   
----+---------------------+---------------------+----------
  1 | 2024-01-01 10:00:00 | 2024-01-01 15:00:00 | Original
  1 | 2024-01-01 15:00:00 | 2024-01-01 18:00:00 | Patched
  1 | 2024-01-01 18:00:00 | 2024-01-01 20:00:00 | Original
  2 | 2024-01-01 10:00:00 | 2024-01-01 20:00:00 | New
(4 rows)

--------------------------------------------------------------------------------
\echo 'Test Type: TIMESTAMPTZ'
Test Type: TIMESTAMPTZ
--------------------------------------------------------------------------------
CREATE TABLE tmt.target_timestamptz (id int, valid_from timestamptz, valid_until timestamptz, value text);
SELECT sql_saga.add_era('tmt.target_timestamptz', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

INSERT INTO tmt.target_timestamptz VALUES (1, '2024-01-01 10:00Z', '2024-01-01 20:00Z', 'Original');
CREATE TEMP TABLE source_timestamptz (row_id int, id int, valid_from timestamptz, valid_until timestamptz, value text);
INSERT INTO source_timestamptz VALUES
    (101, 1, '2024-01-01 15:00Z', '2024-01-01 18:00Z', 'Patched'), -- Update
    (102, 2, '2024-01-01 10:00Z', '2024-01-01 20:00Z', 'New');     -- Insert
CALL sql_saga.temporal_merge(
    target_table => 'tmt.target_timestamptz'::regclass,
    source_table => 'source_timestamptz'::regclass,
    primary_identity_columns => '{id}'::text[]
);
\echo '--- Expected Final State ---'
--- Expected Final State ---
SELECT * FROM (VALUES
    (1, '2024-01-01 10:00Z'::timestamptz, '2024-01-01 15:00Z'::timestamptz, 'Original'),
    (1, '2024-01-01 15:00Z'::timestamptz, '2024-01-01 18:00Z'::timestamptz, 'Patched'),
    (1, '2024-01-01 18:00Z'::timestamptz, '2024-01-01 20:00Z'::timestamptz, 'Original'),
    (2, '2024-01-01 10:00Z'::timestamptz, '2024-01-01 20:00Z'::timestamptz, 'New')
) t(id, valid_from, valid_until, value) ORDER BY id, valid_from;
 id |       valid_from       |      valid_until       |  value   
----+------------------------+------------------------+----------
  1 | 2024-01-01 02:00:00-08 | 2024-01-01 07:00:00-08 | Original
  1 | 2024-01-01 07:00:00-08 | 2024-01-01 10:00:00-08 | Patched
  1 | 2024-01-01 10:00:00-08 | 2024-01-01 12:00:00-08 | Original
  2 | 2024-01-01 02:00:00-08 | 2024-01-01 12:00:00-08 | New
(4 rows)

\echo '--- Actual Final State ---'
--- Actual Final State ---
SELECT * FROM tmt.target_timestamptz ORDER BY id, valid_from;
 id |       valid_from       |      valid_until       |  value   
----+------------------------+------------------------+----------
  1 | 2024-01-01 02:00:00-08 | 2024-01-01 07:00:00-08 | Original
  1 | 2024-01-01 07:00:00-08 | 2024-01-01 10:00:00-08 | Patched
  1 | 2024-01-01 10:00:00-08 | 2024-01-01 12:00:00-08 | Original
  2 | 2024-01-01 02:00:00-08 | 2024-01-01 12:00:00-08 | New
(4 rows)

ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
