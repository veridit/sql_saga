\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
/* Run tests as unprivileged user */
SET ROLE TO sql_saga_unprivileged_user;
/* Basic period definitions with dates */
CREATE TABLE basic (val text, valid_from date, valid_until date);
TABLE sql_saga.era;
 table_schema | table_name | era_name | valid_from_column_name | valid_until_column_name | range_type | range_subtype | range_subtype_category | bounds_check_constraint | audit_schema_name | audit_table_name 
--------------+------------+----------+------------------------+-------------------------+------------+---------------+------------------------+-------------------------+-------------------+------------------
(0 rows)

SELECT sql_saga.add_era('basic', 'valid_from', 'valid_until', 'bp');
 add_era 
---------
 t
(1 row)

TABLE sql_saga.era;
 table_schema | table_name | era_name | valid_from_column_name | valid_until_column_name | range_type | range_subtype | range_subtype_category | bounds_check_constraint | audit_schema_name | audit_table_name 
--------------+------------+----------+------------------------+-------------------------+------------+---------------+------------------------+-------------------------+-------------------+------------------
 public       | basic      | bp       | valid_from             | valid_until             | daterange  | date          | D                      | basic_bp_check          |                   | 
(1 row)

SELECT sql_saga.drop_era('basic', 'bp');
 drop_era 
----------
 t
(1 row)

TABLE sql_saga.era;
 table_schema | table_name | era_name | valid_from_column_name | valid_until_column_name | range_type | range_subtype | range_subtype_category | bounds_check_constraint | audit_schema_name | audit_table_name 
--------------+------------+----------+------------------------+-------------------------+------------+---------------+------------------------+-------------------------+-------------------+------------------
(0 rows)

SELECT sql_saga.add_era('basic', 'valid_from', 'valid_until', 'bp', bounds_check_constraint => 'c');
 add_era 
---------
 t
(1 row)

TABLE sql_saga.era;
 table_schema | table_name | era_name | valid_from_column_name | valid_until_column_name | range_type | range_subtype | range_subtype_category | bounds_check_constraint | audit_schema_name | audit_table_name 
--------------+------------+----------+------------------------+-------------------------+------------+---------------+------------------------+-------------------------+-------------------+------------------
 public       | basic      | bp       | valid_from             | valid_until             | daterange  | date          | D                      | c                       |                   | 
(1 row)

/* Test constraints */
SAVEPOINT pristine;
INSERT INTO basic (val, valid_from, valid_until) VALUES ('x', null, null); --fail
ERROR:  null value in column "valid_from" of relation "basic" violates not-null constraint
DETAIL:  Failing row contains (x, null, null).
ROLLBACK TO SAVEPOINT pristine;
INSERT INTO basic (val, valid_from, valid_until) VALUES ('x', '3000-01-01', null); --fail
ERROR:  null value in column "valid_until" of relation "basic" violates not-null constraint
DETAIL:  Failing row contains (x, 3000-01-01, null).
ROLLBACK TO SAVEPOINT pristine;
INSERT INTO basic (val, valid_from, valid_until) VALUES ('x', null, '1000-01-01'); --fail
ERROR:  null value in column "valid_from" of relation "basic" violates not-null constraint
DETAIL:  Failing row contains (x, null, 1000-01-01).
ROLLBACK TO SAVEPOINT pristine;
INSERT INTO basic (val, valid_from, valid_until) VALUES ('x', '3000-01-01', '1000-01-01'); --fail
ERROR:  new row for relation "basic" violates check constraint "basic_bp_check"
DETAIL:  Failing row contains (x, 3000-01-01, 1000-01-01).
ROLLBACK TO SAVEPOINT pristine;
INSERT INTO basic (val, valid_from, valid_until) VALUES ('x', '1000-01-01', '3000-01-01'); --success
TABLE basic;
 val | valid_from | valid_until 
-----+------------+-------------
 x   | 1000-01-01 | 3000-01-01
(1 row)

/* Test dropping the whole thing */
SELECT sql_saga.drop_era('basic', 'bp');
 drop_era 
----------
 t
(1 row)

DROP TABLE basic;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
