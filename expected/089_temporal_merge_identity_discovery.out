\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
CREATE SCHEMA identity_discovery;
-- This test verifies the "convention-over-configuration" behavior of
-- temporal_merge. When identity columns are omitted, the procedure should
-- discover them from metadata and use them automatically.
-- 1. A target table with one primary key and MULTIPLE natural keys.
CREATE TABLE identity_discovery.person (
    id int GENERATED BY DEFAULT AS IDENTITY,
    ssn text,
    employee_nr text,
    email text,
    full_name text,
    valid_range daterange NOT NULL,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('identity_discovery.person', 'valid_range', 'valid',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "person_synchronize_temporal_columns_trigger" on table identity_discovery.person to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

ALTER TABLE identity_discovery.person ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['id'], 'valid', key_type => 'primary');
NOTICE:  sql_saga: altering table identity_discovery.person to add constraints: ALTER COLUMN id SET NOT NULL
 add_unique_key  
-----------------
 person_id_valid
(1 row)

SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['employee_nr'], 'valid', key_type => 'natural');
NOTICE:  sql_saga: altering table identity_discovery.person to add constraints: ADD CONSTRAINT person_employee_nr_valid_uniq UNIQUE (employee_nr, valid_range WITHOUT OVERLAPS), ADD CONSTRAINT person_employee_nr_valid_pk_consistency_excl EXCLUDE USING gist (employee_nr WITH =, id WITH <>)
      add_unique_key      
--------------------------
 person_employee_nr_valid
(1 row)

SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['ssn'], 'valid', key_type => 'natural');
NOTICE:  sql_saga: altering table identity_discovery.person to add constraints: ADD CONSTRAINT person_ssn_valid_uniq UNIQUE (ssn, valid_range WITHOUT OVERLAPS), ADD CONSTRAINT person_ssn_valid_pk_consistency_excl EXCLUDE USING gist (ssn WITH =, id WITH <>)
  add_unique_key  
------------------
 person_ssn_valid
(1 row)

\d identity_discovery.person
                         Table "identity_discovery.person"
   Column    |   Type    | Collation | Nullable |             Default              
-------------+-----------+-----------+----------+----------------------------------
 id          | integer   |           | not null | generated by default as identity
 ssn         | text      |           |          | 
 employee_nr | text      |           |          | 
 email       | text      |           |          | 
 full_name   | text      |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           | not null | 
 valid_until | date      |           |          | 
Indexes:
    "person_pkey" PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
    "person_employee_nr_idx" btree (employee_nr)
    "person_employee_nr_valid_pk_consistency_excl" EXCLUDE USING gist (employee_nr WITH =, id WITH <>)
    "person_employee_nr_valid_uniq" UNIQUE (employee_nr, valid_range WITHOUT OVERLAPS)
    "person_id_idx" btree (id)
    "person_ssn_idx" btree (ssn)
    "person_ssn_valid_pk_consistency_excl" EXCLUDE USING gist (ssn WITH =, id WITH <>)
    "person_ssn_valid_uniq" UNIQUE (ssn, valid_range WITHOUT OVERLAPS)
Check constraints:
    "person_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)
    "person_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    person_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_range, valid_from, valid_until ON identity_discovery.person FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'null', 'date', 't')

-- 2. The source table for data loading, with a columns.
CREATE TEMP TABLE source_data (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id int,
    ssn text,
    employee_nr text,
    email text,
    full_name text,
    valid_from date,
    valid_until date,
    errors jsonb,
    merge_status jsonb
);
-- 3. Load initial state.
\echo '--- Loading initial state ---'
--- Loading initial state ---
INSERT INTO source_data (employee_id, ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    (NULL, '111', 'E101', 'alice@example.com', 'Alice Smith', '2023-01-01', '2024-01-01'),
    (NULL, '111', 'E101', 'alice@example.com', 'Alice Baker', '2024-01-01', '2025-01-01'),
    (NULL, '111', 'E101', 'alice@baker.com', 'Alice Baker', '2025-01-01', 'infinity');
-- The key of this test: CALL temporal_merge WITHOUT specifying identity columns.
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- State after initial load ---'
--- State after initial load ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;
 id | ssn | employee_nr |       email       |  full_name  | valid_from | valid_until 
----+-----+-------------+-------------------+-------------+------------+-------------
  1 | 111 | E101        | alice@example.com | Alice Smith | 2023-01-01 | 2024-01-01
  1 | 111 | E101        | alice@example.com | Alice Baker | 2024-01-01 | 2025-01-01
  1 | 111 | E101        | alice@baker.com   | Alice Baker | 2025-01-01 | infinity
(3 rows)

-- 4. Update via `employee_nr`. This creates a new historical record (SCD Type 2).
\echo '--- Updating via employee_nr ---'
--- Updating via employee_nr ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (employee_nr, full_name, valid_from, valid_until) VALUES
    ('E101', 'Alice Jones', '2023-06-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
    
\echo '--- State after update via employee_nr ---'
--- State after update via employee_nr ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;
 id | ssn | employee_nr |       email       |  full_name  | valid_from | valid_until 
----+-----+-------------+-------------------+-------------+------------+-------------
  1 | 111 | E101        | alice@example.com | Alice Smith | 2023-01-01 | 2023-06-01
  1 | 111 | E101        | alice@example.com | Alice Jones | 2023-06-01 | 2024-01-01
  1 | 111 | E101        | alice@example.com | Alice Baker | 2024-01-01 | 2025-01-01
  1 | 111 | E101        | alice@baker.com   | Alice Baker | 2025-01-01 | infinity
(4 rows)

-- 5. Update via `email`. This creates a third historical record.
\echo '--- Updating via email ---'
--- Updating via email ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (email, full_name, valid_from, valid_until) VALUES
    ('alice@example.com', 'Alice Jones-Carter', '2023-09-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- Final State after update via email ---'
--- Final State after update via email ---
-- The state is unchanged because the source row was unidentifiable (email is not a natural key).
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;
 id | ssn | employee_nr |       email       |  full_name  | valid_from | valid_until 
----+-----+-------------+-------------------+-------------+------------+-------------
  1 | 111 | E101        | alice@example.com | Alice Smith | 2023-01-01 | 2023-06-01
  1 | 111 | E101        | alice@example.com | Alice Jones | 2023-06-01 | 2024-01-01
  1 | 111 | E101        | alice@example.com | Alice Baker | 2024-01-01 | 2025-01-01
  1 | 111 | E101        | alice@baker.com   | Alice Baker | 2025-01-01 | infinity
(4 rows)

-- 6. Add a second person.
\echo '--- Adding a second person ---'
--- Adding a second person ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('222', 'E102', 'bob@example.com', 'Bob Johnson', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;
 id | ssn | employee_nr |       email       |  full_name  | valid_from | valid_until 
----+-----+-------------+-------------------+-------------+------------+-------------
  1 | 111 | E101        | alice@example.com | Alice Smith | 2023-01-01 | 2023-06-01
  1 | 111 | E101        | alice@example.com | Alice Jones | 2023-06-01 | 2024-01-01
  1 | 111 | E101        | alice@example.com | Alice Baker | 2024-01-01 | 2025-01-01
  1 | 111 | E101        | alice@baker.com   | Alice Baker | 2025-01-01 | infinity
  2 | 222 | E102        | bob@example.com   | Bob Johnson | 2023-01-01 | 2024-01-01
(5 rows)

SAVEPOINT s7;
-- 7. FAIL: Attempt to update with conflicting natural keys.
\echo '--- Updating with conflicting keys (expect error) ---'
--- Updating with conflicting keys (expect error) ---
TRUNCATE source_data RESTART IDENTITY;
-- This source row links Alice's employee_nr with Bob's ssn, creating ambiguity.
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('222', 'E101', 'conflict@example.com', 'Conflict Person', '2023-10-01', '2024-01-01');
    
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    update_source_with_feedback => true,
    feedback_status_column => 'merge_status',
    feedback_status_key => 'test',
    feedback_error_column => 'errors',
    feedback_error_key => 'test'    
);
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity |                  entity_keys                   | identity_keys |              lookup_keys              | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until | old_valid_range | new_valid_range | data |                                                    feedback                                                    | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+------------------------------------------------+---------------+---------------------------------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-----------------+-----------------+------+----------------------------------------------------------------------------------------------------------------+-------+--------------------
           1 |             1 | {1}     | ERROR     |               | 1         | f             | {"id": 1, "ssn": "222", "employee_nr": "E101"} | {"id": 1}     | {"ssn": "222", "employee_nr": "E101"} |              |              |                |                 |                |                 |                 |                 |      | {"error": "Source row is ambiguous. It matches multiple distinct target entities: [{\"id\": 1}, {\"id\": 2}]"} |       | existing_entity__1
(1 row)

\echo '--- Feedback for ambiguous row ---'
--- Feedback for ambiguous row ---
SELECT row_id, merge_status, errors
FROM source_data;
 row_id |   merge_status    |                                                    errors                                                     
--------+-------------------+---------------------------------------------------------------------------------------------------------------
      1 | {"test": "ERROR"} | {"test": "Source row is ambiguous. It matches multiple distinct target entities: [{\"id\": 1}, {\"id\": 2}]"}
(1 row)

ROLLBACK TO SAVEPOINT s7;
-- 8. FAIL: Attempt to insert a completely unidentifiable row.
SAVEPOINT s8;
\echo '--- Inserting unidentifiable row (expect error feedback) ---'
--- Inserting unidentifiable row (expect error feedback) ---
TRUNCATE source_data RESTART IDENTITY;
-- This row has NULL for all identifying columns.
INSERT INTO source_data (full_name, valid_from, valid_until) VALUES
    ('Ghost Person', '2023-11-01', '2024-01-01');
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    update_source_with_feedback => true,
    feedback_status_column => 'merge_status',
    feedback_status_key => 'test',
    feedback_error_column => 'errors',
    feedback_error_key => 'test'
);
\echo '--- Feedback for unidentifiable row ---'
--- Feedback for unidentifiable row ---
-- The status should be ERROR with a specific message.
SELECT row_id, merge_status, errors
FROM source_data;
 row_id |   merge_status    |                                                                 errors                                                                 
--------+-------------------+----------------------------------------------------------------------------------------------------------------------------------------
      1 | {"test": "ERROR"} | {"test": "Source row is unidentifiable. It has NULL for all stable identity columns {id} and all natural keys [[employee_nr], [ssn]]"}
(1 row)

ROLLBACK TO SAVEPOINT s8;
-- 9. Multi-row update to a single entity
\echo '--- Scenario 9: Multi-row update to a single entity with different identity strategies ---'
--- Scenario 9: Multi-row update to a single entity with different identity strategies ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('333', 'E103', 'charlie@example.com', 'Charlie Day', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- State after adding Charlie ---'
--- State after adding Charlie ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
 id | ssn | employee_nr |        email        |  full_name  | valid_from | valid_until 
----+-----+-------------+---------------------+-------------+------------+-------------
  3 | 333 | E103        | charlie@example.com | Charlie Day | 2023-01-01 | 2024-01-01
(1 row)

-- Source data with two consecutive updates for Charlie
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, full_name, valid_from, valid_until) VALUES
    -- Updates by employee_nr
    (NULL, 'E103', 'Charlie Kelly', '2023-04-01', '2023-08-01'),
    (NULL, 'E103', 'Charles Kelly', '2023-08-01', '2024-01-01'),
    -- Updates by ssn
    ('333', NULL, 'C. Day', '2023-02-01', '2023-03-01'),
    ('333', NULL, 'Chuck Day', '2023-03-01', '2023-04-01');
\echo

\echo '--- Case 9a: Multi-row update with auto-discovered keys ---'
--- Case 9a: Multi-row update with auto-discovered keys ---
SAVEPOINT s9;
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => NULL,
    natural_identity_columns => NULL
);
\echo '--- Final state (9a) ---'
--- Final state (9a) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
 id | ssn | employee_nr |        email        |   full_name   | valid_from | valid_until 
----+-----+-------------+---------------------+---------------+------------+-------------
  3 | 333 | E103        | charlie@example.com | Charlie Day   | 2023-01-01 | 2023-02-01
  3 | 333 | E103        | charlie@example.com | C. Day        | 2023-02-01 | 2023-03-01
  3 | 333 | E103        | charlie@example.com | Chuck Day     | 2023-03-01 | 2023-04-01
  3 | 333 | E103        | charlie@example.com | Charlie Kelly | 2023-04-01 | 2023-08-01
  3 | 333 | E103        | charlie@example.com | Charles Kelly | 2023-08-01 | 2024-01-01
(5 rows)

ROLLBACK TO SAVEPOINT s9;
\echo

\echo '--- Case 9b: Multi-row update with explicit stable key and natural key for lookup ---'
--- Case 9b: Multi-row update with explicit stable key and natural key for lookup ---
SAVEPOINT s9;
TABLE identity_discovery.person ORDER BY id,ssn,valid_range;
 id | ssn | employee_nr |        email        |  full_name  |       valid_range       | valid_from | valid_until 
----+-----+-------------+---------------------+-------------+-------------------------+------------+-------------
  1 | 111 | E101        | alice@example.com   | Alice Smith | [2023-01-01,2023-06-01) | 2023-01-01 | 2023-06-01
  1 | 111 | E101        | alice@example.com   | Alice Jones | [2023-06-01,2024-01-01) | 2023-06-01 | 2024-01-01
  1 | 111 | E101        | alice@example.com   | Alice Baker | [2024-01-01,2025-01-01) | 2024-01-01 | 2025-01-01
  1 | 111 | E101        | alice@baker.com     | Alice Baker | [2025-01-01,infinity)   | 2025-01-01 | infinity
  2 | 222 | E102        | bob@example.com     | Bob Johnson | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  3 | 333 | E103        | charlie@example.com | Charlie Day | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
(6 rows)

TABLE source_data;
 row_id | employee_id | ssn | employee_nr | email |   full_name   | valid_from | valid_until | errors | merge_status 
--------+-------------+-----+-------------+-------+---------------+------------+-------------+--------+--------------
      1 |             |     | E103        |       | Charlie Kelly | 2023-04-01 | 2023-08-01  |        | 
      2 |             |     | E103        |       | Charles Kelly | 2023-08-01 | 2024-01-01  |        | 
      3 |             | 333 |             |       | C. Day        | 2023-02-01 | 2023-03-01  |        | 
      4 |             | 333 |             |       | Chuck Day     | 2023-03-01 | 2023-04-01  |        | 
(4 rows)

CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['employee_nr']
);
\echo '--- Final state (9b) ---'
--- Final state (9b) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
 id | ssn | employee_nr |        email        |   full_name   | valid_from | valid_until 
----+-----+-------------+---------------------+---------------+------------+-------------
  3 | 333 | E103        | charlie@example.com | Charlie Day   | 2023-01-01 | 2023-04-01
  3 | 333 | E103        | charlie@example.com | Charlie Kelly | 2023-04-01 | 2023-08-01
  3 | 333 | E103        | charlie@example.com | Charles Kelly | 2023-08-01 | 2024-01-01
(3 rows)

ROLLBACK TO SAVEPOINT s9;
\echo

\echo '--- Case 9c: Multi-row update with explicit natural key (employee_nr only) ---'
--- Case 9c: Multi-row update with explicit natural key (employee_nr only) ---
\echo '--- This will only apply updates from source rows that have a non-NULL employee_nr. ---'
--- This will only apply updates from source rows that have a non-NULL employee_nr. ---
SAVEPOINT s9;
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => NULL,
    natural_identity_columns => ARRAY['employee_nr']
);
\echo '--- Final state (9c) ---'
--- Final state (9c) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
 id | ssn | employee_nr |        email        |   full_name   | valid_from | valid_until 
----+-----+-------------+---------------------+---------------+------------+-------------
  3 | 333 | E103        | charlie@example.com | Charlie Day   | 2023-01-01 | 2023-04-01
  3 | 333 | E103        | charlie@example.com | Charlie Kelly | 2023-04-01 | 2023-08-01
  3 | 333 | E103        | charlie@example.com | Charles Kelly | 2023-08-01 | 2024-01-01
(3 rows)

ROLLBACK TO SAVEPOINT s9;
\echo

\echo '--- Case 9d: Multi-row update with explicit natural key (ssn only) ---'
--- Case 9d: Multi-row update with explicit natural key (ssn only) ---
\echo '--- This will only apply updates from source rows that have a non-NULL ssn. ---'
--- This will only apply updates from source rows that have a non-NULL ssn. ---
SAVEPOINT s9;
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => NULL,
    natural_identity_columns => ARRAY['ssn']
);
\echo '--- Final state (9d) ---'
--- Final state (9d) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
 id | ssn | employee_nr |        email        |  full_name  | valid_from | valid_until 
----+-----+-------------+---------------------+-------------+------------+-------------
  3 | 333 | E103        | charlie@example.com | Charlie Day | 2023-01-01 | 2023-02-01
  3 | 333 | E103        | charlie@example.com | C. Day      | 2023-02-01 | 2023-03-01
  3 | 333 | E103        | charlie@example.com | Chuck Day   | 2023-03-01 | 2023-04-01
  3 | 333 | E103        | charlie@example.com | Charlie Day | 2023-04-01 | 2024-01-01
(4 rows)

ROLLBACK TO SAVEPOINT s9;
\echo

\echo '--- Case 9e: Multi-row update with explicit natural key (both ssn and employee_nr) ---'
--- Case 9e: Multi-row update with explicit natural key (both ssn and employee_nr) ---
\echo '--- The planner will try both keys and should apply all updates. ---'
--- The planner will try both keys and should apply all updates. ---
SAVEPOINT s9;
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => NULL,
    natural_identity_columns => NULL -- Let the planner auto-discover both ['ssn'] and ['employee_nr']
);
\echo '--- Final state (9e) ---'
--- Final state (9e) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
 id | ssn | employee_nr |        email        |   full_name   | valid_from | valid_until 
----+-----+-------------+---------------------+---------------+------------+-------------
  3 | 333 | E103        | charlie@example.com | Charlie Day   | 2023-01-01 | 2023-02-01
  3 | 333 | E103        | charlie@example.com | C. Day        | 2023-02-01 | 2023-03-01
  3 | 333 | E103        | charlie@example.com | Chuck Day     | 2023-03-01 | 2023-04-01
  3 | 333 | E103        | charlie@example.com | Charlie Kelly | 2023-04-01 | 2023-08-01
  3 | 333 | E103        | charlie@example.com | Charles Kelly | 2023-08-01 | 2024-01-01
(5 rows)

ROLLBACK TO SAVEPOINT s9;
-- 10. Multi-row insert for a new entity using natural key
\echo '--- Scenario 10: Multi-row insert for a new entity using auto-discovered natural key ---'
--- Scenario 10: Multi-row insert for a new entity using auto-discovered natural key ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('444', 'E104', 'dennis@example.com', 'Dennis Reynolds', '2023-01-01', '2023-06-01'),
    ('444', 'E104', 'dennis@example.com', 'Dennis R. Reynolds', '2023-06-01', '2024-01-01');
\echo '--- Source for new person Dennis ---'
--- Source for new person Dennis ---
TABLE source_data;
 row_id | employee_id | ssn | employee_nr |       email        |     full_name      | valid_from | valid_until | errors | merge_status 
--------+-------------+-----+-------------+--------------------+--------------------+------------+-------------+--------+--------------
      1 |             | 444 | E104        | dennis@example.com | Dennis Reynolds    | 2023-01-01 | 2023-06-01  |        | 
      2 |             | 444 | E104        | dennis@example.com | Dennis R. Reynolds | 2023-06-01 | 2024-01-01  |        | 
(2 rows)

CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data'
    -- No identity columns specified, should auto-discover and group by natural key
);
\echo '--- Final state after multi-row insert ---'
--- Final state after multi-row insert ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E104' ORDER BY id, valid_from;
 id | ssn | employee_nr |       email        |     full_name      | valid_from | valid_until 
----+-----+-------------+--------------------+--------------------+------------+-------------
  4 | 444 | E104        | dennis@example.com | Dennis Reynolds    | 2023-01-01 | 2023-06-01
  4 | 444 | E104        | dennis@example.com | Dennis R. Reynolds | 2023-06-01 | 2024-01-01
(2 rows)

-- 11. Multi-row insert/update of a fragmented entity (PATCH mode)
\echo '--- Scenario 11: Multi-row insert/update of a fragmented entity (PATCH mode) ---'
--- Scenario 11: Multi-row insert/update of a fragmented entity (PATCH mode) ---
SAVEPOINT s11;
-- This scenario tests the planner's ability to create and update a complex history for a single entity
-- from multiple source rows with fragmented natural key and data information.
-- First, set up the complete source data for all parts of this test.
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('555', 'E105', 'dee@doe.com'    , 'Dee Doe'  , '2023-01-01', '2024-01-01'),
    ('555',  NULL , 'dee@example.com', NULL       , '2023-02-01', '2023-04-01'),
    ('555',  NULL , NULL             , 'Sweet Dee', '2023-04-01', '2023-06-01'),
    ( NULL, 'E105', 'doe@example.com', NULL       , '2023-03-01', '2023-05-01'),
    ( NULL, 'E105', NULL             , 'Sweet Doe', '2023-05-01', '2023-07-01');
\echo '--- Source for fragmented entity ---'
--- Source for fragmented entity ---
TABLE source_data ORDER BY row_id;
 row_id | employee_id | ssn | employee_nr |      email      | full_name | valid_from | valid_until | errors | merge_status 
--------+-------------+-----+-------------+-----------------+-----------+------------+-------------+--------+--------------
      1 |             | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2024-01-01  |        | 
      2 |             | 555 |             | dee@example.com |           | 2023-02-01 | 2023-04-01  |        | 
      3 |             | 555 |             |                 | Sweet Dee | 2023-04-01 | 2023-06-01  |        | 
      4 |             |     | E105        | doe@example.com |           | 2023-03-01 | 2023-05-01  |        | 
      5 |             |     | E105        |                 | Sweet Doe | 2023-05-01 | 2023-07-01  |        | 
(5 rows)

\echo

\echo '--- Case 11a: Merging all source rows in a single batch ---'
--- Case 11a: Merging all source rows in a single batch ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data', mode => 'MERGE_ENTITY_PATCH');
\echo '--- State after single-batch merge (PATCH mode) ---'
--- State after single-batch merge (PATCH mode) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      | full_name | valid_from | valid_until 
----+-----+-------------+-----------------+-----------+------------+-------------
  5 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2023-02-01
  5 | 555 | E105        | dee@example.com | Dee Doe   | 2023-02-01 | 2023-03-01
  5 | 555 | E105        | doe@example.com | Dee Doe   | 2023-03-01 | 2023-04-01
  5 | 555 | E105        | doe@example.com | Sweet Dee | 2023-04-01 | 2023-05-01
  5 | 555 | E105        | dee@doe.com     | Sweet Doe | 2023-05-01 | 2023-07-01
  5 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-07-01 | 2024-01-01
(6 rows)

\echo

\echo '--- Case 11b: Merging in two batches with MERGE_ENTITY_PATCH ---'
--- Case 11b: Merging in two batches with MERGE_ENTITY_PATCH ---
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
CREATE TEMP TABLE source_step1_b AS SELECT * FROM source_data WHERE row_id = 1;
CREATE TEMP TABLE source_step2_b AS SELECT * FROM source_data WHERE row_id > 1;
\echo '--- Step 1: Seeding target with first row ---'
--- Step 1: Seeding target with first row ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step1_b', mode => 'MERGE_ENTITY_PATCH');
TABLE identity_discovery.person ORDER BY id,ssn,valid_range;
 id | ssn | employee_nr |    email    | full_name |       valid_range       | valid_from | valid_until 
----+-----+-------------+-------------+-----------+-------------------------+------------+-------------
  1 | 555 | E105        | dee@doe.com | Dee Doe   | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
(1 row)

\echo '--- Step 2: Merging remaining rows ---'
--- Step 2: Merging remaining rows ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step2_b', mode => 'MERGE_ENTITY_PATCH');
\echo '--- State after two-batch merge (PATCH mode) ---'
--- State after two-batch merge (PATCH mode) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      | full_name | valid_from | valid_until 
----+-----+-------------+-----------------+-----------+------------+-------------
  1 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2023-02-01
  1 | 555 | E105        | dee@example.com | Dee Doe   | 2023-02-01 | 2023-03-01
  1 | 555 | E105        | doe@example.com | Dee Doe   | 2023-03-01 | 2023-04-01
  1 | 555 | E105        | doe@example.com | Sweet Dee | 2023-04-01 | 2023-05-01
  1 | 555 | E105        | dee@doe.com     | Sweet Doe | 2023-05-01 | 2023-07-01
  1 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-07-01 | 2024-01-01
(6 rows)

\echo

\echo '--- Case 11c: Merging in two batches with PATCH_FOR_PORTION_OF ---'
--- Case 11c: Merging in two batches with PATCH_FOR_PORTION_OF ---
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
CREATE TEMP TABLE source_step1_c AS SELECT * FROM source_data WHERE row_id = 1;
CREATE TEMP TABLE source_step2_c AS SELECT * FROM source_data WHERE row_id > 1;
\echo '--- Step 1: Seeding target with first row ---'
--- Step 1: Seeding target with first row ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step1_c', mode => 'MERGE_ENTITY_PATCH');
TABLE identity_discovery.person ORDER BY id,ssn,valid_range;
 id | ssn | employee_nr |    email    | full_name |       valid_range       | valid_from | valid_until 
----+-----+-------------+-------------+-----------+-------------------------+------------+-------------
  1 | 555 | E105        | dee@doe.com | Dee Doe   | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
(1 row)

\echo '--- Step 2: Merging remaining rows with PATCH_FOR_PORTION_OF ---'
--- Step 2: Merging remaining rows with PATCH_FOR_PORTION_OF ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step2_c', mode => 'PATCH_FOR_PORTION_OF');
\echo '--- State after two-batch merge (PORTION_OF mode) ---'
--- State after two-batch merge (PORTION_OF mode) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      | full_name | valid_from | valid_until 
----+-----+-------------+-----------------+-----------+------------+-------------
  1 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2023-02-01
  1 | 555 | E105        | dee@example.com | Dee Doe   | 2023-02-01 | 2023-03-01
  1 | 555 | E105        | doe@example.com | Dee Doe   | 2023-03-01 | 2023-04-01
  1 | 555 | E105        | doe@example.com | Sweet Dee | 2023-04-01 | 2023-05-01
  1 | 555 | E105        | dee@doe.com     | Sweet Doe | 2023-05-01 | 2023-07-01
  1 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-07-01 | 2024-01-01
(6 rows)

ROLLBACK TO SAVEPOINT s11;
-- 12. Multi-row insert/update of a fragmented entity (UPSERT mode)
\echo '--- Scenario 12: Multi-row insert/update of a fragmented entity (UPSERT mode) ---'
--- Scenario 12: Multi-row insert/update of a fragmented entity (UPSERT mode) ---
SAVEPOINT s12;
-- This scenario uses the same fragmented source data as the PATCH test, but with
-- UPSERT mode. The key difference is that UPSERT treats NULLs in the source as
-- explicit values that should overwrite existing data.
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('555', 'E105', 'dee@doe.com'    , 'Dee Doe'  , '2023-01-01', '2024-01-01'),
    ('555',  NULL , 'dee@example.com', NULL       , '2023-02-01', '2023-04-01'),
    ('555',  NULL , NULL             , 'Sweet Dee', '2023-04-01', '2023-06-01'),
    ( NULL, 'E105', 'doe@example.com', NULL       , '2023-03-01', '2023-05-01'),
    ( NULL, 'E105', NULL             , 'Sweet Doe', '2023-05-01', '2023-07-01');
\echo '--- Source for fragmented entity ---'
--- Source for fragmented entity ---
TABLE source_data ORDER BY row_id;
 row_id | employee_id | ssn | employee_nr |      email      | full_name | valid_from | valid_until | errors | merge_status 
--------+-------------+-----+-------------+-----------------+-----------+------------+-------------+--------+--------------
      1 |             | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2024-01-01  |        | 
      2 |             | 555 |             | dee@example.com |           | 2023-02-01 | 2023-04-01  |        | 
      3 |             | 555 |             |                 | Sweet Dee | 2023-04-01 | 2023-06-01  |        | 
      4 |             |     | E105        | doe@example.com |           | 2023-03-01 | 2023-05-01  |        | 
      5 |             |     | E105        |                 | Sweet Doe | 2023-05-01 | 2023-07-01  |        | 
(5 rows)

\echo

\echo '--- Case 12a: Merging all source rows in a single batch ---'
--- Case 12a: Merging all source rows in a single batch ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data', mode => 'MERGE_ENTITY_UPSERT');
\echo '--- State after single-batch merge (UPSERT mode) ---'
--- State after single-batch merge (UPSERT mode) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      | full_name | valid_from | valid_until 
----+-----+-------------+-----------------+-----------+------------+-------------
  6 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2023-02-01
  6 | 555 | E105        | dee@example.com |           | 2023-02-01 | 2023-03-01
  6 | 555 | E105        | doe@example.com |           | 2023-03-01 | 2023-05-01
  6 | 555 | E105        |                 | Sweet Doe | 2023-05-01 | 2023-07-01
  6 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-07-01 | 2024-01-01
(5 rows)

\echo

\echo '--- Case 12b: Merging in two batches with MERGE_ENTITY_UPSERT ---'
--- Case 12b: Merging in two batches with MERGE_ENTITY_UPSERT ---
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
CREATE TEMP TABLE source_step1_b_12 AS SELECT * FROM source_data WHERE row_id = 1;
CREATE TEMP TABLE source_step2_b_12 AS SELECT * FROM source_data WHERE row_id > 1;
\echo '--- Step 1: Seeding target with first row ---'
--- Step 1: Seeding target with first row ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step1_b_12', mode => 'MERGE_ENTITY_UPSERT');
TABLE identity_discovery.person ORDER BY id,ssn,valid_range;
 id | ssn | employee_nr |    email    | full_name |       valid_range       | valid_from | valid_until 
----+-----+-------------+-------------+-----------+-------------------------+------------+-------------
  1 | 555 | E105        | dee@doe.com | Dee Doe   | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
(1 row)

\echo '--- Step 2: Merging remaining rows ---'
--- Step 2: Merging remaining rows ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step2_b_12', mode => 'MERGE_ENTITY_UPSERT');
\echo '--- State after two-batch merge (UPSERT mode) ---'
--- State after two-batch merge (UPSERT mode) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      | full_name | valid_from | valid_until 
----+-----+-------------+-----------------+-----------+------------+-------------
  1 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2023-02-01
  1 | 555 | E105        | dee@example.com |           | 2023-02-01 | 2023-03-01
  1 | 555 | E105        | doe@example.com |           | 2023-03-01 | 2023-05-01
  1 | 555 | E105        |                 | Sweet Doe | 2023-05-01 | 2023-07-01
  1 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-07-01 | 2024-01-01
(5 rows)

\echo

\echo '--- Case 12c: Merging in two batches with UPDATE_FOR_PORTION_OF ---'
--- Case 12c: Merging in two batches with UPDATE_FOR_PORTION_OF ---
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
CREATE TEMP TABLE source_step1_c_12 AS SELECT * FROM source_data WHERE row_id = 1;
CREATE TEMP TABLE source_step2_c_12 AS SELECT * FROM source_data WHERE row_id > 1;
\echo '--- Step 1: Seeding target with first row ---'
--- Step 1: Seeding target with first row ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step1_c_12', mode => 'MERGE_ENTITY_UPSERT');
TABLE identity_discovery.person ORDER BY id,ssn,valid_range;
 id | ssn | employee_nr |    email    | full_name |       valid_range       | valid_from | valid_until 
----+-----+-------------+-------------+-----------+-------------------------+------------+-------------
  1 | 555 | E105        | dee@doe.com | Dee Doe   | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
(1 row)

\echo '--- Step 2: Merging remaining rows with UPDATE_FOR_PORTION_OF ---'
--- Step 2: Merging remaining rows with UPDATE_FOR_PORTION_OF ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step2_c_12', mode => 'UPDATE_FOR_PORTION_OF');
\echo '--- State after two-batch merge (PORTION_OF mode) ---'
--- State after two-batch merge (PORTION_OF mode) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      | full_name | valid_from | valid_until 
----+-----+-------------+-----------------+-----------+------------+-------------
  1 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2023-02-01
  1 | 555 | E105        | dee@example.com |           | 2023-02-01 | 2023-03-01
  1 | 555 | E105        | doe@example.com |           | 2023-03-01 | 2023-05-01
  1 | 555 | E105        |                 | Sweet Doe | 2023-05-01 | 2023-07-01
  1 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-07-01 | 2024-01-01
(5 rows)

ROLLBACK TO SAVEPOINT s12;
-- 13. Multi-row insert/update of a fragmented entity (REPLACE mode)
\echo '--- Scenario 13: Multi-row insert/update of a fragmented entity (REPLACE mode) ---'
--- Scenario 13: Multi-row insert/update of a fragmented entity (REPLACE mode) ---
SAVEPOINT s13;
-- This scenario uses the same fragmented source data as the PATCH/UPSERT tests,
-- but with REPLACE mode. REPLACE completely overwrites data for overlapping
-- time periods. Unlike PATCH/UPSERT, absent columns in a later source row will
-- cause data from an earlier source row to be removed.
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('555', 'E105', 'dee@doe.com'    , 'Dee Doe'  , '2023-01-01', '2024-01-01'),
    ('555',  NULL , 'dee@example.com', NULL       , '2023-02-01', '2023-04-01'),
    ('555',  NULL , NULL             , 'Sweet Dee', '2023-04-01', '2023-06-01'),
    ( NULL, 'E105', 'doe@example.com', NULL       , '2023-03-01', '2023-05-01'),
    ( NULL, 'E105', NULL             , 'Sweet Doe', '2023-05-01', '2023-07-01');
\echo '--- Source for fragmented entity ---'
--- Source for fragmented entity ---
TABLE source_data ORDER BY row_id;
 row_id | employee_id | ssn | employee_nr |      email      | full_name | valid_from | valid_until | errors | merge_status 
--------+-------------+-----+-------------+-----------------+-----------+------------+-------------+--------+--------------
      1 |             | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2024-01-01  |        | 
      2 |             | 555 |             | dee@example.com |           | 2023-02-01 | 2023-04-01  |        | 
      3 |             | 555 |             |                 | Sweet Dee | 2023-04-01 | 2023-06-01  |        | 
      4 |             |     | E105        | doe@example.com |           | 2023-03-01 | 2023-05-01  |        | 
      5 |             |     | E105        |                 | Sweet Doe | 2023-05-01 | 2023-07-01  |        | 
(5 rows)

\echo

\echo '--- Case 13a: Merging all source rows in a single batch ---'
--- Case 13a: Merging all source rows in a single batch ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data', mode => 'MERGE_ENTITY_REPLACE');
\echo '--- State after single-batch merge (REPLACE mode) ---'
--- State after single-batch merge (REPLACE mode) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      | full_name | valid_from | valid_until 
----+-----+-------------+-----------------+-----------+------------+-------------
  7 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2023-02-01
  7 | 555 | E105        | dee@example.com |           | 2023-02-01 | 2023-03-01
  7 | 555 | E105        | doe@example.com |           | 2023-03-01 | 2023-05-01
  7 | 555 | E105        |                 | Sweet Doe | 2023-05-01 | 2023-07-01
  7 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-07-01 | 2024-01-01
(5 rows)

\echo

\echo '--- Case 13b: Merging in two batches with MERGE_ENTITY_REPLACE ---'
--- Case 13b: Merging in two batches with MERGE_ENTITY_REPLACE ---
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
CREATE TEMP TABLE source_step1_b_13 AS SELECT * FROM source_data WHERE row_id = 1;
CREATE TEMP TABLE source_step2_b_13 AS SELECT * FROM source_data WHERE row_id > 1;
\echo '--- Step 1: Seeding target with first row ---'
--- Step 1: Seeding target with first row ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step1_b_13', mode => 'MERGE_ENTITY_REPLACE');
TABLE identity_discovery.person ORDER BY id,ssn,valid_range;
 id | ssn | employee_nr |    email    | full_name |       valid_range       | valid_from | valid_until 
----+-----+-------------+-------------+-----------+-------------------------+------------+-------------
  1 | 555 | E105        | dee@doe.com | Dee Doe   | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
(1 row)

\echo '--- Step 2: Merging remaining rows ---'
--- Step 2: Merging remaining rows ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step2_b_13', mode => 'MERGE_ENTITY_REPLACE');
\echo '--- State after two-batch merge (REPLACE mode) ---'
--- State after two-batch merge (REPLACE mode) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      | full_name | valid_from | valid_until 
----+-----+-------------+-----------------+-----------+------------+-------------
  1 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2023-02-01
  1 | 555 | E105        | dee@example.com |           | 2023-02-01 | 2023-03-01
  1 | 555 | E105        | doe@example.com |           | 2023-03-01 | 2023-05-01
  1 | 555 | E105        |                 | Sweet Doe | 2023-05-01 | 2023-07-01
  1 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-07-01 | 2024-01-01
(5 rows)

\echo

\echo '--- Case 13c: Merging in two batches with REPLACE_FOR_PORTION_OF ---'
--- Case 13c: Merging in two batches with REPLACE_FOR_PORTION_OF ---
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
CREATE TEMP TABLE source_step1_c_13 AS SELECT * FROM source_data WHERE row_id = 1;
CREATE TEMP TABLE source_step2_c_13 AS SELECT * FROM source_data WHERE row_id > 1;
\echo '--- Step 1: Seeding target with first row ---'
--- Step 1: Seeding target with first row ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step1_c_13', mode => 'MERGE_ENTITY_REPLACE');
TABLE identity_discovery.person ORDER BY id,ssn,valid_range;
 id | ssn | employee_nr |    email    | full_name |       valid_range       | valid_from | valid_until 
----+-----+-------------+-------------+-----------+-------------------------+------------+-------------
  1 | 555 | E105        | dee@doe.com | Dee Doe   | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
(1 row)

\echo '--- Step 2: Merging remaining rows with REPLACE_FOR_PORTION_OF ---'
--- Step 2: Merging remaining rows with REPLACE_FOR_PORTION_OF ---
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_step2_c_13', mode => 'REPLACE_FOR_PORTION_OF');
\echo '--- State after two-batch merge (PORTION_OF mode) ---'
--- State after two-batch merge (PORTION_OF mode) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      | full_name | valid_from | valid_until 
----+-----+-------------+-----------------+-----------+------------+-------------
  1 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2023-02-01
  1 | 555 | E105        | dee@example.com |           | 2023-02-01 | 2023-03-01
  1 | 555 | E105        | doe@example.com |           | 2023-03-01 | 2023-05-01
  1 | 555 | E105        |                 | Sweet Doe | 2023-05-01 | 2023-07-01
  1 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-07-01 | 2024-01-01
(5 rows)

ROLLBACK TO SAVEPOINT s13;
-- 14. Multi-row update of a multi-row target
\echo '--- Scenario 14: Multi-row update of a multi-row target ---'
--- Scenario 14: Multi-row update of a multi-row target ---
SAVEPOINT s14;
-- First, create the same multi-row history for Dee using PATCH mode.
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('555', 'E105', 'dee@doe.com'    , 'Dee Doe'  , '2023-01-01', '2024-01-01'),
    ('555',  NULL , 'dee@example.com', NULL       , '2023-02-01', '2023-04-01'),
    ('555',  NULL , NULL             , 'Sweet Dee', '2023-04-01', '2023-06-01'),
    ( NULL, 'E105', 'doe@example.com', NULL       , '2023-03-01', '2023-05-01'),
    ( NULL, 'E105', NULL             , 'Sweet Doe', '2023-05-01', '2023-07-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data', mode => 'MERGE_ENTITY_PATCH');
\echo '--- State after adding Dee (multi-row target) ---'
--- State after adding Dee (multi-row target) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      | full_name | valid_from | valid_until 
----+-----+-------------+-----------------+-----------+------------+-------------
  8 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2023-02-01
  8 | 555 | E105        | dee@example.com | Dee Doe   | 2023-02-01 | 2023-03-01
  8 | 555 | E105        | doe@example.com | Dee Doe   | 2023-03-01 | 2023-04-01
  8 | 555 | E105        | doe@example.com | Sweet Dee | 2023-04-01 | 2023-05-01
  8 | 555 | E105        | dee@doe.com     | Sweet Doe | 2023-05-01 | 2023-07-01
  8 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-07-01 | 2024-01-01
(6 rows)

-- Now, apply a multi-row update to the multi-row target
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (employee_nr, full_name, valid_from, valid_until) VALUES
    ('E105', 'Bird', '2023-02-01', '2023-05-01'),
    ('E105', 'Aluminum Monster', '2023-07-01', '2023-09-01');
\echo '--- Source for multi-row update ---'
--- Source for multi-row update ---
TABLE source_data;
 row_id | employee_id | ssn | employee_nr | email |    full_name     | valid_from | valid_until | errors | merge_status 
--------+-------------+-----+-------------+-------+------------------+------------+-------------+--------+--------------
      1 |             |     | E105        |       | Bird             | 2023-02-01 | 2023-05-01  |        | 
      2 |             |     | E105        |       | Aluminum Monster | 2023-07-01 | 2023-09-01  |        | 
(2 rows)

CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data'
);
\echo '--- Final state after multi-row update ---'
--- Final state after multi-row update ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      |    full_name     | valid_from | valid_until 
----+-----+-------------+-----------------+------------------+------------+-------------
  8 | 555 | E105        | dee@doe.com     | Dee Doe          | 2023-01-01 | 2023-02-01
  8 | 555 | E105        | dee@example.com | Bird             | 2023-02-01 | 2023-03-01
  8 | 555 | E105        | doe@example.com | Bird             | 2023-03-01 | 2023-05-01
  8 | 555 | E105        | dee@doe.com     | Sweet Doe        | 2023-05-01 | 2023-07-01
  8 | 555 | E105        | dee@doe.com     | Aluminum Monster | 2023-07-01 | 2023-09-01
  8 | 555 | E105        | dee@doe.com     | Dee Doe          | 2023-09-01 | 2024-01-01
(6 rows)

ROLLBACK TO SAVEPOINT s14;
-- 15. Multi-row update of multi-row target with pre-filled stable ID
\echo '--- Scenario 15: Multi-row update of multi-row target with pre-filled stable ID ---'
--- Scenario 15: Multi-row update of multi-row target with pre-filled stable ID ---
SAVEPOINT s15;
-- Reset the target state by truncating and re-populating with all previous entities
-- to ensure the IDENTITY column generates a predictable ID for the final entity.
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('111', 'E101', 'alice@example.com', 'Alice Smith', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('222', 'E102', 'bob@example.com', 'Bob Johnson', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('333', 'E103', 'charlie@example.com', 'Charlie Day', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('444', 'E104', 'dennis@example.com', 'Dennis Reynolds', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
-- Now, re-create the multi-row history for Dee. She will receive id=5.
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('555', 'E105', 'dee@example.com', 'Deandra Reynolds', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (employee_nr, full_name, valid_from, valid_until) VALUES ('E105', 'Sweet Dee', '2023-03-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- State after re-adding Dee (multi-row target) ---'
--- State after re-adding Dee (multi-row target) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      |    full_name     | valid_from | valid_until 
----+-----+-------------+-----------------+------------------+------------+-------------
  5 | 555 | E105        | dee@example.com | Deandra Reynolds | 2023-01-01 | 2023-03-01
  5 | 555 | E105        | dee@example.com | Sweet Dee        | 2023-03-01 | 2024-01-01
(2 rows)

-- The source data now includes the stable `id` which was looked up ahead of time.
TRUNCATE source_data RESTART IDENTITY;
ALTER TABLE source_data ADD COLUMN id INT;
INSERT INTO source_data (id, ssn, employee_nr, full_name, valid_from, valid_until) VALUES
    (5, '555', 'E105', 'Bird', '2023-02-01', '2023-05-01'),
    (5, '555', 'E105', 'Aluminum Monster', '2023-07-01', '2023-09-01');
\echo '--- Source for multi-row update with pre-filled ID ---'
--- Source for multi-row update with pre-filled ID ---
TABLE source_data;
 row_id | employee_id | ssn | employee_nr | email |    full_name     | valid_from | valid_until | errors | merge_status | id 
--------+-------------+-----+-------------+-------+------------------+------------+-------------+--------+--------------+----
      1 |             | 555 | E105        |       | Bird             | 2023-02-01 | 2023-05-01  |        |              |  5
      2 |             | 555 | E105        |       | Aluminum Monster | 2023-07-01 | 2023-09-01  |        |              |  5
(2 rows)

CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['employee_nr'] -- Still provided for robust lookup
);
\echo '--- Final state after multi-row update with pre-filled ID ---'
--- Final state after multi-row update with pre-filled ID ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      |    full_name     | valid_from | valid_until 
----+-----+-------------+-----------------+------------------+------------+-------------
  5 | 555 | E105        | dee@example.com | Deandra Reynolds | 2023-01-01 | 2023-02-01
  5 | 555 | E105        | dee@example.com | Bird             | 2023-02-01 | 2023-05-01
  5 | 555 | E105        | dee@example.com | Sweet Dee        | 2023-05-01 | 2023-07-01
  5 | 555 | E105        | dee@example.com | Aluminum Monster | 2023-07-01 | 2023-09-01
  5 | 555 | E105        | dee@example.com | Sweet Dee        | 2023-09-01 | 2024-01-01
(5 rows)

ROLLBACK TO SAVEPOINT s15;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
