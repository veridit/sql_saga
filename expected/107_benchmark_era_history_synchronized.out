\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
\i sql/include/benchmark_setup.sql
\set ECHO none
SET ROLE TO sql_saga_unprivileged_user;
--------------------------------------------------------------------------------
-- BENCHMARK: Era + System Versioning with Synchronized Columns
--
-- This benchmark uses tables with valid_range AND valid_from/valid_until columns.
-- The synchronization trigger fires on every INSERT/UPDATE to keep them in sync.
-- System versioning (system_time) is enabled for history tracking.
-- This measures the combined overhead of:
-- - Native WITHOUT OVERLAPS constraints
-- - Native temporal foreign keys
-- - System versioning triggers (write_history, generated_always)
-- - PLUS the application-time synchronization trigger
--------------------------------------------------------------------------------
\echo '--- Creating Synchronized Era + History Tables ---'
--- Creating Synchronized Era + History Tables ---
CREATE TABLE parent_era_history_sync (
    id INTEGER,
    valid_range daterange NOT NULL,
    valid_from DATE,
    valid_until DATE,
    name VARCHAR NOT NULL
);
CREATE TABLE child_era_history_sync (
    id INTEGER,
    valid_range daterange NOT NULL,
    valid_from DATE,
    valid_until DATE,
    parent_id INTEGER NOT NULL,
    description TEXT NOT NULL
);
-- Add application-time eras with synchronization (creates sync trigger)
SELECT sql_saga.add_era('parent_era_history_sync'::regclass, 'valid_range', 'valid',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "parent_era_history_sync_synchronize_temporal_columns_trigger" on table parent_era_history_sync to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_era('child_era_history_sync'::regclass, 'valid_range', 'valid',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "child_era_history_sync_synchronize_temporal_columns_trigger" on table child_era_history_sync to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

-- Add unique keys (uses WITHOUT OVERLAPS)
SELECT sql_saga.add_unique_key('parent_era_history_sync'::regclass, ARRAY['id'], 'valid');
NOTICE:  sql_saga: Added constraints to table parent_era_history_sync: ADD CONSTRAINT parent_era_history_sync_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
          add_unique_key          
----------------------------------
 parent_era_history_sync_id_valid
(1 row)

SELECT sql_saga.add_unique_key('child_era_history_sync'::regclass, ARRAY['id'], 'valid');
NOTICE:  sql_saga: Added constraints to table child_era_history_sync: ADD CONSTRAINT child_era_history_sync_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
         add_unique_key          
---------------------------------
 child_era_history_sync_id_valid
(1 row)

-- Add temporal foreign key (uses native PG18 temporal FK)
SELECT sql_saga.add_foreign_key(
    'child_era_history_sync'::regclass,
    ARRAY['parent_id'],
    'parent_era_history_sync'::regclass,
    ARRAY['id'],
    fk_era_name => 'valid',
    create_index => true
);
NOTICE:  sql_saga: No compatible index found for foreign key on table child_era_history_sync. Creating new index: CREATE INDEX child_era_history_sync_parent_id_valid_gist_idx ON child_era_history_sync USING GIST (parent_id, valid_range)
            add_foreign_key             
----------------------------------------
 child_era_history_sync_parent_id_valid
(1 row)

-- Add system versioning (creates system_time era and history triggers)
SELECT sql_saga.add_system_versioning('parent_era_history_sync'::regclass);
 add_system_versioning 
-----------------------
 
(1 row)

SELECT sql_saga.add_system_versioning('child_era_history_sync'::regclass);
 add_system_versioning 
-----------------------
 
(1 row)

-- Create performance indexes
CREATE INDEX ON parent_era_history_sync USING GIST (valid_range);
CREATE INDEX ON child_era_history_sync USING GIST (valid_range);
\echo '--- Populating Synchronized Era + History Tables ---'
--- Populating Synchronized Era + History Tables ---
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Synced Era+History INSERTs start', 0, false);
CALL sql_saga.benchmark_reset();
BEGIN;
DO $$
BEGIN
    FOR i IN 1..10000 LOOP
        INSERT INTO parent_era_history_sync (id, valid_range, name)
        VALUES (i, daterange('2015-01-01', 'infinity', '[)'), 'Company ' || i);
        INSERT INTO child_era_history_sync (id, valid_range, parent_id, description)
        VALUES (i, daterange('2015-01-01', 'infinity', '[)'), i, 'Shop ' || i);
    END LOOP;
END; $$;
END;
CALL sql_saga.benchmark_log_and_reset('Synced Era+History INSERTs');
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Synced Era+History INSERTs end', 10000, true);
ANALYZE parent_era_history_sync;
ANALYZE child_era_history_sync;
--------------------------------------------------------------------------------
\echo '--- UPDATE Benchmarks on Synchronized Era + History Tables ---'
--- UPDATE Benchmarks on Synchronized Era + History Tables ---
--------------------------------------------------------------------------------
-- UPDATE with deferred constraints (temporal key change - split timeline)
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Synced Era+History Update deferred start', 0, false);
CALL sql_saga.benchmark_reset();
BEGIN;
    SET CONSTRAINTS ALL DEFERRED;
    UPDATE parent_era_history_sync
    SET valid_range = daterange(lower(valid_range), '2016-01-01', '[)')
    WHERE id <= 10000 AND lower(valid_range) = '2015-01-01';
    INSERT INTO parent_era_history_sync (id, valid_range, name)
    SELECT id, daterange('2016-01-01', 'infinity', '[)'), name
    FROM parent_era_history_sync
    WHERE upper(valid_range) = '2016-01-01';
    SET CONSTRAINTS ALL IMMEDIATE;
END;
CALL sql_saga.benchmark_log_and_reset('Synced Era+History Update deferred');
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Synced Era+History Update deferred end', 10000, true);
-- UPDATE non-key column (no temporal constraint impact)
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Synced Era+History Update non-key start', 0, false);
CALL sql_saga.benchmark_reset();
BEGIN;
    UPDATE parent_era_history_sync SET name = 'New ' || name WHERE id <= 10000;
END;
CALL sql_saga.benchmark_log_and_reset('Synced Era+History Update non-key');
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Synced Era+History Update non-key end', 10000, true);
-- Show row counts
SELECT 'parent_era_history_sync' AS type, COUNT(*) AS count FROM parent_era_history_sync
UNION ALL
SELECT 'child_era_history_sync' AS type, COUNT(*) AS count FROM child_era_history_sync;
          type           | count 
-------------------------+-------
 parent_era_history_sync | 20000
 child_era_history_sync  | 10000
(2 rows)

--------------------------------------------------------------------------------
\echo '--- Teardown ---'
--- Teardown ---
--------------------------------------------------------------------------------
SELECT sql_saga.drop_foreign_key('child_era_history_sync'::regclass, ARRAY['parent_id'], 'valid');
NOTICE:  sql_saga: Dropping automatically created index "child_era_history_sync_parent_id_valid_gist_idx" for foreign key "child_era_history_sync_parent_id_valid"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_unique_key('child_era_history_sync'::regclass, ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_unique_key('parent_era_history_sync'::regclass, ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_system_versioning('child_era_history_sync'::regclass, cleanup => true);
 drop_system_versioning 
------------------------
 t
(1 row)

SELECT sql_saga.drop_system_versioning('parent_era_history_sync'::regclass, cleanup => true);
 drop_system_versioning 
------------------------
 t
(1 row)

SELECT sql_saga.drop_era('child_era_history_sync'::regclass, cleanup => true);
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_era('parent_era_history_sync'::regclass, cleanup => true);
 drop_era 
----------
 t
(1 row)

DROP TABLE child_era_history_sync;
DROP TABLE parent_era_history_sync;
\echo '-- Performance log from pg_stat_monitor --'
-- Performance log from pg_stat_monitor --
\set monitor_log_filename expected/performance/107_benchmark_era_history_synchronized_monitor.csv
\i sql/include/benchmark_monitor_csv.sql
\set ECHO none
 monitor_log_has_rows 
----------------------
 t
(1 row)

-- Verify the benchmark events and row counts
SELECT event, row_count FROM benchmark ORDER BY seq_id;
                  event                   | row_count 
------------------------------------------+-----------
 BEGIN                                    |         0
 Synced Era+History INSERTs start         |         0
 Synced Era+History INSERTs end           |     10000
 Synced Era+History Update deferred start |         0
 Synced Era+History Update deferred end   |     10000
 Synced Era+History Update non-key start  |         0
 Synced Era+History Update non-key end    |     10000
(7 rows)

-- Capture performance metrics to a separate file
\set benchmark_log_filename expected/performance/107_benchmark_era_history_synchronized_report.log
\i sql/include/benchmark_report_log.sql
\set ECHO none
\i sql/include/benchmark_teardown.sql
\set ECHO none
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
