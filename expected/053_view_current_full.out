\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
CREATE ROLE view_test_role;
BEGIN;
-- A stable function to override now() for deterministic testing
CREATE FUNCTION test_now() RETURNS date AS $$ SELECT '2024-02-29'::date $$ LANGUAGE sql;
GRANT EXECUTE ON FUNCTION test_now() TO PUBLIC;
-- Scenario 1: Test with a table in a non-public schema
CREATE SCHEMA test_schema;
CREATE TABLE test_schema.schema_test (
    id int,
    value text,
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('test_schema.schema_test', 'valid_range', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "schema_test_synchronize_temporal_columns_trigger" on table test_schema.schema_test to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('test_schema.schema_test', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table test_schema.schema_test to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
    add_unique_key    
----------------------
 schema_test_id_valid
(1 row)

SELECT sql_saga.add_current_view('test_schema.schema_test'::regclass, delete_mode := 'delete_as_cutoff', current_func_name := 'test_now()');
 add_current_view 
------------------
 t
(1 row)

\d test_schema.schema_test__current_valid
      View "test_schema.schema_test__current_valid"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 value       | text      |           |          | 
 valid_range | daterange |           |          | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
Triggers:
    current_valid INSTEAD OF INSERT OR DELETE OR UPDATE ON test_schema.schema_test__current_valid FOR EACH ROW EXECUTE FUNCTION sql_saga.current_view_trigger('delete_as_cutoff', 'id')

TABLE sql_saga.updatable_view;
 view_schema |         view_name          | view_type | table_schema | table_name  | era_name | trigger_name  | current_func | generated_columns | ephemeral_columns 
-------------+----------------------------+-----------+--------------+-------------+----------+---------------+--------------+-------------------+-------------------
 test_schema | schema_test__current_valid | current   | test_schema  | schema_test | valid    | current_valid | test_now()   | {}                | 
(1 row)

INSERT INTO test_schema.schema_test__current_valid (id, value) VALUES (1, 'A');
TABLE test_schema.schema_test;
 id | value |      valid_range      | valid_from | valid_until 
----+-------+-----------------------+------------+-------------
  1 | A     | [2024-02-29,infinity) | 2024-02-29 | infinity
(1 row)

TABLE pg_temp.temporal_merge_plan;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until | old_valid_range |    new_valid_range    |      data      | feedback | trace | grouping_key  
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-----------------+-----------------------+----------------+----------+-------+---------------
           1 |             1 | {1}     | INSERT    |               | 1         | t             | {"id": 1}   | {"id": 1}     | {}          |              |              |                |                 | 2024-02-29     | infinity        |                 | [2024-02-29,infinity) | {"value": "A"} |          |       | new_entity__1
(1 row)

TABLE pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
             1 | [{"id": 1}]        | APPLIED | 
(1 row)

DROP TABLE pg_temp.temporal_merge_plan;
CALL sql_saga.temporal_merge_drop_cache();
DROP TABLE pg_temp.temporal_merge_feedback;
SELECT sql_saga.drop_current_view('test_schema.schema_test'::regclass);
 drop_current_view 
-------------------
 t
(1 row)

-- Scenario 2: ACL and Ownership tests
CREATE TABLE acl_test (id int, value text, status text, comment text, valid_range daterange, valid_from date, valid_until date);
ALTER TABLE acl_test OWNER to view_test_role;
SELECT sql_saga.add_era('acl_test', 'valid_range', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "acl_test_synchronize_temporal_columns_trigger" on table acl_test to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('acl_test', ARRAY['id']);
NOTICE:  sql_saga: altering table public.acl_test to add constraints: ADD CONSTRAINT acl_test_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
  add_unique_key   
-------------------
 acl_test_id_valid
(1 row)

SET ROLE view_test_role;
-- This should succeed as the role owns the table
SELECT sql_saga.add_current_view('acl_test'::regclass, delete_mode := 'delete_as_documented_ending', current_func_name := 'test_now()');
 add_current_view 
------------------
 t
(1 row)

RESET ROLE;
-- Verify owner of the view is correct
\d acl_test__current_valid
          View "public.acl_test__current_valid"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 value       | text      |           |          | 
 status      | text      |           |          | 
 comment     | text      |           |          | 
 valid_range | daterange |           |          | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
Triggers:
    current_valid INSTEAD OF INSERT OR DELETE OR UPDATE ON acl_test__current_valid FOR EACH ROW EXECUTE FUNCTION sql_saga.current_view_trigger('delete_as_documented_ending', 'id')

TABLE sql_saga.updatable_view;
 view_schema |        view_name        | view_type | table_schema | table_name | era_name | trigger_name  | current_func | generated_columns | ephemeral_columns 
-------------+-------------------------+-----------+--------------+------------+----------+---------------+--------------+-------------------+-------------------
 public      | acl_test__current_valid | current   | public       | acl_test   | valid    | current_valid | test_now()   | {}                | 
(1 row)

SAVEPOINT preserve_role_and_state_before_no_permission;
-- Verify that permissions are handled correctly
GRANT SELECT ON acl_test TO sql_saga_unprivileged_user;
SET ROLE sql_saga_unprivileged_user;
SELECT CURRENT_ROLE;
        current_role        
----------------------------
 sql_saga_unprivileged_user
(1 row)

SAVEPOINT no_insert;
-- Should fail, as we only have SELECT on the base table, which propagates to the
-- view, but we do not have INSERT on the view.
INSERT INTO acl_test__current_valid (id, value, status) VALUES (1, 'no', 'active');
ERROR:  permission denied for view acl_test__current_valid
ROLLBACK TO no_insert;
SAVEPOINT no_update;
-- Should fail, as we only have SELECT on the base table, which propagates to the
-- view, but we do not have UPDATE on the view.
UPDATE acl_test__current_valid SET value = 'no update' WHERE id = 2;
ERROR:  permission denied for view acl_test__current_valid
ROLLBACK TO no_update;
ROLLBACK TO SAVEPOINT preserve_role_and_state_before_no_permission;
-- Test that INSERT permission on base table doesn't grant UPDATE
SAVEPOINT preserve_role_and_state_before_failing_update;
GRANT INSERT ON acl_test TO sql_saga_unprivileged_user;
SET ROLE sql_saga_unprivileged_user;
-- This should fail before the trigger fires, as the user does not have UPDATE
-- permission on the view. The health_checks trigger ensures that view
-- permissions are synchronized with the base table permissions.
UPDATE acl_test__current_valid SET value = 'no update' WHERE id = 2;
ERROR:  permission denied for view acl_test__current_valid
ROLLBACK TO preserve_role_and_state_before_failing_update;
SAVEPOINT can_insert;
GRANT SELECT, INSERT, UPDATE, DELETE ON acl_test TO sql_saga_unprivileged_user;
-- Insert a record with an old start date to test non-empty range soft-delete
INSERT INTO acl_test (id, valid_from, valid_until, value, status, comment) VALUES (2, '2024-01-01', 'infinity', 'initial', 'active', 'pre-existing');
SET ROLE sql_saga_unprivileged_user;
SELECT CURRENT_ROLE;
        current_role        
----------------------------
 sql_saga_unprivileged_user
(1 row)

-- Test soft-delete on a record with a non-empty lifetime.
-- This should perform an UPDATE to close the record.
UPDATE acl_test__current_valid SET valid_from = 'infinity', status = 'deleted', comment = 'Closed pre-existing' WHERE id = 2;
TABLE acl_test ORDER BY id, valid_from;
 id |  value  | status  |       comment       |       valid_range       | valid_from | valid_until 
----+---------+---------+---------------------+-------------------------+------------+-------------
  2 | initial | deleted | Closed pre-existing | [2024-01-01,2024-02-29) | 2024-01-01 | 2024-02-29
(1 row)

-- Test soft-delete on a record created in the same "instant".
-- This should perform a DELETE as the record had no valid lifetime.
INSERT INTO acl_test__current_valid (id, value, status) VALUES (1, 'yes', 'active');
TABLE acl_test ORDER BY id, valid_from;
 id |  value  | status  |       comment       |       valid_range       | valid_from | valid_until 
----+---------+---------+---------------------+-------------------------+------------+-------------
  1 | yes     | active  |                     | [2024-02-29,infinity)   | 2024-02-29 | infinity
  2 | initial | deleted | Closed pre-existing | [2024-01-01,2024-02-29) | 2024-01-01 | 2024-02-29
(2 rows)

UPDATE acl_test__current_valid SET valid_from = 'infinity', status = 'deleted', comment = 'Closed same-day' WHERE id = 1;
TABLE acl_test ORDER BY id, valid_from;
 id |  value  | status  |       comment       |       valid_range       | valid_from | valid_until 
----+---------+---------+---------------------+-------------------------+------------+-------------
  2 | initial | deleted | Closed pre-existing | [2024-01-01,2024-02-29) | 2024-01-01 | 2024-02-29
(1 row)

ROLLBACK TO can_insert;
SELECT sql_saga.drop_current_view('acl_test'::regclass);
 drop_current_view 
-------------------
 t
(1 row)

-- Scenario 3: Range-only table (no synchronized columns)
-- This tests that the current view works with tables that have ONLY
-- a range column, without valid_from/valid_until/valid_to synchronized columns.
SAVEPOINT scenario_3;
\echo 'Scenario 3: Range-only table for current view'
Scenario 3: Range-only table for current view
CREATE TABLE range_only_employees (
    id int,
    valid_range daterange NOT NULL,
    name text,
    department text,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
-- Register era (range-only, no synchronized columns)
SELECT sql_saga.add_era('range_only_employees', 'valid_range');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('range_only_employees', ARRAY['id']);
NOTICE:  sql_saga: altering table public.range_only_employees to add constraints: ADD CONSTRAINT range_only_employees_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
        add_unique_key         
-------------------------------
 range_only_employees_id_valid
(1 row)

-- Populate with initial data using range column
INSERT INTO range_only_employees (id, valid_range, name, department) VALUES
    (1, '[2023-01-01, 2024-01-01)', 'Alice', 'Engineering'),
    (1, '[2024-01-01, infinity)', 'Alice', 'R&D'),
    (2, '[2023-05-01, infinity)', 'Bob', 'Sales');
\echo '--- Initial base table state ---'
--- Initial base table state ---
TABLE range_only_employees ORDER BY id, valid_range;
 id |       valid_range       | name  | department  
----+-------------------------+-------+-------------
  1 | [2023-01-01,2024-01-01) | Alice | Engineering
  1 | [2024-01-01,infinity)   | Alice | R&D
  2 | [2023-05-01,infinity)   | Bob   | Sales
(3 rows)

-- Add the current view
SELECT sql_saga.add_current_view('range_only_employees'::regclass, current_func_name := 'test_now()');
 add_current_view 
------------------
 t
(1 row)

\d range_only_employees__current_valid
    View "public.range_only_employees__current_valid"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 valid_range | daterange |           |          | 
 name        | text      |           |          | 
 department  | text      |           |          | 
Triggers:
    current_valid INSTEAD OF INSERT OR DELETE OR UPDATE ON range_only_employees__current_valid FOR EACH ROW EXECUTE FUNCTION sql_saga.current_view_trigger('delete_as_cutoff', 'id')

-- Test SELECT: Should show only current records (Alice in R&D and Bob)
\echo '--- Current view SELECT ---'
--- Current view SELECT ---
TABLE range_only_employees__current_valid ORDER BY id;
 id |      valid_range      | name  | department 
----+-----------------------+-------+------------
  1 | [2024-01-01,infinity) | Alice | R&D
  2 | [2023-05-01,infinity) | Bob   | Sales
(2 rows)

-- Test INSERT: Carol joins the company
\echo '--- INSERT via current view ---'
--- INSERT via current view ---
INSERT INTO range_only_employees__current_valid (id, name, department)
VALUES (3, 'Carol', 'Marketing');
TABLE range_only_employees ORDER BY id, valid_range;
 id |       valid_range       | name  | department  
----+-------------------------+-------+-------------
  1 | [2023-01-01,2024-01-01) | Alice | Engineering
  1 | [2024-01-01,infinity)   | Alice | R&D
  2 | [2023-05-01,infinity)   | Bob   | Sales
  3 | [2024-02-29,infinity)   | Carol | Marketing
(4 rows)

-- Test UPDATE (SCD Type 2): Bob moves to Management
\echo '--- UPDATE via current view (SCD Type 2) ---'
--- UPDATE via current view (SCD Type 2) ---
UPDATE range_only_employees__current_valid SET department = 'Management' WHERE id = 2;
TABLE range_only_employees ORDER BY id, valid_range;
 id |       valid_range       | name  | department  
----+-------------------------+-------+-------------
  1 | [2023-01-01,2024-01-01) | Alice | Engineering
  1 | [2024-01-01,infinity)   | Alice | R&D
  2 | [2023-05-01,2024-02-29) | Bob   | Sales
  2 | [2024-02-29,infinity)   | Bob   | Management
  3 | [2024-02-29,infinity)   | Carol | Marketing
(5 rows)

-- Test DELETE (soft delete): Carol leaves (same day as creation = hard delete)
\echo '--- DELETE via current view (soft delete on same-day entity = hard delete) ---'
--- DELETE via current view (soft delete on same-day entity = hard delete) ---
DELETE FROM range_only_employees__current_valid WHERE id = 3;
TABLE range_only_employees ORDER BY id, valid_range;
 id |       valid_range       | name  | department  
----+-------------------------+-------+-------------
  1 | [2023-01-01,2024-01-01) | Alice | Engineering
  1 | [2024-01-01,infinity)   | Alice | R&D
  2 | [2023-05-01,2024-02-29) | Bob   | Sales
  2 | [2024-02-29,infinity)   | Bob   | Management
(4 rows)

-- Current view should now show only Alice and Bob
\echo '--- Final current view state ---'
--- Final current view state ---
TABLE range_only_employees__current_valid ORDER BY id;
 id |      valid_range      | name  | department 
----+-----------------------+-------+------------
  1 | [2024-01-01,infinity) | Alice | R&D
  2 | [2024-02-29,infinity) | Bob   | Management
(2 rows)

SELECT sql_saga.drop_current_view('range_only_employees'::regclass);
 drop_current_view 
-------------------
 t
(1 row)

ROLLBACK TO SAVEPOINT scenario_3;
ROLLBACK;
DROP ROLE view_test_role;
CALL sql_saga.temporal_merge_drop_cache();
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
