\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
CREATE ROLE view_test_role;
BEGIN;
-- A stable function to override now() for deterministic testing
CREATE FUNCTION test_now() RETURNS date AS $$ SELECT '2024-02-29'::date $$ LANGUAGE sql;
GRANT EXECUTE ON FUNCTION test_now() TO PUBLIC;
-- Scenario 1: Test with a table in a non-public schema
CREATE SCHEMA test_schema;
CREATE TABLE test_schema.schema_test (
    id int,
    valid_from date,
    valid_until date,
    value text
);
SELECT sql_saga.add_era('test_schema.schema_test', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('test_schema.schema_test', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table test_schema.schema_test to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_from) DEFERRABLE, ADD CONSTRAINT schema_test_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    add_unique_key    
----------------------
 schema_test_id_valid
(1 row)

SELECT sql_saga.add_current_view('test_schema.schema_test'::regclass, delete_mode := 'delete_as_cutoff', current_func_name := 'test_now()');
 add_current_view 
------------------
 t
(1 row)

\d test_schema.schema_test__current_valid
     View "test_schema.schema_test__current_valid"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 id          | integer |           |          | 
 valid_from  | date    |           |          | 
 valid_until | date    |           |          | 
 value       | text    |           |          | 
Triggers:
    current_valid INSTEAD OF INSERT OR DELETE OR UPDATE ON test_schema.schema_test__current_valid FOR EACH ROW EXECUTE FUNCTION sql_saga.current_view_trigger('delete_as_cutoff', 'id')

TABLE sql_saga.updatable_view;
 view_schema |         view_name          | view_type | table_schema | table_name  | era_name | trigger_name  | current_func 
-------------+----------------------------+-----------+--------------+-------------+----------+---------------+--------------
 test_schema | schema_test__current_valid | current   | test_schema  | schema_test | valid    | current_valid | test_now()
(1 row)

INSERT INTO test_schema.schema_test__current_valid (id, value) VALUES (1, 'A');
TABLE test_schema.schema_test;
 id | valid_from | valid_until | value 
----+------------+-------------+-------
  1 | 2024-02-29 | infinity    | A
(1 row)

TABLE pg_temp.temporal_merge_plan;
 plan_op_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |      data      | feedback | trace | grouping_key  
-------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+----------------+----------+-------+---------------
           1 | {1}     | INSERT    |               | 1         | t             | {"id": 1}   | {"id": 1}     | {}          |              |              |                |                 | 2024-02-29     | infinity        | {"value": "A"} |          |       | new_entity__1
(1 row)

TABLE pg_temp.temporal_merge_feedback;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
             1 | [{"id": 1}]        | APPLIED | 
(1 row)

DROP TABLE pg_temp.temporal_merge_plan;
DROP TABLE pg_temp.temporal_merge_feedback;
DROP TABLE pg_temp.temporal_merge_cache;
SELECT sql_saga.drop_current_view('test_schema.schema_test'::regclass);
 drop_current_view 
-------------------
 t
(1 row)

-- Scenario 2: ACL and Ownership tests
CREATE TABLE acl_test (id int, valid_from date, valid_until date, value text, status text, comment text);
ALTER TABLE acl_test OWNER to view_test_role;
SELECT sql_saga.add_era('acl_test', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('acl_test', ARRAY['id']);
NOTICE:  sql_saga: altering table public.acl_test to add constraints: ADD CONSTRAINT acl_test_id_valid_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT acl_test_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
  add_unique_key   
-------------------
 acl_test_id_valid
(1 row)

SET ROLE view_test_role;
-- This should succeed as the role owns the table
SELECT sql_saga.add_current_view('acl_test'::regclass, delete_mode := 'delete_as_documented_ending', current_func_name := 'test_now()');
 add_current_view 
------------------
 t
(1 row)

RESET ROLE;
-- Verify owner of the view is correct
\d acl_test__current_valid
         View "public.acl_test__current_valid"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 id          | integer |           |          | 
 valid_from  | date    |           |          | 
 valid_until | date    |           |          | 
 value       | text    |           |          | 
 status      | text    |           |          | 
 comment     | text    |           |          | 
Triggers:
    current_valid INSTEAD OF INSERT OR DELETE OR UPDATE ON acl_test__current_valid FOR EACH ROW EXECUTE FUNCTION sql_saga.current_view_trigger('delete_as_documented_ending', 'id')

TABLE sql_saga.updatable_view;
 view_schema |        view_name        | view_type | table_schema | table_name | era_name | trigger_name  | current_func 
-------------+-------------------------+-----------+--------------+------------+----------+---------------+--------------
 public      | acl_test__current_valid | current   | public       | acl_test   | valid    | current_valid | test_now()
(1 row)

SAVEPOINT preserve_role_and_state_before_no_permission;
-- Verify that permissions are handled correctly
GRANT SELECT ON acl_test TO sql_saga_unprivileged_user;
SET ROLE sql_saga_unprivileged_user;
SELECT CURRENT_ROLE;
        current_role        
----------------------------
 sql_saga_unprivileged_user
(1 row)

SAVEPOINT no_insert;
-- Should fail, as we only have SELECT on the base table, which propagates to the
-- view, but we do not have INSERT on the view.
INSERT INTO acl_test__current_valid (id, value, status) VALUES (1, 'no', 'active');
ERROR:  permission denied for view acl_test__current_valid
ROLLBACK TO no_insert;
SAVEPOINT no_update;
-- Should fail, as we only have SELECT on the base table, which propagates to the
-- view, but we do not have UPDATE on the view.
UPDATE acl_test__current_valid SET value = 'no update' WHERE id = 2;
ERROR:  permission denied for view acl_test__current_valid
ROLLBACK TO no_update;
ROLLBACK TO SAVEPOINT preserve_role_and_state_before_no_permission;
-- Test that INSERT permission on base table doesn't grant UPDATE
SAVEPOINT preserve_role_and_state_before_failing_update;
GRANT INSERT ON acl_test TO sql_saga_unprivileged_user;
SET ROLE sql_saga_unprivileged_user;
-- This should fail before the trigger fires, as the user does not have UPDATE
-- permission on the view. The health_checks trigger ensures that view
-- permissions are synchronized with the base table permissions.
UPDATE acl_test__current_valid SET value = 'no update' WHERE id = 2;
ERROR:  permission denied for view acl_test__current_valid
ROLLBACK TO preserve_role_and_state_before_failing_update;
SAVEPOINT can_insert;
GRANT SELECT, INSERT, UPDATE, DELETE ON acl_test TO sql_saga_unprivileged_user;
-- Insert a record with an old start date to test non-empty range soft-delete
INSERT INTO acl_test VALUES (2, '2024-01-01', 'infinity', 'initial', 'active', 'pre-existing');
SET ROLE sql_saga_unprivileged_user;
SELECT CURRENT_ROLE;
        current_role        
----------------------------
 sql_saga_unprivileged_user
(1 row)

-- Test soft-delete on a record with a non-empty lifetime.
-- This should perform an UPDATE to close the record.
UPDATE acl_test__current_valid SET valid_from = 'infinity', status = 'deleted', comment = 'Closed pre-existing' WHERE id = 2;
TABLE acl_test ORDER BY id, valid_from;
 id | valid_from | valid_until |  value  | status  |       comment       
----+------------+-------------+---------+---------+---------------------
  2 | 2024-01-01 | 2024-02-29  | initial | deleted | Closed pre-existing
(1 row)

-- Test soft-delete on a record created in the same "instant".
-- This should perform a DELETE as the record had no valid lifetime.
INSERT INTO acl_test__current_valid (id, value, status) VALUES (1, 'yes', 'active');
TABLE acl_test ORDER BY id, valid_from;
 id | valid_from | valid_until |  value  | status  |       comment       
----+------------+-------------+---------+---------+---------------------
  1 | 2024-02-29 | infinity    | yes     | active  | 
  2 | 2024-01-01 | 2024-02-29  | initial | deleted | Closed pre-existing
(2 rows)

UPDATE acl_test__current_valid SET valid_from = 'infinity', status = 'deleted', comment = 'Closed same-day' WHERE id = 1;
TABLE acl_test ORDER BY id, valid_from;
 id | valid_from | valid_until |  value  | status  |       comment       
----+------------+-------------+---------+---------+---------------------
  2 | 2024-01-01 | 2024-02-29  | initial | deleted | Closed pre-existing
(1 row)

ROLLBACK TO can_insert;
SELECT sql_saga.drop_current_view('acl_test'::regclass);
 drop_current_view 
-------------------
 t
(1 row)

ROLLBACK;
DROP ROLE view_test_role;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
