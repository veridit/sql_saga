\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
\i sql/include/benchmark_setup.sql
\set ECHO none
SET ROLE TO sql_saga_unprivileged_user;
--
-- Benchmark with System Versioning ONLY
--
CREATE TABLE legal_unit_sv (
  id INTEGER,
  name varchar NOT NULL
);
CREATE TABLE establishment_sv (
  id INTEGER,
  legal_unit_id INTEGER NOT NULL,
  postal_place TEXT NOT NULL
);
-- Enable system versioning
SELECT sql_saga.add_system_versioning(table_oid => 'legal_unit_sv');
 add_system_versioning 
-----------------------
 
(1 row)

SELECT sql_saga.add_system_versioning(table_oid => 'establishment_sv');
 add_system_versioning 
-----------------------
 
(1 row)

INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('History Only Benchmark', 0, false);
-- With immediate constraints (the default)
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('History INSERTs start', 0, false);
CALL sql_saga.benchmark_reset();
BEGIN;
-- Optimized: Use bulk INSERT with generate_series (10-50x faster than row-by-row)
INSERT INTO legal_unit_sv (id, name) 
SELECT i, 'Company ' || i FROM generate_series(1, 10000) i;
INSERT INTO establishment_sv (id, legal_unit_id, postal_place) 
SELECT i, i, 'Shop ' || i FROM generate_series(1, 10000) i;
END;
CALL sql_saga.benchmark_log_and_reset('History INSERTs');
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('History INSERTs end', 10000, true);
-- UPDATE
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('History Update start', 0, false);
CALL sql_saga.benchmark_reset();
BEGIN;
  UPDATE legal_unit_sv SET name = 'New ' || name WHERE id <= 10000;
END;
CALL sql_saga.benchmark_log_and_reset('History Update');
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('History Update end', 10000, true);
SELECT 'legal_unit_sv' AS type, COUNT(*) AS count FROM legal_unit_sv
UNION ALL
SELECT 'establishment_sv' AS type, COUNT(*) AS count FROM establishment_sv;
       type       | count 
------------------+-------
 legal_unit_sv    | 10000
 establishment_sv | 10000
(2 rows)

--
-- Benchmark with Eras AND History (System Versioning) - using range-only approach
--
CREATE TABLE legal_unit_era_history (
  id INTEGER,
  valid_range daterange NOT NULL,
  name varchar NOT NULL
);
CREATE TABLE establishment_era_history (
  id INTEGER,
  valid_range daterange NOT NULL,
  legal_unit_id INTEGER NOT NULL,
  postal_place TEXT NOT NULL
);
-- Enable Eras and System Versioning
SELECT sql_saga.add_era('legal_unit_era_history'::regclass, 'valid_range', 'valid');
NOTICE:  sql_saga: Created GIST index "legal_unit_era_history_valid_range_gist_idx" on column public.legal_unit_era_history.valid_range for temporal_merge performance
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_era('establishment_era_history'::regclass, 'valid_range', 'valid');
NOTICE:  sql_saga: Created GIST index "establishment_era_history_valid_range_gist_idx" on column public.establishment_era_history.valid_range for temporal_merge performance
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'legal_unit_era_history', column_names => ARRAY['id'], era_name => 'valid');
NOTICE:  sql_saga: Added constraints to table legal_unit_era_history: ADD CONSTRAINT legal_unit_era_history_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
         add_unique_key          
---------------------------------
 legal_unit_era_history_id_valid
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'establishment_era_history', column_names => ARRAY['id'], era_name => 'valid');
NOTICE:  sql_saga: Added constraints to table establishment_era_history: ADD CONSTRAINT establishment_era_history_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
           add_unique_key           
------------------------------------
 establishment_era_history_id_valid
(1 row)

SELECT sql_saga.add_temporal_foreign_key(
    fk_table_oid => 'establishment_era_history',
    fk_column_names => ARRAY['legal_unit_id'],
    fk_era_name => 'valid',
    unique_key_name => 'legal_unit_era_history_id_valid'
);
NOTICE:  sql_saga: No compatible index found for foreign key on table establishment_era_history. Creating new index: CREATE INDEX establishment_era_history_legal_unit_id_valid_gist_idx ON establishment_era_history USING GIST (legal_unit_id, valid_range)
           add_temporal_foreign_key            
-----------------------------------------------
 establishment_era_history_legal_unit_id_valid
(1 row)

SELECT sql_saga.add_system_versioning(table_oid => 'legal_unit_era_history');
 add_system_versioning 
-----------------------
 
(1 row)

SELECT sql_saga.add_system_versioning(table_oid => 'establishment_era_history');
 add_system_versioning 
-----------------------
 
(1 row)

INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Era + History Benchmark', 0, false);
-- With immediate constraints (the default)
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Era + History INSERTs start', 0, false);
CALL sql_saga.benchmark_reset();
BEGIN;
-- Optimized: Use bulk INSERT with generate_series (10-50x faster than row-by-row)
INSERT INTO legal_unit_era_history (id, valid_range, name) 
SELECT i, daterange('2015-01-01', 'infinity', '[)'), 'Company ' || i 
FROM generate_series(1, 10000) i;
INSERT INTO establishment_era_history (id, valid_range, legal_unit_id, postal_place) 
SELECT i, daterange('2015-01-01', 'infinity', '[)'), i, 'Shop ' || i 
FROM generate_series(1, 10000) i;
END;
CALL sql_saga.benchmark_log_and_reset('Era + History INSERTs');
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Era + History INSERTs end', 10000, true);
-- UPDATE with delayed commit checking
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Era + History Update deferred constraints start', 0, false);
CALL sql_saga.benchmark_reset();
BEGIN;
  SET CONSTRAINTS ALL DEFERRED;
  UPDATE legal_unit_era_history SET valid_range = daterange(lower(valid_range), '2016-01-01', '[)') WHERE id <= 10000 AND lower(valid_range) = '2015-01-01';
  INSERT INTO legal_unit_era_history (id, valid_range, name) SELECT id, daterange('2016-01-01', 'infinity', '[)'), name FROM legal_unit_era_history WHERE upper(valid_range) = '2016-01-01';
  SET CONSTRAINTS ALL IMMEDIATE;
END;
CALL sql_saga.benchmark_log_and_reset('Era + History Update deferred constraints');
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Era + History Update deferred constraints end', 10000, true);
-- UPDATE with immediate constraints (non-key column)
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Era + History Update non-key start', 0, false);
CALL sql_saga.benchmark_reset();
BEGIN;
  UPDATE legal_unit_era_history SET name = 'New ' || name WHERE id <= 10000;
END;
CALL sql_saga.benchmark_log_and_reset('Era + History Update non-key');
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Era + History Update non-key end', 10000, true);
SELECT 'legal_unit_era_history' AS type, COUNT(*) AS count FROM legal_unit_era_history
UNION ALL
SELECT 'establishment_era_history' AS type, COUNT(*) AS count FROM establishment_era_history;
           type            | count 
---------------------------+-------
 legal_unit_era_history    | 20000
 establishment_era_history | 10000
(2 rows)

-- Teardown for SV tables
SELECT sql_saga.drop_system_versioning('establishment_sv', cleanup => true);
 drop_system_versioning 
------------------------
 t
(1 row)

SELECT sql_saga.drop_system_versioning('legal_unit_sv', cleanup => true);
 drop_system_versioning 
------------------------
 t
(1 row)

-- Teardown for Era + History tables
SELECT sql_saga.drop_foreign_key('establishment_era_history', ARRAY['legal_unit_id'], 'valid');
NOTICE:  sql_saga: Dropping automatically created index "establishment_era_history_legal_unit_id_valid_gist_idx" for foreign key "establishment_era_history_legal_unit_id_valid"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_unique_key('establishment_era_history', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_system_versioning('establishment_era_history', cleanup => true);
 drop_system_versioning 
------------------------
 t
(1 row)

SELECT sql_saga.drop_era('establishment_era_history', cleanup => true);
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_unique_key('legal_unit_era_history', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_system_versioning('legal_unit_era_history', cleanup => true);
 drop_system_versioning 
------------------------
 t
(1 row)

SELECT sql_saga.drop_era('legal_unit_era_history', cleanup => true);
 drop_era 
----------
 t
(1 row)

INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Constraints disabled', 0, false);
DROP TABLE establishment_sv;
DROP TABLE legal_unit_sv;
DROP TABLE establishment_era_history;
DROP TABLE legal_unit_era_history;
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Tear down complete', 0, false);
\echo '-- Performance log from pg_stat_monitor --'
-- Performance log from pg_stat_monitor --
\set monitor_log_filename expected/performance/103_benchmark_system_versioning_benchmark_monitor.csv
\i sql/include/benchmark_monitor_csv.sql
\set ECHO none
 monitor_log_has_rows 
----------------------
 t
(1 row)

-- Verify the benchmark events and row counts, but exclude volatile timing data
-- from the regression test output to ensure stability.
SELECT event, row_count FROM benchmark ORDER BY seq_id;
                      event                      | row_count 
-------------------------------------------------+-----------
 BEGIN                                           |         0
 History Only Benchmark                          |         0
 History INSERTs start                           |         0
 History INSERTs end                             |     10000
 History Update start                            |         0
 History Update end                              |     10000
 Era + History Benchmark                         |         0
 Era + History INSERTs start                     |         0
 Era + History INSERTs end                       |     10000
 Era + History Update deferred constraints start |         0
 Era + History Update deferred constraints end   |     10000
 Era + History Update non-key start              |         0
 Era + History Update non-key end                |     10000
 Constraints disabled                            |         0
 Tear down complete                              |         0
(15 rows)

-- Capture performance metrics to a separate file for manual review.
\set benchmark_log_filename expected/performance/103_benchmark_system_versioning_benchmark_report.log
\i sql/include/benchmark_report_log.sql
\set ECHO none
\i sql/include/benchmark_teardown.sql
\set ECHO none
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
