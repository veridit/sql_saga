\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
SET ROLE TO sql_saga_unprivileged_user;
BEGIN;
-- Test that the overloaded drop_* functions work as expected.
CREATE TABLE parent(id int, valid_from int, valid_until int);
SELECT sql_saga.add_era('parent'::regclass, 'valid_from', 'valid_until', 'p');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('parent'::regclass, ARRAY['id']::name[], 'p', key_type => 'natural');
NOTICE:  sql_saga: altering table public.parent to add constraints: ADD CONSTRAINT parent_id_p_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT parent_id_p_excl EXCLUDE USING gist (id WITH =, int4range(valid_from, valid_until) WITH &&) DEFERRABLE
 add_unique_key 
----------------
 parent_id_p
(1 row)

CREATE TABLE child(id int, parent_id int, valid_from int, valid_until int);
SELECT sql_saga.add_era('child'::regclass, 'valid_from', 'valid_until', 'q');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_temporal_foreign_key('child'::regclass, ARRAY['parent_id']::name[], 'q', 'parent_id_p');
NOTICE:  No compatible index found for foreign key on table child. Creating new index: CREATE INDEX child_parent_id_q_gist_idx ON child USING GIST (parent_id, int4range(valid_from, valid_until))
 add_temporal_foreign_key 
--------------------------
 child_parent_id_q
(1 row)

-- Test overloaded drop_foreign_key for temporal-to-temporal
TABLE sql_saga.foreign_keys;
 foreign_key_name  |         type         | table_schema | table_name | column_names | fk_era_name |       fk_table_columns_snapshot       | unique_key_name | match_type | update_action | delete_action |      fk_insert_trigger      |      fk_update_trigger      | fk_check_constraint | fk_helper_function |      uk_update_trigger      |      uk_delete_trigger      |       fk_index_name        
-------------------+----------------------+--------------+------------+--------------+-------------+---------------------------------------+-----------------+------------+---------------+---------------+-----------------------------+-----------------------------+---------------------+--------------------+-----------------------------+-----------------------------+----------------------------
 child_parent_id_q | temporal_to_temporal | public       | child      | {parent_id}  | q           | {id,parent_id,valid_from,valid_until} | parent_id_p     | SIMPLE     | NO ACTION     | NO ACTION     | child_parent_id_q_fk_insert | child_parent_id_q_fk_update |                     |                    | child_parent_id_q_uk_update | child_parent_id_q_uk_delete | child_parent_id_q_gist_idx
(1 row)

SELECT sql_saga.drop_foreign_key('child'::regclass, ARRAY['parent_id']::name[], 'q');
NOTICE:  Dropping automatically created index "child_parent_id_q_gist_idx" for foreign key "child_parent_id_q"
 drop_foreign_key 
------------------
 
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name | type | table_schema | table_name | column_names | fk_era_name | fk_table_columns_snapshot | unique_key_name | match_type | update_action | delete_action | fk_insert_trigger | fk_update_trigger | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger | fk_index_name 
------------------+------+--------------+------------+--------------+-------------+---------------------------+-----------------+------------+---------------+---------------+-------------------+-------------------+---------------------+--------------------+-------------------+-------------------+---------------
(0 rows)

-- Test original drop_foreign_key (with positional and named arguments)
SELECT sql_saga.add_temporal_foreign_key('child'::regclass, ARRAY['parent_id']::name[], 'q', 'parent_id_p');
NOTICE:  No compatible index found for foreign key on table child. Creating new index: CREATE INDEX child_parent_id_q_gist_idx ON child USING GIST (parent_id, int4range(valid_from, valid_until))
 add_temporal_foreign_key 
--------------------------
 child_parent_id_q
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name  |         type         | table_schema | table_name | column_names | fk_era_name |       fk_table_columns_snapshot       | unique_key_name | match_type | update_action | delete_action |      fk_insert_trigger      |      fk_update_trigger      | fk_check_constraint | fk_helper_function |      uk_update_trigger      |      uk_delete_trigger      |       fk_index_name        
-------------------+----------------------+--------------+------------+--------------+-------------+---------------------------------------+-----------------+------------+---------------+---------------+-----------------------------+-----------------------------+---------------------+--------------------+-----------------------------+-----------------------------+----------------------------
 child_parent_id_q | temporal_to_temporal | public       | child      | {parent_id}  | q           | {id,parent_id,valid_from,valid_until} | parent_id_p     | SIMPLE     | NO ACTION     | NO ACTION     | child_parent_id_q_fk_insert | child_parent_id_q_fk_update |                     |                    | child_parent_id_q_uk_update | child_parent_id_q_uk_delete | child_parent_id_q_gist_idx
(1 row)

-- by name (positional)
SELECT sql_saga.drop_foreign_key_by_name('child'::regclass, 'child_parent_id_q');
NOTICE:  Dropping automatically created index "child_parent_id_q_gist_idx" for foreign key "child_parent_id_q"
 drop_foreign_key_by_name 
--------------------------
 t
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name | type | table_schema | table_name | column_names | fk_era_name | fk_table_columns_snapshot | unique_key_name | match_type | update_action | delete_action | fk_insert_trigger | fk_update_trigger | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger | fk_index_name 
------------------+------+--------------+------------+--------------+-------------+---------------------------+-----------------+------------+---------------+---------------+-------------------+-------------------+---------------------+--------------------+-------------------+-------------------+---------------
(0 rows)

-- Re-create to test named arguments
SELECT sql_saga.add_temporal_foreign_key('child'::regclass, ARRAY['parent_id']::name[], 'q', 'parent_id_p');
NOTICE:  No compatible index found for foreign key on table child. Creating new index: CREATE INDEX child_parent_id_q_gist_idx ON child USING GIST (parent_id, int4range(valid_from, valid_until))
 add_temporal_foreign_key 
--------------------------
 child_parent_id_q
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name  |         type         | table_schema | table_name | column_names | fk_era_name |       fk_table_columns_snapshot       | unique_key_name | match_type | update_action | delete_action |      fk_insert_trigger      |      fk_update_trigger      | fk_check_constraint | fk_helper_function |      uk_update_trigger      |      uk_delete_trigger      |       fk_index_name        
-------------------+----------------------+--------------+------------+--------------+-------------+---------------------------------------+-----------------+------------+---------------+---------------+-----------------------------+-----------------------------+---------------------+--------------------+-----------------------------+-----------------------------+----------------------------
 child_parent_id_q | temporal_to_temporal | public       | child      | {parent_id}  | q           | {id,parent_id,valid_from,valid_until} | parent_id_p     | SIMPLE     | NO ACTION     | NO ACTION     | child_parent_id_q_fk_insert | child_parent_id_q_fk_update |                     |                    | child_parent_id_q_uk_update | child_parent_id_q_uk_delete | child_parent_id_q_gist_idx
(1 row)

-- by name (named)
SELECT sql_saga.drop_foreign_key_by_name(table_oid => 'child'::regclass, key_name => 'child_parent_id_q');
NOTICE:  Dropping automatically created index "child_parent_id_q_gist_idx" for foreign key "child_parent_id_q"
 drop_foreign_key_by_name 
--------------------------
 t
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name | type | table_schema | table_name | column_names | fk_era_name | fk_table_columns_snapshot | unique_key_name | match_type | update_action | delete_action | fk_insert_trigger | fk_update_trigger | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger | fk_index_name 
------------------+------+--------------+------------+--------------+-------------+---------------------------+-----------------+------------+---------------+---------------+-------------------+-------------------+---------------------+--------------------+-------------------+-------------------+---------------
(0 rows)

-- Test overloaded drop_foreign_key for regular-to-temporal
CREATE TABLE regular_child(id int, parent_id int);
SELECT sql_saga.add_regular_foreign_key('regular_child'::regclass, ARRAY['parent_id']::name[], 'parent_id_p');
NOTICE:  No compatible index found for foreign key on table regular_child. Creating new index: CREATE INDEX regular_child_parent_id_idx ON regular_child USING BTREE (parent_id)
   add_regular_foreign_key    
------------------------------
 regular_child_parent_id_fkey
(1 row)

TABLE sql_saga.foreign_keys;
       foreign_key_name       |        type         | table_schema |  table_name   | column_names | fk_era_name | fk_table_columns_snapshot | unique_key_name | match_type | update_action | delete_action | fk_insert_trigger | fk_update_trigger |      fk_check_constraint      |        fk_helper_function        |           uk_update_trigger            |           uk_delete_trigger            |        fk_index_name        
------------------------------+---------------------+--------------+---------------+--------------+-------------+---------------------------+-----------------+------------+---------------+---------------+-------------------+-------------------+-------------------------------+----------------------------------+----------------------------------------+----------------------------------------+-----------------------------
 regular_child_parent_id_fkey | regular_to_temporal | public       | regular_child | {parent_id}  |             | {id,parent_id}            | parent_id_p     | SIMPLE     | NO ACTION     | NO ACTION     |                   |                   | regular_child_parent_id_check | public.parent_id_exists(integer) | regular_child_parent_id_fkey_uk_update | regular_child_parent_id_fkey_uk_delete | regular_child_parent_id_idx
(1 row)

SELECT sql_saga.drop_foreign_key('regular_child'::regclass, ARRAY['parent_id']::name[]);
NOTICE:  Dropping automatically created index "regular_child_parent_id_idx" for foreign key "regular_child_parent_id_fkey"
 drop_foreign_key 
------------------
 
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name | type | table_schema | table_name | column_names | fk_era_name | fk_table_columns_snapshot | unique_key_name | match_type | update_action | delete_action | fk_insert_trigger | fk_update_trigger | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger | fk_index_name 
------------------+------+--------------+------------+--------------+-------------+---------------------------+-----------------+------------+---------------+---------------+-------------------+-------------------+---------------------+--------------------+-------------------+-------------------+---------------
(0 rows)

DROP TABLE regular_child;
-- Test overloaded drop_unique_key
TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
 parent_id_p     | public       | parent     | natural  | {id}         | p        | parent_id_p_uniq  | parent_id_p_excl   |                  |           |                            |                     |                                  | {}
(1 row)

SELECT sql_saga.drop_unique_key('parent'::regclass, ARRAY['id']::name[], 'p');
 drop_unique_key 
-----------------
 
(1 row)

TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
(0 rows)

-- Test original drop_unique_key (with positional and named arguments)
SELECT sql_saga.add_unique_key('parent'::regclass, ARRAY['id']::name[], 'p', key_type => 'natural');
NOTICE:  sql_saga: altering table public.parent to add constraints: ADD CONSTRAINT parent_id_p_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT parent_id_p_excl EXCLUDE USING gist (id WITH =, int4range(valid_from, valid_until) WITH &&) DEFERRABLE
 add_unique_key 
----------------
 parent_id_p
(1 row)

TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
 parent_id_p     | public       | parent     | natural  | {id}         | p        | parent_id_p_uniq  | parent_id_p_excl   |                  |           |                            |                     |                                  | {}
(1 row)

-- by name (positional)
SELECT sql_saga.drop_unique_key_by_name('parent'::regclass, 'parent_id_p');
 drop_unique_key_by_name 
-------------------------
 
(1 row)

TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
(0 rows)

-- Re-create to test named arguments
SELECT sql_saga.add_unique_key('parent'::regclass, ARRAY['id']::name[], 'p', key_type => 'natural');
NOTICE:  sql_saga: altering table public.parent to add constraints: ADD CONSTRAINT parent_id_p_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT parent_id_p_excl EXCLUDE USING gist (id WITH =, int4range(valid_from, valid_until) WITH &&) DEFERRABLE
 add_unique_key 
----------------
 parent_id_p
(1 row)

TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
 parent_id_p     | public       | parent     | natural  | {id}         | p        | parent_id_p_uniq  | parent_id_p_excl   |                  |           |                            |                     |                                  | {}
(1 row)

-- by name (named)
SELECT sql_saga.drop_unique_key_by_name(table_oid => 'parent'::regclass, key_name => 'parent_id_p');
 drop_unique_key_by_name 
-------------------------
 
(1 row)

TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
(0 rows)

-- Test symmetrical add_era/drop_era with column management
CREATE TABLE era_symmetry_test(id int);
\d era_symmetry_test
         Table "public.era_symmetry_test"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 id     | integer |           |          | 

-- 1. Create era and columns together
SELECT sql_saga.add_era('era_symmetry_test'::regclass, 'v_from', 'v_until', 'v', create_columns => true);
 add_era 
---------
 t
(1 row)

\d era_symmetry_test
                                 Table "public.era_symmetry_test"
 Column  |           Type           | Collation | Nullable |               Default                
---------+--------------------------+-----------+----------+--------------------------------------
 id      | integer                  |           |          | 
 v_from  | timestamp with time zone |           | not null | 
 v_until | timestamp with time zone |           | not null | 'infinity'::timestamp with time zone
Check constraints:
    "era_symmetry_test_v_check" CHECK (v_from < v_until AND v_from > '-infinity'::timestamp with time zone)

-- 2. Drop era and columns together
SELECT sql_saga.drop_era('era_symmetry_test'::regclass, 'v', cleanup => true);
 drop_era 
----------
 t
(1 row)

\d era_symmetry_test
         Table "public.era_symmetry_test"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 id     | integer |           |          | 

-- 3. Verify add_era fails without create_columns => true
SAVEPOINT before_fail;
SELECT sql_saga.add_era('era_symmetry_test'::regclass, 'v_from', 'v_until', 'v');
ERROR:  column "v_from" not found in table "era_symmetry_test"
CONTEXT:  PL/pgSQL function sql_saga.add_era(regclass,name,name,name,regtype,name,name,name,boolean,boolean,boolean) line 149 at RAISE
ROLLBACK TO SAVEPOINT before_fail;
-- 4. Create columns manually, then add era
ALTER TABLE era_symmetry_test ADD COLUMN v_from timestamptz, ADD COLUMN v_until timestamptz;
SELECT sql_saga.add_era('era_symmetry_test'::regclass, 'v_from', 'v_until', 'v');
 add_era 
---------
 t
(1 row)

\d era_symmetry_test
                                 Table "public.era_symmetry_test"
 Column  |           Type           | Collation | Nullable |               Default                
---------+--------------------------+-----------+----------+--------------------------------------
 id      | integer                  |           |          | 
 v_from  | timestamp with time zone |           | not null | 
 v_until | timestamp with time zone |           | not null | 'infinity'::timestamp with time zone
Check constraints:
    "era_symmetry_test_v_check" CHECK (v_from < v_until AND v_from > '-infinity'::timestamp with time zone)

-- 5. Drop era but leave columns (default behavior)
SELECT sql_saga.drop_era('era_symmetry_test'::regclass, 'v');
 drop_era 
----------
 t
(1 row)

\d era_symmetry_test
                                 Table "public.era_symmetry_test"
 Column  |           Type           | Collation | Nullable |               Default                
---------+--------------------------+-----------+----------+--------------------------------------
 id      | integer                  |           |          | 
 v_from  | timestamp with time zone |           | not null | 
 v_until | timestamp with time zone |           | not null | 'infinity'::timestamp with time zone

DROP TABLE era_symmetry_test;
-- Note: The FK and UK were already dropped in the earlier parts of this test.
-- We only need to drop the eras and tables.
SELECT sql_saga.drop_era('child'::regclass, 'q');
 drop_era 
----------
 t
(1 row)

DROP TABLE child;
SELECT sql_saga.drop_era('parent'::regclass, 'p');
 drop_era 
----------
 t
(1 row)

DROP TABLE parent;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
