\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
SET ROLE TO sql_saga_unprivileged_user;
BEGIN;
-- Test that the overloaded drop_* functions work as expected.
CREATE TABLE parent(id int, valid int4range, valid_from int, valid_until int);
SELECT sql_saga.add_era('parent'::regclass, 'valid', 'p');
NOTICE:  sql_saga: Created trigger "parent_synchronize_temporal_columns_trigger" on table parent to synchronize columns: valid_from, valid_until
NOTICE:  sql_saga: Created GIST index "parent_valid_gist_idx" on column public.parent.valid for temporal_merge performance
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('parent'::regclass, ARRAY['id']::name[], 'p', key_type => 'natural');
NOTICE:  sql_saga: Added constraints to table parent: ADD CONSTRAINT parent_id_p_uniq UNIQUE (id, valid WITHOUT OVERLAPS)
 add_unique_key 
----------------
 parent_id_p
(1 row)

TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | pk_consistency_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------------------
 parent_id_p     | public       | parent     | natural  | {id}         | p        | parent_id_p_uniq  |                    |                  |           |                            | {}
(1 row)

CREATE TABLE child(id int, parent_id int, valid int4range, valid_from int, valid_until int);
SELECT sql_saga.add_era('child'::regclass, 'valid', 'q');
NOTICE:  sql_saga: Created trigger "child_synchronize_temporal_columns_trigger" on table child to synchronize columns: valid_from, valid_until
NOTICE:  sql_saga: Created GIST index "child_valid_gist_idx" on column public.child.valid for temporal_merge performance
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_temporal_foreign_key('child'::regclass, ARRAY['parent_id']::name[], 'q', 'parent_id_p');
NOTICE:  sql_saga: No compatible index found for foreign key on table child. Creating new index: CREATE INDEX child_parent_id_q_gist_idx ON child USING GIST (parent_id, valid)
 add_temporal_foreign_key 
--------------------------
 child_parent_id_q
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name  |         type         | table_schema | table_name | column_names | fk_era_name |          fk_table_columns_snapshot          | unique_key_name | match_type | update_action | delete_action | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger |       fk_index_name        
-------------------+----------------------+--------------+------------+--------------+-------------+---------------------------------------------+-----------------+------------+---------------+---------------+---------------------+--------------------+-------------------+-------------------+----------------------------
 child_parent_id_q | temporal_to_temporal | public       | child      | {parent_id}  | q           | {id,parent_id,valid,valid_from,valid_until} | parent_id_p     | SIMPLE     | NO ACTION     | NO ACTION     |                     |                    |                   |                   | child_parent_id_q_gist_idx
(1 row)

-- Test overloaded drop_foreign_key for temporal-to-temporal
SELECT sql_saga.drop_foreign_key('child'::regclass, ARRAY['parent_id']::name[], 'q');
NOTICE:  sql_saga: Dropping automatically created index "child_parent_id_q_gist_idx" for foreign key "child_parent_id_q"
 drop_foreign_key 
------------------
 
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name | type | table_schema | table_name | column_names | fk_era_name | fk_table_columns_snapshot | unique_key_name | match_type | update_action | delete_action | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger | fk_index_name 
------------------+------+--------------+------------+--------------+-------------+---------------------------+-----------------+------------+---------------+---------------+---------------------+--------------------+-------------------+-------------------+---------------
(0 rows)

-- Test original drop_foreign_key (with positional and named arguments)
SELECT sql_saga.add_temporal_foreign_key('child'::regclass, ARRAY['parent_id']::name[], 'q', 'parent_id_p');
NOTICE:  sql_saga: No compatible index found for foreign key on table child. Creating new index: CREATE INDEX child_parent_id_q_gist_idx ON child USING GIST (parent_id, valid)
 add_temporal_foreign_key 
--------------------------
 child_parent_id_q
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name  |         type         | table_schema | table_name | column_names | fk_era_name |          fk_table_columns_snapshot          | unique_key_name | match_type | update_action | delete_action | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger |       fk_index_name        
-------------------+----------------------+--------------+------------+--------------+-------------+---------------------------------------------+-----------------+------------+---------------+---------------+---------------------+--------------------+-------------------+-------------------+----------------------------
 child_parent_id_q | temporal_to_temporal | public       | child      | {parent_id}  | q           | {id,parent_id,valid,valid_from,valid_until} | parent_id_p     | SIMPLE     | NO ACTION     | NO ACTION     |                     |                    |                   |                   | child_parent_id_q_gist_idx
(1 row)

-- by name (positional)
SELECT sql_saga.drop_foreign_key_by_name('child'::regclass, 'child_parent_id_q');
NOTICE:  sql_saga: Dropping automatically created index "child_parent_id_q_gist_idx" for foreign key "child_parent_id_q"
 drop_foreign_key_by_name 
--------------------------
 t
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name | type | table_schema | table_name | column_names | fk_era_name | fk_table_columns_snapshot | unique_key_name | match_type | update_action | delete_action | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger | fk_index_name 
------------------+------+--------------+------------+--------------+-------------+---------------------------+-----------------+------------+---------------+---------------+---------------------+--------------------+-------------------+-------------------+---------------
(0 rows)

-- Re-create to test named arguments
SELECT sql_saga.add_temporal_foreign_key('child'::regclass, ARRAY['parent_id']::name[], 'q', 'parent_id_p');
NOTICE:  sql_saga: No compatible index found for foreign key on table child. Creating new index: CREATE INDEX child_parent_id_q_gist_idx ON child USING GIST (parent_id, valid)
 add_temporal_foreign_key 
--------------------------
 child_parent_id_q
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name  |         type         | table_schema | table_name | column_names | fk_era_name |          fk_table_columns_snapshot          | unique_key_name | match_type | update_action | delete_action | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger |       fk_index_name        
-------------------+----------------------+--------------+------------+--------------+-------------+---------------------------------------------+-----------------+------------+---------------+---------------+---------------------+--------------------+-------------------+-------------------+----------------------------
 child_parent_id_q | temporal_to_temporal | public       | child      | {parent_id}  | q           | {id,parent_id,valid,valid_from,valid_until} | parent_id_p     | SIMPLE     | NO ACTION     | NO ACTION     |                     |                    |                   |                   | child_parent_id_q_gist_idx
(1 row)

-- by name (named)
SELECT sql_saga.drop_foreign_key_by_name(table_oid => 'child'::regclass, key_name => 'child_parent_id_q');
NOTICE:  sql_saga: Dropping automatically created index "child_parent_id_q_gist_idx" for foreign key "child_parent_id_q"
 drop_foreign_key_by_name 
--------------------------
 t
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name | type | table_schema | table_name | column_names | fk_era_name | fk_table_columns_snapshot | unique_key_name | match_type | update_action | delete_action | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger | fk_index_name 
------------------+------+--------------+------------+--------------+-------------+---------------------------+-----------------+------------+---------------+---------------+---------------------+--------------------+-------------------+-------------------+---------------
(0 rows)

-- Test overloaded drop_foreign_key for regular-to-temporal
CREATE TABLE regular_child(id int, parent_id int);
SELECT sql_saga.add_regular_foreign_key('regular_child'::regclass, ARRAY['parent_id']::name[], 'parent_id_p');
NOTICE:  sql_saga: No compatible index found for foreign key on table regular_child. Creating new index: CREATE INDEX regular_child_parent_id_idx ON regular_child USING BTREE (parent_id)
   add_regular_foreign_key    
------------------------------
 regular_child_parent_id_fkey
(1 row)

TABLE sql_saga.foreign_keys;
       foreign_key_name       |        type         | table_schema |  table_name   | column_names | fk_era_name | fk_table_columns_snapshot | unique_key_name | match_type | update_action | delete_action |      fk_check_constraint      |        fk_helper_function        |           uk_update_trigger            |           uk_delete_trigger            |        fk_index_name        
------------------------------+---------------------+--------------+---------------+--------------+-------------+---------------------------+-----------------+------------+---------------+---------------+-------------------------------+----------------------------------+----------------------------------------+----------------------------------------+-----------------------------
 regular_child_parent_id_fkey | regular_to_temporal | public       | regular_child | {parent_id}  |             | {id,parent_id}            | parent_id_p     | SIMPLE     | NO ACTION     | NO ACTION     | regular_child_parent_id_check | public.parent_id_exists(integer) | regular_child_parent_id_fkey_uk_update | regular_child_parent_id_fkey_uk_delete | regular_child_parent_id_idx
(1 row)

SELECT sql_saga.drop_foreign_key('regular_child'::regclass, ARRAY['parent_id']::name[]);
NOTICE:  sql_saga: Dropping automatically created index "regular_child_parent_id_idx" for foreign key "regular_child_parent_id_fkey"
 drop_foreign_key 
------------------
 
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name | type | table_schema | table_name | column_names | fk_era_name | fk_table_columns_snapshot | unique_key_name | match_type | update_action | delete_action | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger | fk_index_name 
------------------+------+--------------+------------+--------------+-------------+---------------------------+-----------------+------------+---------------+---------------+---------------------+--------------------+-------------------+-------------------+---------------
(0 rows)

DROP TABLE regular_child;
-- Test overloaded drop_unique_key
TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | pk_consistency_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------------------
 parent_id_p     | public       | parent     | natural  | {id}         | p        | parent_id_p_uniq  |                    |                  |           |                            | {}
(1 row)

SELECT sql_saga.drop_unique_key('parent'::regclass, ARRAY['id']::name[], 'p');
 drop_unique_key 
-----------------
 
(1 row)

TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | pk_consistency_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------------------
(0 rows)

-- Test original drop_unique_key (with positional and named arguments)
SELECT sql_saga.add_unique_key('parent'::regclass, ARRAY['id']::name[], 'p', key_type => 'natural');
NOTICE:  sql_saga: Added constraints to table parent: ADD CONSTRAINT parent_id_p_uniq UNIQUE (id, valid WITHOUT OVERLAPS)
 add_unique_key 
----------------
 parent_id_p
(1 row)

TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | pk_consistency_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------------------
 parent_id_p     | public       | parent     | natural  | {id}         | p        | parent_id_p_uniq  |                    |                  |           |                            | {}
(1 row)

-- by name (positional)
SELECT sql_saga.drop_unique_key_by_name('parent'::regclass, 'parent_id_p');
 drop_unique_key_by_name 
-------------------------
 
(1 row)

TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | pk_consistency_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------------------
(0 rows)

-- Re-create to test named arguments
SELECT sql_saga.add_unique_key('parent'::regclass, ARRAY['id']::name[], 'p', key_type => 'natural');
NOTICE:  sql_saga: Added constraints to table parent: ADD CONSTRAINT parent_id_p_uniq UNIQUE (id, valid WITHOUT OVERLAPS)
 add_unique_key 
----------------
 parent_id_p
(1 row)

TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | pk_consistency_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------------------
 parent_id_p     | public       | parent     | natural  | {id}         | p        | parent_id_p_uniq  |                    |                  |           |                            | {}
(1 row)

-- by name (named)
SELECT sql_saga.drop_unique_key_by_name(table_oid => 'parent'::regclass, key_name => 'parent_id_p');
 drop_unique_key_by_name 
-------------------------
 
(1 row)

TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | pk_consistency_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------------------
(0 rows)

-- Test symmetrical add_era/drop_era with column management
CREATE TABLE era_symmetry_test(id int);
\d era_symmetry_test
         Table "public.era_symmetry_test"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 id     | integer |           |          | 

-- 1. Create era and columns together
SELECT sql_saga.add_era(table_oid => 'era_symmetry_test'::regclass, range_column_name => 'v', create_columns => true, range_type => 'tstzrange'::regtype);
NOTICE:  sql_saga: Created GIST index "era_symmetry_test_v_gist_idx" on column public.era_symmetry_test.v for temporal_merge performance
 add_era 
---------
 t
(1 row)

\d era_symmetry_test
          Table "public.era_symmetry_test"
 Column |   Type    | Collation | Nullable | Default 
--------+-----------+-----------+----------+---------
 id     | integer   |           |          | 
 v      | tstzrange |           | not null | 
Indexes:
    "era_symmetry_test_v_gist_idx" gist (v) WITH (fillfactor='90')
Check constraints:
    "era_symmetry_test_valid_check" CHECK (NOT isempty(v))

-- 2. Drop era and columns together
SELECT sql_saga.drop_era('era_symmetry_test'::regclass, cleanup => true);
 drop_era 
----------
 t
(1 row)

\d era_symmetry_test
         Table "public.era_symmetry_test"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 id     | integer |           |          | 

-- 3. Verify add_era fails without create_columns => true
SAVEPOINT before_fail;
SELECT sql_saga.add_era('era_symmetry_test'::regclass, 'v');
ERROR:  range column "v" not found in table "era_symmetry_test"
CONTEXT:  PL/pgSQL function sql_saga.add_era(regclass,name,name,boolean,name,name,name,boolean,boolean,boolean,regtype,name,name[]) line 167 at RAISE
ROLLBACK TO SAVEPOINT before_fail;
-- 4. Create columns manually, then add era
ALTER TABLE era_symmetry_test ADD COLUMN v tstzrange;
SELECT sql_saga.add_era('era_symmetry_test'::regclass, 'v');
NOTICE:  sql_saga: Created GIST index "era_symmetry_test_v_gist_idx" on column public.era_symmetry_test.v for temporal_merge performance
 add_era 
---------
 t
(1 row)

\d era_symmetry_test
          Table "public.era_symmetry_test"
 Column |   Type    | Collation | Nullable | Default 
--------+-----------+-----------+----------+---------
 id     | integer   |           |          | 
 v      | tstzrange |           | not null | 
Indexes:
    "era_symmetry_test_v_gist_idx" gist (v) WITH (fillfactor='90')
Check constraints:
    "era_symmetry_test_valid_check" CHECK (NOT isempty(v))

-- 5. Drop era but leave columns (default behavior)
SELECT sql_saga.drop_era('era_symmetry_test'::regclass);
 drop_era 
----------
 t
(1 row)

\d era_symmetry_test
          Table "public.era_symmetry_test"
 Column |   Type    | Collation | Nullable | Default 
--------+-----------+-----------+----------+---------
 id     | integer   |           |          | 
 v      | tstzrange |           | not null | 
Indexes:
    "era_symmetry_test_v_gist_idx" gist (v) WITH (fillfactor='90')

DROP TABLE era_symmetry_test;
-- Note: The FK and UK were already dropped in the earlier parts of this test.
-- We only need to drop the eras and tables.
SELECT sql_saga.drop_era('child'::regclass, 'q');
 drop_era 
----------
 t
(1 row)

DROP TABLE child;
SELECT sql_saga.drop_era('parent'::regclass, 'p');
 drop_era 
----------
 t
(1 row)

DROP TABLE parent;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
