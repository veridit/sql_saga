\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
/* Run tests as unprivileged user */
SET ROLE TO sql_saga_unprivileged_user;
/*
 * Create a sequence to test non-serial primary keys.  This actually tests
 * things like uuid primary keys, but makes for reproducible test cases.
 */
CREATE SEQUENCE pricing_seq;
CREATE TABLE pricing (id1 bigserial,
                      id2 bigint PRIMARY KEY DEFAULT nextval('pricing_seq'),
                      id3 bigint GENERATED ALWAYS AS IDENTITY,
                      id4 bigint GENERATED ALWAYS AS (id1 + id2) STORED,
                      product text, quantity_from integer, quantity_until integer, price numeric);
SELECT sql_saga.add_era('pricing', 'quantity_from', 'quantity_until', 'quantities');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_for_portion_of_view('pricing', 'quantities');
 add_for_portion_of_view 
-------------------------
 t
(1 row)

TABLE sql_saga.updatable_view;
 view_schema |             view_name              |   view_type    | table_schema | table_name |  era_name  |       trigger_name        
-------------+------------------------------------+----------------+--------------+------------+------------+---------------------------
 public      | pricing__for_portion_of_quantities | for_portion_of | public       | pricing    | quantities | for_portion_of_quantities
(1 row)

/* Test UPDATE FOR PORTION */
INSERT INTO pricing (product, quantity_from, quantity_until, price) VALUES ('Trinket', 2, 21, 200);
TABLE pricing ORDER BY quantity_from;
 id1 | id2 | id3 | id4 | product | quantity_from | quantity_until | price 
-----+-----+-----+-----+---------+---------------+----------------+-------
   1 |   1 |   1 |   2 | Trinket |             2 |             21 |   200
(1 row)

-- UPDATE fully preceding
UPDATE pricing__for_portion_of_quantities SET quantity_from = 1, quantity_until = 2, price = 0;
TABLE pricing ORDER BY quantity_from;
 id1 | id2 | id3 | id4 | product | quantity_from | quantity_until | price 
-----+-----+-----+-----+---------+---------------+----------------+-------
   1 |   1 |   1 |   2 | Trinket |             2 |             21 |   200
(1 row)

-- UPDATE fully succeeding
UPDATE pricing__for_portion_of_quantities SET quantity_from = 31, quantity_until = 51, price = 0;
TABLE pricing ORDER BY quantity_from;
 id1 | id2 | id3 | id4 | product | quantity_from | quantity_until | price 
-----+-----+-----+-----+---------+---------------+----------------+-------
   1 |   1 |   1 |   2 | Trinket |             2 |             21 |   200
(1 row)

-- UPDATE fully surrounding
UPDATE pricing__for_portion_of_quantities SET quantity_from = 1, quantity_until = 101, price = 100;
TABLE pricing ORDER BY quantity_from;
 id1 | id2 | id3 | id4 | product | quantity_from | quantity_until | price 
-----+-----+-----+-----+---------+---------------+----------------+-------
   1 |   1 |   1 |   2 | Trinket |             2 |             21 |   100
(1 row)

-- UPDATE portion
UPDATE pricing__for_portion_of_quantities SET quantity_from = 11, quantity_until = 21, price = 80;
TABLE pricing ORDER BY quantity_from;
 id1 | id2 | id3 | id4 | product | quantity_from | quantity_until | price 
-----+-----+-----+-----+---------+---------------+----------------+-------
   2 |   2 |   2 |   4 | Trinket |             2 |             11 |   100
   1 |   1 |   1 |   2 | Trinket |            11 |             21 |    80
(2 rows)

-- UPDATE portion of multiple rows
UPDATE pricing__for_portion_of_quantities SET quantity_from = 5, quantity_until = 15, price = 90;
TABLE pricing ORDER BY quantity_from;
 id1 | id2 | id3 | id4 | product | quantity_from | quantity_until | price 
-----+-----+-----+-----+---------+---------------+----------------+-------
   3 |   3 |   3 |   6 | Trinket |             2 |              5 |   100
   2 |   2 |   2 |   4 | Trinket |             5 |             11 |    90
   1 |   1 |   1 |   2 | Trinket |            11 |             15 |    90
   4 |   4 |   4 |   8 | Trinket |            15 |             21 |    80
(4 rows)

-- If we drop the period with CASCADE, the FOR PORTION views should be
-- dropped, too. First, test that RESTRICT fails as expected.
SAVEPOINT before_drop_era;
SELECT sql_saga.drop_era('pricing', 'quantities', 'RESTRICT');
ERROR:  era quantities is used by an updatable view
CONTEXT:  PL/pgSQL function sql_saga.drop_era(regclass,name,sql_saga.drop_behavior,boolean) line 81 at RAISE
ROLLBACK TO before_drop_era;
-- Now drop with CASCADE
SELECT sql_saga.drop_era('pricing', 'quantities', 'CASCADE');
 drop_era 
----------
 t
(1 row)

TABLE sql_saga.updatable_view;
 view_schema | view_name | view_type | table_schema | table_name | era_name | trigger_name 
-------------+-----------+-----------+--------------+------------+----------+--------------
(0 rows)

-- Add it back to test the drop_for_portion_view function
SELECT sql_saga.add_era('pricing', 'quantity_from', 'quantity_until', 'quantities');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_for_portion_of_view('pricing', 'quantities');
 add_for_portion_of_view 
-------------------------
 t
(1 row)

-- We can't drop the the table without first dropping the FOR PORTION views
-- because Postgres will complain about dependant objects (our views) before we
-- get a chance to clean them up.
SAVEPOINT expect_fail;
DROP TABLE pricing;
ERROR:  cannot drop table pricing because other objects depend on it
DETAIL:  view pricing__for_portion_of_quantities depends on table pricing
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
ROLLBACK TO SAVEPOINT expect_fail;
SELECT sql_saga.drop_for_portion_of_view('pricing', NULL);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

TABLE sql_saga.updatable_view;
 view_schema | view_name | view_type | table_schema | table_name | era_name | trigger_name 
-------------+-----------+-----------+--------------+------------+----------+--------------
(0 rows)

SELECT sql_saga.drop_era('pricing', 'quantities');
 drop_era 
----------
 t
(1 row)

DROP TABLE pricing;
DROP SEQUENCE pricing_seq;
/* Types without btree must be excluded, too */
CREATE TABLE bt (
    id integer PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    pt point,   -- something without btree
    t text,     -- something with btree
    valid_from integer,
    valid_until integer
);
SELECT sql_saga.add_era('bt', 'valid_from', 'valid_until', 'p');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_for_portion_of_view('bt', 'p');
 add_for_portion_of_view 
-------------------------
 t
(1 row)

INSERT INTO bt (pt, t, valid_from, valid_until) VALUES ('(0, 0)', 'sample', 10, 41);
TABLE bt ORDER BY valid_from, valid_until;
 id |  pt   |   t    | valid_from | valid_until 
----+-------+--------+------------+-------------
  1 | (0,0) | sample |         10 |          41
(1 row)

UPDATE bt__for_portion_of_p SET t = 'simple', valid_from = 21, valid_until = 31;
TABLE bt ORDER BY valid_from, valid_until;
 id |  pt   |   t    | valid_from | valid_until 
----+-------+--------+------------+-------------
  2 | (0,0) | sample |         10 |          21
  1 | (0,0) | simple |         21 |          31
  3 | (0,0) | sample |         31 |          41
(3 rows)

SELECT sql_saga.drop_for_portion_of_view('bt', 'p');
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

SELECT sql_saga.drop_era('bt', 'p');
 drop_era 
----------
 t
(1 row)

DROP TABLE bt;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
-- Test that add_updatable_views works without a PK, using a temporal unique key instead.
\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
SET ROLE TO sql_saga_unprivileged_user;
CREATE TABLE no_pk_test (
    id integer,
    value text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('no_pk_test', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('no_pk_test', ARRAY['id']);
   add_unique_key    
---------------------
 no_pk_test_id_valid
(1 row)

SELECT sql_saga.add_for_portion_of_view('no_pk_test');
 add_for_portion_of_view 
-------------------------
 t
(1 row)

INSERT INTO no_pk_test (id, value, valid_from, valid_until) VALUES (1, 'initial', '2020-01-01', '2021-01-01');
TABLE no_pk_test;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | initial | 2020-01-01 | 2021-01-01
(1 row)

UPDATE no_pk_test__for_portion_of_valid SET value = 'updated', valid_from = '2020-06-01', valid_until = '2020-09-01';
TABLE no_pk_test ORDER BY valid_from;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | initial | 2020-01-01 | 2020-06-01
  1 | updated | 2020-06-01 | 2020-09-01
  1 | initial | 2020-09-01 | 2021-01-01
(3 rows)

SELECT sql_saga.drop_for_portion_of_view('no_pk_test', 'valid');
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

SELECT sql_saga.drop_unique_key('no_pk_test', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('no_pk_test');
 drop_era 
----------
 t
(1 row)

DROP TABLE no_pk_test;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
