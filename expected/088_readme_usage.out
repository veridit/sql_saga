\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo 'Test: README Usage Examples'
Test: README Usage Examples
\echo 'This test provides a runnable, self-contained demonstration of the public'
This test provides a runnable, self-contained demonstration of the public
\echo 'API examples documented in README.md, ensuring they remain correct and'
API examples documented in README.md, ensuring they remain correct and
\echo 'functional. It covers the full lifecycle from setup to data loading'
functional. It covers the full lifecycle from setup to data loading
\echo 'with temporal_merge to teardown.'
with temporal_merge to teardown.
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
SET client_min_messages TO NOTICE;
CREATE SCHEMA readme;
--------------------------------------------------------------------------------
\echo '--- 1. Setup: Create and Activate Tables (from README) ---'
--- 1. Setup: Create and Activate Tables (from README) ---
--------------------------------------------------------------------------------
\echo '--- Creating tables: legal_unit, establishment, projects ---'
--- Creating tables: legal_unit, establishment, projects ---
CREATE TABLE readme.legal_unit (
  id SERIAL NOT NULL,
  legal_ident VARCHAR NOT NULL,
  name VARCHAR NOT NULL,
  status TEXT, -- e.g., 'active', 'inactive'
  valid_from DATE,
  valid_to DATE, -- Optional: for human-readable inclusive end dates
  valid_until DATE
);
CREATE TABLE readme.establishment (
  id SERIAL NOT NULL,
  name VARCHAR NOT NULL,
  address TEXT NOT NULL,
  legal_unit_id INTEGER, -- Note: Nullable for initial insert before back-filling
  valid_from DATE,
  valid_until DATE
);
CREATE TABLE readme.projects (id serial primary key, name text, legal_unit_id int);
CREATE TABLE readme.unit_with_range (
  id SERIAL NOT NULL,
  name TEXT,
  start_num INT,
  until_num INT,
  num_range INT4RANGE
);
\echo '--- Activating sql_saga ---'
--- Activating sql_saga ---
-- Register the table as a temporal table (an "era") using default column names.
-- Explicitly enable synchronization for the 'valid_to' column.
SELECT sql_saga.add_era('readme.legal_unit'::regclass, synchronize_valid_to_column := 'valid_to');
NOTICE:  sql_saga: Created trigger "legal_unit_synchronize_temporal_columns_trigger" on table readme.legal_unit to synchronize columns: valid_to
 add_era 
---------
 t
(1 row)

-- Add temporal unique keys. A name is generated if the last argument is omitted.
SELECT sql_saga.add_unique_key(table_oid => 'readme.legal_unit'::regclass, column_names => ARRAY['id'], key_type => 'natural', unique_key_name => 'legal_unit_id_valid');
   add_unique_key    
---------------------
 legal_unit_id_valid
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'readme.legal_unit'::regclass, column_names => ARRAY['legal_ident'], key_type => 'natural', unique_key_name => 'legal_unit_legal_ident_valid');
        add_unique_key        
------------------------------
 legal_unit_legal_ident_valid
(1 row)

-- Add a predicated unique key (e.g., only active units must have a unique name).
SELECT sql_saga.add_unique_key(
    table_oid => 'readme.legal_unit'::regclass,
    column_names => ARRAY['name'],
    key_type => 'predicated',
    predicate => 'status = ''active''',
    unique_key_name => 'legal_unit_active_name_valid'
);
        add_unique_key        
------------------------------
 legal_unit_active_name_valid
(1 row)

SELECT sql_saga.add_era(table_oid => 'readme.establishment'::regclass, valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'readme.establishment'::regclass, column_names => ARRAY['id'], key_type => 'natural', unique_key_name => 'establishment_id_valid');
     add_unique_key     
------------------------
 establishment_id_valid
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'readme.establishment'::regclass, column_names => ARRAY['name'], key_type => 'natural', unique_key_name => 'establishment_name_valid');
      add_unique_key      
--------------------------
 establishment_name_valid
(1 row)

-- Add a temporal foreign key.
SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'readme.establishment'::regclass,
    fk_column_names => ARRAY['legal_unit_id'],
    pk_table_oid => 'readme.legal_unit'::regclass,
    pk_column_names => ARRAY['id']
);
NOTICE:  No compatible index found for foreign key on table readme.establishment. Creating new index: CREATE INDEX establishment_legal_unit_id_valid_gist_idx ON readme.establishment USING GIST (legal_unit_id, daterange(valid_from, valid_until))
          add_foreign_key          
-----------------------------------
 establishment_legal_unit_id_valid
(1 row)

-- Add a foreign key from a regular table to a temporal table.
SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'readme.projects'::regclass,
    fk_column_names => ARRAY['legal_unit_id'],
    pk_table_oid => 'readme.legal_unit'::regclass,
    pk_column_names => ARRAY['id']
);
NOTICE:  No compatible index found for foreign key on table readme.projects. Creating new index: CREATE INDEX projects_legal_unit_id_idx ON readme.projects USING BTREE (legal_unit_id)
       add_foreign_key       
-----------------------------
 projects_legal_unit_id_fkey
(1 row)

SELECT sql_saga.add_era(table_oid => 'readme.unit_with_range'::regclass, valid_from_column_name => 'start_num', valid_until_column_name => 'until_num', synchronize_range_column := 'num_range');
NOTICE:  sql_saga: Created trigger "unit_with_range_synchronize_temporal_columns_trigger" on table readme.unit_with_range to synchronize columns: num_range
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'readme.unit_with_range'::regclass, column_names => ARRAY['id'], key_type => 'natural', unique_key_name => 'unit_with_range_id_valid');
      add_unique_key      
--------------------------
 unit_with_range_id_valid
(1 row)

\echo '--- Verification: Check metadata tables ---'
--- Verification: Check metadata tables ---
SELECT table_schema, table_name, era_name FROM sql_saga.era WHERE table_schema = 'readme' ORDER BY table_name;
 table_schema |   table_name    | era_name 
--------------+-----------------+----------
 readme       | establishment   | valid
 readme       | legal_unit      | valid
 readme       | unit_with_range | valid
(3 rows)

SELECT table_schema, table_name, unique_key_name FROM sql_saga.unique_keys WHERE table_schema = 'readme' ORDER BY unique_key_name;
 table_schema |   table_name    |       unique_key_name        
--------------+-----------------+------------------------------
 readme       | establishment   | establishment_id_valid
 readme       | establishment   | establishment_name_valid
 readme       | legal_unit      | legal_unit_active_name_valid
 readme       | legal_unit      | legal_unit_id_valid
 readme       | legal_unit      | legal_unit_legal_ident_valid
 readme       | unit_with_range | unit_with_range_id_valid
(6 rows)

SELECT table_schema, table_name, foreign_key_name FROM sql_saga.foreign_keys WHERE table_schema = 'readme' ORDER BY foreign_key_name;
 table_schema |  table_name   |         foreign_key_name          
--------------+---------------+-----------------------------------
 readme       | establishment | establishment_legal_unit_id_valid
 readme       | projects      | projects_legal_unit_id_fkey
(2 rows)

--------------------------------------------------------------------------------
\echo '\n--- 2. Data Loading with temporal_merge ---'

--- 2. Data Loading with temporal_merge ---
\echo 'Demonstrates a realistic multi-step import process with ID back-filling.'
Demonstrates a realistic multi-step import process with ID back-filling.
--------------------------------------------------------------------------------
CREATE TEMP TABLE source_data (
    row_id INT,
    identity_correlation_id INT, -- To group related rows for a single new entity
    entity_type TEXT,
    legal_ident TEXT,
    legal_unit_id INT, -- Starts NULL, to be back-filled
    name TEXT,
    status TEXT,
    address TEXT,
    valid_from DATE,
    valid_until DATE
) ON COMMIT DROP;
INSERT INTO source_data VALUES
-- Legal Unit 1: "SpareParts Corp" with a name change history
(101, 1, 'legal_unit', 'LU001', NULL, 'AutoSpareParts INC', 'active', NULL, '2023-07-01', '2024-01-01'),
(102, 1, 'legal_unit', 'LU001', NULL, 'SpareParts Corporation', 'active', NULL, '2024-01-01', 'infinity'),
-- Establishment 1, belonging to Legal Unit 1
(201, 1, 'establishment', NULL, NULL, 'Main Branch', NULL, '123 Innovation Drive', '2023-08-01', 'infinity'),
-- Legal Unit 2: "General Refinement LLC"
(103, 2, 'legal_unit', 'LU002', NULL, 'General Refinement LLC', 'active', NULL, '2023-01-01', 'infinity'),
-- Establishment 2, belonging to Legal Unit 2
(202, 2, 'establishment', NULL, NULL, 'Refinery Plant', NULL, '456 Industrial Ave', '2023-01-01', 'infinity');
\echo '--- Source data for merge ---'
--- Source data for merge ---
SELECT * FROM source_data ORDER BY row_id;
 row_id | identity_correlation_id |  entity_type  | legal_ident | legal_unit_id |          name          | status |       address        | valid_from | valid_until 
--------+-------------------------+---------------+-------------+---------------+------------------------+--------+----------------------+------------+-------------
    101 |                       1 | legal_unit    | LU001       |               | AutoSpareParts INC     | active |                      | 2023-07-01 | 2024-01-01
    102 |                       1 | legal_unit    | LU001       |               | SpareParts Corporation | active |                      | 2024-01-01 | infinity
    103 |                       2 | legal_unit    | LU002       |               | General Refinement LLC | active |                      | 2023-01-01 | infinity
    201 |                       1 | establishment |             |               | Main Branch            |        | 123 Innovation Drive | 2023-08-01 | infinity
    202 |                       2 | establishment |             |               | Refinery Plant         |        | 456 Industrial Ave   | 2023-01-01 | infinity
(5 rows)

\echo '\n--- Step 2a: Merge legal_unit data ---'

--- Step 2a: Merge legal_unit data ---
CREATE TEMP TABLE source_legal_unit ON COMMIT DROP AS SELECT row_id, identity_correlation_id, legal_unit_id AS id, legal_ident, name, status, valid_from, valid_until FROM source_data WHERE entity_type = 'legal_unit';
CALL sql_saga.temporal_merge(
    target_table => 'readme.legal_unit'::regclass,
    source_table => 'source_legal_unit'::regclass,
    identity_columns => '{id}'::text[],
    ephemeral_columns => '{}',
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    identity_correlation_column => 'identity_correlation_id',
    update_source_with_identity => true
);
\echo '--- Verification: Feedback from temporal_merge ---'
--- Verification: Feedback from temporal_merge ---
SELECT * FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | row_ids | operation | update_effect |                entity_ids                 | relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                                  data                                                  | trace 
-------------+---------+-----------+---------------+-------------------------------------------+----------+----------------+-----------------+----------------+-----------------+--------------------------------------------------------------------------------------------------------+-------
           1 | {103}   | INSERT    |               | {"id": 2, "identity_correlation_id": "2"} |          |                |                 | 2023-01-01     | infinity        | {"name": "General Refinement LLC", "status": "active", "valid_to": "infinity", "legal_ident": "LU002"} | 
           2 | {101}   | INSERT    |               | {"id": 1, "identity_correlation_id": "1"} |          |                |                 | 2023-07-01     | 2024-01-01      | {"name": "AutoSpareParts INC", "status": "active", "valid_to": "2023-12-31", "legal_ident": "LU001"}   | 
           3 | {102}   | INSERT    |               | {"id": 1, "identity_correlation_id": "1"} |          |                |                 | 2024-01-01     | infinity        | {"name": "SpareParts Corporation", "status": "active", "valid_to": "infinity", "legal_ident": "LU001"} | 
(3 rows)

SELECT * FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_ids | status  | error_message 
---------------+-------------------+---------+---------------
           101 | [{"id": 1}]       | APPLIED | 
           102 | [{"id": 1}]       | APPLIED | 
           103 | [{"id": 2}]       | APPLIED | 
(3 rows)

\echo '--- Verification: Final state of legal_unit table ---'
--- Verification: Final state of legal_unit table ---
SELECT id, legal_ident, name, status, valid_from, valid_until FROM readme.legal_unit ORDER BY id, valid_from;
 id | legal_ident |          name          | status | valid_from | valid_until 
----+-------------+------------------------+--------+------------+-------------
  1 | LU001       | AutoSpareParts INC     | active | 2023-07-01 | 2024-01-01
  1 | LU001       | SpareParts Corporation | active | 2024-01-01 | infinity
  2 | LU002       | General Refinement LLC | active | 2023-01-01 | infinity
(3 rows)

\echo '--- Verification: Check if IDs were back-filled into the source temp table ---'
--- Verification: Check if IDs were back-filled into the source temp table ---
SELECT row_id, identity_correlation_id, id AS legal_unit_id FROM source_legal_unit ORDER BY row_id;
 row_id | identity_correlation_id | legal_unit_id 
--------+-------------------------+---------------
    101 |                       1 |             1
    102 |                       1 |             1
    103 |                       2 |             2
(3 rows)

\echo '\n--- Step 2b: Back-fill generated legal_unit_id to main source table ---'

--- Step 2b: Back-fill generated legal_unit_id to main source table ---
UPDATE source_data sd
SET legal_unit_id = slu.id
FROM source_legal_unit slu
WHERE sd.identity_correlation_id = slu.identity_correlation_id;
\echo '--- Verification: Main source table after ID back-fill ---'
--- Verification: Main source table after ID back-fill ---
SELECT row_id, identity_correlation_id, entity_type, legal_unit_id, name FROM source_data ORDER BY row_id;
 row_id | identity_correlation_id |  entity_type  | legal_unit_id |          name          
--------+-------------------------+---------------+---------------+------------------------
    101 |                       1 | legal_unit    |             1 | AutoSpareParts INC
    102 |                       1 | legal_unit    |             1 | SpareParts Corporation
    103 |                       2 | legal_unit    |             2 | General Refinement LLC
    201 |                       1 | establishment |             1 | Main Branch
    202 |                       2 | establishment |             2 | Refinery Plant
(5 rows)

\echo '\n--- Step 2c: Merge establishment data ---'

--- Step 2c: Merge establishment data ---
CREATE TEMP TABLE source_establishment ON COMMIT DROP AS SELECT row_id, identity_correlation_id, NULL::INT AS id, legal_unit_id, name, address, valid_from, valid_until FROM source_data WHERE entity_type = 'establishment';
CALL sql_saga.temporal_merge(
    target_table => 'readme.establishment'::regclass,
    source_table => 'source_establishment'::regclass,
    identity_columns => '{id}'::text[],
    ephemeral_columns => '{}',
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    identity_correlation_column => 'identity_correlation_id'
);
\echo '--- Verification: Feedback from temporal_merge ---'
--- Verification: Feedback from temporal_merge ---
SELECT * FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | row_ids | operation | update_effect |                entity_ids                 | relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                                      data                                       | trace 
-------------+---------+-----------+---------------+-------------------------------------------+----------+----------------+-----------------+----------------+-----------------+---------------------------------------------------------------------------------+-------
           1 | {202}   | INSERT    |               | {"id": 2, "identity_correlation_id": "2"} |          |                |                 | 2023-01-01     | infinity        | {"name": "Refinery Plant", "address": "456 Industrial Ave", "legal_unit_id": 2} | 
           2 | {201}   | INSERT    |               | {"id": 1, "identity_correlation_id": "1"} |          |                |                 | 2023-08-01     | infinity        | {"name": "Main Branch", "address": "123 Innovation Drive", "legal_unit_id": 1}  | 
(2 rows)

SELECT * FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_ids | status  | error_message 
---------------+-------------------+---------+---------------
           201 | [{"id": 1}]       | APPLIED | 
           202 | [{"id": 2}]       | APPLIED | 
(2 rows)

\echo '--- Verification: Final state of establishment table ---'
--- Verification: Final state of establishment table ---
SELECT id, name, address, legal_unit_id, valid_from, valid_until FROM readme.establishment ORDER BY id, valid_from;
 id |      name      |       address        | legal_unit_id | valid_from | valid_until 
----+----------------+----------------------+---------------+------------+-------------
  1 | Main Branch    | 123 Innovation Drive |             1 | 2023-08-01 | infinity
  2 | Refinery Plant | 456 Industrial Ave   |             2 | 2023-01-01 | infinity
(2 rows)

--------------------------------------------------------------------------------
\echo '\n--- 2.5. Updatable Views for Simplified Data Management ---'

--- 2.5. Updatable Views for Simplified Data Management ---
--------------------------------------------------------------------------------
\echo '--- Creating updatable views for legal_unit ---'
--- Creating updatable views for legal_unit ---
-- A stable function to override now() for deterministic testing
CREATE FUNCTION readme.test_now() RETURNS date AS $$ SELECT '2024-06-01'::date $$ LANGUAGE sql;
SELECT sql_saga.add_for_portion_of_view('readme.legal_unit'::regclass);
 add_for_portion_of_view 
-------------------------
 t
(1 row)

SELECT sql_saga.add_current_view('readme.legal_unit'::regclass, current_func_name := 'readme.test_now()');
 add_current_view 
------------------
 t
(1 row)

SELECT sql_saga.add_for_portion_of_view('readme.unit_with_range'::regclass);
 add_for_portion_of_view 
-------------------------
 t
(1 row)

\d readme.legal_unit__for_portion_of_valid
          View "readme.legal_unit__for_portion_of_valid"
   Column    |       Type        | Collation | Nullable | Default 
-------------+-------------------+-----------+----------+---------
 id          | integer           |           |          | 
 legal_ident | character varying |           |          | 
 name        | character varying |           |          | 
 status      | text              |           |          | 
 valid_from  | date              |           |          | 
 valid_to    | date              |           |          | 
 valid_until | date              |           |          | 
Triggers:
    for_portion_of_valid INSTEAD OF INSERT OR DELETE OR UPDATE ON readme.legal_unit__for_portion_of_valid FOR EACH ROW EXECUTE FUNCTION sql_saga.for_portion_of_trigger('id')

\d readme.legal_unit__current_valid
             View "readme.legal_unit__current_valid"
   Column    |       Type        | Collation | Nullable | Default 
-------------+-------------------+-----------+----------+---------
 id          | integer           |           |          | 
 legal_ident | character varying |           |          | 
 name        | character varying |           |          | 
 status      | text              |           |          | 
 valid_from  | date              |           |          | 
 valid_to    | date              |           |          | 
 valid_until | date              |           |          | 
Triggers:
    current_valid INSTEAD OF INSERT OR DELETE OR UPDATE ON readme.legal_unit__current_valid FOR EACH ROW EXECUTE FUNCTION sql_saga.current_view_trigger('delete_as_cutoff', 'id')

\d readme.unit_with_range__for_portion_of_valid
  View "readme.unit_with_range__for_portion_of_valid"
  Column   |   Type    | Collation | Nullable | Default 
-----------+-----------+-----------+----------+---------
 id        | integer   |           |          | 
 name      | text      |           |          | 
 start_num | integer   |           |          | 
 until_num | integer   |           |          | 
 num_range | int4range |           |          | 
Triggers:
    for_portion_of_valid INSTEAD OF INSERT OR DELETE OR UPDATE ON readme.unit_with_range__for_portion_of_valid FOR EACH ROW EXECUTE FUNCTION sql_saga.for_portion_of_trigger('id')

\echo '\n--- Using the for_portion_of view (Historical Split) ---'

--- Using the for_portion_of view (Historical Split) ---
\echo 'Mark legal_unit 1 as inactive for a portion of its history'
Mark legal_unit 1 as inactive for a portion of its history
UPDATE readme.legal_unit__for_portion_of_valid
SET
    status = 'inactive',
    valid_from = '2023-09-01',
    valid_until = '2023-11-01'
WHERE id = 1;
\echo '--- Verification: legal_unit history after split ---'
--- Verification: legal_unit history after split ---
SELECT id, status, valid_from, valid_until FROM readme.legal_unit WHERE id = 1 ORDER BY valid_from;
 id |  status  | valid_from | valid_until 
----+----------+------------+-------------
  1 | active   | 2023-07-01 | 2023-09-01
  1 | inactive | 2023-09-01 | 2023-11-01
  1 | active   | 2023-11-01 | 2024-01-01
  1 | active   | 2024-01-01 | infinity
(4 rows)

\echo '\n--- Using the for_portion_of view (Historical Correction) ---'

--- Using the for_portion_of view (Historical Correction) ---
\echo 'Correct the name of legal_unit 1 across its entire history'
Correct the name of legal_unit 1 across its entire history
-- Note: This is a bulk update on all historical records for this entity.
-- The valid_from/valid_until are NOT provided in the SET clause.
UPDATE readme.legal_unit__for_portion_of_valid
SET name = 'Corrected SpareParts'
WHERE id = 1;
\echo '--- Verification: legal_unit history after correction ---'
--- Verification: legal_unit history after correction ---
SELECT id, name, valid_from, valid_until FROM readme.legal_unit WHERE id = 1 ORDER BY valid_from;
 id |         name         | valid_from | valid_until 
----+----------------------+------------+-------------
  1 | Corrected SpareParts | 2023-07-01 | 2023-09-01
  1 | Corrected SpareParts | 2023-09-01 | 2023-11-01
  1 | Corrected SpareParts | 2023-11-01 | infinity
(3 rows)

\echo '\n--- Using the current view ---'

--- Using the current view ---
\echo '--- INSERT: A new legal unit becomes active ---'
--- INSERT: A new legal unit becomes active ---
INSERT INTO readme.legal_unit__current_valid (legal_ident, name, status) VALUES ('LU003', 'New Ventures Inc', 'active');
\echo '--- Verification: The new unit is now current ---'
--- Verification: The new unit is now current ---
TABLE readme.legal_unit__current_valid ORDER BY legal_ident;
 id | legal_ident |          name          | status | valid_from | valid_to | valid_until 
----+-------------+------------------------+--------+------------+----------+-------------
  1 | LU001       | Corrected SpareParts   | active | 2023-11-01 | infinity | infinity
  2 | LU002       | General Refinement LLC | active | 2023-01-01 | infinity | infinity
  3 | LU003       | New Ventures Inc       | active | 2024-06-01 | infinity | infinity
(3 rows)

\echo '\n--- UPDATE (SCD Type 2): Change the name of the new unit ---'

--- UPDATE (SCD Type 2): Change the name of the new unit ---
-- Simulate the passage of time for the SCD Type 2 update
CREATE OR REPLACE FUNCTION readme.test_now() RETURNS date AS $$ SELECT '2024-07-01'::date $$ LANGUAGE sql;
UPDATE readme.legal_unit__current_valid SET name = 'New Ventures LLC' WHERE legal_ident = 'LU003';
\echo '--- Verification: Full history of the renamed unit ---'
--- Verification: Full history of the renamed unit ---
SELECT id, name, valid_from, valid_until FROM readme.legal_unit WHERE legal_ident = 'LU003' ORDER BY valid_from;
 id |       name       | valid_from | valid_until 
----+------------------+------------+-------------
  3 | New Ventures Inc | 2024-06-01 | 2024-07-01
  3 | New Ventures LLC | 2024-07-01 | infinity
(2 rows)

\echo '\n--- DELETE (Soft-Delete): Archive the new unit ---'

--- DELETE (Soft-Delete): Archive the new unit ---
-- Simulate the passage of time for the soft-delete
CREATE OR REPLACE FUNCTION readme.test_now() RETURNS date AS $$ SELECT '2024-08-01'::date $$ LANGUAGE sql;
DELETE FROM readme.legal_unit__current_valid WHERE legal_ident = 'LU003';
\echo '--- Verification: The new unit is no longer current ---'
--- Verification: The new unit is no longer current ---
TABLE readme.legal_unit__current_valid ORDER BY legal_ident;
 id | legal_ident |          name          | status | valid_from | valid_to | valid_until 
----+-------------+------------------------+--------+------------+----------+-------------
  1 | LU001       | Corrected SpareParts   | active | 2023-11-01 | infinity | infinity
  2 | LU002       | General Refinement LLC | active | 2023-01-01 | infinity | infinity
(2 rows)

\echo '--- Verification: The historical record shows the unit''s timeline has ended ---'
--- Verification: The historical record shows the unit's timeline has ended ---
SELECT id, status, valid_from, valid_until FROM readme.legal_unit WHERE legal_ident = 'LU003' ORDER BY valid_from;
 id | status | valid_from | valid_until 
----+--------+------------+-------------
  3 | active | 2024-06-01 | 2024-07-01
  3 | active | 2024-07-01 | 2024-08-01
(2 rows)

--------------------------------------------------------------------------------
\echo '\n--- 3. Deactivation (from README) ---'

--- 3. Deactivation (from README) ---
--------------------------------------------------------------------------------
\echo '--- Deactivating sql_saga ---'
--- Deactivating sql_saga ---
-- Drop the views first, as they depend on the underlying temporal table setup.
SELECT sql_saga.drop_for_portion_of_view('readme.legal_unit'::regclass);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

SELECT sql_saga.drop_current_view('readme.legal_unit'::regclass);
 drop_current_view 
-------------------
 t
(1 row)

SELECT sql_saga.drop_for_portion_of_view('readme.unit_with_range'::regclass);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

-- Foreign keys must be dropped before the unique keys they reference.
-- For temporal tables, era_name is not needed if the table has only one era.
SELECT sql_saga.drop_foreign_key(
    table_oid => 'readme.establishment'::regclass,
    column_names => ARRAY['legal_unit_id']
);
NOTICE:  Dropping automatically created index "establishment_legal_unit_id_valid_gist_idx" for foreign key "establishment_legal_unit_id_valid"
 drop_foreign_key 
------------------
 
(1 row)

-- For regular tables, era_name is always omitted.
SELECT sql_saga.drop_foreign_key(
    table_oid => 'readme.projects'::regclass,
    column_names => ARRAY['legal_unit_id']
);
NOTICE:  Dropping automatically created index "projects_legal_unit_id_idx" for foreign key "projects_legal_unit_id_fkey"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_unique_key(table_oid => 'readme.establishment'::regclass, column_names => ARRAY['id'], era_name => 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_unique_key(table_oid => 'readme.establishment'::regclass, column_names => ARRAY['name'], era_name => 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('readme.establishment'::regclass);
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_unique_key(table_oid => 'readme.legal_unit'::regclass, column_names => ARRAY['id'], era_name => 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_unique_key(table_oid => 'readme.legal_unit'::regclass, column_names => ARRAY['legal_ident'], era_name => 'valid');
 drop_unique_key 
-----------------
 
(1 row)

-- For predicated unique keys, the predicate is not needed for dropping.
SELECT sql_saga.drop_unique_key(table_oid => 'readme.legal_unit'::regclass, column_names => ARRAY['name'], era_name => 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('readme.legal_unit'::regclass);
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_unique_key(table_oid => 'readme.unit_with_range'::regclass, column_names => ARRAY['id'], era_name => 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('readme.unit_with_range'::regclass);
 drop_era 
----------
 t
(1 row)

\echo '--- Verification: Check metadata tables are empty for this schema ---'
--- Verification: Check metadata tables are empty for this schema ---
-- These queries should return no rows. Any rows returned indicate a cleanup failure.
SELECT * FROM sql_saga.era WHERE table_schema = 'readme';
 table_schema | table_name | era_name | valid_from_column_name | valid_until_column_name | range_type | range_subtype | range_subtype_category | bounds_check_constraint | synchronize_valid_to_column | synchronize_range_column | trigger_applies_defaults | audit_schema_name | audit_table_name 
--------------+------------+----------+------------------------+-------------------------+------------+---------------+------------------------+-------------------------+-----------------------------+--------------------------+--------------------------+-------------------+------------------
(0 rows)

SELECT * FROM sql_saga.unique_keys WHERE table_schema = 'readme';
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | predicate 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+-----------
(0 rows)

SELECT * FROM sql_saga.foreign_keys WHERE table_schema = 'readme';
 foreign_key_name | type | table_schema | table_name | column_names | fk_era_name | fk_table_columns_snapshot | unique_key_name | match_type | update_action | delete_action | fk_insert_trigger | fk_update_trigger | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger | fk_index_name 
------------------+------+--------------+------------+--------------+-------------+---------------------------+-----------------+------------+---------------+---------------+-------------------+-------------------+---------------------+--------------------+-------------------+-------------------+---------------
(0 rows)

--------------------------------------------------------------------------------
\echo '--- 4. Cleanup ---'
--- 4. Cleanup ---
--------------------------------------------------------------------------------
DROP FUNCTION readme.test_now();
DROP TABLE readme.legal_unit, readme.establishment, readme.projects, readme.unit_with_range CASCADE;
DROP SCHEMA readme;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
