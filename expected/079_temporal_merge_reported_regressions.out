\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
--
-- REGRESSION: `temporal_merge` ordering dependency
--
-- This script demonstrates a regression or design limitation where `temporal_merge`
-- fails with an exclusion constraint violation if its source data contains
-- complex overlapping temporal segments that are not pre-sorted chronologically.
--
\set ECHO all
BEGIN;
CREATE SCHEMA saga_repro;
-- Base table definitions
CREATE TABLE saga_repro.target_units_template (
    unit_ident text NOT NULL,
    name text,
    valid_from date NOT NULL,
    valid_until date
);
CREATE TABLE saga_repro.source_units_template (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    batch_seq int,
    unit_ident text,
    name text,
    sector text,
    valid_from date,
    valid_until date,
    merge_status jsonb,
    errors jsonb
);
-- Tables for Scenario 1: Ordering Regression
CREATE TABLE saga_repro.target_units_a (LIKE saga_repro.target_units_template);
CREATE TABLE saga_repro.target_units_b (LIKE saga_repro.target_units_template);
CREATE TABLE saga_repro.target_units_c (LIKE saga_repro.target_units_template);
SELECT sql_saga.add_era('saga_repro.target_units_a');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('saga_repro.target_units_a', ARRAY['unit_ident'], key_type => 'natural');
NOTICE:  sql_saga: altering table saga_repro.target_units_a to add constraints: ADD CONSTRAINT target_units_a_unit_ident_valid_uniq UNIQUE (unit_ident, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT target_units_a_unit_ident_valid_excl EXCLUDE USING gist (unit_ident WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
         add_unique_key          
---------------------------------
 target_units_a_unit_ident_valid
(1 row)

SELECT sql_saga.add_era('saga_repro.target_units_b');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('saga_repro.target_units_b', ARRAY['unit_ident'], key_type => 'natural');
NOTICE:  sql_saga: altering table saga_repro.target_units_b to add constraints: ADD CONSTRAINT target_units_b_unit_ident_valid_uniq UNIQUE (unit_ident, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT target_units_b_unit_ident_valid_excl EXCLUDE USING gist (unit_ident WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
         add_unique_key          
---------------------------------
 target_units_b_unit_ident_valid
(1 row)

SELECT sql_saga.add_era('saga_repro.target_units_c');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('saga_repro.target_units_c', ARRAY['unit_ident'], key_type => 'natural');
NOTICE:  sql_saga: altering table saga_repro.target_units_c to add constraints: ADD CONSTRAINT target_units_c_unit_ident_valid_uniq UNIQUE (unit_ident, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT target_units_c_unit_ident_valid_excl EXCLUDE USING gist (unit_ident WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
         add_unique_key          
---------------------------------
 target_units_c_unit_ident_valid
(1 row)

GRANT USAGE ON SCHEMA saga_repro TO sql_saga_unprivileged_user;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA saga_repro TO sql_saga_unprivileged_user;
-- Tables for Scenario 1: Ordering Regression (source data)
CREATE TABLE saga_repro.source_units_ordering (LIKE saga_repro.source_units_template INCLUDING ALL);
INSERT INTO saga_repro.source_units_ordering (batch_seq, unit_ident, name, valid_from, valid_until) VALUES
    (1, 'unit1', 'Initial P1',   '2023-01-01', '2023-03-31'),
    (1, 'unit1', 'Initial P2',   '2023-04-01', '2023-06-30'),
    (1, 'unit1', 'Initial P3',   '2023-07-01', '2023-09-30'),
    (2, 'unit1', 'Replacing pA', '2023-02-15', '2023-05-15'),
    (2, 'unit1', 'Replacing pB', '2023-05-16', '2023-08-15'),
    (2, 'unit1', 'Replacing pC', '2023-08-16', '2023-12-01');
GRANT ALL ON saga_repro.source_units_ordering TO sql_saga_unprivileged_user;
-- Tables for Scenario 2: Coalescing Regression
CREATE TABLE saga_repro.target_units_coalesce (LIKE saga_repro.target_units_template);
CREATE TABLE saga_repro.source_units_coalesce (LIKE saga_repro.source_units_template INCLUDING ALL);
SELECT sql_saga.add_era('saga_repro.target_units_coalesce');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('saga_repro.target_units_coalesce', ARRAY['unit_ident'], key_type => 'natural');
NOTICE:  sql_saga: altering table saga_repro.target_units_coalesce to add constraints: ADD CONSTRAINT target_units_coalesce_unit_ident_valid_uniq UNIQUE (unit_ident, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT target_units_coalesce_unit_ident_valid_excl EXCLUDE USING gist (unit_ident WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
             add_unique_key             
----------------------------------------
 target_units_coalesce_unit_ident_valid
(1 row)

GRANT ALL ON saga_repro.target_units_coalesce TO sql_saga_unprivileged_user;
GRANT ALL ON saga_repro.source_units_coalesce TO sql_saga_unprivileged_user;
/* Run tests as unprivileged user */
SET ROLE TO sql_saga_unprivileged_user;
--------------------------------------------------------------------------------
-- SCENARIO 1: Ordering Dependency Regression
--------------------------------------------------------------------------------
\echo '\n--- SCENARIO 1: Comparing merge strategies for out-of-order source data ---'

--- SCENARIO 1: Comparing merge strategies for out-of-order source data ---
-- Strategy A: Process one row at a time
\echo '\n--- STRATEGY A: Processing one row at a time ---\n'

--- STRATEGY A: Processing one row at a time ---

CREATE TEMP TABLE source_a AS SELECT * FROM saga_repro.source_units_ordering;
-- Row 1
CREATE OR REPLACE TEMP VIEW source_view AS SELECT row_id, unit_ident, name, valid_from, valid_until, errors, merge_status FROM source_a WHERE row_id = 1;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run1');
-- Row 2
CREATE OR REPLACE TEMP VIEW source_view AS SELECT row_id, unit_ident, name, valid_from, valid_until, errors, merge_status FROM source_a WHERE row_id = 2;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run2');
-- Row 3
CREATE OR REPLACE TEMP VIEW source_view AS SELECT row_id, unit_ident, name, valid_from, valid_until, errors, merge_status FROM source_a WHERE row_id = 3;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run3');
-- Row 4
CREATE OR REPLACE TEMP VIEW source_view AS SELECT row_id, unit_ident, name, valid_from, valid_until, errors, merge_status FROM source_a WHERE row_id = 4;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run4');
-- Row 5
CREATE OR REPLACE TEMP VIEW source_view AS SELECT row_id, unit_ident, name, valid_from, valid_until, errors, merge_status FROM source_a WHERE row_id = 5;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run5');
-- Row 6
CREATE OR REPLACE TEMP VIEW source_view AS SELECT row_id, unit_ident, name, valid_from, valid_until, errors, merge_status FROM source_a WHERE row_id = 6;
CALL sql_saga.temporal_merge('saga_repro.target_units_a', 'source_view', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT', update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run6');
DROP VIEW source_view;
-- Strategy B: Process in logical batches
\echo '\n--- STRATEGY B: Processing in logical batches ---\n'

--- STRATEGY B: Processing in logical batches ---

CREATE TEMP TABLE source_b AS SELECT * FROM saga_repro.source_units_ordering;
CREATE TEMP VIEW source_view_b1 AS SELECT row_id, unit_ident, name, valid_from, valid_until, errors, merge_status FROM source_b WHERE batch_seq = 1;
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_b', 'source_view_b1',
    natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT',
    update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'batch1'
);
CREATE TEMP VIEW source_view_b2 AS SELECT row_id, unit_ident, name, valid_from, valid_until, errors, merge_status FROM source_b WHERE batch_seq = 2;
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_b', 'source_view_b2',
    natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT',
    update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'batch2'
);
-- Strategy C: Process all rows in one batch
\echo '\n--- STRATEGY C: Processing all in one batch (original failing case) ---\n'

--- STRATEGY C: Processing all in one batch (original failing case) ---

CREATE TEMP TABLE source_c AS SELECT * FROM saga_repro.source_units_ordering;
CREATE TEMP VIEW source_view_c AS SELECT row_id, unit_ident, name, valid_from, valid_until, errors, merge_status FROM source_c;
CALL sql_saga.temporal_merge(
    'saga_repro.target_units_c', 'source_view_c',
    natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT',
    update_source_with_feedback => true, feedback_status_column => 'merge_status', feedback_status_key => 'run'
);
--------------------------------------------------------------------------------
-- SCENARIO 2: Coalescing Regression
--------------------------------------------------------------------------------
\echo '\n--- SCENARIO 2: Coalescing identical, adjacent records ---'

--- SCENARIO 2: Coalescing identical, adjacent records ---
-- Batch 1
INSERT INTO saga_repro.source_units_coalesce (unit_ident, name, sector, valid_from, valid_until) VALUES
    ('unit1', 'Unit A', 'Manufacturing', '2023-01-01', '2023-07-01');
CALL sql_saga.temporal_merge('saga_repro.target_units_coalesce', 'saga_repro.source_units_coalesce', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT');
-- Batch 2
TRUNCATE saga_repro.source_units_coalesce;
INSERT INTO saga_repro.source_units_coalesce (unit_ident, name, sector, valid_from, valid_until) VALUES
    ('unit1', 'Unit A', 'Manufacturing', '2023-07-01', '2024-01-01');
CALL sql_saga.temporal_merge('saga_repro.target_units_coalesce', 'saga_repro.source_units_coalesce', natural_identity_columns => ARRAY['unit_ident'], mode => 'MERGE_ENTITY_UPSERT');
--------------------------------------------------------------------------------
-- FINAL RESULTS
--------------------------------------------------------------------------------
\echo '\n\n--- FINAL COMPARISON OF FINAL STATES ---'


--- FINAL COMPARISON OF FINAL STATES ---
\echo '\n-- Strategy A: One-by-one Result'

-- Strategy A: One-by-one Result
SELECT unit_ident, name, valid_from, valid_until FROM saga_repro.target_units_a ORDER BY valid_from, name;
 unit_ident |     name     | valid_from | valid_until 
------------+--------------+------------+-------------
 unit1      | Initial P1   | 2023-01-01 | 2023-02-15
 unit1      | Replacing pA | 2023-02-15 | 2023-05-15
 unit1      | Initial P2   | 2023-05-15 | 2023-05-16
 unit1      | Replacing pB | 2023-05-16 | 2023-08-15
 unit1      | Initial P3   | 2023-08-15 | 2023-08-16
 unit1      | Replacing pC | 2023-08-16 | 2023-12-01
(6 rows)

\echo '\n-- Strategy B: Batch-by-batch Result'

-- Strategy B: Batch-by-batch Result
SELECT unit_ident, name, valid_from, valid_until FROM saga_repro.target_units_b ORDER BY valid_from, name;
 unit_ident |     name     | valid_from | valid_until 
------------+--------------+------------+-------------
 unit1      | Initial P1   | 2023-01-01 | 2023-02-15
 unit1      | Replacing pA | 2023-02-15 | 2023-05-15
 unit1      | Initial P2   | 2023-05-15 | 2023-05-16
 unit1      | Replacing pB | 2023-05-16 | 2023-08-15
 unit1      | Initial P3   | 2023-08-15 | 2023-08-16
 unit1      | Replacing pC | 2023-08-16 | 2023-12-01
(6 rows)

\echo '\n-- Strategy C: All-in-one Result'

-- Strategy C: All-in-one Result
SELECT unit_ident, name, valid_from, valid_until FROM saga_repro.target_units_c ORDER BY valid_from, name;
 unit_ident |     name     | valid_from | valid_until 
------------+--------------+------------+-------------
 unit1      | Initial P1   | 2023-01-01 | 2023-02-15
 unit1      | Replacing pA | 2023-02-15 | 2023-05-15
 unit1      | Initial P2   | 2023-05-15 | 2023-05-16
 unit1      | Replacing pB | 2023-05-16 | 2023-08-15
 unit1      | Initial P3   | 2023-08-15 | 2023-08-16
 unit1      | Replacing pC | 2023-08-16 | 2023-12-01
(6 rows)

\echo '\n-- Diff check of strategy results (should be empty)'

-- Diff check of strategy results (should be empty)
\echo '\n-- Diff A vs B:'

-- Diff A vs B:
(TABLE saga_repro.target_units_a EXCEPT TABLE saga_repro.target_units_b)
UNION ALL
(TABLE saga_repro.target_units_b EXCEPT TABLE saga_repro.target_units_a);
 unit_ident | name | valid_from | valid_until 
------------+------+------------+-------------
(0 rows)

\echo '\n-- Diff B vs C:'

-- Diff B vs C:
(TABLE saga_repro.target_units_b EXCEPT TABLE saga_repro.target_units_c)
UNION ALL
(TABLE saga_repro.target_units_c EXCEPT TABLE saga_repro.target_units_b);
 unit_ident | name | valid_from | valid_until 
------------+------+------------+-------------
(0 rows)

\echo '\n-- Coalescing Test Final State (Expected: 1 row)'

-- Coalescing Test Final State (Expected: 1 row)
SELECT unit_ident, name, valid_from, valid_until FROM saga_repro.target_units_coalesce ORDER BY valid_from;
 unit_ident |  name  | valid_from | valid_until 
------------+--------+------------+-------------
 unit1      | Unit A | 2023-01-01 | 2024-01-01
(1 row)

\echo '\n\n--- FINAL COMPARISON OF FEEDBACK ---'


--- FINAL COMPARISON OF FEEDBACK ---
\echo '\n-- Strategy A: One-by-one Feedback'

-- Strategy A: One-by-one Feedback
SELECT row_id, batch_seq, name, merge_status FROM source_a ORDER BY row_id;
 row_id | batch_seq |     name     |    merge_status     
--------+-----------+--------------+---------------------
      1 |         1 | Initial P1   | {"run1": "APPLIED"}
      2 |         1 | Initial P2   | {"run2": "APPLIED"}
      3 |         1 | Initial P3   | {"run3": "APPLIED"}
      4 |         2 | Replacing pA | {"run4": "APPLIED"}
      5 |         2 | Replacing pB | {"run5": "APPLIED"}
      6 |         2 | Replacing pC | {"run6": "APPLIED"}
(6 rows)

\echo '\n-- Strategy B: Batch-by-batch Feedback'

-- Strategy B: Batch-by-batch Feedback
SELECT row_id, batch_seq, name, merge_status FROM source_b ORDER BY row_id;
 row_id | batch_seq |     name     |     merge_status      
--------+-----------+--------------+-----------------------
      1 |         1 | Initial P1   | {"batch1": "APPLIED"}
      2 |         1 | Initial P2   | {"batch1": "APPLIED"}
      3 |         1 | Initial P3   | {"batch1": "APPLIED"}
      4 |         2 | Replacing pA | {"batch2": "APPLIED"}
      5 |         2 | Replacing pB | {"batch2": "APPLIED"}
      6 |         2 | Replacing pC | {"batch2": "APPLIED"}
(6 rows)

\echo '\n-- Strategy C: All-in-one Feedback'

-- Strategy C: All-in-one Feedback
SELECT row_id, batch_seq, name, merge_status FROM source_c ORDER BY row_id;
 row_id | batch_seq |     name     |    merge_status    
--------+-----------+--------------+--------------------
      1 |         1 | Initial P1   | {"run": "APPLIED"}
      2 |         1 | Initial P2   | {"run": "APPLIED"}
      3 |         1 | Initial P3   | {"run": "APPLIED"}
      4 |         2 | Replacing pA | {"run": "APPLIED"}
      5 |         2 | Replacing pB | {"run": "APPLIED"}
      6 |         2 | Replacing pC | {"run": "APPLIED"}
(6 rows)

ABORT;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
