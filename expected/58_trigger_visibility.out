\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
SELECT $$
--------------------------------------------------------------------------------
Test: 58 - MVCC Trigger Visibility Semantics
Purpose:
  This test provides a crystal-clear demonstration of the Multi-Version
  Concurrency Control (MVCC) semantics for PostgreSQL triggers. Its goal is
  not to test any sql_saga functionality, but to establish a baseline of
  understanding about what data is visible to BEFORE and AFTER triggers for
  each DML operation (INSERT, UPDATE, DELETE).

Methodology:
  1. A simple table `mvcc_test.t` is created.
  2. A single, universal trigger function `mvcc_test.log_trigger()` is defined.
     This function logs:
     - The trigger's context (WHEN, OP).
     - The contents of the OLD and NEW tuples.
     - The *full contents of the table* as seen by a `SELECT *` query
       executed from within the trigger function. This is the crucial part
       that reveals the MVCC snapshot available to the trigger.
  3. This function is attached as both a BEFORE and AFTER ROW trigger to the
     table.
  4. A series of simple, isolated DML statements are executed, and the
     resulting NOTICE output is captured to demonstrate the visibility rules.

Expected Observations:
  - BEFORE Triggers: The `SELECT *` will show the state of the table
    *before* the current DML statement has made any changes. The OLD/NEW
    tuples reflect the change that is about to happen.
  - AFTER Triggers: The `SELECT *` will show the state of the table *after*
    the current DML statement has completed. The snapshot includes the
    change made by the statement that fired the trigger.
--------------------------------------------------------------------------------
$$ AS doc;
                                       doc                                        
----------------------------------------------------------------------------------
                                                                                 +
 --------------------------------------------------------------------------------+
 Test: 58 - MVCC Trigger Visibility Semantics                                    +
 Purpose:                                                                        +
   This test provides a crystal-clear demonstration of the Multi-Version         +
   Concurrency Control (MVCC) semantics for PostgreSQL triggers. Its goal is     +
   not to test any sql_saga functionality, but to establish a baseline of        +
   understanding about what data is visible to BEFORE and AFTER triggers for     +
   each DML operation (INSERT, UPDATE, DELETE).                                  +
                                                                                 +
 Methodology:                                                                    +
   1. A simple table `mvcc_test.t` is created.                                   +
   2. A single, universal trigger function `mvcc_test.log_trigger()` is defined. +
      This function logs:                                                        +
      - The trigger's context (WHEN, OP).                                        +
      - The contents of the OLD and NEW tuples.                                  +
      - The *full contents of the table* as seen by a `SELECT *` query           +
        executed from within the trigger function. This is the crucial part      +
        that reveals the MVCC snapshot available to the trigger.                 +
   3. This function is attached as both a BEFORE and AFTER ROW trigger to the    +
      table.                                                                     +
   4. A series of simple, isolated DML statements are executed, and the          +
      resulting NOTICE output is captured to demonstrate the visibility rules.   +
                                                                                 +
 Expected Observations:                                                          +
   - BEFORE Triggers: The `SELECT *` will show the state of the table            +
     *before* the current DML statement has made any changes. The OLD/NEW        +
     tuples reflect the change that is about to happen.                          +
   - AFTER Triggers: The `SELECT *` will show the state of the table *after*     +
     the current DML statement has completed. The snapshot includes the          +
     change made by the statement that fired the trigger.                        +
 --------------------------------------------------------------------------------+
 
(1 row)

CREATE EXTENSION IF NOT EXISTS btree_gist;
NOTICE:  extension "btree_gist" already exists, skipping
CREATE SCHEMA mvcc_test;
CREATE TABLE mvcc_test.t (
    id int primary key,
    group_id int not null,
    value text,
    valid_from int,
    valid_until int,
    EXCLUDE USING gist (group_id WITH =, int4range(valid_from, valid_until) WITH &&) DEFERRABLE
);
CREATE FUNCTION mvcc_test.log_trigger()
RETURNS trigger
LANGUAGE plpgsql AS $$
DECLARE
    v_row record;
BEGIN
    RAISE NOTICE '---';
    RAISE NOTICE 'Trigger Fired: % % ON mvcc_test.t', TG_WHEN, TG_OP;

    IF TG_OP IN ('UPDATE', 'DELETE') THEN
        RAISE NOTICE '  OLD: %', to_jsonb(OLD);
    END IF;
    IF TG_OP IN ('INSERT', 'UPDATE') THEN
        RAISE NOTICE '  NEW: %', to_jsonb(NEW);
    END IF;

    RAISE NOTICE '  Visible Table State (SELECT * FROM mvcc_test.t):';
    FOR v_row IN SELECT * FROM mvcc_test.t ORDER BY id LOOP
        RAISE NOTICE '    %', v_row;
    END LOOP;

    IF TG_WHEN = 'BEFORE' THEN
        RETURN NEW;
    ELSE
        RETURN OLD;
    END IF;
END;
$$;
CREATE TRIGGER t_before
BEFORE INSERT OR UPDATE OR DELETE ON mvcc_test.t
FOR EACH ROW EXECUTE FUNCTION mvcc_test.log_trigger();
CREATE TRIGGER t_after
AFTER INSERT OR UPDATE OR DELETE ON mvcc_test.t
FOR EACH ROW EXECUTE FUNCTION mvcc_test.log_trigger();
\echo '\n--- Initial State ---'

--- Initial State ---
-- group_id=1 has a continuous timeline. group_id=2 is a separate entity.
INSERT INTO mvcc_test.t VALUES (1, 1, 'initial', 10, 20), (2, 1, 'untouched', 20, 30);
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE INSERT ON mvcc_test.t
NOTICE:    NEW: {"id": 1, "value": "initial", "group_id": 1, "valid_from": 10, "valid_until": 20}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE INSERT ON mvcc_test.t
NOTICE:    NEW: {"id": 2, "value": "untouched", "group_id": 1, "valid_from": 20, "valid_until": 30}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,initial,10,20)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER INSERT ON mvcc_test.t
NOTICE:    NEW: {"id": 1, "value": "initial", "group_id": 1, "valid_from": 10, "valid_until": 20}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,initial,10,20)
NOTICE:      (2,1,untouched,20,30)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER INSERT ON mvcc_test.t
NOTICE:    NEW: {"id": 2, "value": "untouched", "group_id": 1, "valid_from": 20, "valid_until": 30}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,initial,10,20)
NOTICE:      (2,1,untouched,20,30)
TABLE mvcc_test.t ORDER BY id;
 id | group_id |   value   | valid_from | valid_until 
----+----------+-----------+------------+-------------
  1 |        1 | initial   |         10 |          20
  2 |        1 | untouched |         20 |          30
(2 rows)

\echo '\n\n--- Scenario 1: INSERT a new row ---'


--- Scenario 1: INSERT a new row ---
BEGIN;
INSERT INTO mvcc_test.t VALUES (3, 2, 'inserted', 100, 110);
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE INSERT ON mvcc_test.t
NOTICE:    NEW: {"id": 3, "value": "inserted", "group_id": 2, "valid_from": 100, "valid_until": 110}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,initial,10,20)
NOTICE:      (2,1,untouched,20,30)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER INSERT ON mvcc_test.t
NOTICE:    NEW: {"id": 3, "value": "inserted", "group_id": 2, "valid_from": 100, "valid_until": 110}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,initial,10,20)
NOTICE:      (2,1,untouched,20,30)
NOTICE:      (3,2,inserted,100,110)
COMMIT;
\echo '\n\n--- Scenario 2: UPDATE an existing row ---'


--- Scenario 2: UPDATE an existing row ---
BEGIN;
UPDATE mvcc_test.t SET value = 'updated' WHERE id = 1;
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 1, "value": "initial", "group_id": 1, "valid_from": 10, "valid_until": 20}
NOTICE:    NEW: {"id": 1, "value": "updated", "group_id": 1, "valid_from": 10, "valid_until": 20}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,initial,10,20)
NOTICE:      (2,1,untouched,20,30)
NOTICE:      (3,2,inserted,100,110)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 1, "value": "initial", "group_id": 1, "valid_from": 10, "valid_until": 20}
NOTICE:    NEW: {"id": 1, "value": "updated", "group_id": 1, "valid_from": 10, "valid_until": 20}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,untouched,20,30)
NOTICE:      (3,2,inserted,100,110)
COMMIT;
\echo '\n\n--- Scenario 3: DELETE an existing row ---'


--- Scenario 3: DELETE an existing row ---
BEGIN;
DELETE FROM mvcc_test.t WHERE id = 1;
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE DELETE ON mvcc_test.t
NOTICE:    OLD: {"id": 1, "value": "updated", "group_id": 1, "valid_from": 10, "valid_until": 20}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,untouched,20,30)
NOTICE:      (3,2,inserted,100,110)
COMMIT;
\echo '\n\n--- Scenario 4: Multi-row UPDATE ---'


--- Scenario 4: Multi-row UPDATE ---
\echo 'Observation: Each row''s AFTER trigger sees the state *after its own update* is complete.'
Observation: Each row's AFTER trigger sees the state *after its own update* is complete.
\echo 'The snapshot for the second row''s triggers includes the update from the first row.'
The snapshot for the second row's triggers includes the update from the first row.
BEGIN;
-- Add a row to update
INSERT INTO mvcc_test.t VALUES (4, 2, 'another', 110, 120);
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE INSERT ON mvcc_test.t
NOTICE:    NEW: {"id": 4, "value": "another", "group_id": 2, "valid_from": 110, "valid_until": 120}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,untouched,20,30)
NOTICE:      (3,2,inserted,100,110)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER INSERT ON mvcc_test.t
NOTICE:    NEW: {"id": 4, "value": "another", "group_id": 2, "valid_from": 110, "valid_until": 120}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,untouched,20,30)
NOTICE:      (3,2,inserted,100,110)
NOTICE:      (4,2,another,110,120)
UPDATE mvcc_test.t SET value = 'multi-updated' WHERE id IN (2, 4);
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 2, "value": "untouched", "group_id": 1, "valid_from": 20, "valid_until": 30}
NOTICE:    NEW: {"id": 2, "value": "multi-updated", "group_id": 1, "valid_from": 20, "valid_until": 30}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,untouched,20,30)
NOTICE:      (3,2,inserted,100,110)
NOTICE:      (4,2,another,110,120)
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 4, "value": "another", "group_id": 2, "valid_from": 110, "valid_until": 120}
NOTICE:    NEW: {"id": 4, "value": "multi-updated", "group_id": 2, "valid_from": 110, "valid_until": 120}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,multi-updated,20,30)
NOTICE:      (3,2,inserted,100,110)
NOTICE:      (4,2,another,110,120)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 2, "value": "untouched", "group_id": 1, "valid_from": 20, "valid_until": 30}
NOTICE:    NEW: {"id": 2, "value": "multi-updated", "group_id": 1, "valid_from": 20, "valid_until": 30}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,multi-updated,20,30)
NOTICE:      (3,2,inserted,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 4, "value": "another", "group_id": 2, "valid_from": 110, "valid_until": 120}
NOTICE:    NEW: {"id": 4, "value": "multi-updated", "group_id": 2, "valid_from": 110, "valid_until": 120}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,multi-updated,20,30)
NOTICE:      (3,2,inserted,100,110)
NOTICE:      (4,2,multi-updated,110,120)
COMMIT;
\echo '\n\n--- Scenario 5: Two statements in one transaction ---'


--- Scenario 5: Two statements in one transaction ---
\echo 'Observation: The triggers for the second UPDATE statement see the table state'
Observation: The triggers for the second UPDATE statement see the table state
\echo 'that includes the completed update from the first statement.'
that includes the completed update from the first statement.
BEGIN;
\echo '-- First statement in transaction --'
-- First statement in transaction --
UPDATE mvcc_test.t SET value = 'tx-update-1' WHERE id = 2;
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 2, "value": "multi-updated", "group_id": 1, "valid_from": 20, "valid_until": 30}
NOTICE:    NEW: {"id": 2, "value": "tx-update-1", "group_id": 1, "valid_from": 20, "valid_until": 30}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,multi-updated,20,30)
NOTICE:      (3,2,inserted,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 2, "value": "multi-updated", "group_id": 1, "valid_from": 20, "valid_until": 30}
NOTICE:    NEW: {"id": 2, "value": "tx-update-1", "group_id": 1, "valid_from": 20, "valid_until": 30}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,inserted,100,110)
NOTICE:      (4,2,multi-updated,110,120)
\echo '-- Second statement in transaction --'
-- Second statement in transaction --
UPDATE mvcc_test.t SET value = 'tx-update-2' WHERE id = 3;
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 3, "value": "inserted", "group_id": 2, "valid_from": 100, "valid_until": 110}
NOTICE:    NEW: {"id": 3, "value": "tx-update-2", "group_id": 2, "valid_from": 100, "valid_until": 110}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,inserted,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 3, "value": "inserted", "group_id": 2, "valid_from": 100, "valid_until": 110}
NOTICE:    NEW: {"id": 3, "value": "tx-update-2", "group_id": 2, "valid_from": 100, "valid_until": 110}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,tx-update-2,100,110)
NOTICE:      (4,2,multi-updated,110,120)
COMMIT;
\echo '\n\n--- Scenario 6: Adjusting Adjacent Timelines (SCD Type 2 simulation) ---'


--- Scenario 6: Adjusting Adjacent Timelines (SCD Type 2 simulation) ---
\echo 'Observation: This scenario demonstrates why the order of operations is critical'
Observation: This scenario demonstrates why the order of operations is critical
\echo 'for temporal data. A "grow" operation (extending a period) must happen before a'
for temporal data. A "grow" operation (extending a period) must happen before a
\echo '"shrink" operation to avoid creating a transient gap that would cause a temporal'
"shrink" operation to avoid creating a transient gap that would cause a temporal
\echo 'foreign key check to fail.'
foreign key check to fail.
BEGIN;
SET CONSTRAINTS ALL DEFERRED;
-- Setup: two adjacent timeline segments for group_id=3
INSERT INTO mvcc_test.t VALUES (5, 3, 'a', 100, 200), (6, 3, 'b', 200, 300);
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE INSERT ON mvcc_test.t
NOTICE:    NEW: {"id": 5, "value": "a", "group_id": 3, "valid_from": 100, "valid_until": 200}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,tx-update-2,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE INSERT ON mvcc_test.t
NOTICE:    NEW: {"id": 6, "value": "b", "group_id": 3, "valid_from": 200, "valid_until": 300}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,tx-update-2,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:      (5,3,a,100,200)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER INSERT ON mvcc_test.t
NOTICE:    NEW: {"id": 5, "value": "a", "group_id": 3, "valid_from": 100, "valid_until": 200}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,tx-update-2,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:      (5,3,a,100,200)
NOTICE:      (6,3,b,200,300)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER INSERT ON mvcc_test.t
NOTICE:    NEW: {"id": 6, "value": "b", "group_id": 3, "valid_from": 200, "valid_until": 300}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,tx-update-2,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:      (5,3,a,100,200)
NOTICE:      (6,3,b,200,300)
\echo '\n-- 6a: Shrink then Grow (Incorrect Order) --'

-- 6a: Shrink then Grow (Incorrect Order) --
\echo '-- We update id=5 to end at 150. The AFTER trigger for this statement sees a'
-- We update id=5 to end at 150. The AFTER trigger for this statement sees a
\echo '-- gap from 150 to 200. A temporal FK check would fail here.'
-- gap from 150 to 200. A temporal FK check would fail here.
SAVEPOINT shrink_grow;
UPDATE mvcc_test.t SET valid_until = 150 WHERE id = 5;
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 5, "value": "a", "group_id": 3, "valid_from": 100, "valid_until": 200}
NOTICE:    NEW: {"id": 5, "value": "a", "group_id": 3, "valid_from": 100, "valid_until": 150}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,tx-update-2,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:      (5,3,a,100,200)
NOTICE:      (6,3,b,200,300)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 5, "value": "a", "group_id": 3, "valid_from": 100, "valid_until": 200}
NOTICE:    NEW: {"id": 5, "value": "a", "group_id": 3, "valid_from": 100, "valid_until": 150}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,tx-update-2,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:      (5,3,a,100,150)
NOTICE:      (6,3,b,200,300)
\echo '\n-- We update id=6 to start at 150, closing the gap.'

-- We update id=6 to start at 150, closing the gap.
UPDATE mvcc_test.t SET valid_from = 150 WHERE id = 6;
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 6, "value": "b", "group_id": 3, "valid_from": 200, "valid_until": 300}
NOTICE:    NEW: {"id": 6, "value": "b", "group_id": 3, "valid_from": 150, "valid_until": 300}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,tx-update-2,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:      (5,3,a,100,150)
NOTICE:      (6,3,b,200,300)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 6, "value": "b", "group_id": 3, "valid_from": 200, "valid_until": 300}
NOTICE:    NEW: {"id": 6, "value": "b", "group_id": 3, "valid_from": 150, "valid_until": 300}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,tx-update-2,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:      (5,3,a,100,150)
NOTICE:      (6,3,b,150,300)
ROLLBACK TO SAVEPOINT shrink_grow;
\echo '\n-- 6b: Grow then Shrink (Correct Order) --'

-- 6b: Grow then Shrink (Correct Order) --
\echo '-- We update id=6 to start at 150. This creates a temporary overlap from 150 to 200.'
-- We update id=6 to start at 150. This creates a temporary overlap from 150 to 200.
\echo '-- The deferred EXCLUDE constraint allows this. An FK check here would pass.'
-- The deferred EXCLUDE constraint allows this. An FK check here would pass.
UPDATE mvcc_test.t SET valid_from = 150 WHERE id = 6;
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 6, "value": "b", "group_id": 3, "valid_from": 200, "valid_until": 300}
NOTICE:    NEW: {"id": 6, "value": "b", "group_id": 3, "valid_from": 150, "valid_until": 300}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,tx-update-2,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:      (5,3,a,100,200)
NOTICE:      (6,3,b,200,300)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 6, "value": "b", "group_id": 3, "valid_from": 200, "valid_until": 300}
NOTICE:    NEW: {"id": 6, "value": "b", "group_id": 3, "valid_from": 150, "valid_until": 300}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,tx-update-2,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:      (5,3,a,100,200)
NOTICE:      (6,3,b,150,300)
\echo '\n-- We update id=5 to end at 150, resolving the overlap. The AFTER trigger'

-- We update id=5 to end at 150, resolving the overlap. The AFTER trigger
\echo '-- for this statement sees a continuous, valid timeline.'
-- for this statement sees a continuous, valid timeline.
UPDATE mvcc_test.t SET valid_until = 150 WHERE id = 5;
NOTICE:  ---
NOTICE:  Trigger Fired: BEFORE UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 5, "value": "a", "group_id": 3, "valid_from": 100, "valid_until": 200}
NOTICE:    NEW: {"id": 5, "value": "a", "group_id": 3, "valid_from": 100, "valid_until": 150}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,tx-update-2,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:      (5,3,a,100,200)
NOTICE:      (6,3,b,150,300)
NOTICE:  ---
NOTICE:  Trigger Fired: AFTER UPDATE ON mvcc_test.t
NOTICE:    OLD: {"id": 5, "value": "a", "group_id": 3, "valid_from": 100, "valid_until": 200}
NOTICE:    NEW: {"id": 5, "value": "a", "group_id": 3, "valid_from": 100, "valid_until": 150}
NOTICE:    Visible Table State (SELECT * FROM mvcc_test.t):
NOTICE:      (1,1,updated,10,20)
NOTICE:      (2,1,tx-update-1,20,30)
NOTICE:      (3,2,tx-update-2,100,110)
NOTICE:      (4,2,multi-updated,110,120)
NOTICE:      (5,3,a,100,150)
NOTICE:      (6,3,b,150,300)
COMMIT;
\echo '\n--- Final State ---'

--- Final State ---
TABLE mvcc_test.t ORDER BY id;
 id | group_id |     value     | valid_from | valid_until 
----+----------+---------------+------------+-------------
  1 |        1 | updated       |         10 |          20
  2 |        1 | tx-update-1   |         20 |          30
  3 |        2 | tx-update-2   |        100 |         110
  4 |        2 | multi-updated |        110 |         120
  5 |        3 | a             |        100 |         150
  6 |        3 | b             |        150 |         300
(6 rows)

DROP SCHEMA mvcc_test CASCADE;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to table mvcc_test.t
drop cascades to function mvcc_test.log_trigger()
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
