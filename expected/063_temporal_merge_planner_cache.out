\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo 'Test: `temporal_merge_plan` EXPLAIN output for performance monitoring'
Test: `temporal_merge_plan` EXPLAIN output for performance monitoring
\echo 'This test verifies that the planner function produces a stable and efficient'
This test verifies that the planner function produces a stable and efficient
\echo 'EXPLAIN plan. Its output is captured to monitor for performance regressions.'
EXPLAIN plan. Its output is captured to monitor for performance regressions.
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
-- Instruct temporal_merge to RAISE NOTICE the sql used for analysis.
SET client_min_messages TO NOTICE;
SET sql_saga.temporal_merge.log_sql = true;
CREATE SCHEMA tmpc;
--------------------------------------------------------------------------------
-- SCENARIO 1: Simple Surrogate Primary Key (id int NOT NULL)
--------------------------------------------------------------------------------
SAVEPOINT s1;
\echo '\n--- Scenario 1: Simple Surrogate Primary Key (id int NOT NULL) ---'

--- Scenario 1: Simple Surrogate Primary Key (id int NOT NULL) ---
CREATE TABLE tmpc.target (id int NOT NULL, valid_from date, valid_until date, value text);
SELECT sql_saga.add_era('tmpc.target', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

CREATE TABLE tmpc.source1 (row_id int, id int NOT NULL, valid_from date, valid_until date, value text);
\echo '--- Setting up tables with indexes and data for a realistic plan ---'
--- Setting up tables with indexes and data for a realistic plan ---
SELECT sql_saga.add_unique_key(table_oid => 'tmpc.target'::regclass, column_names => ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table tmpc.target to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_from) DEFERRABLE, ADD CONSTRAINT target_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
 add_unique_key  
-----------------
 target_id_valid
(1 row)

CREATE INDEX ON tmpc.source1 (id);
CREATE INDEX ON tmpc.source1 USING gist (daterange(valid_from, valid_until));
\echo '\d tmpc.target'
d tmpc.target
\d tmpc.target
                       Table "tmpc.target"
   Column    |  Type   | Collation | Nullable |     Default      
-------------+---------+-----------+----------+------------------
 id          | integer |           | not null | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 'infinity'::date
 value       | text    |           |          | 
Indexes:
    "target_pkey" PRIMARY KEY, btree (id, valid_from) DEFERRABLE
    "target_id_idx" btree (id)
    "target_id_valid_excl" EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
Check constraints:
    "target_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

\echo '\d tmpc.source1'
d tmpc.source1
\d tmpc.source1
                  Table "tmpc.source1"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 row_id      | integer |           |          | 
 id          | integer |           | not null | 
 valid_from  | date    |           |          | 
 valid_until | date    |           |          | 
 value       | text    |           |          | 
Indexes:
    "source1_daterange_idx" gist (daterange(valid_from, valid_until))
    "source1_id_idx" btree (id)

-- Insert enough rows to make an index scan more attractive to the planner.
INSERT INTO tmpc.target (id, valid_from, valid_until, value)
SELECT i, '2023-01-01', '2024-01-01', 'A' FROM generate_series(1, 1000) as i;
INSERT INTO tmpc.source1 VALUES (1, 500, '2023-06-01', '2023-07-01', 'B');
ANALYZE tmpc.target;
ANALYZE tmpc.source1;
\echo '\n--- Performance Monitoring: EXPLAIN the cached planner query ---'

--- Performance Monitoring: EXPLAIN the cached planner query ---
\o /dev/null
SELECT * FROM sql_saga.temporal_merge_plan(
    target_table => 'tmpc.target'::regclass,
    source_table => 'tmpc.source1'::regclass,
    identity_columns => '{id}'::text[],
    mode => 'MERGE_ENTITY_PATCH'::sql_saga.temporal_merge_mode,
    era_name => 'valid'
);
\o
SELECT format('EXPLAIN (COSTS OFF) EXECUTE %I;', name) as explain_command FROM pg_prepared_statements WHERE name LIKE 'tm_plan_%' AND statement LIKE '%FROM tmpc.source1 t%' \gset
no rows returned for \gset
\echo EXPLAIN (COSTS OFF) EXECUTE tm_plan_<...>;
EXPLAIN (COSTS OFF) EXECUTE tm_plan_<...>;
:explain_command
\echo '\n--- Verifying that the plan is optimal (no Seq Scan on target) ---'

--- Verifying that the plan is optimal (no Seq Scan on target) ---
DO $$
DECLARE plan_name TEXT; rec RECORD; has_seq_scan BOOLEAN := false;
BEGIN
    SELECT name INTO plan_name FROM pg_prepared_statements WHERE name LIKE 'tm_plan_%' AND statement LIKE '%FROM tmpc.source1 t%';
    IF plan_name IS NULL THEN RAISE EXCEPTION 'Could not find the prepared statement for the temporal_merge_plan.'; END IF;
    FOR rec IN EXECUTE 'EXPLAIN (COSTS OFF) EXECUTE ' || quote_ident(plan_name) LOOP
        IF rec."QUERY PLAN" LIKE '%Seq Scan on target%' THEN has_seq_scan := true; EXIT; END IF;
    END LOOP;
    IF has_seq_scan THEN RAISE EXCEPTION 'Performance regression detected: EXPLAIN plan contains a "Seq Scan on target". Check for non-SARGable query conditions.'; END IF;
END;
$$;
ERROR:  syntax error at or near ":"
LINE 1: :explain_command
        ^
\echo '--- OK: Verified that EXPLAIN plan is optimal. ---'
--- OK: Verified that EXPLAIN plan is optimal. ---
ROLLBACK TO SAVEPOINT s1;
--------------------------------------------------------------------------------
-- SCENARIO 2: Composite Natural Key (NOT NULL columns)
--------------------------------------------------------------------------------
SAVEPOINT s2;
\echo '\n--- Scenario 2: Composite Natural Key (NOT NULL columns) ---'

--- Scenario 2: Composite Natural Key (NOT NULL columns) ---
CREATE TABLE tmpc.target_nk_not_null (type TEXT NOT NULL, lu_id INT NOT NULL, value TEXT, valid_from date, valid_until date);
SELECT sql_saga.add_era('tmpc.target_nk_not_null', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

CREATE TABLE tmpc.source_nk_not_null (row_id int, type text NOT NULL, lu_id int NOT NULL, value text, valid_from date, valid_until date);
\echo '--- Setting up tables with indexes and data for a realistic plan ---'
--- Setting up tables with indexes and data for a realistic plan ---
SELECT sql_saga.add_unique_key(table_oid => 'tmpc.target_nk_not_null'::regclass, column_names => ARRAY['type', 'lu_id'], key_type => 'primary');
NOTICE:  sql_saga: altering table tmpc.target_nk_not_null to add constraints: ALTER COLUMN type SET NOT NULL, ALTER COLUMN lu_id SET NOT NULL, ADD PRIMARY KEY (type, lu_id, valid_from) DEFERRABLE, ADD CONSTRAINT target_nk_not_null_type_lu_id_valid_excl EXCLUDE USING gist (type WITH =, lu_id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
           add_unique_key            
-------------------------------------
 target_nk_not_null_type_lu_id_valid
(1 row)

INSERT INTO tmpc.target_nk_not_null (type, lu_id, valid_from, valid_until, value) SELECT 'A', i, '2023-01-01', '2024-01-01', 'LU' FROM generate_series(1, 1000) as i;
INSERT INTO tmpc.source_nk_not_null VALUES (1, 'A', 500, 'LU-patched', '2023-06-01', '2023-07-01');
ANALYZE tmpc.target_nk_not_null;
ANALYZE tmpc.source_nk_not_null;
\echo '\d tmpc.target_nk_not_null'
d tmpc.target_nk_not_null
\d tmpc.target_nk_not_null
                 Table "tmpc.target_nk_not_null"
   Column    |  Type   | Collation | Nullable |     Default      
-------------+---------+-----------+----------+------------------
 type        | text    |           | not null | 
 lu_id       | integer |           | not null | 
 value       | text    |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 'infinity'::date
Indexes:
    "target_nk_not_null_pkey" PRIMARY KEY, btree (type, lu_id, valid_from) DEFERRABLE
    "target_nk_not_null_type_lu_id_idx" btree (type, lu_id)
    "target_nk_not_null_type_lu_id_valid_excl" EXCLUDE USING gist (type WITH =, lu_id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
Check constraints:
    "target_nk_not_null_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

\echo '\d tmpc.source_nk_not_null'
d tmpc.source_nk_not_null
\d tmpc.source_nk_not_null
            Table "tmpc.source_nk_not_null"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 row_id      | integer |           |          | 
 type        | text    |           | not null | 
 lu_id       | integer |           | not null | 
 value       | text    |           |          | 
 valid_from  | date    |           |          | 
 valid_until | date    |           |          | 

\echo '\n--- Performance Monitoring: EXPLAIN the cached planner query (Natural Key, NOT NULL) ---'

--- Performance Monitoring: EXPLAIN the cached planner query (Natural Key, NOT NULL) ---
\o /dev/null
SELECT * FROM sql_saga.temporal_merge_plan(
    target_table => 'tmpc.target_nk_not_null'::regclass,
    source_table => 'tmpc.source_nk_not_null'::regclass,
    identity_columns => '{type,lu_id}'::text[],
    mode => 'MERGE_ENTITY_PATCH'::sql_saga.temporal_merge_mode,
    era_name => 'valid'
);
\o
SELECT format('EXPLAIN (COSTS OFF) EXECUTE %I;', name) as explain_command_nk_nn FROM pg_prepared_statements WHERE name LIKE 'tm_plan_%' AND statement LIKE '%FROM tmpc.source_nk_not_null t%' \gset
no rows returned for \gset
\echo EXPLAIN (COSTS OFF) EXECUTE tm_plan_<...>;
EXPLAIN (COSTS OFF) EXECUTE tm_plan_<...>;
:explain_command_nk_nn
\echo '\n--- Verifying that the plan is optimal (no Seq Scan on target) ---'

--- Verifying that the plan is optimal (no Seq Scan on target) ---
DO $$
DECLARE plan_name TEXT; rec RECORD; has_seq_scan BOOLEAN := false;
BEGIN
    SELECT name INTO plan_name FROM pg_prepared_statements WHERE name LIKE 'tm_plan_%' AND statement LIKE '%FROM tmpc.source_nk_not_null t%';
    IF plan_name IS NULL THEN RAISE EXCEPTION 'Could not find the prepared statement for the non-null natural key temporal_merge_plan.'; END IF;
    FOR rec IN EXECUTE 'EXPLAIN (COSTS OFF) EXECUTE ' || quote_ident(plan_name) LOOP
        IF rec."QUERY PLAN" LIKE '%Seq Scan on target_nk_not_null%' THEN has_seq_scan := true; EXIT; END IF;
    END LOOP;
    IF has_seq_scan THEN RAISE EXCEPTION 'Performance regression detected: EXPLAIN plan for non-null natural key contains a "Seq Scan on target_nk_not_null".'; END IF;
END;
$$;
ERROR:  syntax error at or near ":"
LINE 1: :explain_command_nk_nn
        ^
\echo '--- OK: Verified that EXPLAIN plan for non-null natural key is optimal. ---'
--- OK: Verified that EXPLAIN plan for non-null natural key is optimal. ---
ROLLBACK TO SAVEPOINT s2;
--------------------------------------------------------------------------------
-- SCENARIO 3: Composite Natural Key with NULLable XOR columns
--------------------------------------------------------------------------------
SAVEPOINT s3;
\echo '\n--- Scenario 3: Composite Natural Key with NULLable XOR columns ---'

--- Scenario 3: Composite Natural Key with NULLable XOR columns ---
CREATE TABLE tmpc.target_nk (type TEXT NOT NULL, lu_id INT, es_id INT, value TEXT, valid_from date, valid_until date,
    CONSTRAINT lu_or_es_id_check CHECK ((lu_id IS NOT NULL AND es_id IS NULL) OR (lu_id IS NULL AND es_id IS NOT NULL))
);
SELECT sql_saga.add_era('tmpc.target_nk', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

CREATE TABLE tmpc.source_nk (row_id int, type text NOT NULL, lu_id int, es_id int, value text, valid_from date, valid_until date,
    CONSTRAINT source_lu_or_es_id_check CHECK ((lu_id IS NOT NULL AND es_id IS NULL) OR (lu_id IS NULL AND es_id IS NOT NULL))
);
\echo '--- Setting up natural key tables with partial indexes and data ---'
--- Setting up natural key tables with partial indexes and data ---
SELECT sql_saga.add_unique_key(table_oid => 'tmpc.target_nk'::regclass, column_names => ARRAY['type', 'lu_id'], key_type => 'predicated', predicate => 'es_id IS NULL');
NOTICE:  sql_saga: altering table tmpc.target_nk to add constraints: ADD CONSTRAINT target_nk_type_lu_id_valid_excl EXCLUDE USING gist (type WITH =, lu_id WITH =, daterange(valid_from, valid_until) WITH &&) WHERE (es_id IS NULL) DEFERRABLE
       add_unique_key       
----------------------------
 target_nk_type_lu_id_valid
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'tmpc.target_nk'::regclass, column_names => ARRAY['type', 'es_id'], key_type => 'predicated', predicate => 'lu_id IS NULL');
NOTICE:  sql_saga: altering table tmpc.target_nk to add constraints: ADD CONSTRAINT target_nk_type_es_id_valid_excl EXCLUDE USING gist (type WITH =, es_id WITH =, daterange(valid_from, valid_until) WITH &&) WHERE (lu_id IS NULL) DEFERRABLE
       add_unique_key       
----------------------------
 target_nk_type_es_id_valid
(1 row)

INSERT INTO tmpc.target_nk (type, lu_id, es_id, valid_from, valid_until, value) SELECT 'A', i, NULL, '2023-01-01', '2024-01-01', 'LU' FROM generate_series(1, 1000) as i;
INSERT INTO tmpc.target_nk (type, lu_id, es_id, valid_from, valid_until, value) SELECT 'B', NULL, i, '2023-01-01', '2024-01-01', 'ES' FROM generate_series(1, 1000) as i;
INSERT INTO tmpc.source_nk VALUES (1, 'A', 500, NULL, 'LU-patched', '2023-06-01', '2023-07-01');
INSERT INTO tmpc.source_nk VALUES (2, 'B', NULL, 500, 'ES-patched', '2023-06-01', '2023-07-01');
ANALYZE tmpc.target_nk;
ANALYZE tmpc.source_nk;
\echo '\d tmpc.target_nk'
d tmpc.target_nk
\d tmpc.target_nk
                     Table "tmpc.target_nk"
   Column    |  Type   | Collation | Nullable |     Default      
-------------+---------+-----------+----------+------------------
 type        | text    |           | not null | 
 lu_id       | integer |           |          | 
 es_id       | integer |           |          | 
 value       | text    |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 'infinity'::date
Indexes:
    "target_nk_type_es_id_idx" btree (type, es_id)
    "target_nk_type_es_id_valid_excl" EXCLUDE USING gist (type WITH =, es_id WITH =, daterange(valid_from, valid_until) WITH &&) WHERE (lu_id IS NULL) DEFERRABLE
    "target_nk_type_es_id_valid_idx" UNIQUE, btree (type, es_id, valid_from, valid_until) WHERE lu_id IS NULL
    "target_nk_type_lu_id_idx" btree (type, lu_id)
    "target_nk_type_lu_id_valid_excl" EXCLUDE USING gist (type WITH =, lu_id WITH =, daterange(valid_from, valid_until) WITH &&) WHERE (es_id IS NULL) DEFERRABLE
    "target_nk_type_lu_id_valid_idx" UNIQUE, btree (type, lu_id, valid_from, valid_until) WHERE es_id IS NULL
Check constraints:
    "lu_or_es_id_check" CHECK (lu_id IS NOT NULL AND es_id IS NULL OR lu_id IS NULL AND es_id IS NOT NULL)
    "target_nk_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

\echo '\d tmpc.source_nk'
d tmpc.source_nk
\d tmpc.source_nk
                 Table "tmpc.source_nk"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 row_id      | integer |           |          | 
 type        | text    |           | not null | 
 lu_id       | integer |           |          | 
 es_id       | integer |           |          | 
 value       | text    |           |          | 
 valid_from  | date    |           |          | 
 valid_until | date    |           |          | 
Check constraints:
    "source_lu_or_es_id_check" CHECK (lu_id IS NOT NULL AND es_id IS NULL OR lu_id IS NULL AND es_id IS NOT NULL)

\echo '\n--- Performance Monitoring: EXPLAIN the cached planner query (Natural Key, NULLable) ---'

--- Performance Monitoring: EXPLAIN the cached planner query (Natural Key, NULLable) ---
\o /dev/null
SELECT * FROM sql_saga.temporal_merge_plan(
    target_table => 'tmpc.target_nk'::regclass,
    source_table => 'tmpc.source_nk'::regclass,
    identity_columns => '{type,lu_id,es_id}'::text[],
    mode => 'MERGE_ENTITY_PATCH'::sql_saga.temporal_merge_mode,
    era_name => 'valid'
);
\o
SELECT format('EXPLAIN (COSTS OFF) EXECUTE %I;', name) as explain_command_nk FROM pg_prepared_statements WHERE name LIKE 'tm_plan_%' AND statement LIKE '%FROM tmpc.source_nk t%' \gset
no rows returned for \gset
\echo EXPLAIN (COSTS OFF) EXECUTE tm_plan_<...>;
EXPLAIN (COSTS OFF) EXECUTE tm_plan_<...>;
:explain_command_nk
\echo '\n--- Verifying that the plan is optimal (no Seq Scan on target) ---'

--- Verifying that the plan is optimal (no Seq Scan on target) ---
DO $$
DECLARE plan_name TEXT; rec RECORD; has_seq_scan BOOLEAN := false;
BEGIN
    SELECT name INTO plan_name FROM pg_prepared_statements WHERE name LIKE 'tm_plan_%' AND statement LIKE '%FROM tmpc.source_nk t%';
    IF plan_name IS NULL THEN RAISE EXCEPTION 'Could not find the prepared statement for the nullable natural key temporal_merge_plan.'; END IF;
    FOR rec IN EXECUTE 'EXPLAIN (COSTS OFF) EXECUTE ' || quote_ident(plan_name) LOOP
        IF rec."QUERY PLAN" LIKE '%Seq Scan on target_nk%' THEN has_seq_scan := true; EXIT; END IF;
    END LOOP;
    IF has_seq_scan THEN RAISE EXCEPTION 'Performance regression detected: EXPLAIN plan for nullable natural key contains a "Seq Scan on target_nk".'; END IF;
END;
$$;
ERROR:  syntax error at or near ":"
LINE 1: :explain_command_nk
        ^
\echo '--- OK: Verified that EXPLAIN plan for natural key is optimal. ---'
--- OK: Verified that EXPLAIN plan for natural key is optimal. ---
ROLLBACK TO SAVEPOINT s3;
SET client_min_messages TO NOTICE;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
