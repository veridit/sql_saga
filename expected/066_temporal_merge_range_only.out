\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo 'Test Suite: `sql_saga.temporal_merge` Range-Only Tables'
Test Suite: `sql_saga.temporal_merge` Range-Only Tables
\echo 'Description:'
Description:
\echo '  This test suite verifies that `temporal_merge` works correctly with tables'
  This test suite verifies that `temporal_merge` works correctly with tables
\echo '  that have ONLY a range column (no valid_from/valid_until/valid_to columns).'
  that have ONLY a range column (no valid_from/valid_until/valid_to columns).
\echo '  This validates the new valid_range-first API where synchronized columns'
  This validates the new valid_range-first API where synchronized columns
\echo '  are optional.'
  are optional.
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
SET client_min_messages TO NOTICE;
CREATE SCHEMA tmro; -- Temporal Merge Range Only
--------------------------------------------------------------------------------
\echo 'Scenario 1: Basic PATCH with daterange (range-only target)'
Scenario 1: Basic PATCH with daterange (range-only target)
--------------------------------------------------------------------------------
CREATE TABLE tmro.target_date (
    id int,
    valid_range daterange NOT NULL,
    value text,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('tmro.target_date', 'valid_range');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmro.target_date', ARRAY['id']);
NOTICE:  sql_saga: Added constraints to table tmro.target_date: ADD CONSTRAINT target_date_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
    add_unique_key    
----------------------
 target_date_id_valid
(1 row)

INSERT INTO tmro.target_date (id, valid_range, value) VALUES
    (1, '[2024-01-01, 2024-12-31)', 'Original');
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
TABLE tmro.target_date ORDER BY id, valid_range;
 id |       valid_range       |  value   
----+-------------------------+----------
  1 | [2024-01-01,2024-12-31) | Original
(1 row)

-- Source also uses range-only
CREATE TEMP TABLE source_date_1 (row_id int, id int, valid_range daterange, value text);
INSERT INTO source_date_1 VALUES
    (101, 1, '[2024-03-01, 2024-06-01)', 'Patched'),  -- Update middle portion
    (102, 2, '[2024-01-01, 2024-12-31)', 'New');      -- Insert new entity
\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
TABLE source_date_1 ORDER BY row_id;
 row_id | id |       valid_range       |  value  
--------+----+-------------------------+---------
    101 |  1 | [2024-03-01,2024-06-01) | Patched
    102 |  2 | [2024-01-01,2024-12-31) | New
(2 rows)

CALL sql_saga.temporal_merge(
    target_table => 'tmro.target_date'::regclass,
    source_table => 'source_date_1'::regclass,
    primary_identity_columns => '{id}'::text[]
);
\echo '--- Plan ---'
--- Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |     old_valid_range     |     new_valid_range     |         data          | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------+-------------------------+-----------------------+----------+-------+--------------------
           1 |             1 | {101}   | UPDATE    | SHRINK        | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | started_by   | 2024-01-01     | 2024-12-31      | 2024-01-01     | 2024-03-01      | [2024-01-01,2024-12-31) | [2024-01-01,2024-03-01) | {"value": "Original"} |          |       | existing_entity__1
           2 |             2 | {101}   | INSERT    |               | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | contains     | 2024-01-01     | 2024-12-31      | 2024-03-01     | 2024-06-01      | [2024-01-01,2024-12-31) | [2024-03-01,2024-06-01) | {"value": "Patched"}  |          |       | existing_entity__1
           3 |             2 | {101}   | INSERT    |               | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | finished_by  | 2024-01-01     | 2024-12-31      | 2024-06-01     | 2024-12-31      | [2024-01-01,2024-12-31) | [2024-06-01,2024-12-31) | {"value": "Original"} |          |       | existing_entity__1
           4 |             2 | {102}   | INSERT    |               | 102       | t             | {"id": 2}   | {"id": 2}     | {"id": 2}   |              |              |                |                 | 2024-01-01     | 2024-12-31      |                         | [2024-01-01,2024-12-31) | {"value": "New"}      |          |       | new_entity__2
(4 rows)

\echo '--- Expected Final State ---'
--- Expected Final State ---
SELECT * FROM (VALUES
    (1, '[2024-01-01, 2024-03-01)'::daterange, 'Original'),
    (1, '[2024-03-01, 2024-06-01)'::daterange, 'Patched'),
    (1, '[2024-06-01, 2024-12-31)'::daterange, 'Original'),
    (2, '[2024-01-01, 2024-12-31)'::daterange, 'New')
) t(id, valid_range, value) ORDER BY id, valid_range;
 id |       valid_range       |  value   
----+-------------------------+----------
  1 | [2024-01-01,2024-03-01) | Original
  1 | [2024-03-01,2024-06-01) | Patched
  1 | [2024-06-01,2024-12-31) | Original
  2 | [2024-01-01,2024-12-31) | New
(4 rows)

\echo '--- Actual Final State ---'
--- Actual Final State ---
TABLE tmro.target_date ORDER BY id, valid_range;
 id |       valid_range       |  value   
----+-------------------------+----------
  1 | [2024-01-01,2024-03-01) | Original
  1 | [2024-03-01,2024-06-01) | Patched
  1 | [2024-06-01,2024-12-31) | Original
  2 | [2024-01-01,2024-12-31) | New
(4 rows)

--------------------------------------------------------------------------------
\echo 'Scenario 2: Basic PATCH with tstzrange (range-only target)'
Scenario 2: Basic PATCH with tstzrange (range-only target)
--------------------------------------------------------------------------------
CREATE TABLE tmro.target_tstz (
    id int,
    valid_range tstzrange NOT NULL,
    value text,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('tmro.target_tstz', 'valid_range');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmro.target_tstz', ARRAY['id']);
NOTICE:  sql_saga: Added constraints to table tmro.target_tstz: ADD CONSTRAINT target_tstz_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
    add_unique_key    
----------------------
 target_tstz_id_valid
(1 row)

INSERT INTO tmro.target_tstz (id, valid_range, value) VALUES
    (1, '[2024-01-01 00:00:00+00, 2024-12-31 00:00:00+00)', 'Original');
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
TABLE tmro.target_tstz ORDER BY id, valid_range;
 id |                     valid_range                     |  value   
----+-----------------------------------------------------+----------
  1 | ["2023-12-31 16:00:00-08","2024-12-30 16:00:00-08") | Original
(1 row)

CREATE TEMP TABLE source_tstz (row_id int, id int, valid_range tstzrange, value text);
INSERT INTO source_tstz VALUES
    (101, 1, '[2024-03-01 00:00:00+00, 2024-06-01 00:00:00+00)', 'Patched');
\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
TABLE source_tstz ORDER BY row_id;
 row_id | id |                     valid_range                     |  value  
--------+----+-----------------------------------------------------+---------
    101 |  1 | ["2024-02-29 16:00:00-08","2024-05-31 17:00:00-07") | Patched
(1 row)

CALL sql_saga.temporal_merge(
    target_table => 'tmro.target_tstz'::regclass,
    source_table => 'source_tstz'::regclass,
    primary_identity_columns => '{id}'::text[]
);
\echo '--- Plan ---'
--- Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation |     old_valid_from     |    old_valid_until     |     new_valid_from     |    new_valid_until     |                   old_valid_range                   |                   new_valid_range                   |         data          | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+------------------------+------------------------+------------------------+------------------------+-----------------------------------------------------+-----------------------------------------------------+-----------------------+----------+-------+--------------------
           1 |             1 | {101}   | UPDATE    | SHRINK        | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | started_by   | 2023-12-31 16:00:00-08 | 2024-12-30 16:00:00-08 | 2023-12-31 16:00:00-08 | 2024-02-29 16:00:00-08 | ["2023-12-31 16:00:00-08","2024-12-30 16:00:00-08") | ["2023-12-31 16:00:00-08","2024-02-29 16:00:00-08") | {"value": "Original"} |          |       | existing_entity__1
           2 |             2 | {101}   | INSERT    |               | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | contains     | 2023-12-31 16:00:00-08 | 2024-12-30 16:00:00-08 | 2024-02-29 16:00:00-08 | 2024-05-31 17:00:00-07 | ["2023-12-31 16:00:00-08","2024-12-30 16:00:00-08") | ["2024-02-29 16:00:00-08","2024-05-31 17:00:00-07") | {"value": "Patched"}  |          |       | existing_entity__1
           3 |             2 | {101}   | INSERT    |               | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | finished_by  | 2023-12-31 16:00:00-08 | 2024-12-30 16:00:00-08 | 2024-05-31 17:00:00-07 | 2024-12-30 16:00:00-08 | ["2023-12-31 16:00:00-08","2024-12-30 16:00:00-08") | ["2024-05-31 17:00:00-07","2024-12-30 16:00:00-08") | {"value": "Original"} |          |       | existing_entity__1
(3 rows)

\echo '--- Actual Final State ---'
--- Actual Final State ---
TABLE tmro.target_tstz ORDER BY id, valid_range;
 id |                     valid_range                     |  value   
----+-----------------------------------------------------+----------
  1 | ["2023-12-31 16:00:00-08","2024-02-29 16:00:00-08") | Original
  1 | ["2024-02-29 16:00:00-08","2024-05-31 17:00:00-07") | Patched
  1 | ["2024-05-31 17:00:00-07","2024-12-30 16:00:00-08") | Original
(3 rows)

--------------------------------------------------------------------------------
\echo 'Scenario 3: REPLACE mode with range-only table'
Scenario 3: REPLACE mode with range-only table
--------------------------------------------------------------------------------
SAVEPOINT scenario_3;
TRUNCATE tmro.target_date;
INSERT INTO tmro.target_date (id, valid_range, value) VALUES
    (1, '[2024-01-01, 2024-12-31)', 'Original');
CREATE TEMP TABLE source_replace (row_id int, id int, valid_range daterange, value text) ON COMMIT DROP;
INSERT INTO source_replace VALUES
    (101, 1, '[2024-03-01, 2024-06-01)', 'Replaced');
CALL sql_saga.temporal_merge(
    target_table => 'tmro.target_date'::regclass,
    source_table => 'source_replace'::regclass,
    primary_identity_columns => '{id}'::text[],
    mode => 'MERGE_ENTITY_REPLACE'
);
\echo '--- Plan ---'
--- Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |     old_valid_range     |     new_valid_range     |         data          | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------+-------------------------+-----------------------+----------+-------+--------------------
           1 |             1 | {101}   | UPDATE    | SHRINK        | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | started_by   | 2024-01-01     | 2024-12-31      | 2024-01-01     | 2024-03-01      | [2024-01-01,2024-12-31) | [2024-01-01,2024-03-01) | {"value": "Original"} |          |       | existing_entity__1
           2 |             2 | {101}   | INSERT    |               | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | contains     | 2024-01-01     | 2024-12-31      | 2024-03-01     | 2024-06-01      | [2024-01-01,2024-12-31) | [2024-03-01,2024-06-01) | {"value": "Replaced"} |          |       | existing_entity__1
           3 |             2 | {101}   | INSERT    |               | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | finished_by  | 2024-01-01     | 2024-12-31      | 2024-06-01     | 2024-12-31      | [2024-01-01,2024-12-31) | [2024-06-01,2024-12-31) | {"value": "Original"} |          |       | existing_entity__1
(3 rows)

\echo '--- Expected: Original segments kept, middle replaced ---'
--- Expected: Original segments kept, middle replaced ---
SELECT * FROM (VALUES
    (1, '[2024-01-01, 2024-03-01)'::daterange, 'Original'),
    (1, '[2024-03-01, 2024-06-01)'::daterange, 'Replaced'),
    (1, '[2024-06-01, 2024-12-31)'::daterange, 'Original')
) t(id, valid_range, value) ORDER BY id, valid_range;
 id |       valid_range       |  value   
----+-------------------------+----------
  1 | [2024-01-01,2024-03-01) | Original
  1 | [2024-03-01,2024-06-01) | Replaced
  1 | [2024-06-01,2024-12-31) | Original
(3 rows)

\echo '--- Actual Final State ---'
--- Actual Final State ---
TABLE tmro.target_date ORDER BY id, valid_range;
 id |       valid_range       |  value   
----+-------------------------+----------
  1 | [2024-01-01,2024-03-01) | Original
  1 | [2024-03-01,2024-06-01) | Replaced
  1 | [2024-06-01,2024-12-31) | Original
(3 rows)

ROLLBACK TO SAVEPOINT scenario_3;
--------------------------------------------------------------------------------
\echo 'Scenario 4: Source with valid_from/valid_until into range-only target'
Scenario 4: Source with valid_from/valid_until into range-only target
\echo '  When target has only a range column (no synchronized boundary columns),'
  When target has only a range column (no synchronized boundary columns),
\echo '  the source MUST provide data using the same range column.'
  the source MUST provide data using the same range column.
\echo '  This test verifies that an appropriate error is raised.'
  This test verifies that an appropriate error is raised.
--------------------------------------------------------------------------------
SAVEPOINT scenario_4;
TRUNCATE tmro.target_date;
INSERT INTO tmro.target_date (id, valid_range, value) VALUES
    (1, '[2024-01-01, 2024-12-31)', 'Original');
-- Source uses boundary columns instead of range - should fail
CREATE TEMP TABLE source_boundary (row_id int, id int, valid_from date, valid_until date, value text) ON COMMIT DROP;
INSERT INTO source_boundary VALUES
    (101, 1, '2024-03-01', '2024-06-01', 'From Boundary Source');
-- This should fail because target has no synchronized columns to fall back to
SAVEPOINT expect_error;
CALL sql_saga.temporal_merge(
    target_table => 'tmro.target_date'::regclass,
    source_table => 'source_boundary'::regclass,
    primary_identity_columns => '{id}'::text[]
);
ERROR:  Source table "source_boundary" must have either the range column "valid_range" or the component column "<NULL>".
CONTEXT:  PL/pgSQL function sql_saga.temporal_merge_plan(regclass,regclass,sql_saga.temporal_merge_mode,name,text[],name,name,sql_saga.temporal_merge_delete_mode,jsonb,text[],boolean,boolean) line 289 at RAISE
SQL statement "INSERT INTO temporal_merge_plan
    SELECT * FROM sql_saga.temporal_merge_plan(
        target_table => temporal_merge.target_table,
        source_table => temporal_merge.source_table,
        mode => temporal_merge.mode,
        era_name => temporal_merge.era_name,
        identity_columns => v_identity_cols_discovered,
        row_id_column => temporal_merge.row_id_column,
        founding_id_column => temporal_merge.founding_id_column,
        delete_mode => temporal_merge.delete_mode,
        lookup_keys => v_natural_identity_keys_discovered,
        ephemeral_columns => temporal_merge.ephemeral_columns,
        p_log_trace => v_log_trace,
        p_log_sql => v_log_sql
    )"
PL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 179 at SQL statement
ROLLBACK TO SAVEPOINT expect_error;
\echo '--- Workaround: Use a view to compute the range from boundary columns ---'
--- Workaround: Use a view to compute the range from boundary columns ---
CREATE TEMP VIEW source_boundary_with_range AS
SELECT row_id, id, daterange(valid_from, valid_until) AS valid_range, value
FROM source_boundary;
CALL sql_saga.temporal_merge(
    target_table => 'tmro.target_date'::regclass,
    source_table => 'source_boundary_with_range'::regclass,
    primary_identity_columns => '{id}'::text[]
);
\echo '--- Plan ---'
--- Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |     old_valid_range     |     new_valid_range     |               data                | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------+-------------------------+-----------------------------------+----------+-------+--------------------
           1 |             1 | {101}   | UPDATE    | SHRINK        | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | started_by   | 2024-01-01     | 2024-12-31      | 2024-01-01     | 2024-03-01      | [2024-01-01,2024-12-31) | [2024-01-01,2024-03-01) | {"value": "Original"}             |          |       | existing_entity__1
           2 |             2 | {101}   | INSERT    |               | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | contains     | 2024-01-01     | 2024-12-31      | 2024-03-01     | 2024-06-01      | [2024-01-01,2024-12-31) | [2024-03-01,2024-06-01) | {"value": "From Boundary Source"} |          |       | existing_entity__1
           3 |             2 | {101}   | INSERT    |               | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | finished_by  | 2024-01-01     | 2024-12-31      | 2024-06-01     | 2024-12-31      | [2024-01-01,2024-12-31) | [2024-06-01,2024-12-31) | {"value": "Original"}             |          |       | existing_entity__1
(3 rows)

\echo '--- Actual Final State ---'
--- Actual Final State ---
TABLE tmro.target_date ORDER BY id, valid_range;
 id |       valid_range       |        value         
----+-------------------------+----------------------
  1 | [2024-01-01,2024-03-01) | Original
  1 | [2024-03-01,2024-06-01) | From Boundary Source
  1 | [2024-06-01,2024-12-31) | Original
(3 rows)

ROLLBACK TO SAVEPOINT scenario_4;
--------------------------------------------------------------------------------
\echo 'Scenario 5: Range-only with int4range'
Scenario 5: Range-only with int4range
--------------------------------------------------------------------------------
CREATE TABLE tmro.target_int (
    id int,
    valid_range int4range NOT NULL,
    value text,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('tmro.target_int', 'valid_range');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmro.target_int', ARRAY['id']);
NOTICE:  sql_saga: Added constraints to table tmro.target_int: ADD CONSTRAINT target_int_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
   add_unique_key    
---------------------
 target_int_id_valid
(1 row)

INSERT INTO tmro.target_int (id, valid_range, value) VALUES
    (1, '[10, 100)', 'Original');
CREATE TEMP TABLE source_int (row_id int, id int, valid_range int4range, value text);
INSERT INTO source_int VALUES
    (101, 1, '[30, 60)', 'Patched');
CALL sql_saga.temporal_merge(
    target_table => 'tmro.target_int'::regclass,
    source_table => 'source_int'::regclass,
    primary_identity_columns => '{id}'::text[]
);
\echo '--- Plan ---'
--- Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until | old_valid_range | new_valid_range |         data          | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-----------------+-----------------+-----------------------+----------+-------+--------------------
           1 |             1 | {101}   | UPDATE    | SHRINK        | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | started_by   | 10             | 100             | 10             | 30              | [10,100)        | [10,30)         | {"value": "Original"} |          |       | existing_entity__1
           2 |             2 | {101}   | INSERT    |               | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | contains     | 10             | 100             | 30             | 60              | [10,100)        | [30,60)         | {"value": "Patched"}  |          |       | existing_entity__1
           3 |             2 | {101}   | INSERT    |               | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | finished_by  | 10             | 100             | 60             | 100             | [10,100)        | [60,100)        | {"value": "Original"} |          |       | existing_entity__1
(3 rows)

\echo '--- Expected Final State ---'
--- Expected Final State ---
SELECT * FROM (VALUES
    (1, '[10, 30)'::int4range, 'Original'),
    (1, '[30, 60)'::int4range, 'Patched'),
    (1, '[60, 100)'::int4range, 'Original')
) t(id, valid_range, value) ORDER BY id, valid_range;
 id | valid_range |  value   
----+-------------+----------
  1 | [10,30)     | Original
  1 | [30,60)     | Patched
  1 | [60,100)    | Original
(3 rows)

\echo '--- Actual Final State ---'
--- Actual Final State ---
TABLE tmro.target_int ORDER BY id, valid_range;
 id | valid_range |  value   
----+-------------+----------
  1 | [10,30)     | Original
  1 | [30,60)     | Patched
  1 | [60,100)    | Original
(3 rows)

--------------------------------------------------------------------------------
\echo 'Scenario 6: Coalescing adjacent identical segments (range-only)'
Scenario 6: Coalescing adjacent identical segments (range-only)
\echo '  Verifies that temporal_merge correctly coalesces when the patch'
  Verifies that temporal_merge correctly coalesces when the patch
\echo '  results in identical adjacent segments.'
  results in identical adjacent segments.
--------------------------------------------------------------------------------
SAVEPOINT scenario_6;
TRUNCATE tmro.target_date;
INSERT INTO tmro.target_date (id, valid_range, value) VALUES
    (1, '[2024-01-01, 2024-06-01)', 'A'),
    (1, '[2024-06-01, 2024-12-31)', 'B');
\echo '--- Target: Initial State (two segments) ---'
--- Target: Initial State (two segments) ---
TABLE tmro.target_date ORDER BY id, valid_range;
 id |       valid_range       | value 
----+-------------------------+-------
  1 | [2024-01-01,2024-06-01) | A
  1 | [2024-06-01,2024-12-31) | B
(2 rows)

-- Patch the second segment to match the first - should coalesce
CREATE TEMP TABLE source_coalesce (row_id int, id int, valid_range daterange, value text) ON COMMIT DROP;
INSERT INTO source_coalesce VALUES
    (101, 1, '[2024-06-01, 2024-12-31)', 'A');
CALL sql_saga.temporal_merge(
    target_table => 'tmro.target_date'::regclass,
    source_table => 'source_coalesce'::regclass,
    primary_identity_columns => '{id}'::text[]
);
\echo '--- Plan ---'
--- Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |     old_valid_range     |     new_valid_range     |      data      | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------+-------------------------+----------------+----------+-------+--------------------
           1 |             2 | {101}   | UPDATE    | GROW          | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | equals       | starts       | 2024-01-01     | 2024-06-01      | 2024-01-01     | 2024-12-31      | [2024-01-01,2024-06-01) | [2024-01-01,2024-12-31) | {"value": "A"} |          |       | existing_entity__1
           2 |             1 |         | DELETE    |               |           | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   |              |              | 2024-06-01     | 2024-12-31      |                |                 | [2024-06-01,2024-12-31) |                         |                |          |       | 
(2 rows)

\echo '--- Expected: Single coalesced segment ---'
--- Expected: Single coalesced segment ---
SELECT * FROM (VALUES
    (1, '[2024-01-01, 2024-12-31)'::daterange, 'A')
) t(id, valid_range, value) ORDER BY id, valid_range;
 id |       valid_range       | value 
----+-------------------------+-------
  1 | [2024-01-01,2024-12-31) | A
(1 row)

\echo '--- Actual Final State ---'
--- Actual Final State ---
TABLE tmro.target_date ORDER BY id, valid_range;
 id |       valid_range       | value 
----+-------------------------+-------
  1 | [2024-01-01,2024-12-31) | A
(1 row)

ROLLBACK TO SAVEPOINT scenario_6;
--------------------------------------------------------------------------------
\echo 'Scenario 7: DELETE_FOR_PORTION_OF with range-only table'
Scenario 7: DELETE_FOR_PORTION_OF with range-only table
--------------------------------------------------------------------------------
SAVEPOINT scenario_7;
TRUNCATE tmro.target_date;
INSERT INTO tmro.target_date (id, valid_range, value) VALUES
    (1, '[2024-01-01, 2024-12-31)', 'Original');
CREATE TEMP TABLE source_delete (row_id int, id int, valid_range daterange) ON COMMIT DROP;
INSERT INTO source_delete VALUES
    (101, 1, '[2024-03-01, 2024-06-01)');
CALL sql_saga.temporal_merge(
    target_table => 'tmro.target_date'::regclass,
    source_table => 'source_delete'::regclass,
    primary_identity_columns => '{id}'::text[],
    mode => 'DELETE_FOR_PORTION_OF'
);
\echo '--- Plan ---'
--- Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |     old_valid_range     |     new_valid_range     |         data          | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------+-------------------------+-----------------------+----------+-------+--------------------
           1 |             1 | {101}   | UPDATE    | SHRINK        | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | started_by   | 2024-01-01     | 2024-12-31      | 2024-01-01     | 2024-03-01      | [2024-01-01,2024-12-31) | [2024-01-01,2024-03-01) | {"value": "Original"} |          |       | existing_entity__1
           2 |             2 | {101}   | INSERT    |               | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | finished_by  | 2024-01-01     | 2024-12-31      | 2024-06-01     | 2024-12-31      | [2024-01-01,2024-12-31) | [2024-06-01,2024-12-31) | {"value": "Original"} |          |       | existing_entity__1
(2 rows)

\echo '--- Expected: Gap in middle ---'
--- Expected: Gap in middle ---
SELECT * FROM (VALUES
    (1, '[2024-01-01, 2024-03-01)'::daterange, 'Original'),
    (1, '[2024-06-01, 2024-12-31)'::daterange, 'Original')
) t(id, valid_range, value) ORDER BY id, valid_range;
 id |       valid_range       |  value   
----+-------------------------+----------
  1 | [2024-01-01,2024-03-01) | Original
  1 | [2024-06-01,2024-12-31) | Original
(2 rows)

\echo '--- Actual Final State ---'
--- Actual Final State ---
TABLE tmro.target_date ORDER BY id, valid_range;
 id |       valid_range       |  value   
----+-------------------------+----------
  1 | [2024-01-01,2024-03-01) | Original
  1 | [2024-06-01,2024-12-31) | Original
(2 rows)

ROLLBACK TO SAVEPOINT scenario_7;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
