\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
CREATE ROLE view_test_role;
BEGIN;
-- Scenario 1: Test with a table in a non-public schema
SAVEPOINT scenario_1;
CREATE SCHEMA test_schema;
CREATE TABLE test_schema.schema_test (
    id int,
    value text,
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('test_schema.schema_test', 'valid_range');
NOTICE:  sql_saga: Created trigger "schema_test_synchronize_temporal_columns_trigger" on table test_schema.schema_test to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('test_schema.schema_test', ARRAY['id']);
NOTICE:  sql_saga: altering table test_schema.schema_test to add constraints: ADD CONSTRAINT schema_test_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
    add_unique_key    
----------------------
 schema_test_id_valid
(1 row)

SELECT sql_saga.add_for_portion_of_view('test_schema.schema_test'::regclass);
 add_for_portion_of_view 
-------------------------
 t
(1 row)

\d test_schema.schema_test__for_portion_of_valid
   View "test_schema.schema_test__for_portion_of_valid"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 value       | text      |           |          | 
 valid_range | daterange |           |          | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
Triggers:
    for_portion_of_valid INSTEAD OF INSERT OR DELETE OR UPDATE ON test_schema.schema_test__for_portion_of_valid FOR EACH ROW EXECUTE FUNCTION sql_saga.for_portion_of_trigger('id')

TABLE sql_saga.updatable_view;
 view_schema |             view_name             |   view_type    | table_schema | table_name  | era_name |     trigger_name     | current_func | generated_columns | ephemeral_columns 
-------------+-----------------------------------+----------------+--------------+-------------+----------+----------------------+--------------+-------------------+-------------------
 test_schema | schema_test__for_portion_of_valid | for_portion_of | test_schema  | schema_test | valid    | for_portion_of_valid |              | {}                | 
(1 row)

-- DML must be on the base table now
INSERT INTO test_schema.schema_test (id, value, valid_from, valid_until) VALUES (1, 'A', '2024-01-01', 'infinity');
TABLE test_schema.schema_test;
 id | value |      valid_range      | valid_from | valid_until 
----+-------+-----------------------+------------+-------------
  1 | A     | [2024-01-01,infinity) | 2024-01-01 | infinity
(1 row)

SELECT sql_saga.drop_for_portion_of_view('test_schema.schema_test'::regclass);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

ROLLBACK TO SAVEPOINT scenario_1;
-- Scenario 2: ACL and Ownership tests
SAVEPOINT scenario_2;
CREATE TABLE acl_test (id int, value text, valid_range daterange, valid_from date, valid_until date);
ALTER TABLE acl_test OWNER to view_test_role;
SELECT sql_saga.add_era('acl_test', 'valid_range');
NOTICE:  sql_saga: Created trigger "acl_test_synchronize_temporal_columns_trigger" on table acl_test to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('acl_test', ARRAY['id']);
NOTICE:  sql_saga: altering table public.acl_test to add constraints: ADD CONSTRAINT acl_test_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
  add_unique_key   
-------------------
 acl_test_id_valid
(1 row)

SET ROLE view_test_role;
-- This should succeed as the role owns the table
SELECT sql_saga.add_for_portion_of_view('acl_test'::regclass);
 add_for_portion_of_view 
-------------------------
 t
(1 row)

RESET ROLE;
-- Verify owner of the view is correct
\d acl_test__for_portion_of_valid
       View "public.acl_test__for_portion_of_valid"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 value       | text      |           |          | 
 valid_range | daterange |           |          | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
Triggers:
    for_portion_of_valid INSTEAD OF INSERT OR DELETE OR UPDATE ON acl_test__for_portion_of_valid FOR EACH ROW EXECUTE FUNCTION sql_saga.for_portion_of_trigger('id')

TABLE sql_saga.updatable_view;
 view_schema |           view_name            |   view_type    | table_schema | table_name | era_name |     trigger_name     | current_func | generated_columns | ephemeral_columns 
-------------+--------------------------------+----------------+--------------+------------+----------+----------------------+--------------+-------------------+-------------------
 public      | acl_test__for_portion_of_valid | for_portion_of | public       | acl_test   | valid    | for_portion_of_valid |              | {}                | 
(1 row)

-- Verify that permissions are handled correctly
INSERT INTO acl_test (id, value, valid_from, valid_until) VALUES (1, 'initial', '2024-01-01', 'infinity');
GRANT SELECT ON acl_test TO sql_saga_unprivileged_user;
SAVEPOINT no_update;
-- Drop the session's temporary schema to avoid permission issues when changing roles.
DROP SCHEMA IF EXISTS pg_temp CASCADE;
NOTICE:  schema "pg_temp" does not exist, skipping
SET ROLE sql_saga_unprivileged_user;
SELECT CURRENT_ROLE;
        current_role        
----------------------------
 sql_saga_unprivileged_user
(1 row)

-- Should fail, as we only have SELECT on the base table
UPDATE acl_test__for_portion_of_valid SET value = 'no', valid_from = '2024-02-01', valid_until = '2024-03-01' WHERE id = 1;
ERROR:  permission denied for view acl_test__for_portion_of_valid
ROLLBACK TO no_update;
-- An UPDATE that splits a record should now succeed even without DELETE permission.
SAVEPOINT expect_update_without_delete_priv;
GRANT UPDATE, INSERT ON acl_test TO sql_saga_unprivileged_user;
-- Drop the session's temporary schema to avoid permission issues when changing roles.
DROP SCHEMA IF EXISTS pg_temp CASCADE;
NOTICE:  schema "pg_temp" does not exist, skipping
SET ROLE sql_saga_unprivileged_user;
UPDATE acl_test__for_portion_of_valid SET value = 'no', valid_from = '2024-02-01', valid_until = '2024-03-01' WHERE id = 1;
TABLE acl_test ORDER BY valid_from;
 id |  value  |       valid_range       | valid_from | valid_until 
----+---------+-------------------------+------------+-------------
  1 | initial | [2024-01-01,2024-02-01) | 2024-01-01 | 2024-02-01
  1 | no      | [2024-02-01,2024-03-01) | 2024-02-01 | 2024-03-01
  1 | initial | [2024-03-01,infinity)   | 2024-03-01 | infinity
(3 rows)

ROLLBACK TO SAVEPOINT expect_update_without_delete_priv;
RESET ROLE;
SAVEPOINT can_update;
-- NOTE: With DELETE permission, the update should definitely succeed.
GRANT UPDATE, INSERT, DELETE ON acl_test TO sql_saga_unprivileged_user;
-- Drop the session's temporary schema to avoid permission issues when changing roles.
DROP SCHEMA IF EXISTS pg_temp CASCADE;
NOTICE:  schema "pg_temp" does not exist, skipping
SET ROLE sql_saga_unprivileged_user;
SELECT CURRENT_ROLE;
        current_role        
----------------------------
 sql_saga_unprivileged_user
(1 row)

-- Should now succeed
UPDATE acl_test__for_portion_of_valid SET value = 'yes', valid_from = '2024-02-01', valid_until = '2024-03-01' WHERE id = 1;
TABLE acl_test ORDER BY valid_from;
 id |  value  |       valid_range       | valid_from | valid_until 
----+---------+-------------------------+------------+-------------
  1 | initial | [2024-01-01,2024-02-01) | 2024-01-01 | 2024-02-01
  1 | yes     | [2024-02-01,2024-03-01) | 2024-02-01 | 2024-03-01
  1 | initial | [2024-03-01,infinity)   | 2024-03-01 | infinity
(3 rows)

ROLLBACK TO can_update;
SELECT sql_saga.drop_for_portion_of_view('acl_test'::regclass);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

ROLLBACK TO SAVEPOINT scenario_2;
-- Scenario 3: Drop behavior
SAVEPOINT scenario_3;
CREATE TABLE drop_test (id int, value text, valid_range daterange, valid_from date, valid_until date, PRIMARY KEY (id, valid_range WITHOUT OVERLAPS));
SELECT sql_saga.add_era('drop_test', 'valid_range');
NOTICE:  sql_saga: Created trigger "drop_test_synchronize_temporal_columns_trigger" on table drop_test to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_for_portion_of_view('drop_test'::regclass);
 add_for_portion_of_view 
-------------------------
 t
(1 row)

-- RESTRICT should fail because the view depends on the era
SAVEPOINT before_drop_era;
SELECT sql_saga.drop_era('drop_test'::regclass, 'valid', 'RESTRICT');
ERROR:  era valid is used by an updatable view
CONTEXT:  PL/pgSQL function sql_saga.drop_era(regclass,name,sql_saga.drop_behavior,boolean) line 81 at RAISE
ROLLBACK TO before_drop_era;
-- CASCADE should succeed and drop the view
SELECT sql_saga.drop_era('drop_test'::regclass, 'valid', 'CASCADE');
 drop_era 
----------
 t
(1 row)

-- The view should be gone from the metadata
TABLE sql_saga.updatable_view;
 view_schema | view_name | view_type | table_schema | table_name | era_name | trigger_name | current_func | generated_columns | ephemeral_columns 
-------------+-----------+-----------+--------------+------------+----------+--------------+--------------+-------------------+-------------------
(0 rows)

-- DROP TABLE should now succeed
DROP TABLE drop_test;
-- Recreate for next test
CREATE TABLE drop_test (id int, value text, valid_range daterange, valid_from date, valid_until date, PRIMARY KEY (id, valid_range WITHOUT OVERLAPS));
SELECT sql_saga.add_era('drop_test', 'valid_range');
NOTICE:  sql_saga: Created trigger "drop_test_synchronize_temporal_columns_trigger" on table drop_test to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_for_portion_of_view('drop_test'::regclass);
 add_for_portion_of_view 
-------------------------
 t
(1 row)

-- Dropping table directly should fail due to dependent view
SAVEPOINT expect_fail;
DROP TABLE drop_test;
ERROR:  cannot drop table drop_test because other objects depend on it
DETAIL:  view drop_test__for_portion_of_valid depends on table drop_test
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
ROLLBACK TO SAVEPOINT expect_fail;
-- We must drop the view first, then the table
SELECT sql_saga.drop_for_portion_of_view('drop_test'::regclass);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

DROP TABLE drop_test;
ROLLBACK TO SAVEPOINT scenario_3;
-- Scenario 4: Table with no primary key (using temporal unique key as identifier)
SAVEPOINT scenario_4;
CREATE TABLE no_pk_test (
    id integer,
    value text,
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('no_pk_test', 'valid_range');
NOTICE:  sql_saga: Created trigger "no_pk_test_synchronize_temporal_columns_trigger" on table no_pk_test to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('no_pk_test', ARRAY['id']);
NOTICE:  sql_saga: altering table public.no_pk_test to add constraints: ADD CONSTRAINT no_pk_test_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
   add_unique_key    
---------------------
 no_pk_test_id_valid
(1 row)

SELECT sql_saga.add_for_portion_of_view('no_pk_test');
 add_for_portion_of_view 
-------------------------
 t
(1 row)

INSERT INTO no_pk_test (id, value, valid_from, valid_until) VALUES (1, 'initial', '2020-01-01', '2021-01-01');
TABLE no_pk_test;
 id |  value  |       valid_range       | valid_from | valid_until 
----+---------+-------------------------+------------+-------------
  1 | initial | [2020-01-01,2021-01-01) | 2020-01-01 | 2021-01-01
(1 row)

UPDATE no_pk_test__for_portion_of_valid SET value = 'updated', valid_from = '2020-06-01', valid_until = '2020-09-01' WHERE id = 1;
TABLE no_pk_test ORDER BY valid_from;
 id |  value  |       valid_range       | valid_from | valid_until 
----+---------+-------------------------+------------+-------------
  1 | initial | [2020-01-01,2020-06-01) | 2020-01-01 | 2020-06-01
  1 | updated | [2020-06-01,2020-09-01) | 2020-06-01 | 2020-09-01
  1 | initial | [2020-09-01,2021-01-01) | 2020-09-01 | 2021-01-01
(3 rows)

SELECT sql_saga.drop_for_portion_of_view('no_pk_test'::regclass);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

SELECT sql_saga.drop_unique_key('no_pk_test', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('no_pk_test');
 drop_era 
----------
 t
(1 row)

DROP TABLE no_pk_test;
ROLLBACK TO SAVEPOINT scenario_4;
-- Scenario 5: Table with non-B-tree-indexable column types
SAVEPOINT scenario_5;
CREATE TABLE non_btree_test (
    id integer GENERATED BY DEFAULT AS IDENTITY,
    pt point,
    value text,
    valid int4range,
    valid_from integer,
    valid_until integer,
    PRIMARY KEY (id, valid WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('non_btree_test', 'valid', 'p');
NOTICE:  sql_saga: Created trigger "non_btree_test_synchronize_temporal_columns_trigger" on table non_btree_test to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_for_portion_of_view('non_btree_test', 'p');
 add_for_portion_of_view 
-------------------------
 t
(1 row)

INSERT INTO non_btree_test (pt, value, valid_from, valid_until) VALUES ('(0, 0)', 'sample', 10, 41);
TABLE non_btree_test;
 id |  pt   | value  |  valid  | valid_from | valid_until 
----+-------+--------+---------+------------+-------------
  1 | (0,0) | sample | [10,41) |         10 |          41
(1 row)

-- Test with explicit WHERE clause on PK
SAVEPOINT before_btree_update;
UPDATE non_btree_test__for_portion_of_p SET value = 'simple', valid_from = 21, valid_until = 31 WHERE id = 1;
TABLE non_btree_test ORDER BY valid_from;
 id |  pt   | value  |  valid  | valid_from | valid_until 
----+-------+--------+---------+------------+-------------
  1 | (0,0) | sample | [10,21) |         10 |          21
  1 | (0,0) | simple | [21,31) |         21 |          31
  1 | (0,0) | sample | [31,41) |         31 |          41
(3 rows)

ROLLBACK TO before_btree_update;
-- Check that state was restored
TABLE non_btree_test;
 id |  pt   | value  |  valid  | valid_from | valid_until 
----+-------+--------+---------+------------+-------------
  1 | (0,0) | sample | [10,41) |         10 |          41
(1 row)

-- Test without explicit WHERE clause (legacy behavior)
UPDATE non_btree_test__for_portion_of_p SET value = 'simple', valid_from = 21, valid_until = 31;
TABLE non_btree_test ORDER BY valid_from;
 id |  pt   | value  |  valid  | valid_from | valid_until 
----+-------+--------+---------+------------+-------------
  1 | (0,0) | sample | [10,21) |         10 |          21
  1 | (0,0) | simple | [21,31) |         21 |          31
  1 | (0,0) | sample | [31,41) |         31 |          41
(3 rows)

SELECT sql_saga.drop_for_portion_of_view('non_btree_test', 'p');
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

SELECT sql_saga.drop_era('non_btree_test', 'p');
 drop_era 
----------
 t
(1 row)

DROP TABLE non_btree_test;
ROLLBACK TO SAVEPOINT scenario_5;
-- Scenario 6: Test for handling of various generated/identity columns
-- in the FOR PORTION OF update trigger.
SAVEPOINT scenario_6;
-- Drop the session's temporary schema to avoid permission issues when changing roles.
DROP SCHEMA IF EXISTS pg_temp CASCADE;
NOTICE:  schema "pg_temp" does not exist, skipping
SET ROLE sql_saga_unprivileged_user;
-- The update_portion_of() trigger function must correctly identify and
-- exclude all varieties of generated columns (SERIAL, IDENTITY, STORED)
-- from the INSERT statements it dynamically generates when splitting a row.
CREATE TABLE gen_cols_test (
    id_serial BIGSERIAL,
    id_gen_default BIGINT GENERATED BY DEFAULT AS IDENTITY,
    id_gen_always BIGINT GENERATED ALWAYS AS IDENTITY,
    id_stored BIGINT GENERATED ALWAYS AS (id_serial * 2) STORED,
    product TEXT,
    """valid_range""" int4range,
    """from""" INTEGER,
    """until""" INTEGER,
    price NUMERIC,
    PRIMARY KEY (id_gen_default, """valid_range""" WITHOUT OVERLAPS)
);
-- Add sql_saga features with non-standard, quoted column names
SELECT sql_saga.add_era('gen_cols_test', '"valid_range"', era_name => 'p',
    valid_from_column_name => '"from"', 
    valid_until_column_name => '"until"');
WARNING:  Table "gen_cols_test" has a GENERATED ALWAYS AS IDENTITY column ("id_gen_always"). This schema is incompatible with SCD Type 2 history.
HINT:  If you plan to use a temporal primary key for this era, the identity column must be GENERATED BY DEFAULT AS IDENTITY to allow inserting historical records.
NOTICE:  sql_saga: Created trigger "gen_cols_test_synchronize_temporal_columns_trigger" on table gen_cols_test to synchronize columns: "from", "until"
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_for_portion_of_view('gen_cols_test', 'p');
 add_for_portion_of_view 
-------------------------
 t
(1 row)

-- Insert initial data
INSERT INTO gen_cols_test (product, """from""", """until""", price) VALUES ('Widget', 10, 20, 100);
TABLE gen_cols_test;
 id_serial | id_gen_default | id_gen_always | id_stored | product | "valid_range" | "from" | "until" | price 
-----------+----------------+---------------+-----------+---------+---------------+--------+---------+-------
         1 |              1 |             1 |         2 | Widget  | [10,20)       |     10 |      20 |   100
(1 row)

-- Perform an update that splits the existing row.
-- This will trigger an INSERT within the update_portion_of function.
-- If the generated columns are not correctly excluded from the INSERT,
-- this statement will fail, especially for the GENERATED ALWAYS columns.
UPDATE gen_cols_test__for_portion_of_p SET """from""" = 15, """until""" = 20, price = 80;
-- Verify the result. We expect two rows now.
TABLE gen_cols_test ORDER BY """from""";
 id_serial | id_gen_default | id_gen_always | id_stored | product | "valid_range" | "from" | "until" | price 
-----------+----------------+---------------+-----------+---------+---------------+--------+---------+-------
         1 |              1 |             1 |         2 | Widget  | [10,15)       |     10 |      15 |   100
         2 |              1 |             2 |         4 | Widget  | [15,20)       |     15 |      20 |    80
(2 rows)

-- This also automatically rolls back the SET ROLE
ROLLBACK TO SAVEPOINT scenario_6;
-- Scenario 7: Temporal foreign key with DELETE-first execution strategy
-- Demonstrates that DEFERRABLE temporal FKs work with DELETE-first execution.
-- The DELETE-first strategy creates temporary gaps, which are tolerated by
-- DEFERRABLE constraints and checked at transaction end.
SAVEPOINT scenario_7;
CREATE TABLE fk_parent (
    id integer,
    value text,
    valid_range daterange,
    valid_from date,
    valid_until date,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('fk_parent', 'valid_range');
NOTICE:  sql_saga: Created trigger "fk_parent_synchronize_temporal_columns_trigger" on table fk_parent to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('fk_parent', ARRAY['id']);
NOTICE:  sql_saga: altering table public.fk_parent to add constraints: ADD CONSTRAINT fk_parent_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
   add_unique_key   
--------------------
 fk_parent_id_valid
(1 row)

SELECT sql_saga.add_for_portion_of_view('fk_parent');
 add_for_portion_of_view 
-------------------------
 t
(1 row)

CREATE TABLE fk_child (
    id integer,
    parent_id integer,
    value text,
    valid_range daterange,
    valid_from date,
    valid_until date,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('fk_child', 'valid_range');
NOTICE:  sql_saga: Created trigger "fk_child_synchronize_temporal_columns_trigger" on table fk_child to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('fk_child', ARRAY['id']);
NOTICE:  sql_saga: altering table public.fk_child to add constraints: ADD CONSTRAINT fk_child_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
  add_unique_key   
-------------------
 fk_child_id_valid
(1 row)

SELECT sql_saga.add_foreign_key(
    'fk_child'::regclass, ARRAY['parent_id'],
    'fk_parent'::regclass, ARRAY['id']
);
NOTICE:  No compatible index found for foreign key on table fk_child. Creating new index: CREATE INDEX fk_child_parent_id_valid_gist_idx ON fk_child USING GIST (parent_id, valid_range)
     add_foreign_key      
--------------------------
 fk_child_parent_id_valid
(1 row)

INSERT INTO fk_parent (id, value, valid_from, valid_until) VALUES (1, 'parent', '2024-01-01', '2025-01-01');
INSERT INTO fk_child (id, parent_id, value, valid_from, valid_until) VALUES (101, 1, 'child', '2024-01-01', '2025-01-01');
-- This update now succeeds due to the temporal_merge rewrite.
-- The INSERT-then-UPDATE strategy avoids the transient foreign key violation
-- that would occur with a DELETE-then-INSERT approach.
SAVEPOINT expect_fk_update_to_succeed;
UPDATE fk_parent__for_portion_of_valid SET value = 'updated', valid_from = '2024-01-01', valid_until = '2024-06-01' WHERE id = 1;
TABLE fk_parent ORDER BY valid_range;
 id |  value  |       valid_range       | valid_from | valid_until 
----+---------+-------------------------+------------+-------------
  1 | updated | [2024-01-01,2024-06-01) | 2024-01-01 | 2024-06-01
  1 | parent  | [2024-06-01,2025-01-01) | 2024-06-01 | 2025-01-01
(2 rows)

ROLLBACK TO SAVEPOINT expect_fk_update_to_succeed;
ROLLBACK TO SAVEPOINT scenario_7;
-- Scenario 8: Test valid_to handling, coalescing, and exact matches
SAVEPOINT scenario_8;
CREATE TABLE valid_to_test (
    id integer,
    value text,
    valid_range daterange,
    valid_from date,
    valid_to date,
    valid_until date,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('valid_to_test', 'valid_range', valid_to_column_name => 'valid_to');
NOTICE:  sql_saga: Created trigger "valid_to_test_synchronize_temporal_columns_trigger" on table valid_to_test to synchronize columns: valid_to, valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_for_portion_of_view('valid_to_test');
 add_for_portion_of_view 
-------------------------
 t
(1 row)

INSERT INTO valid_to_test (id, value, valid_from, valid_until) VALUES (1, 'A', '2024-01-01', '2025-01-01');
TABLE valid_to_test;
 id | value |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------+-------------------------+------------+------------+-------------
  1 | A     | [2024-01-01,2025-01-01) | 2024-01-01 | 2024-12-31 | 2025-01-01
(1 row)

-- Test 1: Using valid_to should now work correctly.
SAVEPOINT test_valid_to;
-- The new trigger implementation correctly derives valid_until from valid_to.
UPDATE valid_to_test__for_portion_of_valid SET value = 'B', valid_from = '2024-02-01', valid_to = '2024-02-28' WHERE id = 1;
TABLE valid_to_test ORDER BY valid_from;
 id | value |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------+-------------------------+------------+------------+-------------
  1 | A     | [2024-01-01,2024-02-01) | 2024-01-01 | 2024-01-31 | 2024-02-01
  1 | B     | [2024-02-01,2024-02-29) | 2024-02-01 | 2024-02-28 | 2024-02-29
  1 | A     | [2024-02-29,2025-01-01) | 2024-02-29 | 2024-12-31 | 2025-01-01
(3 rows)

ROLLBACK TO SAVEPOINT test_valid_to;
-- Test 2: Coalescing of adjacent identical segments.
SAVEPOINT test_coalescing;
-- Before changing
TABLE valid_to_test ORDER BY valid_from;
 id | value |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------+-------------------------+------------+------------+-------------
  1 | A     | [2024-01-01,2025-01-01) | 2024-01-01 | 2024-12-31 | 2025-01-01
(1 row)

-- Update one slice. This creates a 3-way split.
UPDATE valid_to_test__for_portion_of_valid SET value = 'B', valid_from = '2024-02-01', valid_until = '2024-03-01' WHERE id = 1;
-- After changing
TABLE valid_to_test ORDER BY valid_from;
 id | value |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------+-------------------------+------------+------------+-------------
  1 | A     | [2024-01-01,2024-02-01) | 2024-01-01 | 2024-01-31 | 2024-02-01
  1 | B     | [2024-02-01,2024-03-01) | 2024-02-01 | 2024-02-29 | 2024-03-01
  1 | A     | [2024-03-01,2025-01-01) | 2024-03-01 | 2024-12-31 | 2025-01-01
(3 rows)

-- Update an adjacent slice with the same data. The new logic should coalesce them.
UPDATE valid_to_test__for_portion_of_valid SET value = 'B', valid_from = '2024-03-01', valid_until = '2024-04-01' WHERE id = 1;
-- The rewritten version correctly coalesces the two 'B' rows into a single row.
TABLE valid_to_test ORDER BY valid_from;
 id | value |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------+-------------------------+------------+------------+-------------
  1 | A     | [2024-01-01,2024-02-01) | 2024-01-01 | 2024-01-31 | 2024-02-01
  1 | B     | [2024-02-01,2024-04-01) | 2024-02-01 | 2024-03-31 | 2024-04-01
  1 | A     | [2024-04-01,2025-01-01) | 2024-04-01 | 2024-12-31 | 2025-01-01
(3 rows)

ROLLBACK TO SAVEPOINT test_coalescing;
-- Verify state after rollback
TABLE valid_to_test;
 id | value |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------+-------------------------+------------+------------+-------------
  1 | A     | [2024-01-01,2025-01-01) | 2024-01-01 | 2024-12-31 | 2025-01-01
(1 row)

-- Test 3: Exact match update. This should now perform a simple UPDATE.
SAVEPOINT test_exact_match;
UPDATE valid_to_test__for_portion_of_valid SET value = 'C', valid_from = '2024-01-01', valid_to = '2024-12-31' WHERE id = 1;
-- We expect one row, with the value updated.
TABLE valid_to_test ORDER BY valid_from;
 id | value |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------+-------------------------+------------+------------+-------------
  1 | C     | [2024-01-01,2025-01-01) | 2024-01-01 | 2024-12-31 | 2025-01-01
(1 row)

ROLLBACK TO SAVEPOINT test_exact_match;
-- Test 4: Exact match UPDATE with WHERE clause (data correction on a specific historical slice)
SAVEPOINT exact_match_update_with_where_should_succeed;
UPDATE valid_to_test__for_portion_of_valid
SET
    value = 'D',
    valid_from = '2024-01-01',
    valid_to = '2024-12-31'
WHERE id = 1
  -- For a REST query on a view with valid_to, this is the expected pattern
  AND valid_from >= '2024-01-01'
  AND valid_to <= '2024-12-31';
-- Since this is an exact match, temporal_merge should generate a simple UPDATE.
-- There should be no DELETE.
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |     old_valid_range     |     new_valid_range     |                   data                   | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------+-------------------------+------------------------------------------+----------+-------+--------------------
           1 |             1 | {1}     | UPDATE    | NONE          | 1         | f             | {"id": 1}   | {"id": 1}     | {}          | equals       | equals       | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2025-01-01      | [2024-01-01,2025-01-01) | [2024-01-01,2025-01-01) | {"value": "D", "valid_to": "2024-12-31"} |          |       | existing_entity__1
(1 row)

TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
             1 | [{"id": 1}]        | APPLIED | 
(1 row)

-- Verify value is updated on just that one row.
TABLE valid_to_test ORDER BY valid_from;
 id | value |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------+-------------------------+------------+------------+-------------
  1 | D     | [2024-01-01,2025-01-01) | 2024-01-01 | 2024-12-31 | 2025-01-01
(1 row)

ROLLBACK TO exact_match_update_with_where_should_succeed;
-- Test 5: Exact match UPDATE without WHERE on temporal columns
SAVEPOINT exact_temporal_match_without_where_should_succeed;
UPDATE valid_to_test__for_portion_of_valid
SET
    value = 'E',
    valid_from = '2024-01-01',
    valid_to = '2024-12-31'
WHERE id = 1;
-- Verify there is not DELETE in the plan
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |     old_valid_range     |     new_valid_range     |                   data                   | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------+-------------------------+------------------------------------------+----------+-------+--------------------
           1 |             1 | {1}     | UPDATE    | NONE          | 1         | f             | {"id": 1}   | {"id": 1}     | {}          | equals       | equals       | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2025-01-01      | [2024-01-01,2025-01-01) | [2024-01-01,2025-01-01) | {"value": "E", "valid_to": "2024-12-31"} |          |       | existing_entity__1
(1 row)

TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
             1 | [{"id": 1}]        | APPLIED | 
(1 row)

-- Verify value is updated on just that one row.
TABLE valid_to_test ORDER BY valid_from;
 id | value |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------+-------------------------+------------+------------+-------------
  1 | E     | [2024-01-01,2025-01-01) | 2024-01-01 | 2024-12-31 | 2025-01-01
(1 row)

ROLLBACK TO exact_temporal_match_without_where_should_succeed;
ROLLBACK TO SAVEPOINT scenario_8;
-- Scenario 9: Reproduce statbus regression with valid_to, where an incorrect plan is generated.
SAVEPOINT scenario_9;
CREATE TABLE statbus_repro (
    id integer,
    category_id integer,
    valid_range daterange,
    valid_from date,
    valid_to date,
    valid_until date,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('statbus_repro', 'valid_range', valid_to_column_name => 'valid_to');
NOTICE:  sql_saga: Created trigger "statbus_repro_synchronize_temporal_columns_trigger" on table statbus_repro to synchronize columns: valid_to, valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('statbus_repro', ARRAY['id']);
NOTICE:  sql_saga: altering table public.statbus_repro to add constraints: ADD CONSTRAINT statbus_repro_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
     add_unique_key     
------------------------
 statbus_repro_id_valid
(1 row)

SELECT sql_saga.add_for_portion_of_view('statbus_repro');
 add_for_portion_of_view 
-------------------------
 t
(1 row)

INSERT INTO statbus_repro (id, category_id, valid_from, valid_to) VALUES (1, 13, '2023-01-01', '2025-12-31');
TABLE statbus_repro;
 id | category_id |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------------+-------------------------+------------+------------+-------------
  1 |          13 | [2023-01-01,2026-01-01) | 2023-01-01 | 2025-12-31 | 2026-01-01
(1 row)

-- Test 1: Update using valid_until (the baseline for correct behavior)
SAVEPOINT test_valid_until;
UPDATE statbus_repro__for_portion_of_valid
 SET category_id = 30, valid_from = '2024-01-01', valid_until = '2025-01-01'
 WHERE id = 1;
-- Check plan: should be 1 UPDATE and 2 INSERTs for the 3-way split
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |     old_valid_range     |     new_valid_range     |                     data                      | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------+-------------------------+-----------------------------------------------+----------+-------+--------------------
           1 |             1 | {1}     | UPDATE    | SHRINK        | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | started_by   | 2023-01-01     | 2026-01-01      | 2023-01-01     | 2024-01-01      | [2023-01-01,2026-01-01) | [2023-01-01,2024-01-01) | {"valid_to": "2023-12-31", "category_id": 13} |          |       | existing_entity__1
           2 |             2 | {1}     | INSERT    |               | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | finished_by  | 2023-01-01     | 2026-01-01      | 2025-01-01     | 2026-01-01      | [2023-01-01,2026-01-01) | [2025-01-01,2026-01-01) | {"valid_to": "2025-12-31", "category_id": 13} |          |       | existing_entity__1
           3 |             2 | {1}     | INSERT    |               | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | contains     | 2023-01-01     | 2026-01-01      | 2024-01-01     | 2025-01-01      | [2023-01-01,2026-01-01) | [2024-01-01,2025-01-01) | {"valid_to": "2024-12-31", "category_id": 30} |          |       | existing_entity__1
(3 rows)

-- Check result
TABLE statbus_repro ORDER BY valid_from;
 id | category_id |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------------+-------------------------+------------+------------+-------------
  1 |          13 | [2023-01-01,2024-01-01) | 2023-01-01 | 2023-12-31 | 2024-01-01
  1 |          30 | [2024-01-01,2025-01-01) | 2024-01-01 | 2024-12-31 | 2025-01-01
  1 |          13 | [2025-01-01,2026-01-01) | 2025-01-01 | 2025-12-31 | 2026-01-01
(3 rows)

ROLLBACK TO SAVEPOINT test_valid_until;
-- Test 2: Update using valid_to (this is expected to show the regression)
SAVEPOINT test_valid_to;
UPDATE statbus_repro__for_portion_of_valid
 SET category_id = 30, valid_from = '2024-01-01', valid_to = '2024-12-31'
 WHERE id = 1;
-- Check plan: should be 1 UPDATE and 2 INSERTs for the 3-way split
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |     old_valid_range     |     new_valid_range     |                     data                      | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------+-------------------------+-----------------------------------------------+----------+-------+--------------------
           1 |             1 | {1}     | UPDATE    | SHRINK        | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | started_by   | 2023-01-01     | 2026-01-01      | 2023-01-01     | 2024-01-01      | [2023-01-01,2026-01-01) | [2023-01-01,2024-01-01) | {"valid_to": "2023-12-31", "category_id": 13} |          |       | existing_entity__1
           2 |             2 | {1}     | INSERT    |               | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | finished_by  | 2023-01-01     | 2026-01-01      | 2025-01-01     | 2026-01-01      | [2023-01-01,2026-01-01) | [2025-01-01,2026-01-01) | {"valid_to": "2025-12-31", "category_id": 13} |          |       | existing_entity__1
           3 |             2 | {1}     | INSERT    |               | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | during       | contains     | 2023-01-01     | 2026-01-01      | 2024-01-01     | 2025-01-01      | [2023-01-01,2026-01-01) | [2024-01-01,2025-01-01) | {"valid_to": "2024-12-31", "category_id": 30} |          |       | existing_entity__1
(3 rows)

-- Check result
TABLE statbus_repro ORDER BY valid_from;
 id | category_id |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------------+-------------------------+------------+------------+-------------
  1 |          13 | [2023-01-01,2024-01-01) | 2023-01-01 | 2023-12-31 | 2024-01-01
  1 |          30 | [2024-01-01,2025-01-01) | 2024-01-01 | 2024-12-31 | 2025-01-01
  1 |          13 | [2025-01-01,2026-01-01) | 2025-01-01 | 2025-12-31 | 2026-01-01
(3 rows)

ROLLBACK TO SAVEPOINT test_valid_to;
ROLLBACK TO SAVEPOINT scenario_9;
-- Scenario 10: Era validation - should fail when era doesn't exist
SAVEPOINT scenario_10;
CREATE TABLE no_era_test (
    id int,
    value text,
    valid_range daterange
);
-- Should fail: no era registered on this table
SAVEPOINT expect_error_1;
SELECT sql_saga.add_for_portion_of_view('no_era_test'::regclass);
ERROR:  era "valid" does not exist on table no_era_test
CONTEXT:  PL/pgSQL function sql_saga.add_for_portion_of_view(regclass,name,name[]) line 31 at RAISE
ROLLBACK TO SAVEPOINT expect_error_1;
-- Should also fail with explicit non-existent era name
SAVEPOINT expect_error_2;
SELECT sql_saga.add_for_portion_of_view('no_era_test'::regclass, 'nonexistent');
ERROR:  era "nonexistent" does not exist on table no_era_test
CONTEXT:  PL/pgSQL function sql_saga.add_for_portion_of_view(regclass,name,name[]) line 31 at RAISE
ROLLBACK TO SAVEPOINT expect_error_2;
ROLLBACK TO SAVEPOINT scenario_10;
-- Scenario 11: Range-only table (no synchronized columns)
-- This tests that the for_portion_of view works with tables that have ONLY
-- a range column, without valid_from/valid_until/valid_to.
SAVEPOINT scenario_11;
\echo 'Scenario 11: Range-only table for for_portion_of view'
Scenario 11: Range-only table for for_portion_of view
CREATE TABLE range_only_test (
    id int,
    value text,
    valid_range daterange NOT NULL,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('range_only_test', 'valid_range');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('range_only_test', ARRAY['id']);
NOTICE:  sql_saga: altering table public.range_only_test to add constraints: ADD CONSTRAINT range_only_test_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
      add_unique_key      
--------------------------
 range_only_test_id_valid
(1 row)

SELECT sql_saga.add_for_portion_of_view('range_only_test'::regclass);
 add_for_portion_of_view 
-------------------------
 t
(1 row)

\d range_only_test__for_portion_of_valid
   View "public.range_only_test__for_portion_of_valid"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 value       | text      |           |          | 
 valid_range | daterange |           |          | 
Triggers:
    for_portion_of_valid INSTEAD OF INSERT OR DELETE OR UPDATE ON range_only_test__for_portion_of_valid FOR EACH ROW EXECUTE FUNCTION sql_saga.for_portion_of_trigger('id')

-- Insert initial data directly into base table
INSERT INTO range_only_test (id, value, valid_range) VALUES
    (1, 'Original', '[2024-01-01, 2024-12-31)');
\echo '--- Initial state ---'
--- Initial state ---
TABLE range_only_test ORDER BY id, valid_range;
 id |  value   |       valid_range       
----+----------+-------------------------
  1 | Original | [2024-01-01,2024-12-31)
(1 row)

-- Test UPDATE using the range column directly
\echo '--- UPDATE via for_portion_of view (using range column) ---'
--- UPDATE via for_portion_of view (using range column) ---
UPDATE range_only_test__for_portion_of_valid
SET value = 'Modified', valid_range = '[2024-03-01, 2024-06-01)'
WHERE id = 1;
\echo '--- Expected: 3-way split ---'
--- Expected: 3-way split ---
TABLE range_only_test ORDER BY id, valid_range;
 id |  value   |       valid_range       
----+----------+-------------------------
  1 | Original | [2024-01-01,2024-03-01)
  1 | Modified | [2024-03-01,2024-06-01)
  1 | Original | [2024-06-01,2024-12-31)
(3 rows)

-- Test data-only UPDATE (no temporal change)
\echo '--- Data-only UPDATE (no temporal change) ---'
--- Data-only UPDATE (no temporal change) ---
UPDATE range_only_test__for_portion_of_valid
SET value = 'Data Only Change'
WHERE id = 1 AND valid_range = '[2024-03-01, 2024-06-01)';
TABLE range_only_test ORDER BY id, valid_range;
 id |      value       |       valid_range       
----+------------------+-------------------------
  1 | Original         | [2024-01-01,2024-03-01)
  1 | Data Only Change | [2024-03-01,2024-06-01)
  1 | Original         | [2024-06-01,2024-12-31)
(3 rows)

SELECT sql_saga.drop_for_portion_of_view('range_only_test'::regclass);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

ROLLBACK TO SAVEPOINT scenario_11;
-- Scenario 12: Explicitly setting a column to NULL via for_portion_of view
-- This tests that PATCH semantics properly distinguish between:
--   - Column not changed (omitted from UPDATE) -> preserve existing value
--   - Column explicitly set to NULL (UPDATE col = NULL) -> set to NULL
SAVEPOINT scenario_12;
CREATE TABLE null_test (
    id int,
    name text NOT NULL,
    optional_value text,  -- nullable column for testing NULL assignment
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('null_test', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "null_test_synchronize_temporal_columns_trigger" on table null_test to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('null_test', ARRAY['id']);
NOTICE:  sql_saga: altering table public.null_test to add constraints: ADD CONSTRAINT null_test_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
   add_unique_key   
--------------------
 null_test_id_valid
(1 row)

SELECT sql_saga.add_for_portion_of_view('null_test'::regclass);
 add_for_portion_of_view 
-------------------------
 t
(1 row)

-- Insert initial data with a value
INSERT INTO null_test (id, name, optional_value, valid_from, valid_until)
VALUES (1, 'Test Entity', 'initial value', '2024-01-01', '2025-01-01');
\echo '--- Initial state: optional_value has a value ---'
--- Initial state: optional_value has a value ---
TABLE null_test ORDER BY id, valid_from;
 id |    name     | optional_value |       valid_range       | valid_from | valid_until 
----+-------------+----------------+-------------------------+------------+-------------
  1 | Test Entity | initial value  | [2024-01-01,2025-01-01) | 2024-01-01 | 2025-01-01
(1 row)

-- Test 1: Update name only (optional_value should be preserved, not set to NULL)
\echo '--- Test 1: Update name only (optional_value should be preserved) ---'
--- Test 1: Update name only (optional_value should be preserved) ---
SAVEPOINT test_1;
UPDATE null_test__for_portion_of_valid
SET name = 'Updated Name', valid_from = '2024-03-01', valid_until = '2024-06-01'
WHERE id = 1;
\echo '--- After updating name only: optional_value should still be "initial value" in all segments ---'
--- After updating name only: optional_value should still be "initial value" in all segments ---
SELECT id, name, optional_value, valid_from, valid_until
FROM null_test
ORDER BY valid_from;
 id |     name     | optional_value | valid_from | valid_until 
----+--------------+----------------+------------+-------------
  1 | Test Entity  | initial value  | 2024-01-01 | 2024-03-01
  1 | Updated Name | initial value  | 2024-03-01 | 2024-06-01
  1 | Test Entity  | initial value  | 2024-06-01 | 2025-01-01
(3 rows)

ROLLBACK TO test_1;
-- Test 2: Explicitly set optional_value to NULL
\echo '--- Test 2: Explicitly set optional_value = NULL ---'
--- Test 2: Explicitly set optional_value = NULL ---
SAVEPOINT test_2;
UPDATE null_test__for_portion_of_valid
SET optional_value = NULL, valid_from = '2024-03-01', valid_until = '2024-06-01'
WHERE id = 1;
\echo '--- After explicitly setting to NULL: middle segment should have NULL, edges should preserve value ---'
--- After explicitly setting to NULL: middle segment should have NULL, edges should preserve value ---
SELECT id, name, optional_value, valid_from, valid_until
FROM null_test
ORDER BY valid_from;
 id |    name     | optional_value | valid_from | valid_until 
----+-------------+----------------+------------+-------------
  1 | Test Entity | initial value  | 2024-01-01 | 2024-03-01
  1 | Test Entity |                | 2024-03-01 | 2024-06-01
  1 | Test Entity | initial value  | 2024-06-01 | 2025-01-01
(3 rows)

ROLLBACK TO test_2;
-- Expected:
--   2024-01-01 to 2024-03-01: optional_value = 'initial value' (preserved from original)
--   2024-03-01 to 2024-06-01: optional_value = NULL (explicitly set)
--   2024-06-01 to 2025-01-01: optional_value = 'initial value' (preserved from original)
SELECT sql_saga.drop_for_portion_of_view('null_test'::regclass);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

ROLLBACK TO SAVEPOINT scenario_12;
-- Scenario 13: Era-level ephemeral_columns with FOR_PORTION_OF view
-- Tests that ephemeral_columns set via add_era() are auto-discovered by
-- add_for_portion_of_view() and enable proper coalescing of adjacent rows
-- that have identical business data but different audit column values.
SAVEPOINT scenario_13;
\echo 'Scenario 13: Era-level ephemeral_columns enables coalescing in FOR_PORTION_OF view'
Scenario 13: Era-level ephemeral_columns enables coalescing in FOR_PORTION_OF view
CREATE TABLE ephemeral_test (
    id int,
    name text NOT NULL,
    valid_range daterange,
    valid_from date,
    valid_until date,
    -- Audit columns: will have DIFFERENT values across adjacent rows
    edit_at timestamptz NOT NULL DEFAULT '2024-01-01 10:00:00+00'::timestamptz,
    edit_by_user_id int NOT NULL DEFAULT 1
);
-- KEY: Set ephemeral_columns at the ERA level via add_era()
SELECT sql_saga.add_era('ephemeral_test', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    ephemeral_columns => ARRAY['edit_at', 'edit_by_user_id']);
NOTICE:  sql_saga: Created trigger "ephemeral_test_synchronize_temporal_columns_trigger" on table ephemeral_test to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

-- Verify era has ephemeral_columns set
\echo '--- Era configuration shows ephemeral_columns ---'
--- Era configuration shows ephemeral_columns ---
SELECT era_name, ephemeral_columns FROM sql_saga.era WHERE table_name = 'ephemeral_test';
 era_name |     ephemeral_columns     
----------+---------------------------
 valid    | {edit_at,edit_by_user_id}
(1 row)

ALTER TABLE ephemeral_test ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_unique_key('ephemeral_test', ARRAY['id']);
NOTICE:  sql_saga: altering table public.ephemeral_test to add constraints: ADD CONSTRAINT ephemeral_test_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
     add_unique_key      
-------------------------
 ephemeral_test_id_valid
(1 row)

-- Create FOR_PORTION_OF view WITHOUT ephemeral_columns parameter
-- The view should auto-discover ephemeral_columns from the era
SELECT sql_saga.add_for_portion_of_view('ephemeral_test'::regclass);
 add_for_portion_of_view 
-------------------------
 t
(1 row)

-- Insert two adjacent temporal rows for the SAME entity (id=1)
-- with different names AND different edit_at/edit_by_user_id values
INSERT INTO ephemeral_test (id, name, valid_from, valid_until, edit_at, edit_by_user_id) VALUES
    (1, 'Name A', '2024-01-01', '2024-06-01', '2024-01-15 10:00:00+00', 100),
    (1, 'Name B', '2024-06-01', '2025-01-01', '2024-06-20 14:30:00+00', 200);
\echo '--- Initial State: Two adjacent rows, different names, different audit values ---'
--- Initial State: Two adjacent rows, different names, different audit values ---
SELECT id, name, valid_from, valid_until, edit_at, edit_by_user_id
FROM ephemeral_test
ORDER BY valid_from;
 id |  name  | valid_from | valid_until |        edit_at         | edit_by_user_id 
----+--------+------------+-------------+------------------------+-----------------
  1 | Name A | 2024-01-01 | 2024-06-01  | 2024-01-15 02:00:00-08 |             100
  1 | Name B | 2024-06-01 | 2025-01-01  | 2024-06-20 07:30:00-07 |             200
(2 rows)

-- Now update BOTH rows to the SAME name via FOR_PORTION_OF view
-- This should result in ONE coalesced row (since name becomes identical)
-- The auto-discovered ephemeral_columns should exclude edit_at/edit_by_user_id from comparison
UPDATE ephemeral_test__for_portion_of_valid
SET name = 'UNIFIED NAME', valid_from = '2024-01-01', valid_until = '2025-01-01'
WHERE id = 1;
\echo '--- After UPDATE: Expected 1 coalesced row ---'
--- After UPDATE: Expected 1 coalesced row ---
\echo '--- (era-level ephemeral_columns enables coalescing despite different audit values) ---'
--- (era-level ephemeral_columns enables coalescing despite different audit values) ---
SELECT id, name, valid_from, valid_until, edit_at, edit_by_user_id
FROM ephemeral_test
ORDER BY valid_from;
 id |     name     | valid_from | valid_until |        edit_at         | edit_by_user_id 
----+--------------+------------+-------------+------------------------+-----------------
  1 | UNIFIED NAME | 2024-01-01 | 2025-01-01  | 2024-06-20 07:30:00-07 |             200
(1 row)

-- Verification: should be exactly 1 row
SELECT count(*) as row_count FROM ephemeral_test;
 row_count 
-----------
         1
(1 row)

SELECT sql_saga.drop_for_portion_of_view('ephemeral_test'::regclass);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

ROLLBACK TO SAVEPOINT scenario_13;
ROLLBACK;
DROP ROLE view_test_role;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
