\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
/* Run tests as unprivileged user */
SET ROLE TO sql_saga_unprivileged_user;
-- Unique keys are already pretty much guaranteed by the underlying features of
-- PostgreSQL, but test them anyway.
CREATE TABLE uk (id integer, valid_from integer, valid_until integer, CONSTRAINT uk_pkey PRIMARY KEY (id, valid_from, valid_until) DEFERRABLE);
SELECT sql_saga.add_era('uk', 'valid_from', 'valid_until', 'p');
 add_era 
---------
 t
(1 row)

-- Adopt an existing primary key
SELECT sql_saga.add_unique_key('uk'::regclass, ARRAY['id'], 'p', p_key_type => 'primary', unique_key_name => 'uk_id_p', unique_constraint => 'uk_pkey');
 add_unique_key 
----------------
 uk_id_p
(1 row)

TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | predicate 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+-----------
 uk_id_p         | public       | uk         | primary  | {id}         | p        | uk_pkey           | uk_id_p_excl       | 
(1 row)

INSERT INTO uk (id, valid_from, valid_until) VALUES (100, 2, 4), (100, 4, 5), (100, 5, 11); -- success
INSERT INTO uk (id, valid_from, valid_until) VALUES (200, 2, 4), (200, 4, 5), (200, 6, 11); -- success
SAVEPOINT pristine;
INSERT INTO uk (id, valid_from, valid_until) VALUES (300, 2, 4), (300, 4, 6), (300, 5, 11); -- fail
ERROR:  conflicting key value violates exclusion constraint "uk_id_p_excl"
DETAIL:  Key (id, int4range(valid_from, valid_until))=(300, [5,11)) conflicts with existing key (id, int4range(valid_from, valid_until))=(300, [4,6)).
ROLLBACK TO SAVEPOINT pristine;
CREATE TABLE fk (id integer, uk_id integer, valid_from integer, valid_until integer, PRIMARY KEY (id));
SELECT sql_saga.add_era('fk', 'valid_from', 'valid_until', 'q');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_foreign_key('fk', ARRAY['uk_id'], 'q', 'uk_id_p',
    foreign_key_name => 'fk_uk_id_q',
    fk_insert_trigger => 'fki',
    fk_update_trigger => 'fku',
    uk_update_trigger => 'uku',
    uk_delete_trigger => 'ukd');
 add_foreign_key 
-----------------
 fk_uk_id_q
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name |         type         | table_schema | table_name | column_names | fk_era_name |     fk_table_columns_snapshot     | unique_key_name | match_type | update_action | delete_action | fk_insert_trigger | fk_update_trigger | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger 
------------------+----------------------+--------------+------------+--------------+-------------+-----------------------------------+-----------------+------------+---------------+---------------+-------------------+-------------------+---------------------+--------------------+-------------------+-------------------
 fk_uk_id_q       | temporal_to_temporal | public       | fk         | {uk_id}      | q           | {id,uk_id,valid_from,valid_until} | uk_id_p         | SIMPLE     | NO ACTION     | NO ACTION     | fki               | fku               |                     |                    | uku               | ukd
(1 row)

SELECT sql_saga.drop_foreign_key('fk', ARRAY['uk_id'], 'q');
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.add_foreign_key('fk', ARRAY['uk_id'], 'q', 'uk_id_p', foreign_key_name => 'fk_uk_id_q');
 add_foreign_key 
-----------------
 fk_uk_id_q
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name |         type         | table_schema | table_name | column_names | fk_era_name |     fk_table_columns_snapshot     | unique_key_name | match_type | update_action | delete_action |  fk_insert_trigger   |  fk_update_trigger   | fk_check_constraint | fk_helper_function |  uk_update_trigger   |  uk_delete_trigger   
------------------+----------------------+--------------+------------+--------------+-------------+-----------------------------------+-----------------+------------+---------------+---------------+----------------------+----------------------+---------------------+--------------------+----------------------+----------------------
 fk_uk_id_q       | temporal_to_temporal | public       | fk         | {uk_id}      | q           | {id,uk_id,valid_from,valid_until} | uk_id_p         | SIMPLE     | NO ACTION     | NO ACTION     | fk_uk_id_q_fk_insert | fk_uk_id_q_fk_update |                     |                    | fk_uk_id_q_uk_update | fk_uk_id_q_uk_delete
(1 row)

-- INSERT
SAVEPOINT insert_test;
INSERT INTO fk VALUES (0, 100, 1, 2); -- fail
ERROR:  insert or update on table "public.fk" violates foreign key constraint "fk_uk_id_q"
ROLLBACK TO SAVEPOINT insert_test;
INSERT INTO fk VALUES (0, 100, 1, 11); -- fail
ERROR:  insert or update on table "public.fk" violates foreign key constraint "fk_uk_id_q"
ROLLBACK TO SAVEPOINT insert_test;
INSERT INTO fk VALUES (0, 100, 2, 12); -- fail
ERROR:  insert or update on table "public.fk" violates foreign key constraint "fk_uk_id_q"
ROLLBACK TO SAVEPOINT insert_test;
INSERT INTO fk VALUES (1, 100, 2, 4); -- success
INSERT INTO fk VALUES (2, 100, 2, 11); -- success
-- UPDATE
SAVEPOINT update_fk_test;
UPDATE fk SET valid_until = 21 WHERE id = 1; -- fail
ERROR:  insert or update on table "public.fk" violates foreign key constraint "fk_uk_id_q"
ROLLBACK TO SAVEPOINT update_fk_test;
UPDATE fk SET valid_until = 7 WHERE id = 1; -- success
SAVEPOINT update_uk_test;
UPDATE uk SET valid_from = 3 WHERE (id, valid_from, valid_until) = (100, 2, 4); -- fail
ERROR:  update or delete on table "public.uk" violates foreign key constraint "fk_uk_id_q" on table "public.fk"
ROLLBACK TO SAVEPOINT update_uk_test;
UPDATE uk SET valid_from = 1 WHERE (id, valid_from, valid_until) = (100, 2, 4); -- success
-- DELETE
SAVEPOINT delete_test;
DELETE FROM uk WHERE (id, valid_from, valid_until) = (100, 4, 5); -- fail
ERROR:  update or delete on table "public.uk" violates foreign key constraint "fk_uk_id_q" on table "public.fk"
ROLLBACK TO SAVEPOINT delete_test;
DELETE FROM uk WHERE (id, valid_from, valid_until) = (200, 4, 6); -- success
SELECT sql_saga.drop_foreign_key('fk', ARRAY['uk_id'], 'q');
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_era('fk', 'q');
 drop_era 
----------
 t
(1 row)

DROP TABLE fk;
SELECT sql_saga.drop_unique_key('uk', ARRAY['id'], 'p');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('uk', 'p');
 drop_era 
----------
 t
(1 row)

DROP TABLE uk;
-- Test primary key creation
CREATE TABLE pk_test (id integer, valid_from integer, valid_until integer);
SELECT sql_saga.add_era('pk_test', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_test', '{id}', p_key_type => 'primary');
  add_unique_key  
------------------
 pk_test_id_valid
(1 row)

\d pk_test
                 Table "public.pk_test"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 id          | integer |           | not null | 
 valid_from  | integer |           | not null | 
 valid_until | integer |           | not null | 
Indexes:
    "pk_test_pkey" PRIMARY KEY, btree (id, valid_from, valid_until) DEFERRABLE
    "pk_test_id_idx" btree (id)
    "pk_test_id_valid_excl" EXCLUDE USING gist (id WITH =, int4range(valid_from, valid_until) WITH &&) DEFERRABLE
Check constraints:
    "pk_test_valid_check" CHECK (valid_from < valid_until)

TABLE sql_saga.unique_keys;
 unique_key_name  | table_schema | table_name | key_type | column_names | era_name | unique_constraint |  exclude_constraint   | predicate 
------------------+--------------+------------+----------+--------------+----------+-------------------+-----------------------+-----------
 pk_test_id_valid | public       | pk_test    | primary  | {id}         | valid    | pk_test_pkey      | pk_test_id_valid_excl | 
(1 row)

SELECT sql_saga.drop_unique_key('pk_test', '{id}');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('pk_test');
 drop_era 
----------
 t
(1 row)

DROP TABLE pk_test;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
