\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
CREATE TABLE target_table (
    id INT,
    value TEXT,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('target_table', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "target_table_synchronize_temporal_columns_trigger" on table target_table to synchronize columns: valid_from, valid_until
NOTICE:  sql_saga: Created GIST index "target_table_valid_range_gist_idx" on column public.target_table.valid_range for temporal_merge performance
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('target_table', ARRAY['id']);
NOTICE:  sql_saga: Added constraints to table target_table: ADD CONSTRAINT target_table_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
    add_unique_key     
-----------------------
 target_table_id_valid
(1 row)

-- Also add an updatable view to ensure it doesn't interfere.
SELECT sql_saga.add_current_view('target_table');
 add_current_view 
------------------
 t
(1 row)

-- Scenario 1: No GIST index on source table.
CREATE TEMP TABLE source_table_no_index (
    row_id SERIAL,
    id INT,
    value TEXT,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL
);
\echo

\echo '# Scenario 1a: Small table (< 512 rows) without index. Expect NO warning.'
# Scenario 1a: Small table (< 512 rows) without index. Expect NO warning.
\echo

INSERT INTO source_table_no_index (id, value, valid_range, valid_from, valid_until) 
VALUES (1, 'A', daterange('2023-01-01', NULL, '[)'), '2023-01-01', 'infinity');
ANALYZE source_table_no_index;
-- No warning should be emitted here.
CALL sql_saga.temporal_merge(
    'target_table',
    'source_table_no_index',
    primary_identity_columns => ARRAY['id']
);
\echo

\echo '# Scenario 1b: Large table (>= 512 rows) without index. Expect a WARNING and HINT.'
# Scenario 1b: Large table (>= 512 rows) without index. Expect a WARNING and HINT.
\echo

-- Insert enough rows to cross the threshold.
INSERT INTO source_table_no_index (id, value, valid_range, valid_from, valid_until)
SELECT g, 'A', daterange('2023-01-01', NULL, '[)'), '2023-01-01', 'infinity' FROM generate_series(2, 600) g;
ANALYZE source_table_no_index;
-- The warning should be emitted here.
CALL sql_saga.temporal_merge(
    'target_table',
    'source_table_no_index',
    primary_identity_columns => ARRAY['id']
);
WARNING:  Performance warning: The source relation source_table_no_index lacks a GIST index on its temporal columns.
HINT:  For better performance, consider creating an index, e.g., CREATE INDEX ON source_table_no_index USING GIST (valid_range);
-- Scenario 2: GIST index exists on source table, should be silent.
CREATE TEMP TABLE source_table_with_index (
    row_id SERIAL,
    id INT,
    value TEXT,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL
);
-- The recommended index
CREATE INDEX ON source_table_with_index USING GIST (valid_range);
-- Insert enough rows to cross the threshold; warning should still be suppressed by the index.
INSERT INTO source_table_with_index (id, value, valid_range, valid_from, valid_until)
SELECT g, 'B', daterange('2024-01-01', NULL, '[)'), '2024-01-01', 'infinity' FROM generate_series(1, 600) g;
ANALYZE source_table_with_index;
\echo

\echo '# Scenario 2: Large table with index. Expect no warning.'
# Scenario 2: Large table with index. Expect no warning.
\echo

-- This call should NOT produce a warning.
CALL sql_saga.temporal_merge(
    'target_table',
    'source_table_with_index',
    primary_identity_columns => ARRAY['id']
);
-- Scenario 3: Source is a VIEW. Check if index on underlying table is detected.
\echo

\echo '# Scenario 3: Source is a VIEW. Check if index on underlying table is detected.'
# Scenario 3: Source is a VIEW. Check if index on underlying table is detected.
\echo

-- Base table for the view
CREATE TEMP TABLE source_table_for_view (
    row_id SERIAL,
    id INT,
    value TEXT,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL
);
-- The view itself
CREATE TEMP VIEW source_view AS
SELECT * FROM source_table_for_view;
\echo

\echo '# Scenario 3a: View over small table with NO index. Expect NO warning.'
# Scenario 3a: View over small table with NO index. Expect NO warning.
\echo

INSERT INTO source_table_for_view (id, value, valid_range, valid_from, valid_until) 
VALUES (2, 'C', daterange('2025-01-01', NULL, '[)'), '2025-01-01', 'infinity');
ANALYZE source_table_for_view;
CALL sql_saga.temporal_merge(
    'target_table',
    'source_view'::regclass,
    primary_identity_columns => ARRAY['id']
);
\echo

\echo '# Scenario 3b: View over large table with NO index. Expect a WARNING.'
# Scenario 3b: View over large table with NO index. Expect a WARNING.
\echo

-- Insert enough rows to cross the threshold.
INSERT INTO source_table_for_view (id, value, valid_range, valid_from, valid_until)
SELECT g, 'C', daterange('2025-01-01', NULL, '[)'), '2025-01-01', 'infinity' FROM generate_series(1000, 1600) g;
ANALYZE source_table_for_view;
CALL sql_saga.temporal_merge(
    'target_table',
    'source_view'::regclass,
    primary_identity_columns => ARRAY['id']
);
WARNING:  Performance warning: The source relation source_view lacks a GIST index on its temporal columns.
HINT:  For better performance, consider creating an index, e.g., CREATE INDEX ON source_table_for_view USING GIST (valid_range);
-- Add the recommended index to the *base table*
CREATE INDEX ON source_table_for_view USING GIST (valid_range);
-- Manually truncate the internal cache to ensure the new index is detected in the next call.
-- This is necessary because the cache is session-local and this entire test runs in a single transaction.
CALL sql_saga.temporal_merge_drop_cache();
\echo

\echo '# Scenario 3c: View over large table WITH index. Expect NO warning.'
# Scenario 3c: View over large table WITH index. Expect NO warning.
\echo

-- The table is already large and now has an index.
INSERT INTO source_table_for_view (id, value, valid_range, valid_from, valid_until) 
VALUES (2, 'D', daterange('2026-01-01', NULL, '[)'), '2026-01-01', 'infinity');
ANALYZE source_table_for_view;
CALL sql_saga.temporal_merge(
    'target_table',
    'source_view'::regclass,
    primary_identity_columns => ARRAY['id']
);
-- Verify final state of target table to ensure merge worked
SELECT COUNT(*) FROM target_table;
 count 
-------
  1803
(1 row)

\echo

\echo '# Verify final state of the current view'
# Verify final state of the current view
\echo

SELECT count(*) FROM target_table__current_valid;
 count 
-------
  1201
(1 row)

ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
