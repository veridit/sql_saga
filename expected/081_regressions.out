\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
/* Run tests as unprivileged user */
SET ROLE TO sql_saga_unprivileged_user;
/* https://github.com/xocolatl/periods/issues/27 */
CREATE TABLE uk(id integer, valid_range int4range NOT NULL, f integer, u integer);
SELECT sql_saga.add_era('uk', 'valid_range', 'p',
    valid_from_column_name => 'f',
    valid_until_column_name => 'u');
NOTICE:  sql_saga: Created trigger "uk_synchronize_temporal_columns_trigger" on table uk to synchronize columns: f, u
 add_era 
---------
 t
(1 row)

ALTER TABLE uk ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_unique_key('uk', ARRAY['id'], 'p');
NOTICE:  sql_saga: altering table public.uk to add constraints: ADD CONSTRAINT uk_id_p_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
 add_unique_key 
----------------
 uk_id_p
(1 row)

CREATE TABLE fk(id integer, uk_id integer, valid_range int4range NOT NULL, f integer, u integer);
SELECT sql_saga.add_era('fk', 'valid_range', 'q',
    valid_from_column_name => 'f',
    valid_until_column_name => 'u');
NOTICE:  sql_saga: Created trigger "fk_synchronize_temporal_columns_trigger" on table fk to synchronize columns: f, u
 add_era 
---------
 t
(1 row)

ALTER TABLE fk ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_unique_key('fk', ARRAY['id'], 'q');
NOTICE:  sql_saga: altering table public.fk to add constraints: ADD CONSTRAINT fk_id_q_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
 add_unique_key 
----------------
 fk_id_q
(1 row)

SELECT sql_saga.add_temporal_foreign_key('fk', ARRAY['uk_id'], 'q', 'uk_id_p');
NOTICE:  No compatible index found for foreign key on table fk. Creating new index: CREATE INDEX fk_uk_id_q_gist_idx ON fk USING GIST (uk_id, valid_range)
 add_temporal_foreign_key 
--------------------------
 fk_uk_id_q
(1 row)

--
TABLE sql_saga.era;
 table_schema | table_name | era_name | range_column_name | valid_from_column_name | valid_until_column_name | range_type | multirange_type | range_subtype | range_subtype_category | bounds_check_constraint | boundary_check_constraint | valid_to_column_name | trigger_applies_defaults | audit_schema_name | audit_table_name 
--------------+------------+----------+-------------------+------------------------+-------------------------+------------+-----------------+---------------+------------------------+-------------------------+---------------------------+----------------------+--------------------------+-------------------+------------------
 public       | uk         | p        | valid_range       | f                      | u                       | int4range  | int4multirange  | integer       | N                      | uk_p_check              | uk_check                  |                      | t                        |                   | 
 public       | fk         | q        | valid_range       | f                      | u                       | int4range  | int4multirange  | integer       | N                      | fk_q_check              | fk_check                  |                      | t                        |                   | 
(2 rows)

TABLE sql_saga.foreign_keys;
 foreign_key_name |         type         | table_schema | table_name | column_names | fk_era_name | fk_table_columns_snapshot  | unique_key_name | match_type | update_action | delete_action | fk_insert_trigger | fk_update_trigger | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger |    fk_index_name    
------------------+----------------------+--------------+------------+--------------+-------------+----------------------------+-----------------+------------+---------------+---------------+-------------------+-------------------+---------------------+--------------------+-------------------+-------------------+---------------------
 fk_uk_id_q       | temporal_to_temporal | public       | fk         | {uk_id}      | q           | {id,uk_id,valid_range,f,u} | uk_id_p         | SIMPLE     | NO ACTION     | NO ACTION     |                   |                   |                     |                    |                   |                   | fk_uk_id_q_gist_idx
(1 row)

--
INSERT INTO uk(id, f, u) VALUES (1, 1, 3), (1, 3, 5);
INSERT INTO fk(id, uk_id, f, u) VALUES (1, 1, 1, 2), (2, 1, 2, 5);
-- Make sure the data is there before we start deleting
TABLE uk;
 id | valid_range | f | u 
----+-------------+---+---
  1 | [1,3)       | 1 | 3
  1 | [3,5)       | 3 | 5
(2 rows)

TABLE fk;
 id | uk_id | valid_range | f | u 
----+-------+-------------+---+---
  1 |     1 | [1,2)       | 1 | 2
  2 |     1 | [2,5)       | 2 | 5
(2 rows)

--expected: fail
SAVEPOINT s1;
DELETE FROM uk WHERE (id, f, u) = (1, 1, 3);
ERROR:  update or delete on table "uk" violates foreign key constraint "fk_uk_id_q" on table "fk"
DETAIL:  Key (id, valid_range)=(1, [1,3)) is still referenced from table "fk".
ROLLBACK TO SAVEPOINT s1;
TABLE uk;
 id | valid_range | f | u 
----+-------------+---+---
  1 | [1,3)       | 1 | 3
  1 | [3,5)       | 3 | 5
(2 rows)

TABLE fk;
 id | uk_id | valid_range | f | u 
----+-------+-------------+---+---
  1 |     1 | [1,2)       | 1 | 2
  2 |     1 | [2,5)       | 2 | 5
(2 rows)

--expected: fail
SAVEPOINT s2;
DELETE FROM uk WHERE (id, f, u) = (1, 3, 5);
ERROR:  update or delete on table "uk" violates foreign key constraint "fk_uk_id_q" on table "fk"
DETAIL:  Key (id, valid_range)=(1, [3,5)) is still referenced from table "fk".
ROLLBACK TO SAVEPOINT s2;
INSERT INTO uk(id, f, u) VALUES (2, 1, 5);
INSERT INTO fk(id, uk_id, f, u) VALUES (4, 2, 2, 4);
TABLE uk;
 id | valid_range | f | u 
----+-------------+---+---
  1 | [1,3)       | 1 | 3
  1 | [3,5)       | 3 | 5
  2 | [1,5)       | 1 | 5
(3 rows)

TABLE fk;
 id | uk_id | valid_range | f | u 
----+-------+-------------+---+---
  1 |     1 | [1,2)       | 1 | 2
  2 |     1 | [2,5)       | 2 | 5
  4 |     2 | [2,4)       | 2 | 4
(3 rows)

--expected: fail
SAVEPOINT s3;
UPDATE uk SET u = 3 WHERE (id, f, u) = (2, 1, 5);
ERROR:  update or delete on table "uk" violates foreign key constraint "fk_uk_id_q" on table "fk"
DETAIL:  Key (id, valid_range)=(2, [1,5)) is still referenced from table "fk".
ROLLBACK TO SAVEPOINT s3;
TABLE uk;
 id | valid_range | f | u 
----+-------------+---+---
  1 | [1,3)       | 1 | 3
  1 | [3,5)       | 3 | 5
  2 | [1,5)       | 1 | 5
(3 rows)

TABLE fk;
 id | uk_id | valid_range | f | u 
----+-------+-------------+---+---
  1 |     1 | [1,2)       | 1 | 2
  2 |     1 | [2,5)       | 2 | 5
  4 |     2 | [2,4)       | 2 | 4
(3 rows)

-- Create non contiguous time
INSERT INTO uk(id, f, u) VALUES (3, 1, 3), (3, 4, 5);
-- Reference over non contiguous time - should fail
SAVEPOINT s4;
INSERT INTO fk(id, uk_id, f, u) VALUES (5, 3, 1, 5);
ERROR:  insert or update on table "fk" violates foreign key constraint "fk_uk_id_q"
DETAIL:  Key (uk_id, valid_range)=(3, [1,5)) is not present in table "uk".
ROLLBACK TO SAVEPOINT s4;
-- Create overlapping range - should fail
SAVEPOINT s5;
INSERT INTO uk(id, f, u) VALUES (4, 1, 4), (4, 3, 5);
ERROR:  conflicting key value violates exclusion constraint "uk_pkey"
DETAIL:  Key (id, valid_range)=(4, [3,5)) conflicts with existing key (id, valid_range)=(4, [1,4)).
ROLLBACK TO SAVEPOINT s5;
SELECT sql_saga.drop_foreign_key('fk', ARRAY['uk_id'], 'q');
NOTICE:  Dropping automatically created index "fk_uk_id_q_gist_idx" for foreign key "fk_uk_id_q"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_unique_key('fk', ARRAY['id'], 'q');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('fk', 'q');
 drop_era 
----------
 t
(1 row)

DROP TABLE fk;
SELECT sql_saga.drop_unique_key('uk', ARRAY['id'], 'p');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('uk', 'p');
 drop_era 
----------
 t
(1 row)

DROP TABLE uk;
-- Test for issue with duplicated column in UPDATE OF list for FK trigger
CREATE TABLE t_uk (
    id int,
    valid_range daterange NOT NULL,
    valid_after date,
    valid_until date
);
SELECT sql_saga.add_era('t_uk', 'valid_range', 'valid',
    valid_from_column_name => 'valid_after',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "t_uk_synchronize_temporal_columns_trigger" on table t_uk to synchronize columns: valid_after, valid_until
 add_era 
---------
 t
(1 row)

ALTER TABLE t_uk ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_unique_key('t_uk', ARRAY['id']);
NOTICE:  sql_saga: altering table public.t_uk to add constraints: ADD CONSTRAINT t_uk_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
 add_unique_key 
----------------
 t_uk_id_valid
(1 row)

CREATE TABLE t_fk (
    id int,
    uk_id int,
    valid_range daterange NOT NULL,
    valid_after date,
    valid_until date
);
SELECT sql_saga.add_era('t_fk', 'valid_range', 'valid',
    valid_from_column_name => 'valid_after',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "t_fk_synchronize_temporal_columns_trigger" on table t_fk to synchronize columns: valid_after, valid_until
 add_era 
---------
 t
(1 row)

-- This call failed in a downstream project because it generated:
-- CREATE ... TRIGGER ... AFTER UPDATE OF uk_id, valid_after, valid_to, valid_to ON ...
-- The bug is that 'valid_to' is added to the list twice if it's both the
-- valid_until_column_name and a column named 'valid_to' exists.
SAVEPOINT s_fk_error;
SELECT sql_saga.add_temporal_foreign_key('t_fk', ARRAY['uk_id'], 'valid', 't_uk_id_valid');
NOTICE:  No compatible index found for foreign key on table t_fk. Creating new index: CREATE INDEX t_fk_uk_id_valid_gist_idx ON t_fk USING GIST (uk_id, valid_range)
 add_temporal_foreign_key 
--------------------------
 t_fk_uk_id_valid
(1 row)

ROLLBACK TO SAVEPOINT s_fk_error;
-- cleanup
-- Since the transaction for creating the FK was rolled back, we can just
-- clean up the tables and eras.
SELECT sql_saga.drop_era('t_fk');
 drop_era 
----------
 t
(1 row)

DROP TABLE t_fk;
SELECT sql_saga.drop_unique_key('t_uk', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('t_uk');
 drop_era 
----------
 t
(1 row)

DROP TABLE t_uk;
-- Test generic synchronized column for FK trigger
CREATE TABLE t_uk_gen (
    id int,
    valid_range daterange NOT NULL,
    valid_from date,
    valid_until date,
    valid_end_date date -- synchronized column
);
ALTER TABLE t_uk_gen ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_era('t_uk_gen', 'valid_range', 'valid',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_end_date');
NOTICE:  sql_saga: Created trigger "t_uk_gen_synchronize_temporal_columns_trigger" on table t_uk_gen to synchronize columns: valid_end_date, valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('t_uk_gen', ARRAY['id']);
NOTICE:  sql_saga: altering table public.t_uk_gen to add constraints: ADD CONSTRAINT t_uk_gen_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
  add_unique_key   
-------------------
 t_uk_gen_id_valid
(1 row)

CREATE TABLE t_fk_gen (
    id int,
    uk_id int,
    valid_range daterange NOT NULL,
    valid_from date,
    valid_until date,
    valid_end_date date -- synchronized column
);
SELECT sql_saga.add_era('t_fk_gen', 'valid_range', 'valid',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_end_date');
NOTICE:  sql_saga: Created trigger "t_fk_gen_synchronize_temporal_columns_trigger" on table t_fk_gen to synchronize columns: valid_end_date, valid_from, valid_until
 add_era 
---------
 t
(1 row)

-- This should succeed and create a trigger that watches valid_end_date
SELECT sql_saga.add_temporal_foreign_key('t_fk_gen', ARRAY['uk_id'], 'valid', 't_uk_gen_id_valid');
NOTICE:  No compatible index found for foreign key on table t_fk_gen. Creating new index: CREATE INDEX t_fk_gen_uk_id_valid_gist_idx ON t_fk_gen USING GIST (uk_id, valid_range)
 add_temporal_foreign_key 
--------------------------
 t_fk_gen_uk_id_valid
(1 row)

-- cleanup
SELECT sql_saga.drop_foreign_key('t_fk_gen', ARRAY['uk_id'], 'valid');
NOTICE:  Dropping automatically created index "t_fk_gen_uk_id_valid_gist_idx" for foreign key "t_fk_gen_uk_id_valid"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_era('t_fk_gen');
 drop_era 
----------
 t
(1 row)

DROP TABLE t_fk_gen;
SELECT sql_saga.drop_unique_key('t_uk_gen', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('t_uk_gen');
 drop_era 
----------
 t
(1 row)

DROP TABLE t_uk_gen;
-- Test case for bug with infinite parent validity
CREATE TABLE legal_unit_bug (
    id INT NOT NULL,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    name TEXT,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('legal_unit_bug', 'valid_range', 'valid',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "legal_unit_bug_synchronize_temporal_columns_trigger" on table legal_unit_bug to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('legal_unit_bug', ARRAY['id']);
NOTICE:  sql_saga: altering table public.legal_unit_bug to add constraints: ADD CONSTRAINT legal_unit_bug_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
     add_unique_key      
-------------------------
 legal_unit_bug_id_valid
(1 row)

CREATE TABLE establishment_bug (
    id INT NOT NULL,
    legal_unit_id INT, -- Temporal FK
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    name TEXT,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('establishment_bug', 'valid_range', 'valid',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "establishment_bug_synchronize_temporal_columns_trigger" on table establishment_bug to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

-- Note: A unique key on 'id' is not strictly necessary for this test but good practice.
SELECT sql_saga.add_unique_key('establishment_bug', ARRAY['id']); 
NOTICE:  sql_saga: altering table public.establishment_bug to add constraints: ADD CONSTRAINT establishment_bug_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
       add_unique_key       
----------------------------
 establishment_bug_id_valid
(1 row)

-- Add the temporal foreign key constraint
SELECT sql_saga.add_temporal_foreign_key('establishment_bug', ARRAY['legal_unit_id'], 'valid', 'legal_unit_bug_id_valid');
NOTICE:  No compatible index found for foreign key on table establishment_bug. Creating new index: CREATE INDEX establishment_bug_legal_unit_id_valid_gist_idx ON establishment_bug USING GIST (legal_unit_id, valid_range)
       add_temporal_foreign_key        
---------------------------------------
 establishment_bug_legal_unit_id_valid
(1 row)

INSERT INTO legal_unit_bug (id, valid_from, valid_until, name) VALUES
(1, '2023-12-31', 'infinity', 'Parent LU');
-- This should succeed, as the child's validity is fully contained within the parent's.
INSERT INTO establishment_bug (id, legal_unit_id, valid_from, valid_until, name) VALUES
(101, 1, '2024-01-01', '2025-01-01', 'Child EST');
-- Verify insert
SELECT * FROM establishment_bug;
 id  | legal_unit_id |       valid_range       | valid_from | valid_until |   name    
-----+---------------+-------------------------+------------+-------------+-----------
 101 |             1 | [2024-01-01,2025-01-01) | 2024-01-01 | 2025-01-01  | Child EST
(1 row)

SELECT sql_saga.drop_foreign_key('establishment_bug', ARRAY['legal_unit_id'], 'valid');
NOTICE:  Dropping automatically created index "establishment_bug_legal_unit_id_valid_gist_idx" for foreign key "establishment_bug_legal_unit_id_valid"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_unique_key('establishment_bug', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('establishment_bug', 'valid');
 drop_era 
----------
 t
(1 row)

DROP TABLE establishment_bug;
SELECT sql_saga.drop_unique_key('legal_unit_bug', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('legal_unit_bug', 'valid');
 drop_era 
----------
 t
(1 row)

DROP TABLE legal_unit_bug;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
