\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo 'Test: Unified Temporal Merge with Natural & Surrogate Keys'
Test: Unified Temporal Merge with Natural & Surrogate Keys
\echo 'This test consolidates the tests for natural and surrogate keys into'
This test consolidates the tests for natural and surrogate keys into
\echo 'a single, unified suite using the new temporal_merge function.'
a single, unified suite using the new temporal_merge function.
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Test Scenarios Table of Contents
--------------------------------------------------------------------------------
--
-- Natural-Key Entity: stat_for_unit
--   - Scenario 1: `upsert_replace` with a natural key (`during` split)
--   - Scenario 2: `upsert_patch` with a natural key (`during` split)
--   - Scenario 3: `upsert_replace` with mismatched source/target columns
--
-- Surrogate-Key Entities:
--   - Scenario 4: `upsert_replace` with SERIAL surrogate key on target
--   - Scenario 5: `upsert_replace` with IDENTITY surrogate key on target
--   - Scenario 6: `upsert_patch` with SERIAL surrogate key on target
--   - Scenario 7: `upsert_patch` with IDENTITY surrogate key on target
--   - Scenario 8: `upsert_replace` with non-PK surrogate key
--   - Scenario 9: Multiple, mutually exclusive natural keys with a surrogate ID
--   - Scenario 10: Multiple, mutually exclusive natural keys without a surrogate ID
--   - Scenario 11: Natural key with NULLs using IS NOT DISTINCT FROM logic (complex XOR key)
--   - Scenario 12: Natural key with NULLs on a simple surrogate key table (known anti-pattern)
--
--------------------------------------------------------------------------------
SET client_min_messages TO NOTICE;
-- Setup: Create necessary schema and tables for this test
CREATE SCHEMA IF NOT EXISTS tmtc;
CREATE TYPE tmtc.location_type AS ENUM ('visiting', 'postal', 'physical');
-- Parent tables
CREATE TABLE tmtc.stat_definition (id INT PRIMARY KEY, name TEXT);
CREATE TABLE tmtc.legal_unit (
    id INT NOT NULL, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, PRIMARY KEY (id, valid_from)
);
SELECT sql_saga.add_era('tmtc.legal_unit', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmtc.legal_unit', ARRAY['id'], 'valid', unique_key_name => 'tm_legal_unit_uk');
  add_unique_key  
------------------
 tm_legal_unit_uk
(1 row)

CREATE TABLE tmtc.establishment (
    id INT NOT NULL, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, PRIMARY KEY (id, valid_from)
);
SELECT sql_saga.add_era('tmtc.establishment', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmtc.establishment', ARRAY['id'], 'valid', unique_key_name => 'tm_establishment_uk');
   add_unique_key    
---------------------
 tm_establishment_uk
(1 row)

-- Target table: stat_for_unit (composite key)
CREATE TABLE tmtc.stat_for_unit (
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT
);
SELECT sql_saga.add_era('tmtc.stat_for_unit', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmtc.stat_for_unit', ARRAY['stat_definition_id', 'establishment_id'], 'valid', unique_key_name => 'tm_sfu_uk');
 add_unique_key 
----------------
 tm_sfu_uk
(1 row)

-- Target table with SERIAL surrogate ID
CREATE TABLE tmtc.stat_for_unit_id_pk (
    id SERIAL PRIMARY KEY,
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT
);
SELECT sql_saga.add_era('tmtc.stat_for_unit_id_pk', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmtc.stat_for_unit_id_pk', ARRAY['stat_definition_id', 'establishment_id'], 'valid', unique_key_name => 'tm_sfu_id_uk');
 add_unique_key 
----------------
 tm_sfu_id_uk
(1 row)

-- Target table with IDENTITY surrogate ID
CREATE TABLE tmtc.stat_for_unit_id_gen (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT
);
SELECT sql_saga.add_era('tmtc.stat_for_unit_id_gen', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmtc.stat_for_unit_id_gen', ARRAY['stat_definition_id', 'establishment_id'], 'valid', unique_key_name => 'tm_sfu_identity_uk');
   add_unique_key   
--------------------
 tm_sfu_identity_uk
(1 row)

-- Target table with non-PK surrogate key
CREATE SEQUENCE tmtc.stat_for_unit_no_pk_id_seq;
CREATE TABLE tmtc.stat_for_unit_no_pk (
    id INT NOT NULL DEFAULT nextval('tmtc.stat_for_unit_no_pk_id_seq'),
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT,
    UNIQUE (id, valid_from)
);
SELECT sql_saga.add_era('tmtc.stat_for_unit_no_pk', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmtc.stat_for_unit_no_pk', ARRAY['stat_definition_id', 'establishment_id'], 'valid', unique_key_name => 'tm_sfu_no_pk_uk');
 add_unique_key  
-----------------
 tm_sfu_no_pk_uk
(1 row)

-- Target table with multiple, mutually exclusive natural keys (and surrogate ID)
CREATE TABLE tmtc.location_multi_key (
    id SERIAL NOT NULL,
    type tmtc.location_type NOT NULL,
    legal_unit_id INT,
    establishment_id INT,
    address TEXT,
    edit_comment TEXT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    CONSTRAINT location_multi_key_xor CHECK (
        (legal_unit_id IS NOT NULL AND establishment_id IS NULL) OR
        (legal_unit_id IS NULL AND establishment_id IS NOT NULL)
    ),
    PRIMARY KEY (id, valid_from)
);
SELECT sql_saga.add_era('tmtc.location_multi_key');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmtc.location_multi_key', ARRAY['type', 'legal_unit_id'], 'valid', key_type => 'predicated', unique_key_name => 'loc_mk_lu_uk', predicate => 'legal_unit_id IS NOT NULL');
 add_unique_key 
----------------
 loc_mk_lu_uk
(1 row)

SELECT sql_saga.add_unique_key('tmtc.location_multi_key', ARRAY['type', 'establishment_id'], 'valid', key_type => 'predicated', unique_key_name => 'loc_mk_est_uk', predicate => 'establishment_id IS NOT NULL');
 add_unique_key 
----------------
 loc_mk_est_uk
(1 row)

SELECT sql_saga.add_temporal_foreign_key('tmtc.location_multi_key', ARRAY['legal_unit_id'], 'valid', 'tm_legal_unit_uk');
NOTICE:  No compatible index found for foreign key on table tmtc.location_multi_key. Creating new index: CREATE INDEX location_multi_key_legal_unit_id_valid_gist_idx ON tmtc.location_multi_key USING GIST (legal_unit_id, daterange(valid_from, valid_until))
        add_temporal_foreign_key        
----------------------------------------
 location_multi_key_legal_unit_id_valid
(1 row)

SELECT sql_saga.add_temporal_foreign_key('tmtc.location_multi_key', ARRAY['establishment_id'], 'valid', 'tm_establishment_uk');
NOTICE:  No compatible index found for foreign key on table tmtc.location_multi_key. Creating new index: CREATE INDEX location_multi_key_establishment_id_valid_gist_idx ON tmtc.location_multi_key USING GIST (establishment_id, daterange(valid_from, valid_until))
         add_temporal_foreign_key          
-------------------------------------------
 location_multi_key_establishment_id_valid
(1 row)

-- Target table with multiple, mutually exclusive natural keys (NO surrogate ID)
CREATE TABLE tmtc.location_multi_key_no_id (
    type tmtc.location_type NOT NULL,
    legal_unit_id INT,
    establishment_id INT,
    address TEXT,
    edit_comment TEXT,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    CONSTRAINT location_multi_key_no_id_xor CHECK (
        (legal_unit_id IS NOT NULL AND establishment_id IS NULL) OR
        (legal_unit_id IS NULL AND establishment_id IS NOT NULL)
    )
);
SELECT sql_saga.add_era('tmtc.location_multi_key_no_id');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmtc.location_multi_key_no_id', ARRAY['type', 'legal_unit_id'], 'valid', key_type => 'predicated', unique_key_name => 'loc_mk_noid_lu_uk', predicate => 'legal_unit_id IS NOT NULL');
  add_unique_key   
-------------------
 loc_mk_noid_lu_uk
(1 row)

SELECT sql_saga.add_unique_key('tmtc.location_multi_key_no_id', ARRAY['type', 'establishment_id'], 'valid', key_type => 'predicated', unique_key_name => 'loc_mk_noid_est_uk', predicate => 'establishment_id IS NOT NULL');
   add_unique_key   
--------------------
 loc_mk_noid_est_uk
(1 row)

SELECT sql_saga.add_temporal_foreign_key('tmtc.location_multi_key_no_id', ARRAY['legal_unit_id'], 'valid', 'tm_legal_unit_uk');
NOTICE:  No compatible index found for foreign key on table tmtc.location_multi_key_no_id. Creating new index: CREATE INDEX location_multi_key_no_id_legal_unit_id_valid_gist_idx ON tmtc.location_multi_key_no_id USING GIST (legal_unit_id, daterange(valid_from, valid_until))
           add_temporal_foreign_key           
----------------------------------------------
 location_multi_key_no_id_legal_unit_id_valid
(1 row)

SELECT sql_saga.add_temporal_foreign_key('tmtc.location_multi_key_no_id', ARRAY['establishment_id'], 'valid', 'tm_establishment_uk');
NOTICE:  No compatible index found for foreign key on table tmtc.location_multi_key_no_id. Creating new index: CREATE INDEX location_multi_key_no_id_establishment_id_valid_gist_idx ON tmtc.location_multi_key_no_id USING GIST (establishment_id, daterange(valid_from, valid_until))
            add_temporal_foreign_key             
-------------------------------------------------
 location_multi_key_no_id_establishment_id_valid
(1 row)

-- Helper procedure to reset the target table for a new scenario
CREATE OR REPLACE PROCEDURE tmtc.reset_target() AS $$
BEGIN
    TRUNCATE tmtc.stat_definition, tmtc.legal_unit, tmtc.establishment, tmtc.stat_for_unit, tmtc.stat_for_unit_id_pk, tmtc.stat_for_unit_id_gen, tmtc.stat_for_unit_no_pk, tmtc.location_multi_key, tmtc.location_multi_key_no_id RESTART IDENTITY CASCADE;
    -- Add parent data
    INSERT INTO tmtc.stat_definition (id, name) VALUES (10, 'Total Employees');
    INSERT INTO tmtc.legal_unit (id, valid_from, valid_until, name) VALUES (200, '1900-01-01', 'infinity', 'LU 200');
    INSERT INTO tmtc.establishment (id, valid_from, valid_until, name) VALUES (100, '1900-01-01', 'infinity', 'EST 100');
END;
$$ LANGUAGE plpgsql;
\set source_schema 'pg_temp'
\set ephemeral_cols '{edit_comment}'
--------------------------------------------------------------------------------
\echo 'Scenario 1: `upsert_replace` with a natural key (`during` split)'
Scenario 1: `upsert_replace` with a natural key (`during` split)
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
INSERT INTO tmtc.stat_for_unit (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment) VALUES
(10, 100, '2024-01-01', '2025-01-01', 50, 'Original Value');
CREATE TEMP TABLE temp_source_1 (
    row_id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_1 VALUES (1, 10, 100, '2024-04-01', '2024-09-01', 55, 'Corrected value for mid-year');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit ORDER BY stat_definition_id, establishment_id, valid_from;
 stat_definition_id | establishment_id | valid_from | valid_until | value |  edit_comment  
--------------------+------------------+------------+-------------+-------+----------------
                 10 |              100 | 2024-01-01 | 2025-01-01  |    50 | Original Value
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_1 ORDER BY row_id;
 row_id | stat_definition_id | establishment_id | valid_from | valid_until | value |         edit_comment         
--------+--------------------+------------------+------------+-------------+-------+------------------------------
      1 |                 10 |              100 | 2024-04-01 | 2024-09-01  |    55 | Corrected value for mid-year
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit',
    source_table => 'temp_source_1',
    identity_columns => NULL,
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'UPDATE'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-04-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-04-01'::DATE, '2024-09-01'::DATE, '{"value": 55, "edit_comment": "Corrected value for mid-year"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
 plan_op_seq | row_ids | operation |                     entity_ids                      | old_valid_from | new_valid_from | new_valid_until |                             data                              | relation 
-------------+---------+-----------+-----------------------------------------------------+----------------+----------------+-----------------+---------------------------------------------------------------+----------
           1 | {1}     | UPDATE    | {"establishment_id": 100, "stat_definition_id": 10} | 2024-01-01     | 2024-01-01     | 2024-04-01      | {"value": 50, "edit_comment": "Original Value"}               | starts
           2 | {1}     | INSERT    | {"establishment_id": 100, "stat_definition_id": 10} |                | 2024-04-01     | 2024-09-01      | {"value": 55, "edit_comment": "Corrected value for mid-year"} | 
           3 | {1}     | INSERT    | {"establishment_id": 100, "stat_definition_id": 10} |                | 2024-09-01     | 2025-01-01      | {"value": 50, "edit_comment": "Original Value"}               | 
(3 rows)

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | row_ids | operation | update_effect | corr_ent | new_ent |                     entity_ids                      | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                             data                              | trace 
-------------+---------+-----------+---------------+----------+---------+-----------------------------------------------------+--------------+--------------+----------------+-----------------+----------------+-----------------+---------------------------------------------------------------+-------
           1 | {1}     | INSERT    |               | 1        | f       | {"establishment_id": 100, "stat_definition_id": 10} | during       | contains     | 2024-01-01     | 2025-01-01      | 2024-04-01     | 2024-09-01      | {"value": 55, "edit_comment": "Corrected value for mid-year"} | 
           2 | {1}     | INSERT    |               | 1        | f       | {"establishment_id": 100, "stat_definition_id": 10} | during       | finished_by  | 2024-01-01     | 2025-01-01      | 2024-09-01     | 2025-01-01      | {"value": 50, "edit_comment": "Original Value"}               | 
           3 | {1}     | UPDATE    | SHRINK        | 1        | f       | {"establishment_id": 100, "stat_definition_id": 10} | during       | started_by   | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2024-04-01      | {"value": 50, "edit_comment": "Original Value"}               | 
(3 rows)

\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (1, '[{"establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
 source_row_id |                   target_entity_ids                   | status  | error_message 
---------------+-------------------------------------------------------+---------+---------------
             1 | [{"establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id |                   target_entity_ids                   | status  | error_message 
---------------+-------------------------------------------------------+---------+---------------
             1 | [{"establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (10, 100, '2024-01-01'::DATE, '2024-04-01'::DATE, 50::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-04-01'::DATE, '2024-09-01'::DATE, 55::BIGINT, 'Corrected value for mid-year'::TEXT),
    (10, 100, '2024-09-01'::DATE, '2025-01-01'::DATE, 50::BIGINT, 'Original Value'::TEXT)
) AS t (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
 stat_definition_id | establishment_id | valid_from | valid_until | value |         edit_comment         
--------------------+------------------+------------+-------------+-------+------------------------------
                 10 |              100 | 2024-01-01 | 2024-04-01  |    50 | Original Value
                 10 |              100 | 2024-04-01 | 2024-09-01  |    55 | Corrected value for mid-year
                 10 |              100 | 2024-09-01 | 2025-01-01  |    50 | Original Value
(3 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
 stat_definition_id | establishment_id | valid_from | valid_until | value |         edit_comment         
--------------------+------------------+------------+-------------+-------+------------------------------
                 10 |              100 | 2024-01-01 | 2024-04-01  |    50 | Original Value
                 10 |              100 | 2024-04-01 | 2024-09-01  |    55 | Corrected value for mid-year
                 10 |              100 | 2024-09-01 | 2025-01-01  |    50 | Original Value
(3 rows)

DROP TABLE temp_source_1;
--------------------------------------------------------------------------------
\echo 'Scenario 2: `upsert_patch` with a natural key (`during` split)'
Scenario 2: `upsert_patch` with a natural key (`during` split)
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
INSERT INTO tmtc.stat_for_unit (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment) VALUES
(10, 100, '2024-01-01', '2025-01-01', 50, 'Original Value');
CREATE TEMP TABLE temp_source_2 (
    row_id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
-- Source has a NULL value for 'edit_comment'. In patch mode, this should NOT overwrite the existing value.
INSERT INTO temp_source_2 VALUES (1, 10, 100, '2024-04-01', '2024-09-01', 55, NULL);
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit ORDER BY stat_definition_id, establishment_id, valid_from;
 stat_definition_id | establishment_id | valid_from | valid_until | value |  edit_comment  
--------------------+------------------+------------+-------------+-------+----------------
                 10 |              100 | 2024-01-01 | 2025-01-01  |    50 | Original Value
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_2 ORDER BY row_id;
 row_id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
--------+--------------------+------------------+------------+-------------+-------+--------------
      1 |                 10 |              100 | 2024-04-01 | 2024-09-01  |    55 | 
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit',
    source_table => 'temp_source_2',
    identity_columns => NULL,
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid',
    update_source_with_identity => true
);
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'UPDATE'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-04-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-04-01'::DATE, '2024-09-01'::DATE, '{"value": 55, "edit_comment": "Original Value"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
 plan_op_seq | row_ids | operation |                     entity_ids                      | old_valid_from | new_valid_from | new_valid_until |                      data                       | relation 
-------------+---------+-----------+-----------------------------------------------------+----------------+----------------+-----------------+-------------------------------------------------+----------
           1 | {1}     | UPDATE    | {"establishment_id": 100, "stat_definition_id": 10} | 2024-01-01     | 2024-01-01     | 2024-04-01      | {"value": 50, "edit_comment": "Original Value"} | starts
           2 | {1}     | INSERT    | {"establishment_id": 100, "stat_definition_id": 10} |                | 2024-04-01     | 2024-09-01      | {"value": 55, "edit_comment": "Original Value"} | 
           3 | {1}     | INSERT    | {"establishment_id": 100, "stat_definition_id": 10} |                | 2024-09-01     | 2025-01-01      | {"value": 50, "edit_comment": "Original Value"} | 
(3 rows)

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | row_ids | operation | update_effect | corr_ent | new_ent |                     entity_ids                      | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                      data                       | trace 
-------------+---------+-----------+---------------+----------+---------+-----------------------------------------------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------------------------------+-------
           1 | {1}     | INSERT    |               | 1        | f       | {"establishment_id": 100, "stat_definition_id": 10} | during       | contains     | 2024-01-01     | 2025-01-01      | 2024-04-01     | 2024-09-01      | {"value": 55, "edit_comment": null}             | 
           2 | {1}     | INSERT    |               | 1        | f       | {"establishment_id": 100, "stat_definition_id": 10} | during       | finished_by  | 2024-01-01     | 2025-01-01      | 2024-09-01     | 2025-01-01      | {"value": 50, "edit_comment": "Original Value"} | 
           3 | {1}     | UPDATE    | SHRINK        | 1        | f       | {"establishment_id": 100, "stat_definition_id": 10} | during       | started_by   | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2024-04-01      | {"value": 50, "edit_comment": "Original Value"} | 
(3 rows)

\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (1, '[{"establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
 source_row_id |                   target_entity_ids                   | status  | error_message 
---------------+-------------------------------------------------------+---------+---------------
             1 | [{"establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id |                   target_entity_ids                   | status  | error_message 
---------------+-------------------------------------------------------+---------+---------------
             1 | [{"establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (10, 100, '2024-01-01'::DATE, '2024-04-01'::DATE, 50::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-04-01'::DATE, '2024-09-01'::DATE, 55::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-09-01'::DATE, '2025-01-01'::DATE, 50::BIGINT, 'Original Value'::TEXT)
) AS t (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
 stat_definition_id | establishment_id | valid_from | valid_until | value |  edit_comment  
--------------------+------------------+------------+-------------+-------+----------------
                 10 |              100 | 2024-01-01 | 2024-04-01  |    50 | Original Value
                 10 |              100 | 2024-04-01 | 2024-09-01  |    55 | Original Value
                 10 |              100 | 2024-09-01 | 2025-01-01  |    50 | Original Value
(3 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
 stat_definition_id | establishment_id | valid_from | valid_until | value |  edit_comment  
--------------------+------------------+------------+-------------+-------+----------------
                 10 |              100 | 2024-01-01 | 2024-04-01  |    50 | Original Value
                 10 |              100 | 2024-04-01 | 2024-09-01  |    55 | 
                 10 |              100 | 2024-09-01 | 2025-01-01  |    50 | Original Value
(3 rows)

DROP TABLE temp_source_2;
--------------------------------------------------------------------------------
\echo 'Scenario 3: `upsert_replace` with mismatched source/target columns'
Scenario 3: `upsert_replace` with mismatched source/target columns
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
INSERT INTO tmtc.stat_for_unit (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment) VALUES
(10, 100, '2024-01-01', '2025-01-01', 50, 'Original Value');
-- Source table has an extra column `source_metadata` that is not in the target.
CREATE TEMP TABLE temp_source_3 (
    row_id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT, source_metadata TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_3 VALUES (1, 10, 100, '2024-04-01', '2024-09-01', 55, 'Corrected value for mid-year', 'some extra data');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit ORDER BY stat_definition_id, establishment_id, valid_from;
 stat_definition_id | establishment_id | valid_from | valid_until | value |  edit_comment  
--------------------+------------------+------------+-------------+-------+----------------
                 10 |              100 | 2024-01-01 | 2025-01-01  |    50 | Original Value
(1 row)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_3 ORDER BY row_id;
 row_id | stat_definition_id | establishment_id | valid_from | valid_until | value |         edit_comment         | source_metadata 
--------+--------------------+------------------+------------+-------------+-------+------------------------------+-----------------
      1 |                 10 |              100 | 2024-04-01 | 2024-09-01  |    55 | Corrected value for mid-year | some extra data
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit',
    source_table => 'temp_source_3',
    identity_columns => NULL,
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'UPDATE'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-04-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-04-01'::DATE, '2024-09-01'::DATE, '{"value": 55, "edit_comment": "Corrected value for mid-year"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
 plan_op_seq | row_ids | operation |                     entity_ids                      | old_valid_from | new_valid_from | new_valid_until |                             data                              | relation 
-------------+---------+-----------+-----------------------------------------------------+----------------+----------------+-----------------+---------------------------------------------------------------+----------
           1 | {1}     | UPDATE    | {"establishment_id": 100, "stat_definition_id": 10} | 2024-01-01     | 2024-01-01     | 2024-04-01      | {"value": 50, "edit_comment": "Original Value"}               | starts
           2 | {1}     | INSERT    | {"establishment_id": 100, "stat_definition_id": 10} |                | 2024-04-01     | 2024-09-01      | {"value": 55, "edit_comment": "Corrected value for mid-year"} | 
           3 | {1}     | INSERT    | {"establishment_id": 100, "stat_definition_id": 10} |                | 2024-09-01     | 2025-01-01      | {"value": 50, "edit_comment": "Original Value"}               | 
(3 rows)

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | row_ids | operation | update_effect | corr_ent | new_ent |                     entity_ids                      | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                             data                              | trace 
-------------+---------+-----------+---------------+----------+---------+-----------------------------------------------------+--------------+--------------+----------------+-----------------+----------------+-----------------+---------------------------------------------------------------+-------
           1 | {1}     | INSERT    |               | 1        | f       | {"establishment_id": 100, "stat_definition_id": 10} | during       | contains     | 2024-01-01     | 2025-01-01      | 2024-04-01     | 2024-09-01      | {"value": 55, "edit_comment": "Corrected value for mid-year"} | 
           2 | {1}     | INSERT    |               | 1        | f       | {"establishment_id": 100, "stat_definition_id": 10} | during       | finished_by  | 2024-01-01     | 2025-01-01      | 2024-09-01     | 2025-01-01      | {"value": 50, "edit_comment": "Original Value"}               | 
           3 | {1}     | UPDATE    | SHRINK        | 1        | f       | {"establishment_id": 100, "stat_definition_id": 10} | during       | started_by   | 2024-01-01     | 2025-01-01      | 2024-01-01     | 2024-04-01      | {"value": 50, "edit_comment": "Original Value"}               | 
(3 rows)

\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (1, '[{"establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
 source_row_id |                   target_entity_ids                   | status  | error_message 
---------------+-------------------------------------------------------+---------+---------------
             1 | [{"establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id |                   target_entity_ids                   | status  | error_message 
---------------+-------------------------------------------------------+---------+---------------
             1 | [{"establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (10, 100, '2024-01-01'::DATE, '2024-04-01'::DATE, 50::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-04-01'::DATE, '2024-09-01'::DATE, 55::BIGINT, 'Corrected value for mid-year'::TEXT),
    (10, 100, '2024-09-01'::DATE, '2025-01-01'::DATE, 50::BIGINT, 'Original Value'::TEXT)
) AS t (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
 stat_definition_id | establishment_id | valid_from | valid_until | value |         edit_comment         
--------------------+------------------+------------+-------------+-------+------------------------------
                 10 |              100 | 2024-01-01 | 2024-04-01  |    50 | Original Value
                 10 |              100 | 2024-04-01 | 2024-09-01  |    55 | Corrected value for mid-year
                 10 |              100 | 2024-09-01 | 2025-01-01  |    50 | Original Value
(3 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
 stat_definition_id | establishment_id | valid_from | valid_until | value |         edit_comment         
--------------------+------------------+------------+-------------+-------+------------------------------
                 10 |              100 | 2024-01-01 | 2024-04-01  |    50 | Original Value
                 10 |              100 | 2024-04-01 | 2024-09-01  |    55 | Corrected value for mid-year
                 10 |              100 | 2024-09-01 | 2025-01-01  |    50 | Original Value
(3 rows)

DROP TABLE temp_source_3;
--------------------------------------------------------------------------------
\echo 'Scenario 4: `upsert_replace` with SERIAL surrogate key on target'
Scenario 4: `upsert_replace` with SERIAL surrogate key on target
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_4 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_4 VALUES (1, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial Value');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk ORDER BY id, valid_from;
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
----+--------------------+------------------+------------+-------------+-------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_4 ORDER BY row_id;
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
--------+----+--------------------+------------------+------------+-------------+-------+---------------
      1 |    |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_pk',
    source_table => 'temp_source_4',
    identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
 plan_op_seq | row_ids | operation |                          entity_ids                          | old_valid_from | new_valid_from | new_valid_until |                      data                       | relation 
-------------+---------+-----------+--------------------------------------------------------------+----------------+----------------+-----------------+-------------------------------------------------+----------
           1 | {1}     | INSERT    | {"id": 1, "establishment_id": 100, "stat_definition_id": 10} |                | 2024-01-01     | 2025-01-01      | {"value": 100, "edit_comment": "Initial Value"} | 
(1 row)

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | row_ids | operation | update_effect | corr_ent | new_ent |                          entity_ids                          | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                      data                       | trace 
-------------+---------+-----------+---------------+----------+---------+--------------------------------------------------------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------------------------------+-------
           1 | {1}     | INSERT    |               | 1        | t       | {"id": 1, "establishment_id": 100, "stat_definition_id": 10} |              |              |                |                 | 2024-01-01     | 2025-01-01      | {"value": 100, "edit_comment": "Initial Value"} | 
(1 row)

\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (1, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
 source_row_id |                       target_entity_ids                        | status  | error_message 
---------------+----------------------------------------------------------------+---------+---------------
             1 | [{"id": 1, "establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id |                       target_entity_ids                        | status  | error_message 
---------------+----------------------------------------------------------------+---------+---------------
             1 | [{"id": 1, "establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
----+--------------------+------------------+------------+-------------+-------+---------------
  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
----+--------------------+------------------+------------+-------------+-------+---------------
  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

\echo '--- Source Table: Expected state after back-fill ---'
--- Source Table: Expected state after back-fill ---
SELECT * FROM (VALUES (1, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
--------+----+--------------------+------------------+------------+-------------+-------+---------------
      1 |  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

\echo '--- Source Table: Actual state after back-fill ---'
--- Source Table: Actual state after back-fill ---
SELECT * FROM temp_source_4 ORDER BY row_id;
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
--------+----+--------------------+------------------+------------+-------------+-------+---------------
      1 |  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

DROP TABLE temp_source_4;
--------------------------------------------------------------------------------
\echo 'Scenario 5: `upsert_replace` with IDENTITY surrogate key on target'
Scenario 5: `upsert_replace` with IDENTITY surrogate key on target
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_5 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_5 VALUES (1, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial Value');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen ORDER BY id, valid_from;
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
----+--------------------+------------------+------------+-------------+-------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_5 ORDER BY row_id;
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
--------+----+--------------------+------------------+------------+-------------+-------+---------------
      1 |    |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_gen',
    source_table => 'temp_source_5',
    identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
 plan_op_seq | row_ids | operation |                          entity_ids                          | old_valid_from | new_valid_from | new_valid_until |                      data                       | relation 
-------------+---------+-----------+--------------------------------------------------------------+----------------+----------------+-----------------+-------------------------------------------------+----------
           1 | {1}     | INSERT    | {"id": 1, "establishment_id": 100, "stat_definition_id": 10} |                | 2024-01-01     | 2025-01-01      | {"value": 100, "edit_comment": "Initial Value"} | 
(1 row)

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | row_ids | operation | update_effect | corr_ent | new_ent |                          entity_ids                          | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                      data                       | trace 
-------------+---------+-----------+---------------+----------+---------+--------------------------------------------------------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------------------------------+-------
           1 | {1}     | INSERT    |               | 1        | t       | {"id": 1, "establishment_id": 100, "stat_definition_id": 10} |              |              |                |                 | 2024-01-01     | 2025-01-01      | {"value": 100, "edit_comment": "Initial Value"} | 
(1 row)

\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (1, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
 source_row_id |                       target_entity_ids                        | status  | error_message 
---------------+----------------------------------------------------------------+---------+---------------
             1 | [{"id": 1, "establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id |                       target_entity_ids                        | status  | error_message 
---------------+----------------------------------------------------------------+---------+---------------
             1 | [{"id": 1, "establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
----+--------------------+------------------+------------+-------------+-------+---------------
  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
----+--------------------+------------------+------------+-------------+-------+---------------
  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

\echo '--- Source Table: Expected state after back-fill ---'
--- Source Table: Expected state after back-fill ---
SELECT * FROM (VALUES (1, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
--------+----+--------------------+------------------+------------+-------------+-------+---------------
      1 |  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

\echo '--- Source Table: Actual state after back-fill ---'
--- Source Table: Actual state after back-fill ---
SELECT * FROM temp_source_5 ORDER BY row_id;
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
--------+----+--------------------+------------------+------------+-------------+-------+---------------
      1 |  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

DROP TABLE temp_source_5;
--------------------------------------------------------------------------------
\echo 'Scenario 6: `upsert_patch` with SERIAL surrogate key on target'
Scenario 6: `upsert_patch` with SERIAL surrogate key on target
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_6 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_6 VALUES (104, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial stat');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk ORDER BY id, valid_from;
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
----+--------------------+------------------+------------+-------------+-------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_6 ORDER BY row_id;
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
--------+----+--------------------+------------------+------------+-------------+-------+--------------
    104 |    |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial stat
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_pk',
    source_table => 'temp_source_6',
    identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => '{edit_comment}'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid',
    update_source_with_identity => true
);
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{104}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial stat"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
 plan_op_seq | row_ids | operation |                          entity_ids                          | old_valid_from | new_valid_from | new_valid_until |                      data                      | relation 
-------------+---------+-----------+--------------------------------------------------------------+----------------+----------------+-----------------+------------------------------------------------+----------
           1 | {104}   | INSERT    | {"id": 1, "establishment_id": 100, "stat_definition_id": 10} |                | 2024-01-01     | 2025-01-01      | {"value": 100, "edit_comment": "Initial stat"} | 
(1 row)

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | row_ids | operation | update_effect | corr_ent | new_ent |                          entity_ids                          | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                      data                      | trace 
-------------+---------+-----------+---------------+----------+---------+--------------------------------------------------------------+--------------+--------------+----------------+-----------------+----------------+-----------------+------------------------------------------------+-------
           1 | {104}   | INSERT    |               | 104      | t       | {"id": 1, "establishment_id": 100, "stat_definition_id": 10} |              |              |                |                 | 2024-01-01     | 2025-01-01      | {"value": 100, "edit_comment": "Initial stat"} | 
(1 row)

\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (104, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
 source_row_id |                       target_entity_ids                        | status  | error_message 
---------------+----------------------------------------------------------------+---------+---------------
           104 | [{"id": 1, "establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id |                       target_entity_ids                        | status  | error_message 
---------------+----------------------------------------------------------------+---------+---------------
           104 | [{"id": 1, "establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
----+--------------------+------------------+------------+-------------+-------+--------------
  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial stat
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk WHERE establishment_id = 100 and stat_definition_id = 10 ORDER BY valid_from;
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
----+--------------------+------------------+------------+-------------+-------+--------------
  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial stat
(1 row)

\echo '--- Source Table: Expected state after back-fill ---'
--- Source Table: Expected state after back-fill ---
SELECT * FROM (VALUES (104, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
--------+----+--------------------+------------------+------------+-------------+-------+--------------
    104 |  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial stat
(1 row)

\echo '--- Source Table: Actual state after back-fill ---'
--- Source Table: Actual state after back-fill ---
SELECT * FROM temp_source_6 ORDER BY row_id;
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
--------+----+--------------------+------------------+------------+-------------+-------+--------------
    104 |  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial stat
(1 row)

DROP TABLE temp_source_6;
--------------------------------------------------------------------------------
\echo 'Scenario 7: `upsert_patch` with IDENTITY surrogate key on target'
Scenario 7: `upsert_patch` with IDENTITY surrogate key on target
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_7 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_7 VALUES (105, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial stat');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen ORDER BY id, valid_from;
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
----+--------------------+------------------+------------+-------------+-------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_7 ORDER BY row_id;
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
--------+----+--------------------+------------------+------------+-------------+-------+--------------
    105 |    |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial stat
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_gen',
    source_table => 'temp_source_7',
    identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => '{edit_comment}'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid',
    update_source_with_identity => true
);
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{105}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial stat"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
 plan_op_seq | row_ids | operation |                          entity_ids                          | old_valid_from | new_valid_from | new_valid_until |                      data                      | relation 
-------------+---------+-----------+--------------------------------------------------------------+----------------+----------------+-----------------+------------------------------------------------+----------
           1 | {105}   | INSERT    | {"id": 1, "establishment_id": 100, "stat_definition_id": 10} |                | 2024-01-01     | 2025-01-01      | {"value": 100, "edit_comment": "Initial stat"} | 
(1 row)

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | row_ids | operation | update_effect | corr_ent | new_ent |                          entity_ids                          | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                      data                      | trace 
-------------+---------+-----------+---------------+----------+---------+--------------------------------------------------------------+--------------+--------------+----------------+-----------------+----------------+-----------------+------------------------------------------------+-------
           1 | {105}   | INSERT    |               | 105      | t       | {"id": 1, "establishment_id": 100, "stat_definition_id": 10} |              |              |                |                 | 2024-01-01     | 2025-01-01      | {"value": 100, "edit_comment": "Initial stat"} | 
(1 row)

\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (105, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
 source_row_id |                       target_entity_ids                        | status  | error_message 
---------------+----------------------------------------------------------------+---------+---------------
           105 | [{"id": 1, "establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id |                       target_entity_ids                        | status  | error_message 
---------------+----------------------------------------------------------------+---------+---------------
           105 | [{"id": 1, "establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
----+--------------------+------------------+------------+-------------+-------+--------------
  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial stat
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen WHERE establishment_id = 100 and stat_definition_id = 10 ORDER BY valid_from;
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
----+--------------------+------------------+------------+-------------+-------+--------------
  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial stat
(1 row)

\echo '--- Source Table: Expected state after back-fill ---'
--- Source Table: Expected state after back-fill ---
SELECT * FROM (VALUES (105, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
--------+----+--------------------+------------------+------------+-------------+-------+--------------
    105 |  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial stat
(1 row)

\echo '--- Source Table: Actual state after back-fill ---'
--- Source Table: Actual state after back-fill ---
SELECT * FROM temp_source_7 ORDER BY row_id;
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
--------+----+--------------------+------------------+------------+-------------+-------+--------------
    105 |  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial stat
(1 row)

DROP TABLE temp_source_7;
--------------------------------------------------------------------------------
\echo 'Scenario 8: `upsert_replace` with non-PK surrogate key'
Scenario 8: `upsert_replace` with non-PK surrogate key
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_8 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
INSERT INTO temp_source_8 VALUES (1, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial Value');
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_no_pk ORDER BY id, valid_from;
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment 
----+--------------------+------------------+------------+-------------+-------+--------------
(0 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_8 ORDER BY row_id;
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
--------+----+--------------------+------------------+------------+-------------+-------+---------------
      1 |    |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_no_pk',
    source_table => 'temp_source_8',
    identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
 plan_op_seq | row_ids | operation |                          entity_ids                          | old_valid_from | new_valid_from | new_valid_until |                      data                       | relation 
-------------+---------+-----------+--------------------------------------------------------------+----------------+----------------+-----------------+-------------------------------------------------+----------
           1 | {1}     | INSERT    | {"id": 1, "establishment_id": 100, "stat_definition_id": 10} |                | 2024-01-01     | 2025-01-01      | {"value": 100, "edit_comment": "Initial Value"} | 
(1 row)

\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | row_ids | operation | update_effect | corr_ent | new_ent |                          entity_ids                          | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                      data                       | trace 
-------------+---------+-----------+---------------+----------+---------+--------------------------------------------------------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------------------------------+-------
           1 | {1}     | INSERT    |               | 1        | t       | {"id": 1, "establishment_id": 100, "stat_definition_id": 10} |              |              |                |                 | 2024-01-01     | 2025-01-01      | {"value": 100, "edit_comment": "Initial Value"} | 
(1 row)

\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (1, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
 source_row_id |                       target_entity_ids                        | status  | error_message 
---------------+----------------------------------------------------------------+---------+---------------
             1 | [{"id": 1, "establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
 source_row_id |                       target_entity_ids                        | status  | error_message 
---------------+----------------------------------------------------------------+---------+---------------
             1 | [{"id": 1, "establishment_id": 100, "stat_definition_id": 10}] | APPLIED | 
(1 row)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
----+--------------------+------------------+------------+-------------+-------+---------------
  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_no_pk WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
 id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
----+--------------------+------------------+------------+-------------+-------+---------------
  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

\echo '--- Source Table: Expected state after back-fill ---'
--- Source Table: Expected state after back-fill ---
SELECT * FROM (VALUES (1, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
--------+----+--------------------+------------------+------------+-------------+-------+---------------
      1 |  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

\echo '--- Source Table: Actual state after back-fill ---'
--- Source Table: Actual state after back-fill ---
SELECT * FROM temp_source_8 ORDER BY row_id;
 row_id | id | stat_definition_id | establishment_id | valid_from | valid_until | value | edit_comment  
--------+----+--------------------+------------------+------------+-------------+-------+---------------
      1 |  1 |                 10 |              100 | 2024-01-01 | 2025-01-01  |   100 | Initial Value
(1 row)

DROP TABLE temp_source_8;
SAVEPOINT scenario_9;
-- NOTE on test isolation:
-- Each scenario is wrapped in a SAVEPOINT ... RELEASE SAVEPOINT block. This ensures
-- that each test case runs in its own nested transaction. If a test succeeds, its
-- changes are committed to the main transaction when RELEASE is called. This is a
-- robust pattern for isolating successful, independent test cases.
-- For expected failures, see the different pattern used in Scenario 12.
SET client_min_messages TO NOTICE;
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 9: Multiple, mutually exclusive natural keys with a surrogate ID'
Scenario 9: Multiple, mutually exclusive natural keys with a surrogate ID
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
-- This scenario tests using different natural_identity_columns on the same target table.
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_9 (
    row_id INT, id INT, type tmtc.location_type, legal_unit_id INT, establishment_id INT, address TEXT, valid_from DATE, valid_until DATE, edit_comment TEXT
) ON COMMIT DROP;
-- Insert initial data into target
INSERT INTO tmtc.location_multi_key (type, legal_unit_id, address, valid_from, valid_until) VALUES
('visiting', 200, '200 Main St', '2024-01-01', 'infinity');
INSERT INTO tmtc.location_multi_key (type, establishment_id, address, valid_from, valid_until) VALUES
('visiting', 100, '100 Business Park', '2024-01-01', 'infinity');
\echo '--- Target: Initial state ---'
--- Target: Initial state ---
SELECT id, type, legal_unit_id, establishment_id, address FROM tmtc.location_multi_key ORDER BY id;
 id |   type   | legal_unit_id | establishment_id |      address      
----+----------+---------------+------------------+-------------------
  1 | visiting |           200 |                  | 200 Main St
  2 | visiting |               |              100 | 100 Business Park
(2 rows)

\echo '--- Case 9a: Merge using the (type, legal_unit_id) natural key. ---'
--- Case 9a: Merge using the (type, legal_unit_id) natural key. ---
INSERT INTO temp_source_9 VALUES (1, NULL, 'visiting', 200, NULL, '201 New Main St', '2024-06-01', 'infinity', 'LU address change');
\echo '--- Source (Legal Unit location) ---'
--- Source (Legal Unit location) ---
TABLE temp_source_9;
 row_id | id |   type   | legal_unit_id | establishment_id |     address     | valid_from | valid_until |   edit_comment    
--------+----+----------+---------------+------------------+-----------------+------------+-------------+-------------------
      1 |    | visiting |           200 |                  | 201 New Main St | 2024-06-01 | infinity    | LU address change
(1 row)

CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key',
    source_table => 'temp_source_9',
    identity_columns => '{id}',
    natural_identity_columns => '{type, legal_unit_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
\echo '--- Target: After merge for Legal Unit location ---'
--- Target: After merge for Legal Unit location ---
SELECT id, type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key ORDER BY id, valid_from;
 id |   type   | legal_unit_id | establishment_id |      address      | valid_from | valid_until 
----+----------+---------------+------------------+-------------------+------------+-------------
  1 | visiting |           200 |                  | 200 Main St       | 2024-01-01 | 2024-06-01
  1 | visiting |           200 |                  | 201 New Main St   | 2024-06-01 | infinity
  2 | visiting |               |              100 | 100 Business Park | 2024-01-01 | infinity
(3 rows)

\echo '--- Source: After back-fill ---'
--- Source: After back-fill ---
TABLE temp_source_9;
 row_id | id |   type   | legal_unit_id | establishment_id |     address     | valid_from | valid_until |   edit_comment    
--------+----+----------+---------------+------------------+-----------------+------------+-------------+-------------------
      1 |  1 | visiting |           200 |                  | 201 New Main St | 2024-06-01 | infinity    | LU address change
(1 row)

\echo '--- Case 9b: Merge using the (type, establishment_id) natural key. ---'
--- Case 9b: Merge using the (type, establishment_id) natural key. ---
TRUNCATE temp_source_9;
INSERT INTO temp_source_9 VALUES (2, NULL, 'visiting', NULL, 100, '101 New Business Park', '2024-08-01', 'infinity', 'Est address change');
\echo '--- Source (Establishment location) ---'
--- Source (Establishment location) ---
TABLE temp_source_9;
 row_id | id |   type   | legal_unit_id | establishment_id |        address        | valid_from | valid_until |    edit_comment    
--------+----+----------+---------------+------------------+-----------------------+------------+-------------+--------------------
      2 |    | visiting |               |              100 | 101 New Business Park | 2024-08-01 | infinity    | Est address change
(1 row)

CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key',
    source_table => 'temp_source_9',
    identity_columns => '{id}',
    natural_identity_columns => '{type, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
\echo '--- Target: Final state ---'
--- Target: Final state ---
SELECT id, type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key ORDER BY id, valid_from;
 id |   type   | legal_unit_id | establishment_id |        address        | valid_from | valid_until 
----+----------+---------------+------------------+-----------------------+------------+-------------
  1 | visiting |           200 |                  | 200 Main St           | 2024-01-01 | 2024-06-01
  1 | visiting |           200 |                  | 201 New Main St       | 2024-06-01 | infinity
  2 | visiting |               |              100 | 100 Business Park     | 2024-01-01 | 2024-08-01
  2 | visiting |               |              100 | 101 New Business Park | 2024-08-01 | infinity
(4 rows)

\echo '--- Source: Final after back-fill ---'
--- Source: Final after back-fill ---
TABLE temp_source_9;
 row_id | id |   type   | legal_unit_id | establishment_id |        address        | valid_from | valid_until |    edit_comment    
--------+----+----------+---------------+------------------+-----------------------+------------+-------------+--------------------
      2 |  2 | visiting |               |              100 | 101 New Business Park | 2024-08-01 | infinity    | Est address change
(1 row)

DROP TABLE temp_source_9;
RELEASE SAVEPOINT scenario_9;
SAVEPOINT scenario_10;
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 10: Multiple, mutually exclusive natural keys without a surrogate ID'
Scenario 10: Multiple, mutually exclusive natural keys without a surrogate ID
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_10 (
    row_id INT, type tmtc.location_type, legal_unit_id INT, establishment_id INT, address TEXT, valid_from DATE, valid_until DATE, edit_comment TEXT
) ON COMMIT DROP;
-- Insert initial data into target
INSERT INTO tmtc.location_multi_key_no_id (type, legal_unit_id, address, valid_from, valid_until) VALUES
('visiting', 200, '200 Main St', '2024-01-01', 'infinity');
INSERT INTO tmtc.location_multi_key_no_id (type, establishment_id, address, valid_from, valid_until) VALUES
('visiting', 100, '100 Business Park', '2024-01-01', 'infinity');
\echo '--- Target: Initial state ---'
--- Target: Initial state ---
SELECT type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key_no_id ORDER BY COALESCE(legal_unit_id, establishment_id);
   type   | legal_unit_id | establishment_id |      address      | valid_from | valid_until 
----------+---------------+------------------+-------------------+------------+-------------
 visiting |               |              100 | 100 Business Park | 2024-01-01 | infinity
 visiting |           200 |                  | 200 Main St       | 2024-01-01 | infinity
(2 rows)

\echo '--- Case 10a: Merge using the (type, legal_unit_id) natural key. ---'
--- Case 10a: Merge using the (type, legal_unit_id) natural key. ---
INSERT INTO temp_source_10 VALUES (1, 'visiting', 200, NULL, '201 New Main St', '2024-06-01', 'infinity', 'LU address change');
\echo '--- Source (Legal Unit location) ---'
--- Source (Legal Unit location) ---
TABLE temp_source_10;
 row_id |   type   | legal_unit_id | establishment_id |     address     | valid_from | valid_until |   edit_comment    
--------+----------+---------------+------------------+-----------------+------------+-------------+-------------------
      1 | visiting |           200 |                  | 201 New Main St | 2024-06-01 | infinity    | LU address change
(1 row)

CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key_no_id',
    source_table => 'temp_source_10',
    identity_columns => NULL,
    natural_identity_columns => '{type, legal_unit_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => false
);
\echo '--- Target: After merge for Legal Unit location ---'
--- Target: After merge for Legal Unit location ---
SELECT type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key_no_id ORDER BY COALESCE(legal_unit_id, establishment_id), valid_from;
   type   | legal_unit_id | establishment_id |      address      | valid_from | valid_until 
----------+---------------+------------------+-------------------+------------+-------------
 visiting |               |              100 | 100 Business Park | 2024-01-01 | infinity
 visiting |           200 |                  | 200 Main St       | 2024-01-01 | 2024-06-01
 visiting |           200 |                  | 201 New Main St   | 2024-06-01 | infinity
(3 rows)

\echo '--- Case 10b: Merge using the (type, establishment_id) natural key. ---'
--- Case 10b: Merge using the (type, establishment_id) natural key. ---
TRUNCATE temp_source_10;
INSERT INTO temp_source_10 VALUES (2, 'visiting', NULL, 100, '101 New Business Park', '2024-08-01', 'infinity', 'Est address change');
\echo '--- Source (Establishment location) ---'
--- Source (Establishment location) ---
TABLE temp_source_10;
 row_id |   type   | legal_unit_id | establishment_id |        address        | valid_from | valid_until |    edit_comment    
--------+----------+---------------+------------------+-----------------------+------------+-------------+--------------------
      2 | visiting |               |              100 | 101 New Business Park | 2024-08-01 | infinity    | Est address change
(1 row)

CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key_no_id',
    source_table => 'temp_source_10',
    identity_columns => NULL,
    natural_identity_columns => '{type, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => false
);
\echo '--- Target: Final state ---'
--- Target: Final state ---
SELECT type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key_no_id ORDER BY COALESCE(legal_unit_id, establishment_id), valid_from;
   type   | legal_unit_id | establishment_id |        address        | valid_from | valid_until 
----------+---------------+------------------+-----------------------+------------+-------------
 visiting |               |              100 | 100 Business Park     | 2024-01-01 | 2024-08-01
 visiting |               |              100 | 101 New Business Park | 2024-08-01 | infinity
 visiting |           200 |                  | 200 Main St           | 2024-01-01 | 2024-06-01
 visiting |           200 |                  | 201 New Main St       | 2024-06-01 | infinity
(4 rows)

DROP TABLE temp_source_10;
RELEASE SAVEPOINT scenario_10;
SAVEPOINT scenario_11;
SET client_min_messages TO NOTICE;
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 11: Natural key with NULLs using IS NOT DISTINCT FROM logic'
Scenario 11: Natural key with NULLs using IS NOT DISTINCT FROM logic
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
-- This scenario tests using a single composite natural key that contains NULLs.
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_11 (
    row_id INT, id INT, type tmtc.location_type, legal_unit_id INT, establishment_id INT, address TEXT, valid_from DATE, valid_until DATE, edit_comment TEXT
) ON COMMIT DROP;
-- Insert initial data into target
INSERT INTO tmtc.location_multi_key (type, legal_unit_id, address, valid_from, valid_until) VALUES
('visiting', 200, '200 Main St', '2024-01-01', 'infinity');
INSERT INTO tmtc.location_multi_key (type, establishment_id, address, valid_from, valid_until) VALUES
('visiting', 100, '100 Business Park', '2024-01-01', 'infinity');
\echo '--- Target: Initial state ---'
--- Target: Initial state ---
SELECT id, type, legal_unit_id, establishment_id, address FROM tmtc.location_multi_key ORDER BY id;
 id |   type   | legal_unit_id | establishment_id |      address      
----+----------+---------------+------------------+-------------------
  1 | visiting |           200 |                  | 200 Main St
  2 | visiting |               |              100 | 100 Business Park
(2 rows)

\echo '--- Case 11a: Update Legal Unit location using a composite key with NULL ---'
--- Case 11a: Update Legal Unit location using a composite key with NULL ---
INSERT INTO temp_source_11 VALUES (1, NULL, 'visiting', 200, NULL, '201 New Main St', '2024-06-01', 'infinity', 'LU address change');
\echo '--- Source (Legal Unit location) ---'
--- Source (Legal Unit location) ---
TABLE temp_source_11;
 row_id | id |   type   | legal_unit_id | establishment_id |     address     | valid_from | valid_until |   edit_comment    
--------+----+----------+---------------+------------------+-----------------+------------+-------------+-------------------
      1 |    | visiting |           200 |                  | 201 New Main St | 2024-06-01 | infinity    | LU address change
(1 row)

CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key',
    source_table => 'temp_source_11',
    identity_columns => '{id}',
    natural_identity_columns => '{type, legal_unit_id, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
\echo '--- Target: After merge for Legal Unit location ---'
--- Target: After merge for Legal Unit location ---
SELECT id, type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key ORDER BY id, valid_from;
 id |   type   | legal_unit_id | establishment_id |      address      | valid_from | valid_until 
----+----------+---------------+------------------+-------------------+------------+-------------
  1 | visiting |           200 |                  | 200 Main St       | 2024-01-01 | 2024-06-01
  1 | visiting |           200 |                  | 201 New Main St   | 2024-06-01 | infinity
  2 | visiting |               |              100 | 100 Business Park | 2024-01-01 | infinity
(3 rows)

\echo '--- Source: After back-fill ---'
--- Source: After back-fill ---
TABLE temp_source_11;
 row_id | id |   type   | legal_unit_id | establishment_id |     address     | valid_from | valid_until |   edit_comment    
--------+----+----------+---------------+------------------+-----------------+------------+-------------+-------------------
      1 |  1 | visiting |           200 |                  | 201 New Main St | 2024-06-01 | infinity    | LU address change
(1 row)

\echo '--- Case 11b: Update Establishment location using a composite key with NULL ---'
--- Case 11b: Update Establishment location using a composite key with NULL ---
TRUNCATE temp_source_11;
INSERT INTO temp_source_11 VALUES (2, NULL, 'visiting', NULL, 100, '101 New Business Park', '2024-08-01', 'infinity', 'Est address change');
\echo '--- Source (Establishment location) ---'
--- Source (Establishment location) ---
TABLE temp_source_11;
 row_id | id |   type   | legal_unit_id | establishment_id |        address        | valid_from | valid_until |    edit_comment    
--------+----+----------+---------------+------------------+-----------------------+------------+-------------+--------------------
      2 |    | visiting |               |              100 | 101 New Business Park | 2024-08-01 | infinity    | Est address change
(1 row)

CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key',
    source_table => 'temp_source_11',
    identity_columns => '{id}',
    natural_identity_columns => '{type, legal_unit_id, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
\echo '--- Target: Final state ---'
--- Target: Final state ---
SELECT id, type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key ORDER BY id, valid_from;
 id |   type   | legal_unit_id | establishment_id |        address        | valid_from | valid_until 
----+----------+---------------+------------------+-----------------------+------------+-------------
  1 | visiting |           200 |                  | 200 Main St           | 2024-01-01 | 2024-06-01
  1 | visiting |           200 |                  | 201 New Main St       | 2024-06-01 | infinity
  2 | visiting |               |              100 | 100 Business Park     | 2024-01-01 | 2024-08-01
  2 | visiting |               |              100 | 101 New Business Park | 2024-08-01 | infinity
(4 rows)

\echo '--- Source: Final after back-fill ---'
--- Source: Final after back-fill ---
TABLE temp_source_11;
 row_id | id |   type   | legal_unit_id | establishment_id |        address        | valid_from | valid_until |    edit_comment    
--------+----+----------+---------------+------------------+-----------------------+------------+-------------+--------------------
      2 |  2 | visiting |               |              100 | 101 New Business Park | 2024-08-01 | infinity    | Est address change
(1 row)

DROP TABLE temp_source_11;
RELEASE SAVEPOINT scenario_11;
SAVEPOINT scenario_12;
SET client_min_messages TO NOTICE;
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 12: Natural key with NULLs on a simple surrogate key table (known anti-pattern)'
Scenario 12: Natural key with NULLs on a simple surrogate key table (known anti-pattern)
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
-- on a standard table with a simple SERIAL PRIMARY KEY. This is an anti-pattern for
-- SCD Type 2 history. The test demonstrates that attempting to update an entity
-- on a table with an incompatible schema via natural key lookup correctly
-- results in an error, preventing silent data corruption.
CALL tmtc.reset_target();
CREATE TEMP TABLE temp_source_12 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, value BIGINT, valid_from DATE, valid_until DATE, edit_comment TEXT
) ON COMMIT DROP;
-- Insert initial data into target, where the natural key includes a NULL
INSERT INTO tmtc.stat_for_unit_id_pk (stat_definition_id, establishment_id, value, valid_from, valid_until) VALUES
(10, NULL, 500, '2024-01-01', 'infinity');
\echo '--- Target: Initial state ---'
--- Target: Initial state ---
SELECT id, stat_definition_id, establishment_id, value, valid_from, valid_until FROM tmtc.stat_for_unit_id_pk ORDER BY id;
 id | stat_definition_id | establishment_id | value | valid_from | valid_until 
----+--------------------+------------------+-------+------------+-------------
  1 |                 10 |                  |   500 | 2024-01-01 | infinity
(1 row)

\echo '--- Case 12a: Update entity identified by natural key with NULL ---'
--- Case 12a: Update entity identified by natural key with NULL ---
INSERT INTO temp_source_12 VALUES (1, NULL, 10, NULL, 550, '2024-07-01', 'infinity', 'Stat value update');
\echo '--- Source ---'
--- Source ---
TABLE temp_source_12;
 row_id | id | stat_definition_id | establishment_id | value | valid_from | valid_until |   edit_comment    
--------+----+--------------------+------------------+-------+------------+-------------+-------------------
      1 |    |                 10 |                  |   550 | 2024-07-01 | infinity    | Stat value update
(1 row)

SAVEPOINT expect_error;
-- NOTE on testing expected failures:
-- This call is expected to raise an ERROR. By wrapping it in a SAVEPOINT and
-- then calling ROLLBACK TO SAVEPOINT, we can test the failure without aborting
-- the main transaction. This allows us to see the raw error message and then
-- continue with subsequent tests.
\echo '--- Plan and Feedback (from failing call) ---'
--- Plan and Feedback (from failing call) ---
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_pk',
    source_table => 'temp_source_12',
    identity_columns => '{id}',
    natural_identity_columns => '{stat_definition_id, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
ERROR:  duplicate key value violates unique constraint "stat_for_unit_id_pk_pkey"
DETAIL:  Key (id)=(1) already exists.
CONTEXT:  SQL statement "
                        WITH
                        source_for_insert AS (
                            SELECT
                                p.plan_op_seq, p.new_valid_from, p.new_valid_until,
                                p.entity_ids || p.data as full_data
                            FROM temporal_merge_plan p
                            WHERE p.operation = 'INSERT' AND NOT p.new_ent
                        ),
                        inserted_rows AS (
                            MERGE INTO tmtc.stat_for_unit_id_pk t
                            USING source_for_insert s ON false
                            WHEN NOT MATCHED THEN
                                INSERT (stat_definition_id, edit_comment, establishment_id, value, id, valid_from, valid_until)
                                VALUES ((s.full_data->>'stat_definition_id')::integer, (s.full_data->>'edit_comment')::text, (s.full_data->>'establishment_id')::integer, (s.full_data->>'value')::bigint, (s.full_data->>'id')::integer, s.new_valid_from::date, s.new_valid_until::date)
                            RETURNING t.*, s.plan_op_seq
                        )
                        UPDATE temporal_merge_plan p
                        SET entity_ids = jsonb_build_object('establishment_id', ir.establishment_id, 'id', ir.id, 'stat_definition_id', ir.stat_definition_id)
                        FROM inserted_rows ir
                        WHERE p.plan_op_seq = ir.plan_op_seq;
                    "
PL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[]) line 569 at EXECUTE
SQL statement "CALL sql_saga.temporal_merge_execute(
        target_table => temporal_merge.target_table,
        source_table => temporal_merge.source_table,
        identity_columns => temporal_merge.identity_columns,
        mode => temporal_merge.mode,
        era_name => temporal_merge.era_name,
        row_id_column => temporal_merge.row_id_column,
        founding_id_column => temporal_merge.founding_id_column,
        update_source_with_identity => temporal_merge.update_source_with_identity,
        natural_identity_columns => temporal_merge.natural_identity_columns,
        delete_mode => temporal_merge.delete_mode,
        update_source_with_feedback => temporal_merge.update_source_with_feedback,
        feedback_status_column => temporal_merge.feedback_status_column,
        feedback_status_key => temporal_merge.feedback_status_key,
        feedback_error_column => temporal_merge.feedback_error_column,
        feedback_error_key => temporal_merge.feedback_error_key,
        ephemeral_columns => temporal_merge.ephemeral_columns
    )"
PL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[]) line 81 at CALL
ROLLBACK TO SAVEPOINT expect_error;
\echo '--- Target: After merge (should be unchanged) ---'
--- Target: After merge (should be unchanged) ---
SELECT id, stat_definition_id, establishment_id, value, valid_from, valid_until FROM tmtc.stat_for_unit_id_pk ORDER BY id, valid_from;
 id | stat_definition_id | establishment_id | value | valid_from | valid_until 
----+--------------------+------------------+-------+------------+-------------
  1 |                 10 |                  |   500 | 2024-01-01 | infinity
(1 row)

\echo '--- Source: After back-fill (should be unchanged) ---'
--- Source: After back-fill (should be unchanged) ---
TABLE temp_source_12;
 row_id | id | stat_definition_id | establishment_id | value | valid_from | valid_until |   edit_comment    
--------+----+--------------------+------------------+-------+------------+-------------+-------------------
      1 |    |                 10 |                  |   550 | 2024-07-01 | infinity    | Stat value update
(1 row)

DROP TABLE temp_source_12;
RELEASE SAVEPOINT scenario_12;
-- Final Cleanup
DROP PROCEDURE tmtc.reset_target();
DROP TABLE tmtc.stat_for_unit, tmtc.stat_for_unit_id_pk, tmtc.stat_for_unit_id_gen, tmtc.stat_for_unit_no_pk, tmtc.location_multi_key, tmtc.location_multi_key_no_id;
DROP TABLE tmtc.legal_unit, tmtc.establishment;
DROP TABLE tmtc.stat_definition;
DROP SCHEMA tmtc CASCADE;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to type tmtc.location_type
drop cascades to sequence tmtc.stat_for_unit_no_pk_id_seq
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
