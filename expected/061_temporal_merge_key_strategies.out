\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo 'Test: Unified Temporal Merge with Natural & Surrogate Keys'
Test: Unified Temporal Merge with Natural & Surrogate Keys
\echo 'This test consolidates the tests for natural and surrogate keys into'
This test consolidates the tests for natural and surrogate keys into
\echo 'a single, unified suite using the new temporal_merge function.'
a single, unified suite using the new temporal_merge function.
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Test Scenarios Table of Contents
--------------------------------------------------------------------------------
--
-- Natural-Key Entity: stat_for_unit
--   - Scenario 1: `upsert_replace` with a natural key (`during` split)
--   - Scenario 2: `upsert_patch` with a natural key (`during` split)
--   - Scenario 3: `upsert_replace` with mismatched source/target columns
--
-- Surrogate-Key Entities:
--   - Scenario 4: `upsert_replace` with SERIAL surrogate key on target
--   - Scenario 5: `upsert_replace` with IDENTITY surrogate key on target
--   - Scenario 6: `upsert_patch` with SERIAL surrogate key on target
--   - Scenario 7: `upsert_patch` with IDENTITY surrogate key on target
--   - Scenario 8: `upsert_replace` with non-PK surrogate key
--   - Scenario 9: Multiple, mutually exclusive natural keys with a surrogate ID
--   - Scenario 10: Multiple, mutually exclusive natural keys without a surrogate ID
--   - Scenario 11: Natural key with NULLs using IS NOT DISTINCT FROM logic (complex XOR key)
--   - Scenario 12: Natural key with NULLs on a simple surrogate key table (known anti-pattern)
--
--------------------------------------------------------------------------------
SET client_min_messages TO NOTICE;
-- Setup: Create necessary schema and tables for this test
CREATE SCHEMA IF NOT EXISTS tmtc;
CREATE TYPE tmtc.location_type AS ENUM ('visiting', 'postal', 'physical');
-- Parent tables
CREATE TABLE tmtc.stat_definition (id INT PRIMARY KEY, name TEXT);
CREATE TABLE tmtc.legal_unit (
    id INT NOT NULL, valid_range daterange NOT NULL, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('tmtc.legal_unit', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "legal_unit_synchronize_temporal_columns_trigger" on table tmtc.legal_unit to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmtc.legal_unit', ARRAY['id'], 'valid', unique_key_name => 'tm_legal_unit_uk');
NOTICE:  sql_saga: altering table tmtc.legal_unit to add constraints: ADD CONSTRAINT tm_legal_unit_uk_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
  add_unique_key  
------------------
 tm_legal_unit_uk
(1 row)

CREATE TABLE tmtc.establishment (
    id INT NOT NULL, valid_range daterange NOT NULL, valid_from DATE NOT NULL, valid_until DATE NOT NULL, name TEXT, PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('tmtc.establishment', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "establishment_synchronize_temporal_columns_trigger" on table tmtc.establishment to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmtc.establishment', ARRAY['id'], 'valid', unique_key_name => 'tm_establishment_uk');
NOTICE:  sql_saga: altering table tmtc.establishment to add constraints: ADD CONSTRAINT tm_establishment_uk_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
   add_unique_key    
---------------------
 tm_establishment_uk
(1 row)

-- Target table: stat_for_unit (composite key)
CREATE TABLE tmtc.stat_for_unit (
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT
);
SELECT sql_saga.add_era('tmtc.stat_for_unit', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "stat_for_unit_synchronize_temporal_columns_trigger" on table tmtc.stat_for_unit to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmtc.stat_for_unit', ARRAY['stat_definition_id', 'establishment_id'], 'valid', key_type => 'primary', unique_key_name => 'tm_sfu_uk');
NOTICE:  sql_saga: altering table tmtc.stat_for_unit to add constraints: ALTER COLUMN stat_definition_id SET NOT NULL, ALTER COLUMN establishment_id SET NOT NULL, ADD PRIMARY KEY (stat_definition_id, establishment_id, valid_range WITHOUT OVERLAPS)
 add_unique_key 
----------------
 tm_sfu_uk
(1 row)

-- Target table with SERIAL surrogate ID
CREATE TABLE tmtc.stat_for_unit_id_pk (
    id SERIAL NOT NULL,
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('tmtc.stat_for_unit_id_pk', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "stat_for_unit_id_pk_synchronize_temporal_columns_trigger" on table tmtc.stat_for_unit_id_pk to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmtc.stat_for_unit_id_pk', ARRAY['stat_definition_id', 'establishment_id'], 'valid', unique_key_name => 'tm_sfu_id_uk');
NOTICE:  sql_saga: altering table tmtc.stat_for_unit_id_pk to add constraints: ADD CONSTRAINT tm_sfu_id_uk_uniq UNIQUE (stat_definition_id, establishment_id, valid_range WITHOUT OVERLAPS), ADD CONSTRAINT tm_sfu_id_uk_pk_consistency_excl EXCLUDE USING gist (stat_definition_id WITH =, establishment_id WITH =, id WITH <>)
 add_unique_key 
----------------
 tm_sfu_id_uk
(1 row)

-- Target table with IDENTITY surrogate ID
CREATE TABLE tmtc.stat_for_unit_id_gen (
    id INT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT,
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
SELECT sql_saga.add_era('tmtc.stat_for_unit_id_gen', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "stat_for_unit_id_gen_synchronize_temporal_columns_trigger" on table tmtc.stat_for_unit_id_gen to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmtc.stat_for_unit_id_gen', ARRAY['stat_definition_id', 'establishment_id'], 'valid', unique_key_name => 'tm_sfu_identity_uk');
NOTICE:  sql_saga: altering table tmtc.stat_for_unit_id_gen to add constraints: ADD CONSTRAINT tm_sfu_identity_uk_uniq UNIQUE (stat_definition_id, establishment_id, valid_range WITHOUT OVERLAPS), ADD CONSTRAINT tm_sfu_identity_uk_pk_consistency_excl EXCLUDE USING gist (stat_definition_id WITH =, establishment_id WITH =, id WITH <>)
ERROR:  relation "stat_for_unit__stat_definitio_establishment__valid_range_idx" already exists
CONTEXT:  SQL statement "CREATE INDEX stat_for_unit__stat_definitio_establishment__valid_range_idx ON tmtc.stat_for_unit_id_gen (stat_definition_id, establishment_id, valid_range)"
PL/pgSQL function sql_saga.add_unique_key(regclass,name[],name,sql_saga.unique_key_type,boolean,name,name,name,text,name[]) line 563 at EXECUTE
-- Target table with non-PK surrogate key
CREATE SEQUENCE tmtc.stat_for_unit_no_pk_id_seq;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CREATE TABLE tmtc.stat_for_unit_no_pk (
    id INT NOT NULL DEFAULT nextval('tmtc.stat_for_unit_no_pk_id_seq'),
    stat_definition_id INT NOT NULL,
    establishment_id INT,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    value BIGINT,
    edit_comment TEXT,
    UNIQUE (id, valid_range WITHOUT OVERLAPS)
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT sql_saga.add_era('tmtc.stat_for_unit_no_pk', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT sql_saga.add_unique_key('tmtc.stat_for_unit_no_pk', ARRAY['stat_definition_id', 'establishment_id'], 'valid', unique_key_name => 'tm_sfu_no_pk_uk');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Target table with multiple, mutually exclusive natural keys (and surrogate ID)
CREATE TABLE tmtc.location_multi_key (
    id SERIAL NOT NULL,
    type tmtc.location_type NOT NULL,
    legal_unit_id INT,
    establishment_id INT,
    address TEXT,
    edit_comment TEXT,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    CONSTRAINT location_multi_key_xor CHECK (
        (legal_unit_id IS NOT NULL AND establishment_id IS NULL) OR
        (legal_unit_id IS NULL AND establishment_id IS NOT NULL)
    ),
    PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT sql_saga.add_era('tmtc.location_multi_key', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT sql_saga.add_unique_key('tmtc.location_multi_key', ARRAY['type', 'legal_unit_id'], 'valid', key_type => 'predicated', unique_key_name => 'loc_mk_lu_uk', predicate => 'legal_unit_id IS NOT NULL');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT sql_saga.add_unique_key('tmtc.location_multi_key', ARRAY['type', 'establishment_id'], 'valid', key_type => 'predicated', unique_key_name => 'loc_mk_est_uk', predicate => 'establishment_id IS NOT NULL');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT sql_saga.add_temporal_foreign_key('tmtc.location_multi_key', ARRAY['legal_unit_id'], 'valid', 'tm_legal_unit_uk');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT sql_saga.add_temporal_foreign_key('tmtc.location_multi_key', ARRAY['establishment_id'], 'valid', 'tm_establishment_uk');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Target table with multiple, mutually exclusive natural keys (NO surrogate ID)
CREATE TABLE tmtc.location_multi_key_no_id (
    type tmtc.location_type NOT NULL,
    legal_unit_id INT,
    establishment_id INT,
    address TEXT,
    edit_comment TEXT,
    valid_range daterange NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT sql_saga.add_era('tmtc.location_multi_key_no_id', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT sql_saga.add_unique_key(
    table_oid => 'tmtc.location_multi_key_no_id',
    column_names => ARRAY['type', 'legal_unit_id', 'establishment_id'],
    era_name => 'valid',
    key_type => 'natural',
    unique_key_name => 'loc_mk_noid_pk',
    mutually_exclusive_columns => ARRAY['legal_unit_id', 'establishment_id']
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT sql_saga.add_temporal_foreign_key('tmtc.location_multi_key_no_id', ARRAY['legal_unit_id'], 'valid', 'tm_legal_unit_uk');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT sql_saga.add_temporal_foreign_key('tmtc.location_multi_key_no_id', ARRAY['establishment_id'], 'valid', 'tm_establishment_uk');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Helper procedure to reset the target table for a new scenario
CREATE OR REPLACE PROCEDURE tmtc.reset_target() AS $$
BEGIN
    TRUNCATE tmtc.stat_definition, tmtc.legal_unit, tmtc.establishment, tmtc.stat_for_unit, tmtc.stat_for_unit_id_pk, tmtc.stat_for_unit_id_gen, tmtc.stat_for_unit_no_pk, tmtc.location_multi_key, tmtc.location_multi_key_no_id RESTART IDENTITY CASCADE;
    -- Add parent data
    INSERT INTO tmtc.stat_definition (id, name) VALUES (10, 'Total Employees');
    INSERT INTO tmtc.legal_unit (id, valid_from, valid_until, name) VALUES (200, '1900-01-01', 'infinity', 'LU 200');
    INSERT INTO tmtc.establishment (id, valid_from, valid_until, name) VALUES (100, '1900-01-01', 'infinity', 'EST 100');
END;
$$ LANGUAGE plpgsql;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\set source_schema 'pg_temp'
\set ephemeral_cols '{edit_comment}'
--------------------------------------------------------------------------------
\echo 'Scenario 1: `upsert_replace` with a natural key (`during` split)'
Scenario 1: `upsert_replace` with a natural key (`during` split)
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO tmtc.stat_for_unit (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment) VALUES
(10, 100, '2024-01-01', '2025-01-01', 50, 'Original Value');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CREATE TEMP TABLE temp_source_1 (
    row_id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO temp_source_1 VALUES (1, 10, 100, '2024-04-01', '2024-09-01', 55, 'Corrected value for mid-year');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit ORDER BY stat_definition_id, establishment_id, valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_1 ORDER BY row_id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit',
    source_table => 'temp_source_1',
    primary_identity_columns => NULL,
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'UPDATE'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-04-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-04-01'::DATE, '2024-09-01'::DATE, '{"value": 55, "edit_comment": "Corrected value for mid-year"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (1, '[{"establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (10, 100, '2024-01-01'::DATE, '2024-04-01'::DATE, 50::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-04-01'::DATE, '2024-09-01'::DATE, 55::BIGINT, 'Corrected value for mid-year'::TEXT),
    (10, 100, '2024-09-01'::DATE, '2025-01-01'::DATE, 50::BIGINT, 'Original Value'::TEXT)
) AS t (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE temp_source_1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
--------------------------------------------------------------------------------
\echo 'Scenario 2: `upsert_patch` with a natural key (`during` split)'
Scenario 2: `upsert_patch` with a natural key (`during` split)
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO tmtc.stat_for_unit (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment) VALUES
(10, 100, '2024-01-01', '2025-01-01', 50, 'Original Value');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CREATE TEMP TABLE temp_source_2 (
    row_id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Source has a NULL value for 'edit_comment'. In patch mode, this should NOT overwrite the existing value.
INSERT INTO temp_source_2 VALUES (1, 10, 100, '2024-04-01', '2024-09-01', 55, NULL);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit ORDER BY stat_definition_id, establishment_id, valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_2 ORDER BY row_id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit',
    source_table => 'temp_source_2',
    primary_identity_columns => NULL,
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid',
    update_source_with_identity => true
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'UPDATE'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-04-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-04-01'::DATE, '2024-09-01'::DATE, '{"value": 55, "edit_comment": "Original Value"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (1, '[{"establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (10, 100, '2024-01-01'::DATE, '2024-04-01'::DATE, 50::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-04-01'::DATE, '2024-09-01'::DATE, 55::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-09-01'::DATE, '2025-01-01'::DATE, 50::BIGINT, 'Original Value'::TEXT)
) AS t (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE temp_source_2;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
--------------------------------------------------------------------------------
\echo 'Scenario 3: `upsert_replace` with mismatched source/target columns'
Scenario 3: `upsert_replace` with mismatched source/target columns
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO tmtc.stat_for_unit (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment) VALUES
(10, 100, '2024-01-01', '2025-01-01', 50, 'Original Value');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Source table has an extra column `source_metadata` that is not in the target.
CREATE TEMP TABLE temp_source_3 (
    row_id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT, source_metadata TEXT
) ON COMMIT DROP;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO temp_source_3 VALUES (1, 10, 100, '2024-04-01', '2024-09-01', 55, 'Corrected value for mid-year', 'some extra data');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit ORDER BY stat_definition_id, establishment_id, valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_3 ORDER BY row_id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit',
    source_table => 'temp_source_3',
    primary_identity_columns => NULL,
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'UPDATE'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-04-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-04-01'::DATE, '2024-09-01'::DATE, '{"value": 55, "edit_comment": "Corrected value for mid-year"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": 50, "edit_comment": "Original Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (1, '[{"establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (10, 100, '2024-01-01'::DATE, '2024-04-01'::DATE, 50::BIGINT, 'Original Value'::TEXT),
    (10, 100, '2024-04-01'::DATE, '2024-09-01'::DATE, 55::BIGINT, 'Corrected value for mid-year'::TEXT),
    (10, 100, '2024-09-01'::DATE, '2025-01-01'::DATE, 50::BIGINT, 'Original Value'::TEXT)
) AS t (stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE temp_source_3;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
--------------------------------------------------------------------------------
\echo 'Scenario 4: `upsert_replace` with SERIAL surrogate key on target'
Scenario 4: `upsert_replace` with SERIAL surrogate key on target
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CREATE TEMP TABLE temp_source_4 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO temp_source_4 VALUES (1, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial Value');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk ORDER BY id, valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_4 ORDER BY row_id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_pk',
    source_table => 'temp_source_4',
    primary_identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (1, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source Table: Expected state after back-fill ---'
--- Source Table: Expected state after back-fill ---
SELECT * FROM (VALUES (1, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source Table: Actual state after back-fill ---'
--- Source Table: Actual state after back-fill ---
SELECT * FROM temp_source_4 ORDER BY row_id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE temp_source_4;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
--------------------------------------------------------------------------------
\echo 'Scenario 5: `upsert_replace` with IDENTITY surrogate key on target'
Scenario 5: `upsert_replace` with IDENTITY surrogate key on target
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CREATE TEMP TABLE temp_source_5 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO temp_source_5 VALUES (1, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial Value');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen ORDER BY id, valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_5 ORDER BY row_id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_gen',
    source_table => 'temp_source_5',
    primary_identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (1, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source Table: Expected state after back-fill ---'
--- Source Table: Expected state after back-fill ---
SELECT * FROM (VALUES (1, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source Table: Actual state after back-fill ---'
--- Source Table: Actual state after back-fill ---
SELECT * FROM temp_source_5 ORDER BY row_id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE temp_source_5;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
--------------------------------------------------------------------------------
\echo 'Scenario 6: `upsert_patch` with SERIAL surrogate key on target'
Scenario 6: `upsert_patch` with SERIAL surrogate key on target
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CREATE TEMP TABLE temp_source_6 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO temp_source_6 VALUES (104, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial stat');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk ORDER BY id, valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_6 ORDER BY row_id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_pk',
    source_table => 'temp_source_6',
    primary_identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => '{edit_comment}'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid',
    update_source_with_identity => true
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{104}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial stat"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (104, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_pk WHERE establishment_id = 100 and stat_definition_id = 10 ORDER BY valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source Table: Expected state after back-fill ---'
--- Source Table: Expected state after back-fill ---
SELECT * FROM (VALUES (104, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source Table: Actual state after back-fill ---'
--- Source Table: Actual state after back-fill ---
SELECT * FROM temp_source_6 ORDER BY row_id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE temp_source_6;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
--------------------------------------------------------------------------------
\echo 'Scenario 7: `upsert_patch` with IDENTITY surrogate key on target'
Scenario 7: `upsert_patch` with IDENTITY surrogate key on target
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CREATE TEMP TABLE temp_source_7 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO temp_source_7 VALUES (105, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial stat');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen ORDER BY id, valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_7 ORDER BY row_id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_gen',
    source_table => 'temp_source_7',
    primary_identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => '{edit_comment}'::TEXT[],
    mode => 'MERGE_ENTITY_PATCH',
    era_name => 'valid',
    update_source_with_identity => true
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{105}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial stat"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (105, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_id_gen WHERE establishment_id = 100 and stat_definition_id = 10 ORDER BY valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source Table: Expected state after back-fill ---'
--- Source Table: Expected state after back-fill ---
SELECT * FROM (VALUES (105, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial stat'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source Table: Actual state after back-fill ---'
--- Source Table: Actual state after back-fill ---
SELECT * FROM temp_source_7 ORDER BY row_id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE temp_source_7;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
--------------------------------------------------------------------------------
\echo 'Scenario 8: `upsert_replace` with non-PK surrogate key'
Scenario 8: `upsert_replace` with non-PK surrogate key
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CREATE TEMP TABLE temp_source_8 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, valid_from DATE NOT NULL, valid_until DATE NOT NULL, value BIGINT, edit_comment TEXT
) ON COMMIT DROP;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO temp_source_8 VALUES (1, NULL, 10, 100, '2024-01-01', '2025-01-01', 100, 'Initial Value');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Initial State (before merge) ---'
--- Target: Initial State (before merge) ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_no_pk ORDER BY id, valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_8 ORDER BY row_id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Run the orchestrator and store its feedback
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_no_pk',
    source_table => 'temp_source_8',
    primary_identity_columns => '{id}'::TEXT[],
    natural_identity_columns => '{stat_definition_id, establishment_id}'::TEXT[],
    ephemeral_columns => :'ephemeral_cols'::TEXT[],
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    update_source_with_identity => true
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{1}'::INT[], 'INSERT'::sql_saga.temporal_merge_plan_action, '{"id": 1, "establishment_id": 100, "stat_definition_id": 10}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": 100, "edit_comment": "Initial Value"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Planner: Actual Plan (from Orchestrator) ---'
--- Planner: Actual Plan (from Orchestrator) ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES (1, '[{"id": 1, "establishment_id": 100, "stat_definition_id": 10}]'::JSONB, 'APPLIED'::sql_saga.temporal_merge_feedback_status, NULL::TEXT)) AS t (source_row_id, target_entity_ids, status, error_message);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)
) AS t (id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment FROM tmtc.stat_for_unit_no_pk WHERE stat_definition_id = 10 AND establishment_id = 100 ORDER BY valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source Table: Expected state after back-fill ---'
--- Source Table: Expected state after back-fill ---
SELECT * FROM (VALUES (1, 1, 10, 100, '2024-01-01'::DATE, '2025-01-01'::DATE, 100::BIGINT, 'Initial Value'::TEXT)) t(row_id, id, stat_definition_id, establishment_id, valid_from, valid_until, value, edit_comment);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source Table: Actual state after back-fill ---'
--- Source Table: Actual state after back-fill ---
SELECT * FROM temp_source_8 ORDER BY row_id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE temp_source_8;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SAVEPOINT scenario_9;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- NOTE on test isolation:
-- Each scenario is wrapped in a SAVEPOINT ... RELEASE SAVEPOINT block. This ensures
-- that each test case runs in its own nested transaction. If a test succeeds, its
-- changes are committed to the main transaction when RELEASE is called. This is a
-- robust pattern for isolating successful, independent test cases.
-- For expected failures, see the different pattern used in Scenario 12.
SET client_min_messages TO NOTICE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 9: Multiple, mutually exclusive natural keys with a surrogate ID'
Scenario 9: Multiple, mutually exclusive natural keys with a surrogate ID
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
-- This scenario tests using different natural_identity_columns on the same target table.
CALL tmtc.reset_target();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CREATE TEMP TABLE temp_source_9 (
    row_id INT, id INT, type tmtc.location_type, legal_unit_id INT, establishment_id INT, address TEXT, valid_from DATE, valid_until DATE, edit_comment TEXT
) ON COMMIT DROP;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Insert initial data into target
INSERT INTO tmtc.location_multi_key (type, legal_unit_id, address, valid_from, valid_until) VALUES
('visiting', 200, '200 Main St', '2024-01-01', 'infinity');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO tmtc.location_multi_key (type, establishment_id, address, valid_from, valid_until) VALUES
('visiting', 100, '100 Business Park', '2024-01-01', 'infinity');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Initial state ---'
--- Target: Initial state ---
SELECT id, type, legal_unit_id, establishment_id, address FROM tmtc.location_multi_key ORDER BY id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Case 9a: Merge using the (type, legal_unit_id) natural key. ---'
--- Case 9a: Merge using the (type, legal_unit_id) natural key. ---
INSERT INTO temp_source_9 VALUES (1, NULL, 'visiting', 200, NULL, '201 New Main St', '2024-06-01', 'infinity', 'LU address change');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source (Legal Unit location) ---'
--- Source (Legal Unit location) ---
TABLE temp_source_9;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key',
    source_table => 'temp_source_9',
    primary_identity_columns => '{id}',
    natural_identity_columns => '{type, legal_unit_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: After merge for Legal Unit location ---'
--- Target: After merge for Legal Unit location ---
SELECT id, type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key ORDER BY id, valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source: After back-fill ---'
--- Source: After back-fill ---
TABLE temp_source_9;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Case 9b: Merge using the (type, establishment_id) natural key. ---'
--- Case 9b: Merge using the (type, establishment_id) natural key. ---
TRUNCATE temp_source_9;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO temp_source_9 VALUES (2, NULL, 'visiting', NULL, 100, '101 New Business Park', '2024-08-01', 'infinity', 'Est address change');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source (Establishment location) ---'
--- Source (Establishment location) ---
TABLE temp_source_9;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key',
    source_table => 'temp_source_9',
    primary_identity_columns => '{id}',
    natural_identity_columns => '{type, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Final state ---'
--- Target: Final state ---
SELECT id, type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key ORDER BY id, valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source: Final after back-fill ---'
--- Source: Final after back-fill ---
TABLE temp_source_9;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE temp_source_9;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
RELEASE SAVEPOINT scenario_9;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SAVEPOINT scenario_10;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 10: Multiple, mutually exclusive natural keys without a surrogate ID'
Scenario 10: Multiple, mutually exclusive natural keys without a surrogate ID
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
CALL tmtc.reset_target();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CREATE TEMP TABLE temp_source_10 (
    row_id INT, type tmtc.location_type, legal_unit_id INT, establishment_id INT, address TEXT, valid_from DATE, valid_until DATE, edit_comment TEXT
) ON COMMIT DROP;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Insert initial data into target
INSERT INTO tmtc.location_multi_key_no_id (type, legal_unit_id, address, valid_from, valid_until) VALUES
('visiting', 200, '200 Main St', '2024-01-01', 'infinity');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO tmtc.location_multi_key_no_id (type, establishment_id, address, valid_from, valid_until) VALUES
('visiting', 100, '100 Business Park', '2024-01-01', 'infinity');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Initial state ---'
--- Target: Initial state ---
SELECT type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key_no_id ORDER BY COALESCE(legal_unit_id, establishment_id);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Case 10a: Merge using the (type, legal_unit_id) natural key. ---'
--- Case 10a: Merge using the (type, legal_unit_id) natural key. ---
INSERT INTO temp_source_10 VALUES (1, 'visiting', 200, NULL, '201 New Main St', '2024-06-01', 'infinity', 'LU address change');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source (Legal Unit location) ---'
--- Source (Legal Unit location) ---
TABLE temp_source_10;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key_no_id',
    source_table => 'temp_source_10',
    primary_identity_columns => NULL,
    natural_identity_columns => '{type, legal_unit_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => false
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: After merge for Legal Unit location ---'
--- Target: After merge for Legal Unit location ---
SELECT type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key_no_id ORDER BY COALESCE(legal_unit_id, establishment_id), valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Case 10b: Merge using the (type, establishment_id) natural key. ---'
--- Case 10b: Merge using the (type, establishment_id) natural key. ---
TRUNCATE temp_source_10;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO temp_source_10 VALUES (2, 'visiting', NULL, 100, '101 New Business Park', '2024-08-01', 'infinity', 'Est address change');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source (Establishment location) ---'
--- Source (Establishment location) ---
TABLE temp_source_10;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key_no_id',
    source_table => 'temp_source_10',
    primary_identity_columns => NULL,
    natural_identity_columns => '{type, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => false
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Final state ---'
--- Target: Final state ---
SELECT type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key_no_id ORDER BY COALESCE(legal_unit_id, establishment_id), valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE temp_source_10;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
RELEASE SAVEPOINT scenario_10;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SAVEPOINT scenario_11;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SET client_min_messages TO NOTICE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 11: Natural key with NULLs using IS NOT DISTINCT FROM logic'
Scenario 11: Natural key with NULLs using IS NOT DISTINCT FROM logic
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
-- This scenario tests using a single composite natural key that contains NULLs.
CALL tmtc.reset_target();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CREATE TEMP TABLE temp_source_11 (
    row_id INT, id INT, type tmtc.location_type, legal_unit_id INT, establishment_id INT, address TEXT, valid_from DATE, valid_until DATE, edit_comment TEXT
) ON COMMIT DROP;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Insert initial data into target
INSERT INTO tmtc.location_multi_key (type, legal_unit_id, address, valid_from, valid_until) VALUES
('visiting', 200, '200 Main St', '2024-01-01', 'infinity');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO tmtc.location_multi_key (type, establishment_id, address, valid_from, valid_until) VALUES
('visiting', 100, '100 Business Park', '2024-01-01', 'infinity');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Initial state ---'
--- Target: Initial state ---
SELECT id, type, legal_unit_id, establishment_id, address FROM tmtc.location_multi_key ORDER BY id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Case 11a: Update Legal Unit location using a composite key with NULL ---'
--- Case 11a: Update Legal Unit location using a composite key with NULL ---
INSERT INTO temp_source_11 VALUES (1, NULL, 'visiting', 200, NULL, '201 New Main St', '2024-06-01', 'infinity', 'LU address change');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source (Legal Unit location) ---'
--- Source (Legal Unit location) ---
TABLE temp_source_11;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key',
    source_table => 'temp_source_11',
    primary_identity_columns => '{id}',
    natural_identity_columns => '{type, legal_unit_id, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: After merge for Legal Unit location ---'
--- Target: After merge for Legal Unit location ---
SELECT id, type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key ORDER BY id, valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source: After back-fill ---'
--- Source: After back-fill ---
TABLE temp_source_11;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Case 11b: Update Establishment location using a composite key with NULL ---'
--- Case 11b: Update Establishment location using a composite key with NULL ---
TRUNCATE temp_source_11;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO temp_source_11 VALUES (2, NULL, 'visiting', NULL, 100, '101 New Business Park', '2024-08-01', 'infinity', 'Est address change');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source (Establishment location) ---'
--- Source (Establishment location) ---
TABLE temp_source_11;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.location_multi_key',
    source_table => 'temp_source_11',
    primary_identity_columns => '{id}',
    natural_identity_columns => '{type, legal_unit_id, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Final state ---'
--- Target: Final state ---
SELECT id, type, legal_unit_id, establishment_id, address, valid_from, valid_until FROM tmtc.location_multi_key ORDER BY id, valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source: Final after back-fill ---'
--- Source: Final after back-fill ---
TABLE temp_source_11;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE temp_source_11;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
RELEASE SAVEPOINT scenario_11;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SAVEPOINT scenario_12;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SET client_min_messages TO NOTICE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 12: Test failure on SCD Type 2 update with incompatible simple PRIMARY KEY'
Scenario 12: Test failure on SCD Type 2 update with incompatible simple PRIMARY KEY
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
-- Purpose: This test verifies that `temporal_merge` correctly fails when asked to
-- perform a history-preserving update (SCD Type 2) on a table with an
-- incompatible schema.
--
-- The target table `stat_for_unit_id_pk` has a simple `PRIMARY KEY (id)`,
-- which is an anti-pattern for temporal tables because it prevents storing
-- multiple historical versions of the same entity.
--
-- The `MERGE_ENTITY_REPLACE` operation attempts an SCD Type 2 update:
-- 1. It finds the existing entity via the natural key.
-- 2. It plans to "close out" the current record by updating its `valid_until`.
-- 3. It plans to INSERT a new record with the updated data. This new record
--    will have the same stable identifier (`id`) as the old one.
--
-- This INSERT correctly fails with a unique constraint violation because a row
-- with that `id` already exists. The test confirms that `sql_saga` raises this
-- error instead of silently corrupting data.
CALL tmtc.reset_target();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CREATE TEMP TABLE temp_source_12 (
    row_id INT, id INT, stat_definition_id INT, establishment_id INT, value BIGINT, valid_from DATE, valid_until DATE, edit_comment TEXT
) ON COMMIT DROP;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Insert initial data into target, where the natural key includes a NULL
INSERT INTO tmtc.stat_for_unit_id_pk (stat_definition_id, establishment_id, value, valid_from, valid_until) VALUES
(10, NULL, 500, '2024-01-01', 'infinity');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Target: Initial state ---'
--- Target: Initial state ---
SELECT id, stat_definition_id, establishment_id, value, valid_from, valid_until FROM tmtc.stat_for_unit_id_pk ORDER BY id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Case 12a: Update entity identified by natural key with NULL ---'
--- Case 12a: Update entity identified by natural key with NULL ---
INSERT INTO temp_source_12 VALUES (1, NULL, 10, NULL, 550, '2024-07-01', 'infinity', 'Stat value update');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source ---'
--- Source ---
TABLE temp_source_12;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SAVEPOINT expect_error;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- NOTE on testing expected failures:
-- This call is expected to raise an ERROR. By wrapping it in a SAVEPOINT and
-- then calling ROLLBACK TO SAVEPOINT, we can test the failure without aborting
-- the main transaction. This allows us to see the raw error message and then
-- continue with subsequent tests.
\echo '--- Plan and Feedback (from failing call) ---'
--- Plan and Feedback (from failing call) ---
CALL sql_saga.temporal_merge(
    target_table => 'tmtc.stat_for_unit_id_pk',
    source_table => 'temp_source_12',
    primary_identity_columns => '{id}',
    natural_identity_columns => '{stat_definition_id, establishment_id}',
    ephemeral_columns => '{edit_comment}',
    mode => 'MERGE_ENTITY_REPLACE',
    update_source_with_identity => true
);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK TO SAVEPOINT expect_error;
ERROR:  savepoint "expect_error" does not exist
\echo '--- Target: After merge (should be unchanged) ---'
--- Target: After merge (should be unchanged) ---
SELECT id, stat_definition_id, establishment_id, value, valid_from, valid_until FROM tmtc.stat_for_unit_id_pk ORDER BY id, valid_from;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\echo '--- Source: After back-fill (should be unchanged) ---'
--- Source: After back-fill (should be unchanged) ---
TABLE temp_source_12;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE temp_source_12;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
RELEASE SAVEPOINT scenario_12;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Final Cleanup
DROP PROCEDURE tmtc.reset_target();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE tmtc.stat_for_unit, tmtc.stat_for_unit_id_pk, tmtc.stat_for_unit_id_gen, tmtc.stat_for_unit_no_pk, tmtc.location_multi_key, tmtc.location_multi_key_no_id;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE tmtc.legal_unit, tmtc.establishment;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE tmtc.stat_definition;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CALL sql_saga.temporal_merge_drop_cache();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP SCHEMA tmtc CASCADE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
