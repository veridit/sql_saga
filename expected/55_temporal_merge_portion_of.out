\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
CREATE SCHEMA tm_portion_of;
CREATE TABLE tm_portion_of.target(
    id int,
    payload TEXT,
    edit_comment TEXT,
    valid_from DATE,
    valid_until DATE
);
SELECT sql_saga.add_era('tm_portion_of.target'::regclass, 'valid_from', 'valid_until', 'valid');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tm_portion_of.target'::regclass, '{id}', 'valid');
 add_unique_key  
-----------------
 target_id_valid
(1 row)

-- Helper function to reset target state
CREATE OR REPLACE PROCEDURE tm_portion_of.reset_target() AS $$
BEGIN
    TRUNCATE tm_portion_of.target;
    -- Add control entities that should not be affected by the merge
    INSERT INTO tm_portion_of.target (id, payload, edit_comment, valid_from, valid_until) VALUES
        (0, 'Control PRE', 'Unaffected', '2020-01-01', '2025-01-01');

    -- Target entity has two adjacent periods, a gap, and a final period
    INSERT INTO tm_portion_of.target (id, payload, edit_comment, valid_from, valid_until) VALUES
        (1, 'A-1', 'Adjacent 1', '2021-01-01', '2022-01-01'),
        (1, 'A-2', 'Adjacent 2', '2022-01-01', '2023-01-01'),
        (1, 'B-1', 'After Gap',  '2024-01-01', '2025-01-01');

    INSERT INTO tm_portion_of.target (id, payload, edit_comment, valid_from, valid_until) VALUES
        (2, 'Control POST', 'Unaffected', '2020-01-01', '2025-01-01');
END;
$$ LANGUAGE plpgsql;
--------------------------------------------------------------------------------
\echo 'Scenario 1: `PATCH_FOR_PORTION_OF` performs a surgical patch'
Scenario 1: `PATCH_FOR_PORTION_OF` performs a surgical patch
--------------------------------------------------------------------------------
CALL tm_portion_of.reset_target();
CREATE TEMP TABLE source_1 (row_id int, id int, payload text, edit_comment text, valid_from date, valid_until date) ON COMMIT DROP;
-- Source data to test multiple patch scenarios at once
INSERT INTO source_1 (row_id, id, payload, edit_comment, valid_from, valid_until) VALUES
    -- 1. Ignored change (identical data)
    (101, 1, 'A-1', 'Adjacent 1', '2021-01-01', '2022-01-01'),
    -- 2. Straddling change (covers half of each adjacent period)
    (102, 1, 'Patched-Straddle', 'Surgical Patch Straddling', '2021-07-01', '2022-07-01'),
    -- 3. Perfectly aligned change (on the segment after the gap)
    (103, 1, 'Patched-Aligned', 'Surgical Patch Aligned', '2024-01-01', '2025-01-01');
CALL sql_saga.temporal_merge(p_target_table => 'tm_portion_of.target'::regclass, p_source_table => 'source_1'::regclass, p_id_columns => '{id}'::text[], p_ephemeral_columns => '{edit_comment}'::text[], p_mode => 'PATCH_FOR_PORTION_OF'::sql_saga.temporal_merge_mode, p_era_name => 'valid');
\echo '--- Plan and Feedback ---'
--- Plan and Feedback ---
SELECT * FROM temporal_merge_plan;
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |                                     data                                     | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+------------------------------------------------------------------------------+----------
           1 | {102}          | UPDATE    | {"id": 1}  | 2021-01-01     | 2021-01-01     | 2021-07-01      | {"payload": "A-1", "edit_comment": "Adjacent 1"}                             | starts
           3 | {102}          | UPDATE    | {"id": 1}  | 2022-01-01     | 2022-07-01     | 2023-01-01      | {"payload": "A-2", "edit_comment": "Adjacent 2"}                             | finishes
           4 | {103}          | UPDATE    | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2025-01-01      | {"payload": "Patched-Aligned", "edit_comment": "Surgical Patch Aligned"}     | equals
           2 | {102}          | INSERT    | {"id": 1}  |                | 2021-07-01     | 2022-07-01      | {"payload": "Patched-Straddle", "edit_comment": "Surgical Patch Straddling"} | 
(4 rows)

SELECT source_row_id, status FROM temporal_merge_feedback ORDER BY source_row_id;
 source_row_id |      status      
---------------+------------------
           101 | SKIPPED_FILTERED
           102 | APPLIED
           103 | APPLIED
(3 rows)

\echo '--- Expected Final State ---'
--- Expected Final State ---
SELECT * FROM (VALUES
    (0, 'Control PRE', 'Unaffected', '2020-01-01'::date, '2025-01-01'::date),
    (1, 'A-1', 'Adjacent 1', '2021-01-01'::date, '2021-07-01'::date),
    (1, 'Patched-Straddle', 'Surgical Patch Straddling', '2021-07-01'::date, '2022-07-01'::date),
    (1, 'A-2', 'Adjacent 2', '2022-07-01'::date, '2023-01-01'::date),
    (1, 'Patched-Aligned', 'Surgical Patch Aligned', '2024-01-01'::date, '2025-01-01'::date),
    (2, 'Control POST', 'Unaffected', '2020-01-01'::date, '2025-01-01'::date)
) AS v(id, payload, edit_comment, valid_from, valid_until) ORDER BY id, valid_from;
 id |     payload      |       edit_comment        | valid_from | valid_until 
----+------------------+---------------------------+------------+-------------
  0 | Control PRE      | Unaffected                | 2020-01-01 | 2025-01-01
  1 | A-1              | Adjacent 1                | 2021-01-01 | 2021-07-01
  1 | Patched-Straddle | Surgical Patch Straddling | 2021-07-01 | 2022-07-01
  1 | A-2              | Adjacent 2                | 2022-07-01 | 2023-01-01
  1 | Patched-Aligned  | Surgical Patch Aligned    | 2024-01-01 | 2025-01-01
  2 | Control POST     | Unaffected                | 2020-01-01 | 2025-01-01
(6 rows)

\echo '--- Actual Final State ---'
--- Actual Final State ---
SELECT id, payload, edit_comment, valid_from, valid_until FROM tm_portion_of.target ORDER BY id, valid_from;
 id |     payload      |       edit_comment        | valid_from | valid_until 
----+------------------+---------------------------+------------+-------------
  0 | Control PRE      | Unaffected                | 2020-01-01 | 2025-01-01
  1 | A-1              | Adjacent 1                | 2021-01-01 | 2021-07-01
  1 | Patched-Straddle | Surgical Patch Straddling | 2021-07-01 | 2022-07-01
  1 | A-2              | Adjacent 2                | 2022-07-01 | 2023-01-01
  1 | Patched-Aligned  | Surgical Patch Aligned    | 2024-01-01 | 2025-01-01
  2 | Control POST     | Unaffected                | 2020-01-01 | 2025-01-01
(6 rows)

--------------------------------------------------------------------------------
\echo 'Scenario 2: `REPLACE_FOR_PORTION_OF` performs a surgical replacement'
Scenario 2: `REPLACE_FOR_PORTION_OF` performs a surgical replacement
--------------------------------------------------------------------------------
CALL tm_portion_of.reset_target();
CREATE TEMP TABLE source_2 (row_id int, id int, payload text, edit_comment text, valid_from date, valid_until date) ON COMMIT DROP;
-- Source data to test multiple replace scenarios at once
INSERT INTO source_2 (row_id, id, payload, edit_comment, valid_from, valid_until) VALUES
    -- 1. Ignored change (identical data)
    (201, 1, 'A-1', 'Adjacent 1', '2021-01-01', '2022-01-01'),
    -- 2. Straddling change (covers half of each adjacent period)
    (202, 1, 'Replaced-Straddle', 'Surgical Replace Straddling', '2021-07-01', '2022-07-01'),
    -- 3. Perfectly aligned change (on the segment after the gap)
    (203, 1, 'Replaced-Aligned', 'Surgical Replace Aligned', '2024-01-01', '2025-01-01');
CALL sql_saga.temporal_merge(p_target_table => 'tm_portion_of.target'::regclass, p_source_table => 'source_2'::regclass, p_id_columns => '{id}'::text[], p_ephemeral_columns => '{edit_comment}'::text[], p_mode => 'REPLACE_FOR_PORTION_OF'::sql_saga.temporal_merge_mode, p_era_name => 'valid');
\echo '--- Plan and Feedback ---'
--- Plan and Feedback ---
SELECT * FROM temporal_merge_plan;
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |                                      data                                       | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+---------------------------------------------------------------------------------+----------
           1 | {202}          | UPDATE    | {"id": 1}  | 2021-01-01     | 2021-01-01     | 2021-07-01      | {"payload": "A-1", "edit_comment": "Adjacent 1"}                                | starts
           3 | {202}          | UPDATE    | {"id": 1}  | 2022-01-01     | 2022-07-01     | 2023-01-01      | {"payload": "A-2", "edit_comment": "Adjacent 2"}                                | finishes
           4 | {203}          | UPDATE    | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2025-01-01      | {"payload": "Replaced-Aligned", "edit_comment": "Surgical Replace Aligned"}     | equals
           2 | {202}          | INSERT    | {"id": 1}  |                | 2021-07-01     | 2022-07-01      | {"payload": "Replaced-Straddle", "edit_comment": "Surgical Replace Straddling"} | 
(4 rows)

SELECT source_row_id, status FROM temporal_merge_feedback ORDER BY source_row_id;
 source_row_id |      status      
---------------+------------------
           201 | SKIPPED_FILTERED
           202 | APPLIED
           203 | APPLIED
(3 rows)

\echo '--- Expected Final State ---'
--- Expected Final State ---
SELECT * FROM (VALUES
    (0, 'Control PRE', 'Unaffected', '2020-01-01'::date, '2025-01-01'::date),
    (1, 'A-1', 'Adjacent 1', '2021-01-01'::date, '2021-07-01'::date),
    (1, 'Replaced-Straddle', 'Surgical Replace Straddling', '2021-07-01'::date, '2022-07-01'::date),
    (1, 'A-2', 'Adjacent 2', '2022-07-01'::date, '2023-01-01'::date),
    (1, 'Replaced-Aligned', 'Surgical Replace Aligned', '2024-01-01'::date, '2025-01-01'::date),
    (2, 'Control POST', 'Unaffected', '2020-01-01'::date, '2025-01-01'::date)
) AS v(id, payload, edit_comment, valid_from, valid_until) ORDER BY id, valid_from;
 id |      payload      |        edit_comment         | valid_from | valid_until 
----+-------------------+-----------------------------+------------+-------------
  0 | Control PRE       | Unaffected                  | 2020-01-01 | 2025-01-01
  1 | A-1               | Adjacent 1                  | 2021-01-01 | 2021-07-01
  1 | Replaced-Straddle | Surgical Replace Straddling | 2021-07-01 | 2022-07-01
  1 | A-2               | Adjacent 2                  | 2022-07-01 | 2023-01-01
  1 | Replaced-Aligned  | Surgical Replace Aligned    | 2024-01-01 | 2025-01-01
  2 | Control POST      | Unaffected                  | 2020-01-01 | 2025-01-01
(6 rows)

\echo '--- Actual Final State ---'
--- Actual Final State ---
SELECT id, payload, edit_comment, valid_from, valid_until FROM tm_portion_of.target ORDER BY id, valid_from;
 id |      payload      |        edit_comment         | valid_from | valid_until 
----+-------------------+-----------------------------+------------+-------------
  0 | Control PRE       | Unaffected                  | 2020-01-01 | 2025-01-01
  1 | A-1               | Adjacent 1                  | 2021-01-01 | 2021-07-01
  1 | Replaced-Straddle | Surgical Replace Straddling | 2021-07-01 | 2022-07-01
  1 | A-2               | Adjacent 2                  | 2022-07-01 | 2023-01-01
  1 | Replaced-Aligned  | Surgical Replace Aligned    | 2024-01-01 | 2025-01-01
  2 | Control POST      | Unaffected                  | 2020-01-01 | 2025-01-01
(6 rows)

--------------------------------------------------------------------------------
\echo 'Scenario 3: `DELETE_FOR_PORTION_OF` carves out a piece of the timeline'
Scenario 3: `DELETE_FOR_PORTION_OF` carves out a piece of the timeline
--------------------------------------------------------------------------------
CALL tm_portion_of.reset_target();
CREATE TEMP TABLE source_3 (row_id int, id int, payload text, edit_comment text, valid_from date, valid_until date) ON COMMIT DROP;
-- Source data to test multiple delete scenarios at once
INSERT INTO source_3 (row_id, id, payload, edit_comment, valid_from, valid_until) VALUES
    -- 1. Straddling delete (covers half of each adjacent period)
    (301, 1, NULL, 'Surgical Delete Straddling', '2021-07-01', '2022-07-01'),
    -- 2. Perfectly aligned delete (on the segment after the gap)
    (302, 1, NULL, 'Surgical Delete Aligned', '2024-01-01', '2025-01-01');
CALL sql_saga.temporal_merge(p_target_table => 'tm_portion_of.target'::regclass, p_source_table => 'source_3'::regclass, p_id_columns => '{id}'::text[], p_ephemeral_columns => '{edit_comment}'::text[], p_mode => 'DELETE_FOR_PORTION_OF'::sql_saga.temporal_merge_mode, p_era_name => 'valid');
\echo '--- Plan and Feedback ---'
--- Plan and Feedback ---
SELECT * FROM temporal_merge_plan;
 plan_op_seq | source_row_ids |   operation    | entity_ids | old_valid_from | new_valid_from | new_valid_until |                       data                       | relation 
-------------+----------------+----------------+------------+----------------+----------------+-----------------+--------------------------------------------------+----------
           1 | {301}          | UPDATE         | {"id": 1}  | 2021-01-01     | 2021-01-01     | 2021-07-01      | {"payload": "A-1", "edit_comment": "Adjacent 1"} | starts
           2 | {301}          | SKIP_IDENTICAL | {"id": 1}  |                | 2021-07-01     | 2022-07-01      |                                                  | 
           3 | {301}          | UPDATE         | {"id": 1}  | 2022-01-01     | 2022-07-01     | 2023-01-01      | {"payload": "A-2", "edit_comment": "Adjacent 2"} | finishes
           4 | {302}          | DELETE         | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2025-01-01      |                                                  | equals
(4 rows)

SELECT source_row_id, status FROM temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | status  
---------------+---------
           301 | APPLIED
           302 | APPLIED
(2 rows)

\echo '--- Expected Final State ---'
--- Expected Final State ---
SELECT * FROM (VALUES
    (0, 'Control PRE', 'Unaffected', '2020-01-01'::date, '2025-01-01'::date),
    (1, 'A-1', 'Adjacent 1', '2021-01-01'::date, '2021-07-01'::date),
    (1, 'A-2', 'Adjacent 2', '2022-07-01'::date, '2023-01-01'::date),
    (2, 'Control POST', 'Unaffected', '2020-01-01'::date, '2025-01-01'::date)
) AS v(id, payload, edit_comment, valid_from, valid_until) ORDER BY id, valid_from;
 id |   payload    | edit_comment | valid_from | valid_until 
----+--------------+--------------+------------+-------------
  0 | Control PRE  | Unaffected   | 2020-01-01 | 2025-01-01
  1 | A-1          | Adjacent 1   | 2021-01-01 | 2021-07-01
  1 | A-2          | Adjacent 2   | 2022-07-01 | 2023-01-01
  2 | Control POST | Unaffected   | 2020-01-01 | 2025-01-01
(4 rows)

\echo '--- Actual Final State ---'
--- Actual Final State ---
SELECT id, payload, edit_comment, valid_from, valid_until FROM tm_portion_of.target ORDER BY id, valid_from;
 id |   payload    | edit_comment | valid_from | valid_until 
----+--------------+--------------+------------+-------------
  0 | Control PRE  | Unaffected   | 2020-01-01 | 2025-01-01
  1 | A-1          | Adjacent 1   | 2021-01-01 | 2021-07-01
  1 | A-2          | Adjacent 2   | 2022-07-01 | 2023-01-01
  2 | Control POST | Unaffected   | 2020-01-01 | 2025-01-01
(4 rows)

--------------------------------------------------------------------------------
\echo 'Scenario 4: `..._FOR_PORTION_OF` modes return TARGET_NOT_FOUND for non-existent entities'
Scenario 4: `..._FOR_PORTION_OF` modes return TARGET_NOT_FOUND for non-existent entities
--------------------------------------------------------------------------------
TRUNCATE tm_portion_of.target;
CREATE TEMP TABLE source_4 (row_id int, id int, payload text, edit_comment text, valid_from date, valid_until date) ON COMMIT DROP;
-- Source attempts to modify an entity that does not exist in the target
INSERT INTO source_4 VALUES (104, 999, 'No-op', 'Should be SKIPPED_NO_TARGET', '2021-06-01', '2021-09-01');
\echo '--- PATCH_FOR_PORTION_OF ---'
--- PATCH_FOR_PORTION_OF ---
CALL sql_saga.temporal_merge(p_target_table => 'tm_portion_of.target'::regclass, p_source_table => 'source_4'::regclass, p_id_columns => '{id}'::text[], p_ephemeral_columns => '{edit_comment}'::text[], p_mode => 'PATCH_FOR_PORTION_OF'::sql_saga.temporal_merge_mode, p_era_name => 'valid');
SELECT operation, entity_ids FROM temporal_merge_plan;
   operation    | entity_ids  
----------------+-------------
 SKIP_NO_TARGET | {"id": 999}
(1 row)

SELECT source_row_id, status FROM temporal_merge_feedback ORDER BY source_row_id;
 source_row_id |      status       
---------------+-------------------
           104 | SKIPPED_NO_TARGET
(1 row)

\echo '--- REPLACE_FOR_PORTION_OF ---'
--- REPLACE_FOR_PORTION_OF ---
CALL sql_saga.temporal_merge(p_target_table => 'tm_portion_of.target'::regclass, p_source_table => 'source_4'::regclass, p_id_columns => '{id}'::text[], p_ephemeral_columns => '{edit_comment}'::text[], p_mode => 'REPLACE_FOR_PORTION_OF'::sql_saga.temporal_merge_mode, p_era_name => 'valid');
SELECT operation, entity_ids FROM temporal_merge_plan;
   operation    | entity_ids  
----------------+-------------
 SKIP_NO_TARGET | {"id": 999}
(1 row)

SELECT source_row_id, status FROM temporal_merge_feedback ORDER BY source_row_id;
 source_row_id |      status       
---------------+-------------------
           104 | SKIPPED_NO_TARGET
(1 row)

\echo '--- DELETE_FOR_PORTION_OF ---'
--- DELETE_FOR_PORTION_OF ---
CALL sql_saga.temporal_merge(p_target_table => 'tm_portion_of.target'::regclass, p_source_table => 'source_4'::regclass, p_id_columns => '{id}'::text[], p_ephemeral_columns => '{edit_comment}'::text[], p_mode => 'DELETE_FOR_PORTION_OF'::sql_saga.temporal_merge_mode, p_era_name => 'valid');
SELECT operation, entity_ids FROM temporal_merge_plan;
   operation    | entity_ids  
----------------+-------------
 SKIP_NO_TARGET | {"id": 999}
(1 row)

SELECT source_row_id, status FROM temporal_merge_feedback ORDER BY source_row_id;
 source_row_id |      status       
---------------+-------------------
           104 | SKIPPED_NO_TARGET
(1 row)

ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
