\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
CREATE ROLE view_test_role;
BEGIN;
-- Scenario 1: Test with a table in a non-public schema
CREATE SCHEMA test_schema;
CREATE TABLE test_schema.schema_test (
    id int,
    value text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('test_schema.schema_test', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('test_schema.schema_test', ARRAY['id']);
    add_unique_key    
----------------------
 schema_test_id_valid
(1 row)

SELECT sql_saga.add_for_portion_of_view('test_schema.schema_test'::regclass);
 add_for_portion_of_view 
-------------------------
 t
(1 row)

\d test_schema.schema_test__for_portion_of_valid
  View "test_schema.schema_test__for_portion_of_valid"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 id          | integer |           |          | 
 value       | text    |           |          | 
 valid_from  | date    |           |          | 
 valid_until | date    |           |          | 
Triggers:
    for_portion_of_valid INSTEAD OF INSERT OR DELETE OR UPDATE ON test_schema.schema_test__for_portion_of_valid FOR EACH ROW EXECUTE FUNCTION sql_saga.for_portion_of_trigger('id')

TABLE sql_saga.updatable_view;
 view_schema |             view_name             |   view_type    | table_schema | table_name  | era_name |     trigger_name     | current_func 
-------------+-----------------------------------+----------------+--------------+-------------+----------+----------------------+--------------
 test_schema | schema_test__for_portion_of_valid | for_portion_of | test_schema  | schema_test | valid    | for_portion_of_valid | 
(1 row)

-- DML must be on the base table now
INSERT INTO test_schema.schema_test VALUES (1, 'A', '2024-01-01', 'infinity');
TABLE test_schema.schema_test;
 id | value | valid_from | valid_until 
----+-------+------------+-------------
  1 | A     | 2024-01-01 | infinity
(1 row)

SELECT sql_saga.drop_for_portion_of_view('test_schema.schema_test'::regclass);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

-- Scenario 2: ACL and Ownership tests
CREATE TABLE acl_test (id int, value text, valid_from date, valid_until date);
ALTER TABLE acl_test OWNER to view_test_role;
SELECT sql_saga.add_era('acl_test', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('acl_test', ARRAY['id']);
  add_unique_key   
-------------------
 acl_test_id_valid
(1 row)

SET ROLE view_test_role;
-- This should succeed as the role owns the table
SELECT sql_saga.add_for_portion_of_view('acl_test'::regclass);
 add_for_portion_of_view 
-------------------------
 t
(1 row)

RESET ROLE;
-- Verify owner of the view is correct
\d acl_test__for_portion_of_valid
      View "public.acl_test__for_portion_of_valid"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 id          | integer |           |          | 
 value       | text    |           |          | 
 valid_from  | date    |           |          | 
 valid_until | date    |           |          | 
Triggers:
    for_portion_of_valid INSTEAD OF INSERT OR DELETE OR UPDATE ON acl_test__for_portion_of_valid FOR EACH ROW EXECUTE FUNCTION sql_saga.for_portion_of_trigger('id')

TABLE sql_saga.updatable_view;
 view_schema |           view_name            |   view_type    | table_schema | table_name | era_name |     trigger_name     | current_func 
-------------+--------------------------------+----------------+--------------+------------+----------+----------------------+--------------
 public      | acl_test__for_portion_of_valid | for_portion_of | public       | acl_test   | valid    | for_portion_of_valid | 
(1 row)

-- Verify that permissions are handled correctly
INSERT INTO acl_test (id, value, valid_from, valid_until) VALUES (1, 'initial', '2024-01-01', 'infinity');
GRANT SELECT ON acl_test TO sql_saga_unprivileged_user;
SAVEPOINT no_update;
SET ROLE sql_saga_unprivileged_user;
SELECT CURRENT_ROLE;
        current_role        
----------------------------
 sql_saga_unprivileged_user
(1 row)

-- Should fail, as we only have SELECT on the base table
UPDATE acl_test__for_portion_of_valid SET value = 'no', valid_from = '2024-02-01', valid_until = '2024-03-01' WHERE id = 1;
ERROR:  permission denied for view acl_test__for_portion_of_valid
ROLLBACK TO no_update;
SAVEPOINT can_update;
GRANT UPDATE, INSERT ON acl_test TO sql_saga_unprivileged_user;
SET ROLE sql_saga_unprivileged_user;
SELECT CURRENT_ROLE;
        current_role        
----------------------------
 sql_saga_unprivileged_user
(1 row)

-- Should now succeed
UPDATE acl_test__for_portion_of_valid SET value = 'yes', valid_from = '2024-02-01', valid_until = '2024-03-01' WHERE id = 1;
TABLE acl_test ORDER BY valid_from;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | initial | 2024-01-01 | 2024-02-01
  1 | yes     | 2024-02-01 | 2024-03-01
  1 | initial | 2024-03-01 | infinity
(3 rows)

ROLLBACK TO can_update;
SELECT sql_saga.drop_for_portion_of_view('acl_test'::regclass);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

-- Scenario 3: Drop behavior
CREATE TABLE drop_test (id int PRIMARY KEY, value text, valid_from date, valid_until date);
SELECT sql_saga.add_era('drop_test', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_for_portion_of_view('drop_test'::regclass);
 add_for_portion_of_view 
-------------------------
 t
(1 row)

-- RESTRICT should fail because the view depends on the era
SAVEPOINT before_drop_era;
SELECT sql_saga.drop_era('drop_test'::regclass, 'valid', 'RESTRICT');
ERROR:  era valid is used by an updatable view
CONTEXT:  PL/pgSQL function sql_saga.drop_era(regclass,name,sql_saga.drop_behavior,boolean) line 81 at RAISE
ROLLBACK TO before_drop_era;
-- CASCADE should succeed and drop the view
SELECT sql_saga.drop_era('drop_test'::regclass, 'valid', 'CASCADE');
 drop_era 
----------
 t
(1 row)

-- The view should be gone from the metadata
TABLE sql_saga.updatable_view;
 view_schema | view_name | view_type | table_schema | table_name | era_name | trigger_name | current_func 
-------------+-----------+-----------+--------------+------------+----------+--------------+--------------
(0 rows)

-- DROP TABLE should now succeed
DROP TABLE drop_test;
-- Recreate for next test
CREATE TABLE drop_test (id int PRIMARY KEY, value text, valid_from date, valid_until date);
SELECT sql_saga.add_era('drop_test', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_for_portion_of_view('drop_test'::regclass);
 add_for_portion_of_view 
-------------------------
 t
(1 row)

-- Dropping table directly should fail due to dependent view
SAVEPOINT expect_fail;
DROP TABLE drop_test;
ERROR:  cannot drop table drop_test because other objects depend on it
DETAIL:  view drop_test__for_portion_of_valid depends on table drop_test
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
ROLLBACK TO SAVEPOINT expect_fail;
-- We must drop the view first, then the table
SELECT sql_saga.drop_for_portion_of_view('drop_test'::regclass);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

DROP TABLE drop_test;
-- Scenario 4: Table with no primary key (using temporal unique key as identifier)
CREATE TABLE no_pk_test (
    id integer,
    value text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('no_pk_test', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('no_pk_test', ARRAY['id']);
   add_unique_key    
---------------------
 no_pk_test_id_valid
(1 row)

SELECT sql_saga.add_for_portion_of_view('no_pk_test');
 add_for_portion_of_view 
-------------------------
 t
(1 row)

INSERT INTO no_pk_test (id, value, valid_from, valid_until) VALUES (1, 'initial', '2020-01-01', '2021-01-01');
TABLE no_pk_test;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | initial | 2020-01-01 | 2021-01-01
(1 row)

UPDATE no_pk_test__for_portion_of_valid SET value = 'updated', valid_from = '2020-06-01', valid_until = '2020-09-01' WHERE id = 1;
TABLE no_pk_test ORDER BY valid_from;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | initial | 2020-01-01 | 2020-06-01
  1 | updated | 2020-06-01 | 2020-09-01
  1 | initial | 2020-09-01 | 2021-01-01
(3 rows)

SELECT sql_saga.drop_for_portion_of_view('no_pk_test'::regclass);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

SELECT sql_saga.drop_unique_key('no_pk_test', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('no_pk_test');
 drop_era 
----------
 t
(1 row)

DROP TABLE no_pk_test;
-- Scenario 5: Table with non-B-tree-indexable column types
CREATE TABLE non_btree_test (
    id integer PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    pt point,
    value text,
    valid_from integer,
    valid_until integer
);
SELECT sql_saga.add_era('non_btree_test', 'valid_from', 'valid_until', 'p');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_for_portion_of_view('non_btree_test', 'p');
 add_for_portion_of_view 
-------------------------
 t
(1 row)

INSERT INTO non_btree_test (pt, value, valid_from, valid_until) VALUES ('(0, 0)', 'sample', 10, 41);
TABLE non_btree_test;
 id |  pt   | value  | valid_from | valid_until 
----+-------+--------+------------+-------------
  1 | (0,0) | sample |         10 |          41
(1 row)

-- Test with explicit WHERE clause on PK
SAVEPOINT before_btree_update;
UPDATE non_btree_test__for_portion_of_p SET value = 'simple', valid_from = 21, valid_until = 31 WHERE id = 1;
TABLE non_btree_test ORDER BY valid_from;
 id |  pt   | value  | valid_from | valid_until 
----+-------+--------+------------+-------------
  2 | (0,0) | sample |         10 |          21
  1 | (0,0) | simple |         21 |          31
  3 | (0,0) | sample |         31 |          41
(3 rows)

ROLLBACK TO before_btree_update;
-- Check that state was restored
TABLE non_btree_test;
 id |  pt   | value  | valid_from | valid_until 
----+-------+--------+------------+-------------
  1 | (0,0) | sample |         10 |          41
(1 row)

-- Test without explicit WHERE clause (legacy behavior)
UPDATE non_btree_test__for_portion_of_p SET value = 'simple', valid_from = 21, valid_until = 31;
TABLE non_btree_test ORDER BY valid_from;
 id |  pt   | value  | valid_from | valid_until 
----+-------+--------+------------+-------------
  4 | (0,0) | sample |         10 |          21
  1 | (0,0) | simple |         21 |          31
  5 | (0,0) | sample |         31 |          41
(3 rows)

SELECT sql_saga.drop_for_portion_of_view('non_btree_test', 'p');
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

SELECT sql_saga.drop_era('non_btree_test', 'p');
 drop_era 
----------
 t
(1 row)

DROP TABLE non_btree_test;
ROLLBACK;
DROP ROLE view_test_role;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
