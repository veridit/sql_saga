\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
-- Test the new declarative add_foreign_key function.
-- Scenario 1: Target is a NATURAL key
SAVEPOINT natural_key_target;
-- 1. Setup: Temporal parent and child tables, and a regular child table.
CREATE TABLE parent_natural(id int, valid_from int, valid_until int);
SELECT sql_saga.add_era('parent_natural'::regclass, 'valid_from', 'valid_until', 'p');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('parent_natural'::regclass, ARRAY['id']::name[], 'p', key_type => 'natural');
   add_unique_key    
---------------------
 parent_natural_id_p
(1 row)

CREATE TABLE temporal_child_natural(id int, parent_id int, valid_from int, valid_until int);
SELECT sql_saga.add_era('temporal_child_natural'::regclass, 'valid_from', 'valid_until', 'q');
 add_era 
---------
 t
(1 row)

CREATE TABLE regular_child_natural(id int, parent_id int);
\echo

\echo '--- Test: Declarative add_foreign_key for temporal-to-temporal (natural key) ---'
--- Test: Declarative add_foreign_key for temporal-to-temporal (natural key) ---
-- Use the new declarative function
SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'temporal_child_natural'::regclass,
    fk_column_names => ARRAY['parent_id'],
    pk_table_oid => 'parent_natural'::regclass,
    pk_column_names => ARRAY['id']
);
          add_foreign_key           
------------------------------------
 temporal_child_natural_parent_id_q
(1 row)

-- Verify it was created correctly
TABLE sql_saga.foreign_keys;
          foreign_key_name          |         type         | table_schema |       table_name       | column_names | fk_era_name |       fk_table_columns_snapshot       |   unique_key_name   | match_type | update_action | delete_action |              fk_insert_trigger               |              fk_update_trigger               | fk_check_constraint | fk_helper_function |              uk_update_trigger               |              uk_delete_trigger               
------------------------------------+----------------------+--------------+------------------------+--------------+-------------+---------------------------------------+---------------------+------------+---------------+---------------+----------------------------------------------+----------------------------------------------+---------------------+--------------------+----------------------------------------------+----------------------------------------------
 temporal_child_natural_parent_id_q | temporal_to_temporal | public       | temporal_child_natural | {parent_id}  | q           | {id,parent_id,valid_from,valid_until} | parent_natural_id_p | SIMPLE     | NO ACTION     | NO ACTION     | temporal_child_natural_parent_id_q_fk_insert | temporal_child_natural_parent_id_q_fk_update |                     |                    | temporal_child_natural_parent_id_q_uk_update | temporal_child_natural_parent_id_q_uk_delete
(1 row)

-- Cleanup
SELECT sql_saga.drop_foreign_key('temporal_child_natural'::regclass, ARRAY['parent_id']);
 drop_foreign_key 
------------------
 
(1 row)

\echo

\echo '--- Test: Declarative add_foreign_key for regular-to-temporal (natural key) ---'
--- Test: Declarative add_foreign_key for regular-to-temporal (natural key) ---
-- Use the new declarative function
SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'regular_child_natural'::regclass,
    fk_column_names => ARRAY['parent_id'],
    pk_table_oid => 'parent_natural'::regclass,
    pk_column_names => ARRAY['id']
);
           add_foreign_key            
--------------------------------------
 regular_child_natural_parent_id_fkey
(1 row)

-- Verify it was created correctly
TABLE sql_saga.foreign_keys;
           foreign_key_name           |        type         | table_schema |      table_name       | column_names | fk_era_name | fk_table_columns_snapshot |   unique_key_name   | match_type | update_action | delete_action | fk_insert_trigger | fk_update_trigger |          fk_check_constraint          |            fk_helper_function            |               uk_update_trigger                |               uk_delete_trigger                
--------------------------------------+---------------------+--------------+-----------------------+--------------+-------------+---------------------------+---------------------+------------+---------------+---------------+-------------------+-------------------+---------------------------------------+------------------------------------------+------------------------------------------------+------------------------------------------------
 regular_child_natural_parent_id_fkey | regular_to_temporal | public       | regular_child_natural | {parent_id}  |             | {id,parent_id}            | parent_natural_id_p | SIMPLE     | NO ACTION     | NO ACTION     |                   |                   | regular_child_natural_parent_id_check | public.parent_natural_id_exists(integer) | regular_child_natural_parent_id_fkey_uk_update | regular_child_natural_parent_id_fkey_uk_delete
(1 row)

-- Cleanup
SELECT sql_saga.drop_foreign_key('regular_child_natural'::regclass, ARRAY['parent_id']);
 drop_foreign_key 
------------------
 
(1 row)

RELEASE SAVEPOINT natural_key_target;
-- Scenario 2: Target is a PRIMARY key
SAVEPOINT primary_key_target;
-- 1. Setup: Temporal parent and child tables, and a regular child table.
CREATE TABLE parent_pk(
    id int,
    valid_from int,
    valid_until int,
    -- Note: A temporal primary key must include a temporal column
    PRIMARY KEY (id, valid_from) DEFERRABLE
);
SELECT sql_saga.add_era('parent_pk'::regclass, 'valid_from', 'valid_until', 'p');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('parent_pk'::regclass, ARRAY['id']::name[], 'p', key_type => 'primary');
 add_unique_key 
----------------
 parent_pk_id_p
(1 row)

CREATE TABLE temporal_child_pk(id int, parent_id int, valid_from int, valid_until int);
SELECT sql_saga.add_era('temporal_child_pk'::regclass, 'valid_from', 'valid_until', 'q');
 add_era 
---------
 t
(1 row)

CREATE TABLE regular_child_pk(id int, parent_id int);
\echo

\echo '--- Test: Declarative add_foreign_key for temporal-to-temporal (primary key) ---'
--- Test: Declarative add_foreign_key for temporal-to-temporal (primary key) ---
-- Use the new declarative function
SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'temporal_child_pk'::regclass,
    fk_column_names => ARRAY['parent_id'],
    pk_table_oid => 'parent_pk'::regclass,
    pk_column_names => ARRAY['id']
);
        add_foreign_key        
-------------------------------
 temporal_child_pk_parent_id_q
(1 row)

-- Verify it was created correctly
TABLE sql_saga.foreign_keys;
       foreign_key_name        |         type         | table_schema |    table_name     | column_names | fk_era_name |       fk_table_columns_snapshot       | unique_key_name | match_type | update_action | delete_action |            fk_insert_trigger            |            fk_update_trigger            | fk_check_constraint | fk_helper_function |            uk_update_trigger            |            uk_delete_trigger            
-------------------------------+----------------------+--------------+-------------------+--------------+-------------+---------------------------------------+-----------------+------------+---------------+---------------+-----------------------------------------+-----------------------------------------+---------------------+--------------------+-----------------------------------------+-----------------------------------------
 temporal_child_pk_parent_id_q | temporal_to_temporal | public       | temporal_child_pk | {parent_id}  | q           | {id,parent_id,valid_from,valid_until} | parent_pk_id_p  | SIMPLE     | NO ACTION     | NO ACTION     | temporal_child_pk_parent_id_q_fk_insert | temporal_child_pk_parent_id_q_fk_update |                     |                    | temporal_child_pk_parent_id_q_uk_update | temporal_child_pk_parent_id_q_uk_delete
(1 row)

-- Cleanup
SELECT sql_saga.drop_foreign_key('temporal_child_pk'::regclass, ARRAY['parent_id']);
 drop_foreign_key 
------------------
 
(1 row)

\echo

\echo '--- Test: Declarative add_foreign_key for regular-to-temporal (primary key) ---'
--- Test: Declarative add_foreign_key for regular-to-temporal (primary key) ---
-- Use the new declarative function
SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'regular_child_pk'::regclass,
    fk_column_names => ARRAY['parent_id'],
    pk_table_oid => 'parent_pk'::regclass,
    pk_column_names => ARRAY['id']
);
         add_foreign_key         
---------------------------------
 regular_child_pk_parent_id_fkey
(1 row)

-- Verify it was created correctly
TABLE sql_saga.foreign_keys;
        foreign_key_name         |        type         | table_schema |    table_name    | column_names | fk_era_name | fk_table_columns_snapshot | unique_key_name | match_type | update_action | delete_action | fk_insert_trigger | fk_update_trigger |       fk_check_constraint        |         fk_helper_function          |             uk_update_trigger             |             uk_delete_trigger             
---------------------------------+---------------------+--------------+------------------+--------------+-------------+---------------------------+-----------------+------------+---------------+---------------+-------------------+-------------------+----------------------------------+-------------------------------------+-------------------------------------------+-------------------------------------------
 regular_child_pk_parent_id_fkey | regular_to_temporal | public       | regular_child_pk | {parent_id}  |             | {id,parent_id}            | parent_pk_id_p  | SIMPLE     | NO ACTION     | NO ACTION     |                   |                   | regular_child_pk_parent_id_check | public.parent_pk_id_exists(integer) | regular_child_pk_parent_id_fkey_uk_update | regular_child_pk_parent_id_fkey_uk_delete
(1 row)

-- Cleanup
SELECT sql_saga.drop_foreign_key('regular_child_pk'::regclass, ARRAY['parent_id']);
 drop_foreign_key 
------------------
 
(1 row)

RELEASE SAVEPOINT primary_key_target;
-- Full cleanup
DROP TABLE parent_natural, temporal_child_natural, regular_child_natural;
DROP TABLE parent_pk, temporal_child_pk, regular_child_pk;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
