\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
SET client_min_messages TO NOTICE;
CREATE SCHEMA repro;
-- This is a minimal reproduction of the coalescing bug found in the Statbus
-- `304_test_complex_happy_path` test.
-- The bug: an adjacent timeline segment is not coalesced if the update only
-- changes ephemeral data and the entity is identified by a natural key.
-- 1. A minimal target table. The key is that `edit_comment` is ephemeral.
CREATE TABLE repro.establishment (
    id int GENERATED BY DEFAULT AS IDENTITY,
    org_nr text,
    name text,
    edit_comment text,
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_until date
);
SELECT sql_saga.add_era('repro.establishment', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "establishment_synchronize_temporal_columns_trigger" on table repro.establishment to synchronize columns: valid_from, valid_until
NOTICE:  sql_saga: Created GIST index "establishment_valid_range_gist_idx" on column repro.establishment.valid_range for temporal_merge performance
 add_era 
---------
 t
(1 row)

ALTER TABLE repro.establishment ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS);
SELECT sql_saga.add_unique_key('repro.establishment', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: Added constraints to table repro.establishment: ALTER COLUMN id SET NOT NULL
     add_unique_key     
------------------------
 establishment_id_valid
(1 row)

SELECT sql_saga.add_unique_key('repro.establishment', ARRAY['org_nr'], key_type => 'natural');
NOTICE:  sql_saga: Added constraints to table repro.establishment: ADD CONSTRAINT establishment_org_nr_valid_uniq UNIQUE (org_nr, valid_range WITHOUT OVERLAPS); ADD CONSTRAINT establishment_org_nr_valid_pk_consistency_excl EXCLUDE USING gist (org_nr WITH =, id WITH <>)
       add_unique_key       
----------------------------
 establishment_org_nr_valid
(1 row)

-- 2. The source table for data loading.
CREATE TEMP TABLE source_data (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    org_nr text,
    name text,
    edit_comment text,
    valid_from date,
    valid_until date
) ON COMMIT DROP;
-- 3. Load initial state for Q1.
-- The `id` column is absent from the source, forcing lookup purely by the natural key `org_nr`.
\echo '--- Loading Q1: Initial state ---'
--- Loading Q1: Initial state ---
INSERT INTO source_data (org_nr, name, edit_comment, valid_from, valid_until) VALUES
    ('111', 'Est A v1', 'Q1 Load', '2023-01-01', '2023-04-01');
-- The key of this test: CALL temporal_merge WITHOUT specifying identity columns.
-- The procedure should discover the primary key ('id') and natural key ('org_nr')
-- from the metadata.
CALL sql_saga.temporal_merge(
    target_table => 'repro.establishment',
    source_table => 'source_data',
    ephemeral_columns => ARRAY['edit_comment'],
    mode => 'MERGE_ENTITY_PATCH'
);
\echo '--- State after Q1 load ---'
--- State after Q1 load ---
SELECT id, org_nr, name, edit_comment, valid_from, valid_until
FROM repro.establishment ORDER BY id, valid_from;
 id | org_nr |   name   | edit_comment | valid_from | valid_until 
----+--------+----------+--------------+------------+-------------
  1 | 111    | Est A v1 | Q1 Load      | 2023-01-01 | 2023-04-01
(1 row)

-- 4. Load an update for Q2 with a real data change. This creates a new slice.
\echo '--- Loading Q2: Real data change ---'
--- Loading Q2: Real data change ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (org_nr, name, edit_comment, valid_from, valid_until) VALUES
    ('111', 'Est A v2', 'Q2 Load', '2023-04-01', '2023-07-01');
CALL sql_saga.temporal_merge(
    target_table => 'repro.establishment',
    source_table => 'source_data',
    ephemeral_columns => ARRAY['edit_comment'],
    mode => 'MERGE_ENTITY_PATCH'
);
\echo '--- State after Q2 load ---'
--- State after Q2 load ---
SELECT id, org_nr, name, edit_comment, valid_from, valid_until
FROM repro.establishment ORDER BY id, valid_from;
 id | org_nr |   name   | edit_comment | valid_from | valid_until 
----+--------+----------+--------------+------------+-------------
  1 | 111    | Est A v1 | Q1 Load      | 2023-01-01 | 2023-04-01
  1 | 111    | Est A v2 | Q2 Load      | 2023-04-01 | 2023-07-01
(2 rows)

-- 5. Load an update for Q3 with only an ephemeral change.
-- This SHOULD coalesce with the previous (Q2) slice.
\echo '--- Loading Q3: Ephemeral-only change (BUG REPRODUCED HERE) ---'
--- Loading Q3: Ephemeral-only change (BUG REPRODUCED HERE) ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (org_nr, name, edit_comment, valid_from, valid_until) VALUES
    ('111', 'Est A v2', 'Q3 Load', '2023-07-01', '2023-10-01');
CALL sql_saga.temporal_merge(
    target_table => 'repro.establishment',
    source_table => 'source_data',
    ephemeral_columns => ARRAY['edit_comment'],
    mode => 'MERGE_ENTITY_PATCH'
);
\echo '--- Final State ---'
--- Final State ---
-- The bug manifests as an extra, un-coalesced row for Q3.
SELECT id, org_nr, name, edit_comment, valid_from, valid_until
FROM repro.establishment ORDER BY id, valid_from;
 id | org_nr |   name   | edit_comment | valid_from | valid_until 
----+--------+----------+--------------+------------+-------------
  1 | 111    | Est A v1 | Q1 Load      | 2023-01-01 | 2023-04-01
  1 | 111    | Est A v2 | Q3 Load      | 2023-04-01 | 2023-10-01
(2 rows)

-- Expected output after Q3 load: 2 rows
-- 1. [2023-01-01, 2023-04-01) -> name: 'Est A v1'
-- 2. [2023-04-01, 2023-10-01) -> name: 'Est A v2' (coalesced from Q2 and Q3)
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
