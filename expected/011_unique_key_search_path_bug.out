\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
--
-- This script reproduces a bug where sql_saga's C-based FK triggers fail to
-- resolve the correct target table when the table name is ambiguous due to the
-- `search_path`.
--
-- Setup schema as superuser before starting transaction.
-- Drop if exists ensures a clean state if the previous run failed.
DROP SCHEMA IF EXISTS saga_bug_test CASCADE;
NOTICE:  schema "saga_bug_test" does not exist, skipping
CREATE SCHEMA saga_bug_test;
GRANT ALL ON SCHEMA saga_bug_test TO sql_saga_unprivileged_user;
BEGIN;
SET ROLE TO sql_saga_unprivileged_user;
SET client_min_messages TO NOTICE;
SET datestyle TO 'ISO, DMY';
-- Set a search_path that will cause ambiguity. Because `public` is first,
-- any unqualified table name that exists in both schemas will resolve to public.
SET search_path TO public, saga_bug_test;
-- 1. Setup Tables
-- Create the "impostor" table in the `public` schema.
CREATE TABLE public.legal_unit (
    id INT NOT NULL,
    valid_range DATERANGE NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    name TEXT,
    PRIMARY KEY (id, valid_range)
);
SELECT sql_saga.add_era('public.legal_unit', 'valid_range');
NOTICE:  sql_saga: Created trigger "legal_unit_synchronize_temporal_columns_trigger" on table legal_unit to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

-- On the impostor table, create a unique key with a non-interfering name.
SELECT sql_saga.add_unique_key('public.legal_unit', ARRAY['id'], 'valid', key_type => 'natural', unique_key_name => 'impostor_uk');
NOTICE:  sql_saga: altering table public.legal_unit to add constraints: ADD CONSTRAINT impostor_uk_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
 add_unique_key 
----------------
 impostor_uk
(1 row)

-- Create the real parent table in the `saga_bug_test` schema.
CREATE TABLE saga_bug_test.legal_unit (
    id INT NOT NULL,
    valid_range DATERANGE NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    name TEXT,
    PRIMARY KEY (id, valid_range)
);
SELECT sql_saga.add_era('saga_bug_test.legal_unit', 'valid_range');
NOTICE:  sql_saga: Created trigger "legal_unit_synchronize_temporal_columns_trigger" on table saga_bug_test.legal_unit to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

-- Use a different, non-interfering name for the unique key on the correct table.
SELECT sql_saga.add_unique_key('saga_bug_test.legal_unit', ARRAY['id'], 'valid', key_type => 'natural', unique_key_name => 'correct_table_uk');
NOTICE:  sql_saga: altering table saga_bug_test.legal_unit to add constraints: ADD CONSTRAINT correct_table_uk_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
  add_unique_key  
------------------
 correct_table_uk
(1 row)

-- Child table with a temporal FK
CREATE TABLE saga_bug_test.establishment (
    id INT NOT NULL,
    legal_unit_id INT, -- Temporal FK
    valid_range DATERANGE NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE NOT NULL,
    name TEXT,
    PRIMARY KEY (id, valid_range)
);
SELECT sql_saga.add_era('saga_bug_test.establishment', 'valid_range');
NOTICE:  sql_saga: Created trigger "establishment_synchronize_temporal_columns_trigger" on table establishment to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('saga_bug_test.establishment', ARRAY['id'], key_type => 'natural');
NOTICE:  sql_saga: altering table saga_bug_test.establishment to add constraints: ADD CONSTRAINT establishment_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
     add_unique_key     
------------------------
 establishment_id_valid
(1 row)

-- Add the temporal FK, correctly pointing to the unique key on the
-- `saga_bug_test.legal_unit` table.
-- If the bug exists, the C-trigger will get confused by the search_path and
-- check `public.legal_unit` anyway, causing a failure.
-- If the bug is fixed, the trigger will check the correct table, and the
-- INSERT will succeed.
SELECT sql_saga.add_temporal_foreign_key(
    'saga_bug_test.establishment',
    ARRAY['legal_unit_id'],
    'valid',
    'correct_table_uk' -- This UK is on saga_bug_test.legal_unit
);
NOTICE:  No compatible index found for foreign key on table establishment. Creating new index: CREATE INDEX establishment_legal_unit_id_valid_gist_idx ON establishment USING GIST (legal_unit_id, valid_range)
     add_temporal_foreign_key      
-----------------------------------
 establishment_legal_unit_id_valid
(1 row)

-- 2. Insert Data
-- Insert the parent record into the *correct* table.
INSERT INTO saga_bug_test.legal_unit (id, valid_from, valid_until, name) VALUES
(1, '2023-12-31', 'infinity', 'Parent LU');
-- This INSERT should succeed.
-- EXPECTED BEHAVIOR: INSERT succeeds because the parent record exists in `saga_bug_test.legal_unit`.
-- ACTUAL BEHAVIOR (BUG): INSERT fails with a foreign key violation. The trigger
-- incorrectly checks for a parent record in `public.legal_unit` (the impostor
-- table), which is empty.
INSERT INTO saga_bug_test.establishment (id, legal_unit_id, valid_from, valid_until, name) VALUES
(101, 1, '2024-01-01', '2025-01-01', 'Child EST');
-- If we get here, the bug is fixed.
SELECT 'BUG IS FIXED: INSERT into child table succeeded.' as status;
                      status                      
--------------------------------------------------
 BUG IS FIXED: INSERT into child table succeeded.
(1 row)

-- 3. Verify UPDATE trigger
-- Insert another parent record and a child record to be updated.
INSERT INTO saga_bug_test.legal_unit (id, valid_from, valid_until, name) VALUES
(2, '2023-12-31', 'infinity', 'Another Parent LU');
INSERT INTO saga_bug_test.establishment (id, legal_unit_id, valid_from, valid_until, name) VALUES
(102, 2, '2024-01-02', 'infinity', 'Child EST to be updated');
-- This UPDATE should succeed.
-- The `fk_update_check_c` trigger will fire. If the bug still existed, it
-- would incorrectly check `public.legal_unit` and fail. With the fix, it
-- checks the correct table and succeeds.
UPDATE saga_bug_test.establishment
SET legal_unit_id = 1
WHERE id = 102;
-- If we get here, the UPDATE trigger is also fixed.
SELECT 'BUG IS FIXED: UPDATE on child table succeeded.' as status;
                     status                     
------------------------------------------------
 BUG IS FIXED: UPDATE on child table succeeded.
(1 row)

ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
