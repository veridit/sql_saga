\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
SET ROLE TO sql_saga_unprivileged_user;
CREATE TABLE legal_unit (
  id INTEGER,
  valid_from date,
  valid_until date,
  name varchar NOT NULL
);
CREATE TABLE establishment (
  id INTEGER,
  valid_from date,
  valid_until date,
  legal_unit_id INTEGER NOT NULL,
  postal_place TEXT NOT NULL
);
CREATE TEMPORARY TABLE benchmark (
  timestamp TIMESTAMPTZ DEFAULT NOW(),
  event TEXT,
  row_count INTEGER
);
-- Record the start of the setup
INSERT INTO benchmark (event, row_count) VALUES ('BEGIN', 0);
-- Enable sql_saga constraints
SELECT sql_saga.add_era(table_oid => 'legal_unit', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_era(table_oid => 'establishment', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'legal_unit', column_names => ARRAY['id'], era_name => 'valid');
   add_unique_key    
---------------------
 legal_unit_id_valid
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'establishment', column_names => ARRAY['id'], era_name => 'valid');
     add_unique_key     
------------------------
 establishment_id_valid
(1 row)

SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'establishment',
    fk_column_names => ARRAY['legal_unit_id'],
    fk_era_name => 'valid',
    unique_key_name => 'legal_unit_id_valid'
);
          add_foreign_key          
-----------------------------------
 establishment_legal_unit_id_valid
(1 row)

-- Record after enabling constraints
INSERT INTO benchmark (event, row_count) VALUES ('Constraints enabled', 0);
-- Count number of different units before, during, and after.
SELECT 'legal_unit' AS type, COUNT(*) AS count FROM legal_unit
UNION ALL
SELECT 'establishment' AS type, COUNT(*) AS count FROM establishment;
     type      | count 
---------------+-------
 legal_unit    |     0
 establishment |     0
(2 rows)

-- With delayed constraints
INSERT INTO benchmark (event, row_count) VALUES ('INSERTs delayed constraints start', 0);
BEGIN;
SET CONSTRAINTS ALL DEFERRED;
DO $$
BEGIN
  FOR i IN 1..10000 LOOP
    INSERT INTO legal_unit (id, valid_from, valid_until, name) VALUES
    (i, '2015-01-01', 'infinity', 'Company ' || i);

    INSERT INTO establishment (id, valid_from, valid_until, legal_unit_id, postal_place) VALUES
    (i, '2015-01-01', 'infinity', i, 'Shop ' || i);
  END LOOP;
END; $$;
SET CONSTRAINTS ALL IMMEDIATE;
END;
INSERT INTO benchmark (event, row_count) VALUES ('INSERTs delayed constraints end', 10000);
SELECT 'legal_unit' AS type, COUNT(*) AS count FROM legal_unit
UNION ALL
SELECT 'establishment' AS type, COUNT(*) AS count FROM establishment;
     type      | count 
---------------+-------
 legal_unit    | 10000
 establishment | 10000
(2 rows)

-- With immediate constraints
INSERT INTO benchmark (event, row_count) VALUES ('INSERTs immediate constraints start', 0);
BEGIN;
DO $$
BEGIN
  FOR i IN 10001..20000 LOOP
    INSERT INTO legal_unit (id, valid_from, valid_until, name) VALUES
    (i, '2015-01-01', 'infinity', 'Company ' || i);

    INSERT INTO establishment (id, valid_from, valid_until, legal_unit_id, postal_place) VALUES
    (i, '2015-01-01', 'infinity', i, 'Shop ' || i);
  END LOOP;
END; $$;
END;
INSERT INTO benchmark (event, row_count) VALUES ('INSERTs immediate constraints end', 10000);
SELECT 'legal_unit' AS type, COUNT(*) AS count FROM legal_unit
UNION ALL
SELECT 'establishment' AS type, COUNT(*) AS count FROM establishment;
     type      | count 
---------------+-------
 legal_unit    | 20000
 establishment | 20000
(2 rows)

-- UPDATE with delayed commit checking
INSERT INTO benchmark (event, row_count) VALUES ('Update deferred constraints start', 0);
BEGIN;
  SET CONSTRAINTS ALL DEFERRED;
  UPDATE legal_unit SET valid_until = '2016-01-01' WHERE id <= 10000 AND valid_from = '2015-01-01';
  INSERT INTO legal_unit (id, valid_from, valid_until, name)
    SELECT id, '2016-01-01', 'infinity', name
    FROM legal_unit WHERE valid_until = '2016-01-01';
  SET CONSTRAINTS ALL IMMEDIATE;
END;
INSERT INTO benchmark (event, row_count) VALUES ('Update deferred constraints end', 20000);
SELECT 'legal_unit' AS type, COUNT(*) AS count FROM legal_unit
UNION ALL
SELECT 'establishment' AS type, COUNT(*) AS count FROM establishment;
     type      | count 
---------------+-------
 legal_unit    | 30000
 establishment | 20000
(2 rows)

-- Teardown sql_saga constraints
SELECT sql_saga.drop_foreign_key(table_oid => 'establishment', key_name => 'establishment_legal_unit_id_valid');
 drop_foreign_key 
------------------
 t
(1 row)

SELECT sql_saga.drop_unique_key(table_oid => 'legal_unit', key_name => 'legal_unit_id_valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_unique_key(table_oid => 'establishment', key_name => 'establishment_id_valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('legal_unit');
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_era('establishment');
 drop_era 
----------
 t
(1 row)

INSERT INTO benchmark (event, row_count) VALUES ('Constraints disabled', 0);
DROP TABLE establishment;
DROP TABLE legal_unit;
INSERT INTO benchmark (event, row_count) VALUES ('Tear down complete', 0);
-- Verify the benchmark events and row counts, but exclude volatile timing data
-- from the regression test output to ensure stability.
SELECT event, row_count FROM benchmark ORDER BY timestamp;
                event                | row_count 
-------------------------------------+-----------
 BEGIN                               |         0
 Constraints enabled                 |         0
 INSERTs delayed constraints start   |         0
 INSERTs delayed constraints end     |     10000
 INSERTs immediate constraints start |         0
 INSERTs immediate constraints end   |     10000
 Update deferred constraints start   |         0
 Update deferred constraints end     |     20000
 Constraints disabled                |         0
 Tear down complete                  |         0
(10 rows)

-- Capture performance metrics to a separate file for manual review.
-- This output is not part of the main regression test, so timing variations
-- will not cause the test to fail. You should commit this file to git.
\o expected/43_benchmark_performance.out
-- Calculate rows per second
CREATE OR REPLACE FUNCTION round_to_nearest_100(value FLOAT8) RETURNS FLOAT8 AS $$
BEGIN
    RETURN round(value / 100.0) * 100.0;
END;
$$ LANGUAGE plpgsql;
WITH benchmark_calculated AS (
  SELECT
    timestamp,
    event,
    row_count,
    ROUND(EXTRACT(EPOCH FROM (timestamp - FIRST_VALUE(timestamp) OVER (ORDER BY timestamp)))::NUMERIC, 0) AS time_from_start,
    ROUND(EXTRACT(EPOCH FROM (timestamp - LAG(timestamp) OVER (ORDER BY timestamp)))::NUMERIC, 0) AS time_from_prev,
    CASE
      WHEN EXTRACT(EPOCH FROM (timestamp - LAG(timestamp) OVER (ORDER BY timestamp))) = 0
      THEN NULL
      ELSE round_to_nearest_100(row_count::FLOAT8 / EXTRACT(EPOCH FROM (timestamp - LAG(timestamp) OVER (ORDER BY timestamp))))
    END AS rows_per_second
  FROM
    benchmark
)
SELECT
  event,
  row_count,
  time_from_start || ' secs' AS time_from_start,
  COALESCE(time_from_prev || ' secs', '') AS time_from_prev,
  row_count || ' rows' AS row_count,
  '~' || COALESCE(rows_per_second, 0)::TEXT || ' rows/s' AS rows_per_second
FROM
  benchmark_calculated
ORDER BY
  timestamp;
-- Stop redirecting output
\o
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
