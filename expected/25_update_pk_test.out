-- ON UPDATE RESTRICT
BEGIN;
SELECT enable_sql_saga_for_shifts_houses_and_rooms();
 enable_sql_saga_for_shifts_houses_and_rooms 
---------------------------------------------
 
(1 row)

INSERT INTO houses VALUES
  (1, 150000, '2015-01-01', '2016-01-01'),
  (1, 200000, '2016-01-01', '2017-01-01'),
  (2, 300000, '2015-01-01', '2016-01-01'),
  (3, 100000, '2014-01-01', '2015-01-01'),
  (3, 200000, '2015-01-01', 'infinity')
;
-- You can update a finite pk id with no references
UPDATE houses SET id = 4 WHERE id = 1;
UPDATE houses SET id = 1 WHERE id = 4;
-- You can update a finite pk range with no references
UPDATE houses SET valid_after = '1999-01-01', valid_to = '2000-01-01' WHERE id = 1 AND tstzrange(valid_after, valid_to) @> '2015-06-01'::timestamptz;
UPDATE houses SET valid_after = '2015-01-01', valid_to = '2016-01-01' WHERE id = 1 AND tstzrange(valid_after, valid_to) @> '1999-06-01'::timestamptz;
-- You can update a finite pk range that is partly covered elsewhere
INSERT INTO rooms VALUES (1, 1, '2016-01-01', '2016-06-01');
UPDATE houses SET valid_after = '2016-01-01', valid_to = '2016-09-01' WHERE id = 1 AND tstzrange(valid_after, valid_to) @> '2016-06-01'::timestamptz;
UPDATE houses SET valid_after = '2016-01-01', valid_to = '2017-01-01' WHERE id = 1 AND tstzrange(valid_after, valid_to) @> '2016-06-01'::timestamptz;
DELETE FROM rooms;
-- You can't update a finite pk id that is partly covered
SAVEPOINT test;
INSERT INTO rooms VALUES (1, 1, '2016-01-01', '2016-06-01');
-- The following UPDATE should fail.
UPDATE houses SET id = 4 WHERE id = 1;
ERROR:  update or delete on table "houses" violates foreign key constraint "rooms_house_id_valid" on table "rooms"
CONTEXT:  PL/pgSQL function sql_saga.validate_foreign_key_old_row(jsonb,boolean,name,regclass,text,text,text[],text,text,text,regclass,text,text,text[],text,text,text,sql_saga.fk_match_types,sql_saga.fk_actions,sql_saga.fk_actions) line 66 at RAISE
SQL statement "SELECT sql_saga.validate_foreign_key_old_row(jold, true /* is_update */, foreign_key_name, fk_table_oid, fk_schema_name, fk_table_name, fk_column_names, fk_era_name, fk_start_after_column_name, fk_stop_on_column_name, uk_table_oid, uk_schema_name, uk_table_name, uk_column_names, uk_era_name, uk_start_after_column_name, uk_stop_on_column_name, match_type, update_action, delete_action)"
PL/pgSQL function sql_saga.uk_update_check() line 40 at PERFORM
ROLLBACK TO SAVEPOINT test;
-- You can't update a finite pk range that is partly covered
SAVEPOINT test;
INSERT INTO rooms VALUES (1, 1, '2016-01-01', '2016-06-01');
-- The following UPDATE should fail.
UPDATE houses SET valid_after = '2017-01-01', valid_to = '2018-01-01' WHERE id = 1 AND tstzrange(valid_after, valid_to) @> '2016-06-01'::timestamptz;
ERROR:  update or delete on table "houses" violates foreign key constraint "rooms_house_id_valid" on table "rooms"
CONTEXT:  PL/pgSQL function sql_saga.validate_foreign_key_old_row(jsonb,boolean,name,regclass,text,text,text[],text,text,text,regclass,text,text,text[],text,text,text,sql_saga.fk_match_types,sql_saga.fk_actions,sql_saga.fk_actions) line 66 at RAISE
SQL statement "SELECT sql_saga.validate_foreign_key_old_row(jold, true /* is_update */, foreign_key_name, fk_table_oid, fk_schema_name, fk_table_name, fk_column_names, fk_era_name, fk_start_after_column_name, fk_stop_on_column_name, uk_table_oid, uk_schema_name, uk_table_name, uk_column_names, uk_era_name, uk_start_after_column_name, uk_stop_on_column_name, match_type, update_action, delete_action)"
PL/pgSQL function sql_saga.uk_update_check() line 40 at PERFORM
ROLLBACK TO SAVEPOINT test;
-- You can't update a finite pk id that is exactly covered
SAVEPOINT test;
-- The following INSERT should pass.
INSERT INTO rooms VALUES (1, 1, '2016-01-01', '2017-01-01');
-- The following UPDATE should fail.
UPDATE houses SET id = 4 WHERE id = 1;
ERROR:  update or delete on table "houses" violates foreign key constraint "rooms_house_id_valid" on table "rooms"
CONTEXT:  PL/pgSQL function sql_saga.validate_foreign_key_old_row(jsonb,boolean,name,regclass,text,text,text[],text,text,text,regclass,text,text,text[],text,text,text,sql_saga.fk_match_types,sql_saga.fk_actions,sql_saga.fk_actions) line 66 at RAISE
SQL statement "SELECT sql_saga.validate_foreign_key_old_row(jold, true /* is_update */, foreign_key_name, fk_table_oid, fk_schema_name, fk_table_name, fk_column_names, fk_era_name, fk_start_after_column_name, fk_stop_on_column_name, uk_table_oid, uk_schema_name, uk_table_name, uk_column_names, uk_era_name, uk_start_after_column_name, uk_stop_on_column_name, match_type, update_action, delete_action)"
PL/pgSQL function sql_saga.uk_update_check() line 40 at PERFORM
ROLLBACK TO SAVEPOINT test;
-- You can't update a finite pk range that is exactly covered
SAVEPOINT test;
-- The following INSERT should pass.
INSERT INTO rooms VALUES (1, 1, '2016-01-01', '2017-01-01');
-- The following UPDATE should fail.
UPDATE houses SET valid_after = '2017-01-01', valid_to = '2018-01-01' WHERE id = 1 AND tstzrange(valid_after, valid_to) @> '2016-06-01'::timestamptz;
ERROR:  update or delete on table "houses" violates foreign key constraint "rooms_house_id_valid" on table "rooms"
CONTEXT:  PL/pgSQL function sql_saga.validate_foreign_key_old_row(jsonb,boolean,name,regclass,text,text,text[],text,text,text,regclass,text,text,text[],text,text,text,sql_saga.fk_match_types,sql_saga.fk_actions,sql_saga.fk_actions) line 66 at RAISE
SQL statement "SELECT sql_saga.validate_foreign_key_old_row(jold, true /* is_update */, foreign_key_name, fk_table_oid, fk_schema_name, fk_table_name, fk_column_names, fk_era_name, fk_start_after_column_name, fk_stop_on_column_name, uk_table_oid, uk_schema_name, uk_table_name, uk_column_names, uk_era_name, uk_start_after_column_name, uk_stop_on_column_name, match_type, update_action, delete_action)"
PL/pgSQL function sql_saga.uk_update_check() line 40 at PERFORM
ROLLBACK TO SAVEPOINT test;
-- You can't update a finite pk id that is more than covered
SAVEPOINT test;
-- The following INSERT should pass.
INSERT INTO rooms VALUES (1, 1, '2015-06-01', '2017-01-01');
-- The following UPDATE should fail.
UPDATE houses SET id = 4 WHERE id = 1;
ERROR:  update or delete on table "houses" violates foreign key constraint "rooms_house_id_valid" on table "rooms"
CONTEXT:  PL/pgSQL function sql_saga.validate_foreign_key_old_row(jsonb,boolean,name,regclass,text,text,text[],text,text,text,regclass,text,text,text[],text,text,text,sql_saga.fk_match_types,sql_saga.fk_actions,sql_saga.fk_actions) line 66 at RAISE
SQL statement "SELECT sql_saga.validate_foreign_key_old_row(jold, true /* is_update */, foreign_key_name, fk_table_oid, fk_schema_name, fk_table_name, fk_column_names, fk_era_name, fk_start_after_column_name, fk_stop_on_column_name, uk_table_oid, uk_schema_name, uk_table_name, uk_column_names, uk_era_name, uk_start_after_column_name, uk_stop_on_column_name, match_type, update_action, delete_action)"
PL/pgSQL function sql_saga.uk_update_check() line 40 at PERFORM
ROLLBACK TO SAVEPOINT test;
-- You can't update a finite pk range that is more than covered
SAVEPOINT test;
-- The following INSERT should pass.
INSERT INTO rooms VALUES (1, 1, '2015-06-01', '2017-01-01');
-- The following UPDATE should fail.
UPDATE houses SET valid_after = '2017-01-01', valid_to = '2018-01-01' WHERE id = 1 AND tstzrange(valid_after, valid_to) @> '2016-06-01'::timestamptz;
ERROR:  update or delete on table "houses" violates foreign key constraint "rooms_house_id_valid" on table "rooms"
CONTEXT:  PL/pgSQL function sql_saga.validate_foreign_key_old_row(jsonb,boolean,name,regclass,text,text,text[],text,text,text,regclass,text,text,text[],text,text,text,sql_saga.fk_match_types,sql_saga.fk_actions,sql_saga.fk_actions) line 66 at RAISE
SQL statement "SELECT sql_saga.validate_foreign_key_old_row(jold, true /* is_update */, foreign_key_name, fk_table_oid, fk_schema_name, fk_table_name, fk_column_names, fk_era_name, fk_start_after_column_name, fk_stop_on_column_name, uk_table_oid, uk_schema_name, uk_table_name, uk_column_names, uk_era_name, uk_start_after_column_name, uk_stop_on_column_name, match_type, update_action, delete_action)"
PL/pgSQL function sql_saga.uk_update_check() line 40 at PERFORM
ROLLBACK TO SAVEPOINT test;
-- You can update an infinite pk id with no references
SAVEPOINT test;
INSERT INTO rooms VALUES (1, 3, '2014-06-01', '2015-01-01');
UPDATE houses SET id = 4 WHERE id = 3 and tstzrange(valid_after, valid_to) @> '2016-01-01'::timestamptz;
UPDATE houses SET id = 3 WHERE id = 4;
ROLLBACK TO SAVEPOINT test;
-- You can update an infinite pk range with no references
SAVEPOINT test;
INSERT INTO rooms VALUES (1, 3, '2014-06-01', '2015-01-01');
UPDATE houses SET valid_after = '2017-01-01', valid_to = '2018-01-01' WHERE id = 3 and tstzrange(valid_after, valid_to) @> '2016-01-01'::timestamptz;
UPDATE houses SET valid_after = '2015-01-01', valid_to = 'infinity' WHERE id = 3 and tstzrange(valid_after, valid_to) @> '2017-06-01'::timestamptz;
ROLLBACK TO SAVEPOINT test;
-- You can't update an infinite pk id that is partly covered
SAVEPOINT test;
INSERT INTO rooms VALUES (1, 3, '2016-01-01', '2017-01-01');
UPDATE houses SET id = 4 WHERE id = 3 and tstzrange(valid_after, valid_to) @> '2016-01-01'::timestamptz;
ERROR:  update or delete on table "houses" violates foreign key constraint "rooms_house_id_valid" on table "rooms"
CONTEXT:  PL/pgSQL function sql_saga.validate_foreign_key_old_row(jsonb,boolean,name,regclass,text,text,text[],text,text,text,regclass,text,text,text[],text,text,text,sql_saga.fk_match_types,sql_saga.fk_actions,sql_saga.fk_actions) line 66 at RAISE
SQL statement "SELECT sql_saga.validate_foreign_key_old_row(jold, true /* is_update */, foreign_key_name, fk_table_oid, fk_schema_name, fk_table_name, fk_column_names, fk_era_name, fk_start_after_column_name, fk_stop_on_column_name, uk_table_oid, uk_schema_name, uk_table_name, uk_column_names, uk_era_name, uk_start_after_column_name, uk_stop_on_column_name, match_type, update_action, delete_action)"
PL/pgSQL function sql_saga.uk_update_check() line 40 at PERFORM
ROLLBACK TO SAVEPOINT test;
-- You can't update an infinite pk range that is partly covered
SAVEPOINT test;
-- The following INSERT should pass.
INSERT INTO rooms VALUES (1, 3, '2016-01-01', '2017-01-01');
-- The following UPDATE should fail.
UPDATE houses SET valid_after = '2017-01-01', valid_to = '2018-01-01' WHERE id = 3 and tstzrange(valid_after, valid_to) @> '2016-01-01'::timestamptz;
ERROR:  update or delete on table "houses" violates foreign key constraint "rooms_house_id_valid" on table "rooms"
CONTEXT:  PL/pgSQL function sql_saga.validate_foreign_key_old_row(jsonb,boolean,name,regclass,text,text,text[],text,text,text,regclass,text,text,text[],text,text,text,sql_saga.fk_match_types,sql_saga.fk_actions,sql_saga.fk_actions) line 66 at RAISE
SQL statement "SELECT sql_saga.validate_foreign_key_old_row(jold, true /* is_update */, foreign_key_name, fk_table_oid, fk_schema_name, fk_table_name, fk_column_names, fk_era_name, fk_start_after_column_name, fk_stop_on_column_name, uk_table_oid, uk_schema_name, uk_table_name, uk_column_names, uk_era_name, uk_start_after_column_name, uk_stop_on_column_name, match_type, update_action, delete_action)"
PL/pgSQL function sql_saga.uk_update_check() line 40 at PERFORM
ROLLBACK TO SAVEPOINT test;
-- You can't update an infinite pk id that is exactly covered
SAVEPOINT test;
INSERT INTO rooms VALUES (1, 3, '2015-01-01', 'infinity');
UPDATE houses SET id = 4 WHERE id = 3 and tstzrange(valid_after, valid_to) @> '2016-01-01'::timestamptz;
ERROR:  update or delete on table "houses" violates foreign key constraint "rooms_house_id_valid" on table "rooms"
CONTEXT:  PL/pgSQL function sql_saga.validate_foreign_key_old_row(jsonb,boolean,name,regclass,text,text,text[],text,text,text,regclass,text,text,text[],text,text,text,sql_saga.fk_match_types,sql_saga.fk_actions,sql_saga.fk_actions) line 66 at RAISE
SQL statement "SELECT sql_saga.validate_foreign_key_old_row(jold, true /* is_update */, foreign_key_name, fk_table_oid, fk_schema_name, fk_table_name, fk_column_names, fk_era_name, fk_start_after_column_name, fk_stop_on_column_name, uk_table_oid, uk_schema_name, uk_table_name, uk_column_names, uk_era_name, uk_start_after_column_name, uk_stop_on_column_name, match_type, update_action, delete_action)"
PL/pgSQL function sql_saga.uk_update_check() line 40 at PERFORM
ROLLBACK TO SAVEPOINT test;
-- You can't update an infinite pk range that is exactly covered
SAVEPOINT test;
INSERT INTO rooms VALUES (1, 3, '2015-01-01', 'infinity');
UPDATE  houses SET valid_after = '2017-01-01', valid_to = '2018-01-01' WHERE id = 3 and tstzrange(valid_after, valid_to) @> '2016-01-01'::timestamptz;
ERROR:  update or delete on table "houses" violates foreign key constraint "rooms_house_id_valid" on table "rooms"
CONTEXT:  PL/pgSQL function sql_saga.validate_foreign_key_old_row(jsonb,boolean,name,regclass,text,text,text[],text,text,text,regclass,text,text,text[],text,text,text,sql_saga.fk_match_types,sql_saga.fk_actions,sql_saga.fk_actions) line 66 at RAISE
SQL statement "SELECT sql_saga.validate_foreign_key_old_row(jold, true /* is_update */, foreign_key_name, fk_table_oid, fk_schema_name, fk_table_name, fk_column_names, fk_era_name, fk_start_after_column_name, fk_stop_on_column_name, uk_table_oid, uk_schema_name, uk_table_name, uk_column_names, uk_era_name, uk_start_after_column_name, uk_stop_on_column_name, match_type, update_action, delete_action)"
PL/pgSQL function sql_saga.uk_update_check() line 40 at PERFORM
ROLLBACK TO SAVEPOINT test;
-- You can't update an infinite pk id that is more than covered
SAVEPOINT test;
INSERT INTO rooms VALUES (1, 3, '2014-06-01', 'infinity');
UPDATE houses SET id = 4 WHERE id = 3 and tstzrange(valid_after, valid_to) @> '2016-01-01'::timestamptz;
ERROR:  update or delete on table "houses" violates foreign key constraint "rooms_house_id_valid" on table "rooms"
CONTEXT:  PL/pgSQL function sql_saga.validate_foreign_key_old_row(jsonb,boolean,name,regclass,text,text,text[],text,text,text,regclass,text,text,text[],text,text,text,sql_saga.fk_match_types,sql_saga.fk_actions,sql_saga.fk_actions) line 66 at RAISE
SQL statement "SELECT sql_saga.validate_foreign_key_old_row(jold, true /* is_update */, foreign_key_name, fk_table_oid, fk_schema_name, fk_table_name, fk_column_names, fk_era_name, fk_start_after_column_name, fk_stop_on_column_name, uk_table_oid, uk_schema_name, uk_table_name, uk_column_names, uk_era_name, uk_start_after_column_name, uk_stop_on_column_name, match_type, update_action, delete_action)"
PL/pgSQL function sql_saga.uk_update_check() line 40 at PERFORM
ROLLBACK TO SAVEPOINT test;
-- You can't update an infinite pk range that is more than covered
SAVEPOINT test;
INSERT INTO rooms VALUES (1, 3, '2014-06-01', 'infinity');
UPDATE houses SET valid_after = '2017-01-01', valid_to = '2018-01-01' WHERE id = 3 and tstzrange(valid_after, valid_to) @> '2016-01-01'::timestamptz;
ERROR:  update or delete on table "houses" violates foreign key constraint "rooms_house_id_valid" on table "rooms"
CONTEXT:  PL/pgSQL function sql_saga.validate_foreign_key_old_row(jsonb,boolean,name,regclass,text,text,text[],text,text,text,regclass,text,text,text[],text,text,text,sql_saga.fk_match_types,sql_saga.fk_actions,sql_saga.fk_actions) line 66 at RAISE
SQL statement "SELECT sql_saga.validate_foreign_key_old_row(jold, true /* is_update */, foreign_key_name, fk_table_oid, fk_schema_name, fk_table_name, fk_column_names, fk_era_name, fk_start_after_column_name, fk_stop_on_column_name, uk_table_oid, uk_schema_name, uk_table_name, uk_column_names, uk_era_name, uk_start_after_column_name, uk_stop_on_column_name, match_type, update_action, delete_action)"
PL/pgSQL function sql_saga.uk_update_check() line 40 at PERFORM
ROLLBACK TO SAVEPOINT test;
-- ON UPDATE NOACTION
-- TODO
-- ON UPDATE CASCADE
-- TODO
-- ON UPDATE SET NULL
-- TODO
-- ON UPDATE SET DEFAULT
-- TODO
COMMIT;
DELETE FROM rooms;
DELETE FROM houses;
SELECT disable_sql_saga_for_shifts_houses_and_rooms();
 disable_sql_saga_for_shifts_houses_and_rooms 
----------------------------------------------
 
(1 row)

