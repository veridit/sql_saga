\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 1: Demonstrate automatic discovery of natural keys for lookups'
Scenario 1: Demonstrate automatic discovery of natural keys for lookups
\echo 'temporal_merge can automatically discover registered natural keys if they are'
temporal_merge can automatically discover registered natural keys if they are
\echo 'not explicitly provided. This test demonstrates that both automatic discovery'
not explicitly provided. This test demonstrates that both automatic discovery
\echo 'and explicit provision of natural keys result in the correct behavior.'
and explicit provision of natural keys result in the correct behavior.
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
-- 1. Setup
CREATE SCHEMA IF NOT EXISTS tmrb;
DROP TABLE IF EXISTS tmrb.my_stat_for_unit;
NOTICE:  table "my_stat_for_unit" does not exist, skipping
CREATE TABLE tmrb.my_stat_for_unit (
    id SERIAL,
    legal_unit_id int NOT NULL,
    value_int int,
    valid_from date NOT NULL,
    valid_until date,
    PRIMARY KEY (id, valid_from)
);
SELECT sql_saga.add_era('tmrb.my_stat_for_unit'::regclass);
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmrb.my_stat_for_unit'::regclass, '{id}');
NOTICE:  sql_saga: altering table tmrb.my_stat_for_unit to add constraints: ADD CONSTRAINT my_stat_for_unit_id_valid_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT my_stat_for_unit_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
      add_unique_key       
---------------------------
 my_stat_for_unit_id_valid
(1 row)

SELECT sql_saga.add_unique_key('tmrb.my_stat_for_unit'::regclass, '{legal_unit_id}');
NOTICE:  sql_saga: altering table tmrb.my_stat_for_unit to add constraints: ADD CONSTRAINT my_stat_for_unit_legal_unit_id_valid_uniq UNIQUE (legal_unit_id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT my_stat_for_unit_legal_unit_id_valid_excl EXCLUDE USING gist (legal_unit_id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
            add_unique_key            
--------------------------------------
 my_stat_for_unit_legal_unit_id_valid
(1 row)

-- 2. First Import: Create initial record.
CREATE TEMP TABLE source_data_1 (
    row_id int, founding_row_id int, id int, legal_unit_id int, value_int int, valid_from date, valid_until date
) ON COMMIT DROP;
INSERT INTO source_data_1 VALUES
(1, 1, NULL, 100, 4, '2023-01-01', '2023-04-01');
\echo '--- Source Data for First Import ---'
--- Source Data for First Import ---
TABLE source_data_1;
 row_id | founding_row_id | id | legal_unit_id | value_int | valid_from | valid_until 
--------+-----------------+----+---------------+-----------+------------+-------------
      1 |               1 |    |           100 |         4 | 2023-01-01 | 2023-04-01
(1 row)

CALL sql_saga.temporal_merge(
    target_table => 'tmrb.my_stat_for_unit',
    source_table => 'source_data_1',
    identity_columns => ARRAY['id'],
    natural_identity_columns => NULL,
    ephemeral_columns => NULL,
    founding_id_column => 'founding_row_id'
);
\echo '--- Target Table after First Import (Expect 1 row) ---'
--- Target Table after First Import (Expect 1 row) ---
SELECT id, legal_unit_id, value_int, valid_from, valid_until FROM tmrb.my_stat_for_unit;
 id | legal_unit_id | value_int | valid_from | valid_until 
----+---------------+-----------+------------+-------------
  1 |           100 |         4 | 2023-01-01 | 2023-04-01
(1 row)

-- 3. Second Import: Consecutive period, SAME value.
CREATE TEMP TABLE source_data_2 (
    row_id int, founding_row_id int, id int, legal_unit_id int, value_int int, valid_from date, valid_until date
) ON COMMIT DROP;
INSERT INTO source_data_2 VALUES
(2, 1, NULL, 100, 4, '2023-04-01', '2023-07-01');
\echo '--- Case 1a: Correct Usage (automatic discovery of natural key) ---'
--- Case 1a: Correct Usage (automatic discovery of natural key) ---
\echo '--- Source Data for Second Import ---'
--- Source Data for Second Import ---
TABLE source_data_2;
 row_id | founding_row_id | id | legal_unit_id | value_int | valid_from | valid_until 
--------+-----------------+----+---------------+-----------+------------+-------------
      2 |               1 |    |           100 |         4 | 2023-04-01 | 2023-07-01
(1 row)

-- This call correctly finds the existing entity by automatically discovering and
-- using the natural key on `legal_unit_id`. Because the data is the same,
-- it extends the timeline of the existing record.
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.my_stat_for_unit',
    source_table => 'source_data_2',
    identity_columns => ARRAY['id'],
    natural_identity_columns => NULL,
    ephemeral_columns => NULL,
    founding_id_column => 'founding_row_id'
);
\echo '--- Target Table after Second Import (CORRECT: 1 extended row due to auto-discovery) ---'
--- Target Table after Second Import (CORRECT: 1 extended row due to auto-discovery) ---
SELECT id, legal_unit_id, value_int, valid_from, valid_until FROM tmrb.my_stat_for_unit ORDER BY id, valid_from;
 id | legal_unit_id | value_int | valid_from | valid_until 
----+---------------+-----------+------------+-------------
  1 |           100 |         4 | 2023-01-01 | 2023-07-01
(1 row)

-- 4. Reset and demonstrate correct usage.
TRUNCATE tmrb.my_stat_for_unit;
TRUNCATE source_data_1;
INSERT INTO source_data_1 VALUES (1, 1, NULL, 100, 4, '2023-01-01', '2023-04-01');
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.my_stat_for_unit',
    source_table => 'source_data_1',
    identity_columns => '{id}',
    natural_identity_columns => NULL,
    ephemeral_columns => NULL,
    founding_id_column => 'founding_row_id'
);
\echo '--- Case 1b: Correct Usage (explicitly providing natural key) ---'
--- Case 1b: Correct Usage (explicitly providing natural key) ---
-- This call also correctly finds the existing entity, this time because the natural
-- key is provided explicitly. The result is the same.
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.my_stat_for_unit',
    source_table => 'source_data_2',
    identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['legal_unit_id'],
    ephemeral_columns => NULL,
    founding_id_column => 'founding_row_id'
);
\echo '--- Target Table after Second Import (CORRECT: 1 extended row) ---'
--- Target Table after Second Import (CORRECT: 1 extended row) ---
SELECT id, legal_unit_id, value_int, valid_from, valid_until FROM tmrb.my_stat_for_unit;
 id | legal_unit_id | value_int | valid_from | valid_until 
----+---------------+-----------+------------+-------------
  2 |           100 |         4 | 2023-01-01 | 2023-07-01
(1 row)

\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 2: Demonstrate correct Primary Key usage for SCD Type 2'
Scenario 2: Demonstrate correct Primary Key usage for SCD Type 2
\echo 'An SCD Type 2 update requires a composite primary key that includes a'
An SCD Type 2 update requires a composite primary key that includes a
\echo 'temporal column (e.g., PRIMARY KEY (id, valid_from)). This allows multiple'
temporal column (e.g., PRIMARY KEY (id, valid_from)). This allows multiple
\echo 'historical versions of an entity to be stored. This test demonstrates'
historical versions of an entity to be stored. This test demonstrates
\echo 'the failure with an incorrect PK and the success with a correct one.'
the failure with an incorrect PK and the success with a correct one.
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
-- 1. Setup with incorrect schema
DROP TABLE IF EXISTS tmrb.my_stat_for_unit_bad_pk;
NOTICE:  table "my_stat_for_unit_bad_pk" does not exist, skipping
CREATE TABLE tmrb.my_stat_for_unit_bad_pk (
    id SERIAL PRIMARY KEY, -- Incorrect: PK should include a temporal column
    legal_unit_id int NOT NULL,
    value_int int,
    valid_from date NOT NULL,
    valid_until date
);
SELECT sql_saga.add_era('tmrb.my_stat_for_unit_bad_pk'::regclass);
 add_era 
---------
 t
(1 row)

-- 2. First Import
TRUNCATE source_data_1;
INSERT INTO source_data_1 VALUES (1, 1, NULL, 100, 4, '2023-01-01', '2023-04-01');
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.my_stat_for_unit_bad_pk',
    source_table => 'source_data_1',
    identity_columns => '{id}',
    natural_identity_columns => NULL,
    ephemeral_columns => NULL,
    update_source_with_identity => true
);
\echo '--- Target after first import ---'
--- Target after first import ---
TABLE tmrb.my_stat_for_unit_bad_pk;
 id | legal_unit_id | value_int | valid_from | valid_until 
----+---------------+-----------+------------+-------------
  1 |           100 |         4 | 2023-01-01 | 2023-04-01
(1 row)

\echo '--- Source after ID back-fill ---'
--- Source after ID back-fill ---
TABLE source_data_1;
 row_id | founding_row_id | id | legal_unit_id | value_int | valid_from | valid_until 
--------+-----------------+----+---------------+-----------+------------+-------------
      1 |               1 |  1 |           100 |         4 | 2023-01-01 | 2023-04-01
(1 row)

-- 3. Second Import with changed data.
TRUNCATE source_data_2;
INSERT INTO source_data_2 VALUES (2, 1, 1, 100, 5, '2023-04-01', '2023-07-01');
\echo '--- Case 2a: Incorrect Schema (PK on id only) ---'
--- Case 2a: Incorrect Schema (PK on id only) ---
\echo '--- Source for second import (with changed value and known ID) ---'
--- Source for second import (with changed value and known ID) ---
TABLE source_data_2;
 row_id | founding_row_id | id | legal_unit_id | value_int | valid_from | valid_until 
--------+-----------------+----+---------------+-----------+------------+-------------
      2 |               1 |  1 |           100 |         5 | 2023-04-01 | 2023-07-01
(1 row)

-- This call will fail because it tries to INSERT a new history slice with id=1,
-- which violates the PRIMARY KEY constraint.
SET client_min_messages TO NOTICE;
DO $$
BEGIN
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.my_stat_for_unit_bad_pk',
    source_table => 'source_data_2',
    identity_columns => ARRAY['id'],
    natural_identity_columns => NULL,
    ephemeral_columns => NULL
);
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Caught expected error: %', SQLERRM;
END;
$$;
NOTICE:  Caught expected error: duplicate key value violates unique constraint "my_stat_for_unit_bad_pk_pkey"
RESET client_min_messages;
-- 4. Setup with correct schema
DROP TABLE IF EXISTS tmrb.my_stat_for_unit_good_pk;
NOTICE:  table "my_stat_for_unit_good_pk" does not exist, skipping
CREATE TABLE tmrb.my_stat_for_unit_good_pk (
    id SERIAL NOT NULL,
    legal_unit_id int NOT NULL,
    value_int int,
    valid_from date NOT NULL,
    valid_until date,
    PRIMARY KEY (id, valid_from) -- Correct: Composite PK
);
SELECT sql_saga.add_era('tmrb.my_stat_for_unit_good_pk'::regclass);
 add_era 
---------
 t
(1 row)

TRUNCATE source_data_1;
INSERT INTO source_data_1 VALUES (1, 1, NULL, 100, 4, '2023-01-01', '2023-04-01');
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.my_stat_for_unit_good_pk',
    source_table => 'source_data_1',
    identity_columns => '{id}',
    natural_identity_columns => NULL,
    ephemeral_columns => NULL,
    update_source_with_identity => true
);
\echo '--- Case 2b: Correct Schema (Composite PK) ---'
--- Case 2b: Correct Schema (Composite PK) ---
TRUNCATE source_data_2;
INSERT INTO source_data_2 VALUES (2, 1, 1, 100, 5, '2023-04-01', '2023-07-01');
\echo '--- Source for second import ---'
--- Source for second import ---
TABLE source_data_2;
 row_id | founding_row_id | id | legal_unit_id | value_int | valid_from | valid_until 
--------+-----------------+----+---------------+-----------+------------+-------------
      2 |               1 |  1 |           100 |         5 | 2023-04-01 | 2023-07-01
(1 row)

\echo '--- Target for second import ---'
--- Target for second import ---
TABLE tmrb.my_stat_for_unit_good_pk;
 id | legal_unit_id | value_int | valid_from | valid_until 
----+---------------+-----------+------------+-------------
  1 |           100 |         4 | 2023-01-01 | 2023-04-01
(1 row)

CALL sql_saga.temporal_merge(
    target_table => 'tmrb.my_stat_for_unit_good_pk',
    source_table => 'source_data_2',
    identity_columns => ARRAY['id'],
    natural_identity_columns => NULL,
    ephemeral_columns => NULL
);
\echo '--- Planner output for Case 2b ---'
--- Planner output for Case 2b ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | row_ids | operation | update_effect | corr_ent | new_ent | entity_ids | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                  data                  | feedback | trace 
-------------+---------+-----------+---------------+----------+---------+------------+--------------+--------------+----------------+-----------------+----------------+-----------------+----------------------------------------+----------+-------
           1 | {2}     | INSERT    |               | 2        | f       | {"id": 1}  |              |              |                |                 | 2023-04-01     | 2023-07-01      | {"value_int": 5, "legal_unit_id": 100} |          | 
(1 row)

\echo '--- Target after second import (CORRECT: 2 historical rows for id=1) ---'
--- Target after second import (CORRECT: 2 historical rows for id=1) ---
SELECT * FROM tmrb.my_stat_for_unit_good_pk ORDER BY id, valid_from;
 id | legal_unit_id | value_int | valid_from | valid_until 
----+---------------+-----------+------------+-------------
  1 |           100 |         4 | 2023-01-01 | 2023-04-01
  1 |           100 |         5 | 2023-04-01 | 2023-07-01
(2 rows)

\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 3: Demonstrate correct usage of GENERATED ... AS IDENTITY'
Scenario 3: Demonstrate correct usage of GENERATED ... AS IDENTITY
\echo '`GENERATED ALWAYS AS IDENTITY` is incompatible with SCD Type 2 history because'
`GENERATED ALWAYS AS IDENTITY` is incompatible with SCD Type 2 history because
\echo 'it prevents re-inserting a stable ID for a new history slice. The correct'
it prevents re-inserting a stable ID for a new history slice. The correct
\echo 'pattern is `GENERATED BY DEFAULT AS IDENTITY` with a composite primary key.'
pattern is `GENERATED BY DEFAULT AS IDENTITY` with a composite primary key.
\echo 'This test demonstrates both the failure and the correct pattern.'
This test demonstrates both the failure and the correct pattern.
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
-- 1. Setup with incorrect `GENERATED ALWAYS` schema
DROP TABLE IF EXISTS tmrb.my_stat_for_unit_gen_always;
NOTICE:  table "my_stat_for_unit_gen_always" does not exist, skipping
CREATE TABLE tmrb.my_stat_for_unit_gen_always (
    id int GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    legal_unit_id int NOT NULL,
    value_int int,
    valid_from date NOT NULL,
    valid_until date
);
SELECT sql_saga.add_era('tmrb.my_stat_for_unit_gen_always'::regclass);
 add_era 
---------
 t
(1 row)

-- 2. Attempt to import, which will fail
TRUNCATE source_data_1;
INSERT INTO source_data_1 VALUES (1, 1, NULL, 100, 4, '2023-01-01', '2023-04-01');
\echo '--- Source Data for Import ---'
--- Source Data for Import ---
TABLE source_data_1;
 row_id | founding_row_id | id | legal_unit_id | value_int | valid_from | valid_until 
--------+-----------------+----+---------------+-----------+------------+-------------
      1 |               1 |    |           100 |         4 | 2023-01-01 | 2023-04-01
(1 row)

\echo '--- Calling temporal_merge (This will fail because of GENERATED ALWAYS) ---'
--- Calling temporal_merge (This will fail because of GENERATED ALWAYS) ---
DO $$
BEGIN
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.my_stat_for_unit_gen_always',
    source_table => 'source_data_1',
    identity_columns => ARRAY['id'],
    natural_identity_columns => NULL,
    ephemeral_columns => NULL,
    founding_id_column => 'founding_row_id'
);
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Caught expected error: %', SQLERRM;
END;
$$;
NOTICE:  Caught expected error: cannot insert a non-DEFAULT value into column "id"
-- 3. Setup with correct `GENERATED BY DEFAULT` schema
DROP TABLE IF EXISTS tmrb.my_stat_for_unit_gen_default;
NOTICE:  table "my_stat_for_unit_gen_default" does not exist, skipping
CREATE TABLE tmrb.my_stat_for_unit_gen_default (
    id int GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    legal_unit_id int NOT NULL,
    value_int int,
    valid_from date NOT NULL,
    valid_until date,
    PRIMARY KEY (id, valid_from)
);
SELECT sql_saga.add_era('tmrb.my_stat_for_unit_gen_default'::regclass);
 add_era 
---------
 t
(1 row)

-- 4. Import new entity, which succeeds
TRUNCATE source_data_1;
INSERT INTO source_data_1 VALUES (1, 1, NULL, 100, 4, '2023-01-01', '2023-04-01');
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.my_stat_for_unit_gen_default',
    source_table => 'source_data_1',
    identity_columns => ARRAY['id'],
    natural_identity_columns => NULL,
    ephemeral_columns => NULL,
    update_source_with_identity => true
);
\echo '--- Target after first import ---'
--- Target after first import ---
TABLE tmrb.my_stat_for_unit_gen_default;
 id | legal_unit_id | value_int | valid_from | valid_until 
----+---------------+-----------+------------+-------------
  1 |           100 |         4 | 2023-01-01 | 2023-04-01
(1 row)

-- 5. Import an update for the same entity, which also succeeds
TRUNCATE source_data_2;
INSERT INTO source_data_2 VALUES (2, 1, 1, 100, 5, '2023-04-01', '2023-07-01');
\echo '--- Source for second import ---'
--- Source for second import ---
TABLE source_data_2;
 row_id | founding_row_id | id | legal_unit_id | value_int | valid_from | valid_until 
--------+-----------------+----+---------------+-----------+------------+-------------
      2 |               1 |  1 |           100 |         5 | 2023-04-01 | 2023-07-01
(1 row)

CALL sql_saga.temporal_merge(
    target_table => 'tmrb.my_stat_for_unit_gen_default',
    source_table => 'source_data_2',
    identity_columns => ARRAY['id'],
    natural_identity_columns => NULL,
    ephemeral_columns => NULL
);
\echo '--- Target after second import (CORRECT: 2 historical rows for id=1) ---'
--- Target after second import (CORRECT: 2 historical rows for id=1) ---
SELECT * FROM tmrb.my_stat_for_unit_gen_default ORDER BY id, valid_from;
 id | legal_unit_id | value_int | valid_from | valid_until 
----+---------------+-----------+------------+-------------
  1 |           100 |         4 | 2023-01-01 | 2023-04-01
  1 |           100 |         5 | 2023-04-01 | 2023-07-01
(2 rows)

\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 4: Reproduce NOT NULL violation on UPDATE (Bug #1)'
Scenario 4: Reproduce NOT NULL violation on UPDATE (Bug #1)
\echo 'The executor must not include identity columns in the SET clause of UPDATEs.'
The executor must not include identity columns in the SET clause of UPDATEs.
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
CREATE TABLE tmrb.bug_repro_1 (
    id SERIAL NOT NULL,
    legal_unit_id int NOT NULL,
    value_int int,
    valid_from date NOT NULL,
    valid_until date,
    -- The PK does NOT include the stable identifier `id`, which is what causes the bug.
    PRIMARY KEY (legal_unit_id, valid_from)
);
SELECT sql_saga.add_era('tmrb.bug_repro_1'::regclass);
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmrb.bug_repro_1'::regclass, '{legal_unit_id}');
NOTICE:  sql_saga: altering table tmrb.bug_repro_1 to add constraints: ADD CONSTRAINT bug_repro_1_legal_unit_id_valid_uniq UNIQUE (legal_unit_id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT bug_repro_1_legal_unit_id_valid_excl EXCLUDE USING gist (legal_unit_id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
         add_unique_key          
---------------------------------
 bug_repro_1_legal_unit_id_valid
(1 row)

-- Insert initial record
TRUNCATE source_data_1;
INSERT INTO source_data_1 VALUES (1, 1, NULL, 100, 4, '2023-01-01', 'infinity');
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.bug_repro_1',
    source_table => 'source_data_1',
    identity_columns => '{id}',
    natural_identity_columns => '{legal_unit_id}',
    update_source_with_identity => true
);
\echo '--- Target after initial import ---'
--- Target after initial import ---
TABLE tmrb.bug_repro_1;
 id | legal_unit_id | value_int | valid_from | valid_until 
----+---------------+-----------+------------+-------------
  1 |           100 |         4 | 2023-01-01 | infinity
(1 row)

-- This source data will cause an UPDATE on the existing id=1
TRUNCATE source_data_2;
INSERT INTO source_data_2 VALUES (2, 1, 1, 100, 5, '2023-04-01', 'infinity');
\echo '--- Source for second import (SCD Type 2 update) ---'
--- Source for second import (SCD Type 2 update) ---
TABLE source_data_2;
 row_id | founding_row_id | id | legal_unit_id | value_int | valid_from | valid_until 
--------+-----------------+----+---------------+-----------+------------+-------------
      2 |               1 |  1 |           100 |         5 | 2023-04-01 | infinity
(1 row)

\echo '--- Calling temporal_merge (should now succeed) ---'
--- Calling temporal_merge (should now succeed) ---
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.bug_repro_1',
    source_table => 'source_data_2',
    identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['legal_unit_id'],
    mode => 'MERGE_ENTITY_REPLACE'
);
\echo '--- Target after second import (CORRECT: 2 historical rows for id=1) ---'
--- Target after second import (CORRECT: 2 historical rows for id=1) ---
SELECT * FROM tmrb.bug_repro_1 ORDER BY id, valid_from;
 id | legal_unit_id | value_int | valid_from | valid_until 
----+---------------+-----------+------------+-------------
  1 |           100 |         4 | 2023-01-01 | 2023-04-01
  1 |           100 |         5 | 2023-04-01 | infinity
(2 rows)

\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 5: Reproduce invalid boolean cast on GUC (Bug #2)'
Scenario 5: Reproduce invalid boolean cast on GUC (Bug #2)
\echo 'The logging logic must handle empty string GUC values gracefully.'
The logging logic must handle empty string GUC values gracefully.
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo '--- Setting log_plan GUC to an empty string ---'
--- Setting log_plan GUC to an empty string ---
SET sql_saga.temporal_merge.log_plan = '';
\echo '--- Calling temporal_merge (should now succeed) ---'
--- Calling temporal_merge (should now succeed) ---
-- The content of the call doesn't matter, as the error happens during parameter
-- processing before the planner runs. The fix ensures this now runs without error.
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.bug_repro_1',
    source_table => 'source_data_2',
    identity_columns => ARRAY['id'],
    natural_identity_columns => NULL
);
-- Reset GUC for any subsequent tests
RESET sql_saga.temporal_merge.log_plan;
-- Common setup for Kranløft bug scenarios
SAVEPOINT kranloft_scenarios;
-- Source Data: Three contiguous rows for the same entity. The core data ('name')
-- is identical. Only the synchronized 'valid_to' column changes.
CREATE TEMP TABLE source_data_kranloft (
    row_id int,
    founding_row_id int,
    id int,
    name text,
    valid_from date,
    valid_until date,
    valid_to date
) ON COMMIT DROP;
INSERT INTO source_data_kranloft VALUES
(1, 1, 741, 'Kranløft Vestland', '2010-01-01', '2011-01-01', '2010-12-31'),
(2, 1, 741, 'Kranløft Vestland', '2011-01-01', '2012-01-15', '2012-01-14'),
(3, 1, 741, 'Kranløft Vestland', '2012-01-15', 'infinity', 'infinity');
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 6: Reproduce incorrect coalescing with synchronized columns (Kranløft Bug)'
Scenario 6: Reproduce incorrect coalescing with synchronized columns (Kranløft Bug)
\echo 'temporal_merge must not treat changes to synchronized columns (e.g., valid_to)'
temporal_merge must not treat changes to synchronized columns (e.g., valid_to)
\echo 'as data changes when determining if timeline segments should be coalesced.'
as data changes when determining if timeline segments should be coalesced.
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
SAVEPOINT kranloft_bug_coalesce;
-- Setup: A simple temporal table with a synchronized 'valid_to' column.
CREATE TABLE tmrb.legal_unit_kranloft (
    id int,
    name text,
    valid_from date,
    valid_until date,
    valid_to date -- Synchronized column
);
SELECT sql_saga.add_era('tmrb.legal_unit_kranloft'::regclass, synchronize_valid_to_column := 'valid_to');
NOTICE:  sql_saga: Created trigger "legal_unit_kranloft_synchronize_temporal_columns_trigger" on table tmrb.legal_unit_kranloft to synchronize columns: valid_to
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmrb.legal_unit_kranloft'::regclass, '{id}');
NOTICE:  sql_saga: altering table tmrb.legal_unit_kranloft to add constraints: ADD CONSTRAINT legal_unit_kranloft_id_valid_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT legal_unit_kranloft_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
        add_unique_key        
------------------------------
 legal_unit_kranloft_id_valid
(1 row)

\echo '--- Source Data ---'
--- Source Data ---
TABLE source_data_kranloft;
 row_id | founding_row_id | id  |       name        | valid_from | valid_until |  valid_to  
--------+-----------------+-----+-------------------+------------+-------------+------------
      1 |               1 | 741 | Kranløft Vestland | 2010-01-01 | 2011-01-01  | 2010-12-31
      2 |               1 | 741 | Kranløft Vestland | 2011-01-01 | 2012-01-15  | 2012-01-14
      3 |               1 | 741 | Kranløft Vestland | 2012-01-15 | infinity    | infinity
(3 rows)

\echo '--- Calling temporal_merge (which should now automatically treat valid_to as ephemeral)...'
--- Calling temporal_merge (which should now automatically treat valid_to as ephemeral)...
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.legal_unit_kranloft'::regclass,
    source_table => 'source_data_kranloft'::regclass,
    identity_columns => '{id}'::text[],
    founding_id_column => 'founding_row_id',
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid',
    ephemeral_columns => NULL
);
\echo '--- Result: CORRECT - Creates 1 coalesced row ---'
--- Result: CORRECT - Creates 1 coalesced row ---
SELECT * FROM tmrb.legal_unit_kranloft ORDER BY valid_from;
 id  |       name        | valid_from | valid_until | valid_to 
-----+-------------------+------------+-------------+----------
 741 | Kranløft Vestland | 2010-01-01 | infinity    | infinity
(1 row)

ROLLBACK TO SAVEPOINT kranloft_bug_coalesce;
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 8: Validate ephemeral_columns parameter'
Scenario 8: Validate ephemeral_columns parameter
\echo 'temporal_merge must reject calls where temporal boundary or synchronized columns'
temporal_merge must reject calls where temporal boundary or synchronized columns
\echo 'are manually specified in ephemeral_columns.'
are manually specified in ephemeral_columns.
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
SAVEPOINT ephemeral_validation;
-- Use the same setup as the kranloft bug
CREATE TABLE tmrb.ephemeral_validation (
    id int, name text, valid_from date, valid_until date, valid_to date
);
SELECT sql_saga.add_era('tmrb.ephemeral_validation'::regclass, synchronize_valid_to_column := 'valid_to');
NOTICE:  sql_saga: Created trigger "ephemeral_validation_synchronize_temporal_columns_trigger" on table tmrb.ephemeral_validation to synchronize columns: valid_to
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmrb.ephemeral_validation'::regclass, '{id}');
NOTICE:  sql_saga: altering table tmrb.ephemeral_validation to add constraints: ADD CONSTRAINT ephemeral_validation_id_valid_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT ephemeral_validation_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
        add_unique_key         
-------------------------------
 ephemeral_validation_id_valid
(1 row)

\echo '-- Attempting to pass valid_from as ephemeral (should fail) --'
-- Attempting to pass valid_from as ephemeral (should fail) --
DO $$ BEGIN
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.ephemeral_validation'::regclass,
    source_table => 'source_data_kranloft'::regclass,
    identity_columns => '{id}',
    ephemeral_columns => ARRAY['valid_from']
);
EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'Caught expected error: %', SQLERRM; END; $$;
NOTICE:  Caught expected error: Temporal boundary columns ("valid_from", "valid_until") cannot be specified in ephemeral_columns.
\echo '-- Attempting to pass valid_until as ephemeral (should fail) --'
-- Attempting to pass valid_until as ephemeral (should fail) --
DO $$ BEGIN
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.ephemeral_validation'::regclass,
    source_table => 'source_data_kranloft'::regclass,
    identity_columns => '{id}',
    ephemeral_columns => ARRAY['valid_until']
);
EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'Caught expected error: %', SQLERRM; END; $$;
NOTICE:  Caught expected error: Temporal boundary columns ("valid_from", "valid_until") cannot be specified in ephemeral_columns.
\echo '-- Attempting to pass synchronized valid_to as ephemeral (should fail) --'
-- Attempting to pass synchronized valid_to as ephemeral (should fail) --
DO $$ BEGIN
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.ephemeral_validation'::regclass,
    source_table => 'source_data_kranloft'::regclass,
    identity_columns => '{id}',
    ephemeral_columns => ARRAY['valid_to']
);
EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'Caught expected error: %', SQLERRM; END; $$;
NOTICE:  Caught expected error: Synchronized column "valid_to" is automatically handled and should not be specified in ephemeral_columns.
ROLLBACK TO SAVEPOINT ephemeral_validation;
-- Clean up the common setup
ROLLBACK TO SAVEPOINT kranloft_scenarios;
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 9: Reproduce FK violation on MERGE_ENTITY_REPLACE (Bug #3)'
Scenario 9: Reproduce FK violation on MERGE_ENTITY_REPLACE (Bug #3)
\echo 'A MERGE_ENTITY_REPLACE on a parent table must not fail with a temporal'
A MERGE_ENTITY_REPLACE on a parent table must not fail with a temporal
\echo 'foreign key violation if the parent has existing child records.'
foreign key violation if the parent has existing child records.
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
SAVEPOINT fk_violation_on_replace;
-- Setup: Parent and child temporal tables with a temporal foreign key.
CREATE TABLE tmrb.legal_unit_fk_bug (
    id int, name text, valid_from date, valid_until date
);
SELECT sql_saga.add_era('tmrb.legal_unit_fk_bug'::regclass);
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmrb.legal_unit_fk_bug'::regclass, '{id}', unique_key_name => 'legal_unit_fk_bug_id_valid');
NOTICE:  sql_saga: altering table tmrb.legal_unit_fk_bug to add constraints: ADD CONSTRAINT legal_unit_fk_bug_id_valid_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT legal_unit_fk_bug_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
       add_unique_key       
----------------------------
 legal_unit_fk_bug_id_valid
(1 row)

CREATE TABLE tmrb.activity_fk_bug (
    id int, legal_unit_id int, activity_code text, valid_from date, valid_until date
);
SELECT sql_saga.add_era('tmrb.activity_fk_bug'::regclass);
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmrb.activity_fk_bug'::regclass, '{id}', unique_key_name => 'activity_fk_bug_id_valid');
NOTICE:  sql_saga: altering table tmrb.activity_fk_bug to add constraints: ADD CONSTRAINT activity_fk_bug_id_valid_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT activity_fk_bug_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
      add_unique_key      
--------------------------
 activity_fk_bug_id_valid
(1 row)

SELECT sql_saga.add_temporal_foreign_key(
    fk_table_oid => 'tmrb.activity_fk_bug'::regclass,
    fk_column_names => ARRAY['legal_unit_id'],
    fk_era_name => 'valid',
    unique_key_name => 'legal_unit_fk_bug_id_valid'
);
NOTICE:  No compatible index found for foreign key on table tmrb.activity_fk_bug. Creating new index: CREATE INDEX activity_fk_bug_legal_unit_id_valid_gist_idx ON tmrb.activity_fk_bug USING GIST (legal_unit_id, daterange(valid_from, valid_until))
      add_temporal_foreign_key       
-------------------------------------
 activity_fk_bug_legal_unit_id_valid
(1 row)

-- Initial State: Insert a parent LU and a child Activity.
INSERT INTO tmrb.legal_unit_fk_bug (id, name, valid_from, valid_until) VALUES
(101, 'Original Company', '2023-01-01', '2024-01-01');
INSERT INTO tmrb.activity_fk_bug (id, legal_unit_id, activity_code, valid_from, valid_until) VALUES
(201, 101, 'A101', '2023-01-01', '2024-01-01');
-- Source Data: A new timeline for the existing parent LU.
CREATE TEMP TABLE source_data_fk_bug (
    row_id int, founding_row_id int, id int, name text, valid_from date, valid_until date
) ON COMMIT DROP;
INSERT INTO source_data_fk_bug VALUES
(1, 101, 101, 'Updated Company', '2023-01-01', '2024-01-01');
-- This call used to fail due to a bug in the FK trigger, but now succeeds.
-- This test now serves as a regression test to confirm the fix.
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.legal_unit_fk_bug'::regclass,
    source_table => 'source_data_fk_bug'::regclass,
    identity_columns => '{id}'::text[],
    founding_id_column => 'founding_row_id',
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid'
);
\echo '--- Final state of parent table (CORRECT: timeline replaced) ---'
--- Final state of parent table (CORRECT: timeline replaced) ---
TABLE tmrb.legal_unit_fk_bug;
 id  |      name       | valid_from | valid_until 
-----+-----------------+------------+-------------
 101 | Updated Company | 2023-01-01 | 2024-01-01
(1 row)

ROLLBACK TO SAVEPOINT fk_violation_on_replace;
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 10: Reproduce NOT NULL violation for defaulted column (Bug #4)'
Scenario 10: Reproduce NOT NULL violation for defaulted column (Bug #4)
\echo 'An UPDATE must not fail if the source is missing a column that has a'
An UPDATE must not fail if the source is missing a column that has a
\echo 'NOT NULL DEFAULT constraint in the target.'
NOT NULL DEFAULT constraint in the target.
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
SAVEPOINT not_null_default_bug;
-- Setup
CREATE TABLE tmrb.unit_default_bug (
    id int PRIMARY KEY, name text, is_active boolean NOT NULL DEFAULT true, valid_from date, valid_until date
);
SELECT sql_saga.add_era('tmrb.unit_default_bug'::regclass);
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmrb.unit_default_bug'::regclass, '{id}');
NOTICE:  sql_saga: altering table tmrb.unit_default_bug to add constraints: ADD CONSTRAINT unit_default_bug_id_valid_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT unit_default_bug_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
      add_unique_key       
---------------------------
 unit_default_bug_id_valid
(1 row)

-- Initial State
INSERT INTO tmrb.unit_default_bug (id, name, is_active, valid_from, valid_until) VALUES
(1, 'Initial Name', true, '2023-01-01', '2024-01-01');
-- Source Data (missing is_active)
CREATE TEMP TABLE source_data_default_bug (
    row_id int, founding_row_id int, id int, name text, valid_from date, valid_until date
) ON COMMIT DROP;
INSERT INTO source_data_default_bug VALUES
(1, 1, 1, 'Updated Name', '2023-01-01', '2024-01-01');
-- This call used to fail due to the bug, but now succeeds.
-- This test now serves as a regression test to confirm the fix.
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.unit_default_bug'::regclass,
    source_table => 'source_data_default_bug'::regclass,
    identity_columns => '{id}'::text[],
    founding_id_column => 'founding_row_id',
    mode => 'MERGE_ENTITY_REPLACE',
    era_name => 'valid'
);
\echo '--- Final state of target table (CORRECT: is_active preserved its default) ---'
--- Final state of target table (CORRECT: is_active preserved its default) ---
TABLE tmrb.unit_default_bug;
 id |     name     | is_active | valid_from | valid_until 
----+--------------+-----------+------------+-------------
  1 | Updated Name | t         | 2023-01-01 | 2024-01-01
(1 row)

ROLLBACK TO SAVEPOINT not_null_default_bug;
-- ANCHOR Add SAVEPOINT managed test scenarios above this line
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
\echo 'Scenario 11: Coalescing adjacent segments must use data from the LATEST segment'
Scenario 11: Coalescing adjacent segments must use data from the LATEST segment
\echo 'When two adjacent timeline segments are coalesced because their core data is'
When two adjacent timeline segments are coalesced because their core data is
\echo 'identical, the resulting merged segment must inherit its data payload (including'
identical, the resulting merged segment must inherit its data payload (including
\echo 'ephemeral columns) from the chronologically later of the two segments.'
ephemeral columns) from the chronologically later of the two segments.
\echo '--------------------------------------------------------------------------------'
--------------------------------------------------------------------------------
SAVEPOINT coalesce_uses_latest_data;
-- 1. Setup
CREATE TABLE tmrb.coalesce_bug (
    id int,
    value int,
    edit_comment text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('tmrb.coalesce_bug'::regclass);
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tmrb.coalesce_bug'::regclass, '{id}');
NOTICE:  sql_saga: altering table tmrb.coalesce_bug to add constraints: ADD CONSTRAINT coalesce_bug_id_valid_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT coalesce_bug_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    add_unique_key     
-----------------------
 coalesce_bug_id_valid
(1 row)

-- 2. Initial State
INSERT INTO tmrb.coalesce_bug VALUES (1, 100, 'Old Comment', '2023-01-01', '2023-02-01');
-- 3. Source Data
CREATE TEMP TABLE source_coalesce_bug (
    row_id int, id int, value int, edit_comment text, valid_from date, valid_until date
);
INSERT INTO source_coalesce_bug VALUES
(1, 1, 100, 'New Comment', '2023-02-01', '2023-03-01');
\echo '--- Target state BEFORE merge ---'
--- Target state BEFORE merge ---
TABLE tmrb.coalesce_bug;
 id | value | edit_comment | valid_from | valid_until 
----+-------+--------------+------------+-------------
  1 |   100 | Old Comment  | 2023-01-01 | 2023-02-01
(1 row)

\echo '--- Source data FOR merge ---'
--- Source data FOR merge ---
TABLE source_coalesce_bug;
 row_id | id | value | edit_comment | valid_from | valid_until 
--------+----+-------+--------------+------------+-------------
      1 |  1 |   100 | New Comment  | 2023-02-01 | 2023-03-01
(1 row)

-- 4. Execute Merge
CALL sql_saga.temporal_merge(
    target_table => 'tmrb.coalesce_bug'::regclass,
    source_table => 'source_coalesce_bug'::regclass,
    identity_columns => '{id}',
    ephemeral_columns => '{edit_comment}'
);
-- 5. Verify Result
\echo '--- Target state AFTER merge (CORRECT: edit_comment is "New Comment") ---'
--- Target state AFTER merge (CORRECT: edit_comment is "New Comment") ---
SELECT * FROM tmrb.coalesce_bug;
 id | value | edit_comment | valid_from | valid_until 
----+-------+--------------+------------+-------------
  1 |   100 | New Comment  | 2023-01-01 | 2023-03-01
(1 row)

ROLLBACK TO SAVEPOINT coalesce_uses_latest_data;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
