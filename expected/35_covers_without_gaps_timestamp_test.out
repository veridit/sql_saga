\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
SET ROLE TO sql_saga_unprivileged_user;
CREATE TABLE timestamp_shifts (
  job_id INTEGER,
  worker_id INTEGER,
  valid_from TIMESTAMPTZ,
  valid_until TIMESTAMPTZ
);
-- Add era and unique key via sql_saga
SELECT sql_saga.add_era('timestamp_shifts', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('timestamp_shifts', ARRAY['job_id', 'worker_id']);
             add_unique_key              
-----------------------------------------
 timestamp_shifts_job_id_worker_id_valid
(1 row)

TABLE sql_saga.era;
 table_schema |    table_name    | era_name | valid_from_column_name | valid_until_column_name | range_type |      range_subtype       | range_subtype_category |   bounds_check_constraint    | synchronize_valid_to_column | synchronize_range_column | audit_schema_name | audit_table_name 
--------------+------------------+----------+------------------------+-------------------------+------------+--------------------------+------------------------+------------------------------+-----------------------------+--------------------------+-------------------+------------------
 public       | timestamp_shifts | valid    | valid_from             | valid_until             | tstzrange  | timestamp with time zone | D                      | timestamp_shifts_valid_check |                             |                          |                   | 
(1 row)

TABLE sql_saga.unique_keys;
             unique_key_name             | table_schema |    table_name    |    column_names    | era_name |                      unique_constraint                       |              exclude_constraint              | predicate 
-----------------------------------------+--------------+------------------+--------------------+----------+--------------------------------------------------------------+----------------------------------------------+-----------
 timestamp_shifts_job_id_worker_id_valid | public       | timestamp_shifts | {job_id,worker_id} | valid    | timestamp_shifts_job_id_worker_id_valid_from_valid_until_key | timestamp_shifts_job_id_worker_id_valid_excl | 
(1 row)

INSERT INTO timestamp_shifts(job_id, worker_id, valid_from, valid_until) VALUES
  (1, 1, '2017-11-27 06:00:00', '2017-11-27 12:00:00'),
  (1, 2, '2017-11-27 12:00:00', '2017-11-27 17:00:00'),
  (2, 3, '2017-11-27 06:00:00', '2017-11-27 12:00:00'),
  (2, 4, '2017-11-27 13:00:00', '2017-11-27 17:00:00'),
  (3, 5, '-infinity',           '2017-11-27 12:00:00'),
  (3, 6, '2017-11-27 12:00:00', '2017-11-27 17:00:00'),
  (4, 7, '2017-11-27 06:00:00', '2017-11-27 12:00:00'),
  (4, 8, '2017-11-27 12:00:00', 'infinity')
;
-- TRUE:
-- it covers when the range matches one exactly:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 06:00:00', '2017-11-27 12:00:00') ORDER BY valid_from)
FROM    timestamp_shifts
WHERE   job_id = 1;
 covers_without_gaps 
---------------------
 t
(1 row)

-- it covers when the range matches two exactly:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 06:00:00', '2017-11-27 17:00:00') ORDER BY valid_from)
FROM    timestamp_shifts
WHERE   job_id = 1;
 covers_without_gaps 
---------------------
 t
(1 row)

-- it covers when the range has extra in front:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 08:00:00', '2017-11-27 17:00:00') ORDER BY valid_from)
FROM    timestamp_shifts
WHERE   job_id = 1;
 covers_without_gaps 
---------------------
 t
(1 row)

-- it covers when the range has extra behind:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 06:00:00', '2017-11-27 14:00:00') ORDER BY valid_from)
FROM    timestamp_shifts
WHERE   job_id = 1;
 covers_without_gaps 
---------------------
 t
(1 row)

-- it covers when the range has extra on both sides:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 08:00:00', '2017-11-27 14:00:00') ORDER BY valid_from)
FROM    timestamp_shifts
WHERE   job_id = 1;
 covers_without_gaps 
---------------------
 t
(1 row)

-- an infinite start will cover a finite target:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 06:00:00', '2017-11-27 17:00:00') ORDER BY valid_from)
FROM    timestamp_shifts
WHERE   job_id = 3;
 covers_without_gaps 
---------------------
 t
(1 row)

-- an infinite start will cover an infinite target:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('-infinity', '2017-11-27 17:00:00') ORDER BY valid_from)
FROM    timestamp_shifts
WHERE   job_id = 3;
 covers_without_gaps 
---------------------
 t
(1 row)

-- an infinite end will cover a finite target:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 06:00:00', '2017-11-27 17:00:00') ORDER BY valid_from)
FROM    timestamp_shifts
WHERE   job_id = 4;
 covers_without_gaps 
---------------------
 t
(1 row)

-- an infinite end will cover an infinite target:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 06:00:00', 'infinity') ORDER BY valid_from)
FROM    timestamp_shifts
WHERE   job_id = 4;
 covers_without_gaps 
---------------------
 t
(1 row)

-- FALSE:
-- it does not cover when the range is null:
SELECT  sql_saga.covers_without_gaps(NULL, tstzrange('2017-11-27 08:00:00', '2017-11-27 14:00:00'))
FROM    timestamp_shifts
WHERE   job_id = 1;
 covers_without_gaps 
---------------------
 f
(1 row)

-- it does not cover when the range misses completely:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-29 08:00:00', '2017-11-29 14:00:00'))
FROM    timestamp_shifts
WHERE   job_id = 1;
 covers_without_gaps 
---------------------
 f
(1 row)

-- it does not cover when the range has something at the beginning:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 04:00:00', '2017-11-27 14:00:00'))
FROM    timestamp_shifts
WHERE   job_id = 1;
 covers_without_gaps 
---------------------
 f
(1 row)

-- it does not cover when the range has something at the end:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 06:00:00', '2017-11-27 20:00:00'))
FROM    timestamp_shifts
WHERE   job_id = 1;
 covers_without_gaps 
---------------------
 f
(1 row)

-- it does not cover when the range has something in the middle:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 06:00:00', '2017-11-27 17:00:00'))
FROM    timestamp_shifts
WHERE   job_id = 2;
 covers_without_gaps 
---------------------
 f
(1 row)

-- it does not cover when the range is lower-unbounded:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('-infinity', '2017-11-27 17:00:00'))
FROM    timestamp_shifts
WHERE   job_id = 1;
 covers_without_gaps 
---------------------
 f
(1 row)

-- it does not cover when the range is upper-unbounded:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 06:00:00', 'infinity'))
FROM    timestamp_shifts
WHERE   job_id = 1;
 covers_without_gaps 
---------------------
 f
(1 row)

-- it does not cover when the range is both-sides-unbounded:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('-infinity', 'infinity'))
FROM    timestamp_shifts
WHERE   job_id = 1;
 covers_without_gaps 
---------------------
 f
(1 row)

-- an infinite start will not cover a finite target if there is uncovered time at the end:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 06:00:00', '2017-11-27 20:00:00'))
FROM    timestamp_shifts
WHERE   job_id = 3;
 covers_without_gaps 
---------------------
 f
(1 row)

-- an infinite start will not cover an infinite target if there is uncovered time at the end:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('-infinity', '2017-11-27 20:00:00'))
FROM    timestamp_shifts
WHERE   job_id = 3;
 covers_without_gaps 
---------------------
 f
(1 row)

-- an infinite end will not cover a finite target if there is uncovered time at the beginning:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 03:00:00', '2017-11-27 17:00:00'))
FROM    timestamp_shifts
WHERE   job_id = 4;
 covers_without_gaps 
---------------------
 f
(1 row)

-- an infinite end will not cover an infinite target if there is uncovered time at the beginning:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 03:00:00', 'infinity'))
FROM    timestamp_shifts
WHERE   job_id = 4;
 covers_without_gaps 
---------------------
 f
(1 row)

-- NULL:
-- it is unknown when the target is null:
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), null)
FROM    timestamp_shifts
WHERE   job_id = 1;
 covers_without_gaps 
---------------------
 
(1 row)

-- Errors:
-- it fails if the input ranges go backwards:
SAVEPOINT s;
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 13:00:00', '2017-11-27 20:00:00') ORDER BY worker_id DESC)
FROM    timestamp_shifts
WHERE   job_id = 1;
ERROR:  input to covers_without_gaps must be sorted by range start
ROLLBACK TO SAVEPOINT s;
-- it handles an empty target range
SELECT  sql_saga.covers_without_gaps(tstzrange(valid_from,valid_until), tstzrange('2017-11-27 10:00:00', '2017-11-27 10:00:00') ORDER BY valid_from)
FROM    timestamp_shifts
WHERE   job_id = 1;
 covers_without_gaps 
---------------------
 t
(1 row)

DELETE FROM timestamp_shifts;
SELECT sql_saga.drop_unique_key('timestamp_shifts', ARRAY['job_id', 'worker_id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('timestamp_shifts');
 drop_era 
----------
 t
(1 row)

DROP TABLE timestamp_shifts;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
