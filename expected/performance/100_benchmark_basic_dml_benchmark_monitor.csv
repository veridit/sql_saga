log_id,event,label,queryid,calls,total_exec_time,rows,shared_blks_hit,shared_blks_read,temp_blks_read,temp_blks_written,total_plan_time,wal_records,wal_bytes,query
f80,Child INSERT (No Index),,2751195442669386938,1,33.846083,1000,20034,4,0,0,0,8024,755384,"INSERT INTO establishment (id, valid_range, legal_unit_id, postal_place) SELECT i, daterange('2015-01-01', 'infinity', '[)'), i, 'New Shop ' || i FROM generate_series(10001, 11000) i"
bc5,Child INSERT (No Index),,3801168477474623637,1000,6.7779090000000055,1000,4000,0,0,0,0,1000,54000,"SELECT 1 FROM (SELECT ""valid_range"" AS r FROM ONLY ""public"".""legal_unit"" x WHERE ""id"" OPERATOR(pg_catalog.=) $1 AND ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.&&) $2::pg_catalog.anyrange FOR KEY SHARE OF x) x1 HAVING   $2::pg_catalog.anyrange OPERATOR(pg_catalog.<@) pg_catalog.range_agg(x1.r)"
255,Child INSERT (Plain),,2751195442669386938,1,11.987,1000,6028,0,0,0,0,3009,326528,"INSERT INTO establishment (id, valid_range, legal_unit_id, postal_place) SELECT i, daterange('2015-01-01', 'infinity', '[)'), i, 'New Shop ' || i FROM generate_series(10001, 11000) i"
b73,Child INSERT (With Index),,2751195442669386938,1,38.753292,1000,22025,1,0,0,0,10033,987832,"INSERT INTO establishment (id, valid_range, legal_unit_id, postal_place) SELECT i, daterange('2015-01-01', 'infinity', '[)'), i, 'New Shop ' || i FROM generate_series(11001, 12000) i"
8f3,Child INSERT (With Index),,3801168477474623637,1000,7.184447999999993,1000,4000,0,0,0,0,1000,54000,"SELECT 1 FROM (SELECT ""valid_range"" AS r FROM ONLY ""public"".""legal_unit"" x WHERE ""id"" OPERATOR(pg_catalog.=) $1 AND ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.&&) $2::pg_catalog.anyrange FOR KEY SHARE OF x) x1 HAVING   $2::pg_catalog.anyrange OPERATOR(pg_catalog.<@) pg_catalog.range_agg(x1.r)"
8e3,Child UPDATE Key (No Index),,2480189997267991601,1,27.407291999999998,1000,28063,9,0,0,0,7059,640289,"UPDATE establishment SET valid_range = daterange('2014-01-01', upper(valid_range), '[)') WHERE id BETWEEN 1 AND 1000"
ae6,Child UPDATE Key (No Index),,3801168477474623637,1000,5.769051999999993,1000,6004,0,0,0,0,1009,56740,"SELECT 1 FROM (SELECT ""valid_range"" AS r FROM ONLY ""public"".""legal_unit"" x WHERE ""id"" OPERATOR(pg_catalog.=) $1 AND ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.&&) $2::pg_catalog.anyrange FOR KEY SHARE OF x) x1 HAVING   $2::pg_catalog.anyrange OPERATOR(pg_catalog.<@) pg_catalog.range_agg(x1.r)"
5b6,Child UPDATE Key (With Index),,2480189997267991601,1,32.941166,1000,29872,8,0,0,0,8034,805707,"UPDATE establishment SET valid_range = daterange('2013-01-01', upper(valid_range), '[)') WHERE id BETWEEN 2001 AND 3000"
d2b,Child UPDATE Key (With Index),,3801168477474623637,1000,6.214106999999986,1000,5964,0,0,0,0,1009,56682,"SELECT 1 FROM (SELECT ""valid_range"" AS r FROM ONLY ""public"".""legal_unit"" x WHERE ""id"" OPERATOR(pg_catalog.=) $1 AND ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.&&) $2::pg_catalog.anyrange FOR KEY SHARE OF x) x1 HAVING   $2::pg_catalog.anyrange OPERATOR(pg_catalog.<@) pg_catalog.range_agg(x1.r)"
f43,Child UPDATE Non-Key (No Index),,-6603853390843512690,1,16.027375,1000,19607,8,0,0,0,5896,557861,UPDATE establishment SET postal_place = 'New Place' WHERE id BETWEEN 1001 AND 2000
195,Child UPDATE Non-Key (With Index),,-6603853390843512690,1,20.811458000000002,1000,21850,11,0,0,0,6970,714210,UPDATE establishment SET postal_place = 'New Place Again' WHERE id BETWEEN 3001 AND 4000
2ed,"Parent DELETE (Check Only, No Index)",,-2355103134172566288,1,957.476666,1000,136014,0,0,0,0,1000,54000,DELETE FROM legal_unit WHERE id BETWEEN 20001 AND 21000
708,"Parent DELETE (Check Only, No Index)",,476854885423386359,1000,936.0317949999994,0,130000,0,0,0,0,0,0,"SELECT 1 FROM ONLY ""public"".""establishment"" x WHERE $1 OPERATOR(pg_catalog.=) ""legal_unit_id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange AND NOT coalesce(  (  ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.*) $2::pg_catalog.anyrange)::pg_catalog.anyrange OPERATOR(pg_catalog.<@) (SELECT pg_catalog.range_agg(r) FROM (SELECT y.""valid_range"" r FROM ONLY ""public"".""legal_unit"" y WHERE $1 OPERATOR(pg_catalog.=) ""id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange FOR KEY SHARE OF y) y2), false) FOR KEY SHARE OF x"
9e9,"Parent DELETE (Check Only, No Index)",,-6873348994332248717,1000,1.4108199999999973,1000,2000,0,0,0,0,0,0,SELECT EXISTS (SELECT 1 FROM public.projects AS fk WHERE fk.legal_unit_id = $1)
87f,"Parent DELETE (Check Only, With Index)",,-2355103134172566288,1,14.275084,1000,7014,0,0,0,0,1000,54000,DELETE FROM legal_unit WHERE id BETWEEN 21001 AND 22000
44a,"Parent DELETE (Check Only, With Index)",,476854885423386359,1000,1.5595439999999905,0,1000,0,0,0,0,0,0,"SELECT 1 FROM ONLY ""public"".""establishment"" x WHERE $1 OPERATOR(pg_catalog.=) ""legal_unit_id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange AND NOT coalesce(  (  ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.*) $2::pg_catalog.anyrange)::pg_catalog.anyrange OPERATOR(pg_catalog.<@) (SELECT pg_catalog.range_agg(r) FROM (SELECT y.""valid_range"" r FROM ONLY ""public"".""legal_unit"" y WHERE $1 OPERATOR(pg_catalog.=) ""id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange FOR KEY SHARE OF y) y2), false) FOR KEY SHARE OF x"
ff3,"Parent DELETE (Check Only, With Index)",,-6873348994332248717,1000,0.6528969999999933,1000,2000,0,0,0,0,0,0,SELECT EXISTS (SELECT 1 FROM public.projects AS fk WHERE fk.legal_unit_id = $1)
be9,Parent DELETE (No Index),,-2355103134172566288,1,955.474001,1000,136045,4,0,0,0,1000,54000,DELETE FROM legal_unit WHERE id BETWEEN 15001 AND 16000
e73,Parent DELETE (No Index),,476854885423386359,1000,935.4001209999998,0,130000,0,0,0,0,0,0,"SELECT 1 FROM ONLY ""public"".""establishment"" x WHERE $1 OPERATOR(pg_catalog.=) ""legal_unit_id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange AND NOT coalesce(  (  ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.*) $2::pg_catalog.anyrange)::pg_catalog.anyrange OPERATOR(pg_catalog.<@) (SELECT pg_catalog.range_agg(r) FROM (SELECT y.""valid_range"" r FROM ONLY ""public"".""legal_unit"" y WHERE $1 OPERATOR(pg_catalog.=) ""id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange FOR KEY SHARE OF y) y2), false) FOR KEY SHARE OF x"
6f6,Parent DELETE (No Index),,-6873348994332248717,1000,1.2105469999999963,1000,2000,0,0,0,0,0,0,SELECT EXISTS (SELECT 1 FROM public.projects AS fk WHERE fk.legal_unit_id = $1)
9b9,Parent DELETE (With Index),,-2355103134172566288,1,14.689792,1000,7010,3,0,0,0,1001,54230,DELETE FROM legal_unit WHERE id BETWEEN 16001 AND 17000
a7f,Parent DELETE (With Index),,476854885423386359,1000,1.598361999999997,0,1000,0,0,0,0,0,0,"SELECT 1 FROM ONLY ""public"".""establishment"" x WHERE $1 OPERATOR(pg_catalog.=) ""legal_unit_id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange AND NOT coalesce(  (  ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.*) $2::pg_catalog.anyrange)::pg_catalog.anyrange OPERATOR(pg_catalog.<@) (SELECT pg_catalog.range_agg(r) FROM (SELECT y.""valid_range"" r FROM ONLY ""public"".""legal_unit"" y WHERE $1 OPERATOR(pg_catalog.=) ""id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange FOR KEY SHARE OF y) y2), false) FOR KEY SHARE OF x"
a67,Parent DELETE (With Index),,-6873348994332248717,1000,0.664990999999992,1000,2000,0,0,0,0,0,0,SELECT EXISTS (SELECT 1 FROM public.projects AS fk WHERE fk.legal_unit_id = $1)
5eb,Parent INSERT (No Index),,-6962160005659942149,1,30.472084,1000,15036,3,0,0,0,7025,699144,"INSERT INTO legal_unit (id, valid_range, name) SELECT i, daterange('2015-01-01', 'infinity', '[)'), 'New Company ' || i FROM generate_series(20001, 21000) i"
298,Parent INSERT (Plain),,-6962160005659942149,1,18.3075,1000,6028,0,0,0,0,3009,323528,"INSERT INTO legal_unit (id, valid_range, name) SELECT i, daterange('2015-01-01', 'infinity', '[)'), 'New Company ' || i FROM generate_series(20001, 21000) i"
ee9,Parent INSERT (With Index),,-6962160005659942149,1,31.554376,1000,15025,0,0,0,0,7025,705776,"INSERT INTO legal_unit (id, valid_range, name) SELECT i, daterange('2015-01-01', 'infinity', '[)'), 'New Company ' || i FROM generate_series(21001, 22000) i"
1e0,Parent UPDATE Key (No Index),,-5008329604151558703,1,970.011541,1000,156919,11,0,0,0,7051,642790,"UPDATE legal_unit SET valid_range = daterange('2014-01-01', upper(valid_range), '[)') WHERE id BETWEEN 1 AND 1000"
77d,Parent UPDATE Key (No Index),,476854885423386359,1000,935.7480459999989,0,134774,0,0,0,0,1000,54000,"SELECT 1 FROM ONLY ""public"".""establishment"" x WHERE $1 OPERATOR(pg_catalog.=) ""legal_unit_id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange AND NOT coalesce(  (  ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.*) $2::pg_catalog.anyrange)::pg_catalog.anyrange OPERATOR(pg_catalog.<@) (SELECT pg_catalog.range_agg(r) FROM (SELECT y.""valid_range"" r FROM ONLY ""public"".""legal_unit"" y WHERE $1 OPERATOR(pg_catalog.=) ""id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange FOR KEY SHARE OF y) y2), false) FOR KEY SHARE OF x"
2e6,Parent UPDATE Key (With Index),,-5008329604151558703,1,42.00875,1000,29934,15,0,0,0,7017,644774,"UPDATE legal_unit SET valid_range = daterange('2013-01-01', upper(valid_range), '[)') WHERE id BETWEEN 2001 AND 3000"
1e8,Parent UPDATE Key (With Index),,476854885423386359,1000,11.427984999999946,0,7957,7,0,0,0,1001,54192,"SELECT 1 FROM ONLY ""public"".""establishment"" x WHERE $1 OPERATOR(pg_catalog.=) ""legal_unit_id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange AND NOT coalesce(  (  ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.*) $2::pg_catalog.anyrange)::pg_catalog.anyrange OPERATOR(pg_catalog.<@) (SELECT pg_catalog.range_agg(r) FROM (SELECT y.""valid_range"" r FROM ONLY ""public"".""legal_unit"" y WHERE $1 OPERATOR(pg_catalog.=) ""id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange FOR KEY SHARE OF y) y2), false) FOR KEY SHARE OF x"
248,Parent UPDATE Non-Key (No Index),,4340914437108901275,1,19.061791000000003,1000,19402,8,0,0,0,5836,553456,UPDATE legal_unit SET name = 'Updated Company' WHERE id BETWEEN 1001 AND 2000
f7a,Parent UPDATE Non-Key (With Index),,4340914437108901275,1,21.49925,1000,19959,7,0,0,0,5998,575770,UPDATE legal_unit SET name = 'Updated Again Company' WHERE id BETWEEN 3001 AND 4000
f53,Regular INSERT (No Index),,-8805169522762314890,1,11.046208,1000,9024,0,0,0,0,3035,225251,"INSERT INTO projects (name, legal_unit_id) SELECT 'New Project ' || i, i FROM generate_series(10001, 11000) i"
d7f,Regular INSERT (No Index),,-1640871935848111309,1000,5.790831999999981,1000,3000,0,0,0,0,0,0,SELECT EXISTS (SELECT 1 FROM public.legal_unit AS uk WHERE uk.id = $1)
408,Regular INSERT (With Index),,-8805169522762314890,1,11.349708,1000,9020,0,0,0,0,3036,218530,"INSERT INTO projects (name, legal_unit_id) SELECT 'New Project ' || i, i FROM generate_series(11001, 12000) i"
d4a,Regular INSERT (With Index),,-1640871935848111309,1000,6.219615999999993,1000,3000,0,0,0,0,0,0,                 SELECT EXISTS (SELECT 1 FROM public.legal_unit AS uk WHERE uk.id = $1);             
49b,temporal_merge Child (With Index),,-9186742824002461237,1,215.147708,0,44430,41,0,0,0,13353,1523247,"CALL sql_saga.temporal_merge('establishment'::regclass, 'establishment_source'::regclass, ARRAY['id'])"
474,temporal_merge Child (With Index),,7833591089880058545,1,166.296,1000,15701,1,0,0,0,3979,490373,"INSERT INTO temporal_merge_plan     SELECT * FROM sql_saga.temporal_merge_plan(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         identity_columns => v_identity_cols_discovered,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         delete_mode => temporal_merge.delete_mode,         lookup_keys => v_natural_identity_keys_discovered,         ephemeral_columns => temporal_merge.ephemeral_columns,         p_log_trace => v_log_trace,         p_log_sql => v_log_sql     )"
cf4,temporal_merge Child (With Index),,-214370746534177287,1,46.813291,0,27863,40,0,0,0,9197,1013616,"CALL sql_saga.temporal_merge_execute(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         identity_columns => v_identity_cols_discovered,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         update_source_with_identity => temporal_merge.update_source_with_identity,         lookup_columns => v_natural_identity_cols_discovered,         delete_mode => temporal_merge.delete_mode,         update_source_with_feedback => temporal_merge.update_source_with_feedback,         feedback_status_column => temporal_merge.feedback_status_column,         feedback_status_key => temporal_merge.feedback_status_key,         feedback_error_column => temporal_merge.feedback_error_column,         feedback_error_key => temporal_merge.feedback_error_key,         ephemeral_columns => temporal_merge.ephemeral_columns,         delay_constraints => temporal_merge.delay_constraints     )"
f4e,temporal_merge Child (With Index),,941778361422124368,1,34.465583,1000,496,0,0,0,0,118,13155,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         -- OPTIMIZATION: Use pre-computed valid_range instead of repeated daterange() calls                         -- Combined with composite index, this provides 30-40 percent total performance improvement                         COALESCE(sql_saga.covers_without_gaps(s2.valid_range, s1.valid_range ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.lookup_columns_unavailable AND (s1.id IS NOT DISTINCT FROM s2.id))                             OR                             (s1.lookup_columns_unavailable AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info"
379,temporal_merge Child (With Index),,9124375050176383526,1,33.971582,1000,301,0,0,0,0,117,13103,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         -- OPTIMIZATION: Use pre-computed valid_range instead of repeated daterange() calls                         -- Combined with composite index, this provides 30-40 percent total performance improvement                         COALESCE(sql_saga.covers_without_gaps(s2.valid_range, s1.valid_range ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.lookup_columns_unavailable AND (s1.id IS NOT DISTINCT FROM s2.id))                             OR                             (s1.lookup_columns_unavailable AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info;"
c2c,temporal_merge Child (With Index),,3900227311665976700,1,29.956917,1000,25687,40,0,0,0,8875,966368,"UPDATE establishment t SET valid_range = p.new_valid_range::daterange, legal_unit_id = CASE WHEN p.data ? 'legal_unit_id' THEN (p.data->>'legal_unit_id')::integer ELSE t.legal_unit_id END, postal_place = CASE WHEN p.data ? 'postal_place' THEN (p.data->>'postal_place')::text ELSE t.postal_place END                                 FROM (SELECT *, (entity_keys->>'id')::integer AS id_ek FROM temporal_merge_plan WHERE operation = 'UPDATE' AND statement_seq = 1 ORDER BY plan_op_seq) p                                 WHERE t.id = p.id_ek AND t.valid_range = p.old_valid_range::daterange"
3eb,temporal_merge Child (With Index),,-4576498192398325130,1,11.42775,1000,452,0,0,0,0,129,14466,"CREATE TEMP TABLE coalesced_final_segments ON COMMIT DROP AS                 SELECT                     grouping_key, max(id) as id,                     sql_saga.first(causal_id ORDER BY valid_from) as causal_id,                     sql_saga.first(stable_identity_columns_are_null ORDER BY valid_from) as stable_identity_columns_are_null,                     sql_saga.first(lookup_columns_unavailable ORDER BY valid_from) as lookup_columns_unavailable,                     sql_saga.first(is_new_entity ORDER BY valid_from) as is_new_entity,                     sql_saga.first(is_identifiable ORDER BY valid_from) as is_identifiable,                     sql_saga.first(is_ambiguous ORDER BY valid_from) as is_ambiguous,                     sql_saga.first(conflicting_ids ORDER BY valid_from) as conflicting_ids,                     sql_saga.first(unified_canonical_nk_json ORDER BY valid_from) as canonical_nk_json,                     sql_saga.first(orig_source_target_relation ORDER BY valid_from) as orig_source_target_relation,                     sql_saga.first(t_valid_from ORDER BY valid_from) as ancestor_valid_from,                     MIN(valid_from) as valid_from,                     MAX(valid_until) as valid_until,                     (sql_saga.first(data_payload ORDER BY valid_from DESC) || sql_saga.first(ephemeral_payload ORDER BY valid_from DESC)) as final_payload,                     sql_saga.first(stable_pk_payload ORDER BY valid_from DESC) as stable_pk_payload,                     bool_and(unaffected_target_only_segment) as unaffected_target_only_segment,                     (SELECT array_agg(DISTINCT e) FROM unnest(array_concat_agg(causal_source_row_ids)) e WHERE e IS NOT NULL) as row_ids,                     CASE WHEN 'f'::boolean                         THEN jsonb_build_object( 'cte', 'coalesced', 'island_group_id', island_group_id, 'coalesced_stable_pk', sql_saga.first(stable_pk_payload ORDER BY valid_from DESC), 'final_payload', sql_saga.first(data_payload ORDER BY valid_from DESC), 'final_payload_sans_epheme"
b26,temporal_merge Child (With Index),,-1236056701791326179,1,10.95025,1000,322,0,0,0,0,129,14466,"CREATE TEMP TABLE coalesced_final_segments ON COMMIT DROP AS                 SELECT                     grouping_key, max(id) as id,                     sql_saga.first(causal_id ORDER BY valid_from) as causal_id,                     sql_saga.first(stable_identity_columns_are_null ORDER BY valid_from) as stable_identity_columns_are_null,                     sql_saga.first(lookup_columns_unavailable ORDER BY valid_from) as lookup_columns_unavailable,                     sql_saga.first(is_new_entity ORDER BY valid_from) as is_new_entity,                     sql_saga.first(is_identifiable ORDER BY valid_from) as is_identifiable,                     sql_saga.first(is_ambiguous ORDER BY valid_from) as is_ambiguous,                     sql_saga.first(conflicting_ids ORDER BY valid_from) as conflicting_ids,                     sql_saga.first(unified_canonical_nk_json ORDER BY valid_from) as canonical_nk_json,                     sql_saga.first(orig_source_target_relation ORDER BY valid_from) as orig_source_target_relation,                     sql_saga.first(t_valid_from ORDER BY valid_from) as ancestor_valid_from,                     MIN(valid_from) as valid_from,                     MAX(valid_until) as valid_until,                     (sql_saga.first(data_payload ORDER BY valid_from DESC) || sql_saga.first(ephemeral_payload ORDER BY valid_from DESC)) as final_payload,                     sql_saga.first(stable_pk_payload ORDER BY valid_from DESC) as stable_pk_payload,                     bool_and(unaffected_target_only_segment) as unaffected_target_only_segment,                     (SELECT array_agg(DISTINCT e) FROM unnest(array_concat_agg(causal_source_row_ids)) e WHERE e IS NOT NULL) as row_ids,                     CASE WHEN 'f'::boolean                         THEN jsonb_build_object( 'cte', 'coalesced', 'island_group_id', island_group_id, 'coalesced_stable_pk', sql_saga.first(stable_pk_payload ORDER BY valid_from DESC), 'final_payload', sql_saga.first(data_payload ORDER BY valid_from DESC), 'final_payload_sans_epheme"
210,temporal_merge Child (With Index),,-2046183703977100040,1,10.145,4000,364,0,0,0,0,117,16725,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
632,temporal_merge Parent (With Index),,-9186742824002461237,1,370.366459,0,41195,35,0,0,0,12376,1381219,"CALL sql_saga.temporal_merge('legal_unit'::regclass, 'legal_unit_source'::regclass, ARRAY['id'])"
56a,temporal_merge Parent (With Index),,7833591089880058545,1,322.894125,1000,15242,1,0,0,0,4110,511677,"INSERT INTO temporal_merge_plan     SELECT * FROM sql_saga.temporal_merge_plan(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         identity_columns => v_identity_cols_discovered,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         delete_mode => temporal_merge.delete_mode,         lookup_keys => v_natural_identity_keys_discovered,         ephemeral_columns => temporal_merge.ephemeral_columns,         p_log_trace => v_log_trace,         p_log_sql => v_log_sql     )"
082,temporal_merge Parent (With Index),,5315683203855809984,1,172.037417,1000,485,0,0,0,0,139,16613,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     with_base_payload.*,                     with_base_payload.stable_pk_payload as propagated_stable_pk_payload                 FROM (                     SELECT                         seg.*, source_payloads.source_row_id, source_payloads.contributing_row_ids,                          source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                         source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until                     FROM all_segments seg                                              LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE                  ((seg.is_new_entity AND source_row.grouping_key = seg.grouping_key)                 OR                 (NOT seg.is_new_entity AND (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))))              -- v_lateral_join_sr_to_seg                                 AND daterange(seg.valid_from, seg.valid_until) <@ daterange(source_row.valid_from, source_row.valid_until)                             ),                             running_payload AS (                                 SELECT rn, source_row_id, data_payload, ephemeral_payload, valid_from, val"
16b,temporal_merge Parent (With Index),,3398468697331273295,1,171.29375,1000,341,0,0,0,0,139,16613,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     with_base_payload.*,                     with_base_payload.stable_pk_payload as propagated_stable_pk_payload                 FROM (                     SELECT                         seg.*, source_payloads.source_row_id, source_payloads.contributing_row_ids,                          source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                         source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until                     FROM all_segments seg                                              LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE                  ((seg.is_new_entity AND source_row.grouping_key = seg.grouping_key)                 OR                 (NOT seg.is_new_entity AND (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))))              -- v_lateral_join_sr_to_seg                                 AND daterange(seg.valid_from, seg.valid_until) <@ daterange(source_row.valid_from, source_row.valid_until)                             ),                             running_payload AS (                                 SELECT rn, source_row_id, data_payload, ephemeral_payload, valid_from, val"
f4a,temporal_merge Parent (With Index),,-214370746534177287,1,44.683459,0,25248,34,0,0,0,8089,849418,"CALL sql_saga.temporal_merge_execute(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         identity_columns => v_identity_cols_discovered,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         update_source_with_identity => temporal_merge.update_source_with_identity,         lookup_columns => v_natural_identity_cols_discovered,         delete_mode => temporal_merge.delete_mode,         update_source_with_feedback => temporal_merge.update_source_with_feedback,         feedback_status_column => temporal_merge.feedback_status_column,         feedback_status_key => temporal_merge.feedback_status_key,         feedback_error_column => temporal_merge.feedback_error_column,         feedback_error_key => temporal_merge.feedback_error_key,         ephemeral_columns => temporal_merge.ephemeral_columns,         delay_constraints => temporal_merge.delay_constraints     )"
fcb,temporal_merge Parent (With Index),,941778361422124368,1,34.27825,1000,469,0,0,0,0,117,13107,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         -- OPTIMIZATION: Use pre-computed valid_range instead of repeated daterange() calls                         -- Combined with composite index, this provides 30-40 percent total performance improvement                         COALESCE(sql_saga.covers_without_gaps(s2.valid_range, s1.valid_range ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.lookup_columns_unavailable AND (s1.id IS NOT DISTINCT FROM s2.id))                             OR                             (s1.lookup_columns_unavailable AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info"
e1e,temporal_merge Parent (With Index),,9124375050176383526,1,33.777916999999995,1000,296,0,0,0,0,117,13107,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         -- OPTIMIZATION: Use pre-computed valid_range instead of repeated daterange() calls                         -- Combined with composite index, this provides 30-40 percent total performance improvement                         COALESCE(sql_saga.covers_without_gaps(s2.valid_range, s1.valid_range ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.lookup_columns_unavailable AND (s1.id IS NOT DISTINCT FROM s2.id))                             OR                             (s1.lookup_columns_unavailable AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info;"
7e9,temporal_merge Parent (With Index),,1941681265824575303,1,29.223084,1000,23383,34,0,0,0,7771,804993,"UPDATE legal_unit t SET valid_range = p.new_valid_range::daterange, name = CASE WHEN p.data ? 'name' THEN (p.data->>'name')::character varying ELSE t.name END                                 FROM (SELECT *, (entity_keys->>'id')::integer AS id_ek FROM temporal_merge_plan WHERE operation = 'UPDATE' AND statement_seq = 1 ORDER BY plan_op_seq) p                                 WHERE t.id = p.id_ek AND t.valid_range = p.old_valid_range::daterange"
c03,temporal_merge Parent (With Index),,-2046183703977100040,1,10.30475,4000,350,0,0,0,0,117,13309,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
