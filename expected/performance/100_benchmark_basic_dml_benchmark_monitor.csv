log_id,event,label,queryid,calls,total_exec_time,rows,shared_blks_hit,shared_blks_read,temp_blks_read,temp_blks_written,total_plan_time,wal_records,wal_bytes,query
294,Child INSERT (No Index),,2751195442669386938,1,33.026417,1000,19090,2,0,0,0,7020,671252,"INSERT INTO establishment (id, valid_range, legal_unit_id, postal_place) SELECT i, daterange('2015-01-01', 'infinity', '[)'), i, 'New Shop ' || i FROM generate_series(10001, 11000) i"
4a7,Child INSERT (No Index),,3801168477474623637,1000,6.8869329999999955,1000,5000,0,0,0,0,1000,54000,"SELECT 1 FROM (SELECT ""valid_range"" AS r FROM ONLY ""public"".""legal_unit"" x WHERE ""id"" OPERATOR(pg_catalog.=) $1 AND ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.&&) $2::pg_catalog.anyrange FOR KEY SHARE OF x) x1 HAVING   $2::pg_catalog.anyrange OPERATOR(pg_catalog.<@) pg_catalog.range_agg(x1.r)"
b2c,Child INSERT (Plain),,2751195442669386938,1,11.871042,1000,6028,0,0,0,0,3009,326528,"INSERT INTO establishment (id, valid_range, legal_unit_id, postal_place) SELECT i, daterange('2015-01-01', 'infinity', '[)'), i, 'New Shop ' || i FROM generate_series(10001, 11000) i"
568,Child INSERT (With Index),,2751195442669386938,1,38.022417000000004,1000,21021,1,0,0,0,9029,904472,"INSERT INTO establishment (id, valid_range, legal_unit_id, postal_place) SELECT i, daterange('2015-01-01', 'infinity', '[)'), i, 'New Shop ' || i FROM generate_series(11001, 12000) i"
fa1,Child INSERT (With Index),,3801168477474623637,1000,7.223523999999987,1000,5000,0,0,0,0,1000,54000,"SELECT 1 FROM (SELECT ""valid_range"" AS r FROM ONLY ""public"".""legal_unit"" x WHERE ""id"" OPERATOR(pg_catalog.=) $1 AND ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.&&) $2::pg_catalog.anyrange FOR KEY SHARE OF x) x1 HAVING   $2::pg_catalog.anyrange OPERATOR(pg_catalog.<@) pg_catalog.range_agg(x1.r)"
014,Child UPDATE Key (No Index),,2480189997267991601,1,25.678292,1000,24978,3,0,0,0,6042,524001,"UPDATE establishment SET valid_range = daterange('2014-01-01', upper(valid_range), '[)') WHERE id BETWEEN 1 AND 1000"
cdf,Child UPDATE Key (No Index),,3801168477474623637,1000,4.964006999999998,1000,4922,0,0,0,0,1001,54148,"SELECT 1 FROM (SELECT ""valid_range"" AS r FROM ONLY ""public"".""legal_unit"" x WHERE ""id"" OPERATOR(pg_catalog.=) $1 AND ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.&&) $2::pg_catalog.anyrange FOR KEY SHARE OF x) x1 HAVING   $2::pg_catalog.anyrange OPERATOR(pg_catalog.<@) pg_catalog.range_agg(x1.r)"
1c8,Child UPDATE Key (With Index),,2480189997267991601,1,32.266792,1000,27865,3,0,0,0,7025,688545,"UPDATE establishment SET valid_range = daterange('2013-01-01', upper(valid_range), '[)') WHERE id BETWEEN 2001 AND 3000"
c5c,Child UPDATE Key (With Index),,3801168477474623637,1000,6.258452999999996,1000,5964,0,0,0,0,1010,56960,"SELECT 1 FROM (SELECT ""valid_range"" AS r FROM ONLY ""public"".""legal_unit"" x WHERE ""id"" OPERATOR(pg_catalog.=) $1 AND ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.&&) $2::pg_catalog.anyrange FOR KEY SHARE OF x) x1 HAVING   $2::pg_catalog.anyrange OPERATOR(pg_catalog.<@) pg_catalog.range_agg(x1.r)"
8c5,Child UPDATE Non-Key (No Index),,-6603853390843512690,1,15.020624999999999,1000,17647,3,0,0,0,4914,446325,UPDATE establishment SET postal_place = 'New Place' WHERE id BETWEEN 1001 AND 2000
e50,Child UPDATE Non-Key (With Index),,-6603853390843512690,1,19.948376,1000,19859,6,0,0,0,5972,601394,UPDATE establishment SET postal_place = 'New Place Again' WHERE id BETWEEN 3001 AND 4000
cfc,"Parent DELETE (Check Only, No Index)",,-2355103134172566288,1,949.783209,1000,136014,0,0,0,0,1000,54000,DELETE FROM legal_unit WHERE id BETWEEN 20001 AND 21000
547,"Parent DELETE (Check Only, No Index)",,476854885423386359,1000,929.6719019999999,0,130000,0,0,0,0,0,0,"SELECT 1 FROM ONLY ""public"".""establishment"" x WHERE $1 OPERATOR(pg_catalog.=) ""legal_unit_id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange AND NOT coalesce(  (  ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.*) $2::pg_catalog.anyrange)::pg_catalog.anyrange OPERATOR(pg_catalog.<@) (SELECT pg_catalog.range_agg(r) FROM (SELECT y.""valid_range"" r FROM ONLY ""public"".""legal_unit"" y WHERE $1 OPERATOR(pg_catalog.=) ""id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange FOR KEY SHARE OF y) y2), false) FOR KEY SHARE OF x"
e7a,"Parent DELETE (Check Only, No Index)",,-6873348994332248717,1000,1.3089819999999972,1000,2000,0,0,0,0,0,0,SELECT EXISTS (SELECT 1 FROM public.projects AS fk WHERE fk.legal_unit_id = $1)
9c1,"Parent DELETE (Check Only, With Index)",,-2355103134172566288,1,14.670333000000001,1000,7013,0,0,0,0,1000,54000,DELETE FROM legal_unit WHERE id BETWEEN 21001 AND 22000
791,"Parent DELETE (Check Only, With Index)",,476854885423386359,1000,1.5867349999999931,0,1000,0,0,0,0,0,0,"SELECT 1 FROM ONLY ""public"".""establishment"" x WHERE $1 OPERATOR(pg_catalog.=) ""legal_unit_id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange AND NOT coalesce(  (  ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.*) $2::pg_catalog.anyrange)::pg_catalog.anyrange OPERATOR(pg_catalog.<@) (SELECT pg_catalog.range_agg(r) FROM (SELECT y.""valid_range"" r FROM ONLY ""public"".""legal_unit"" y WHERE $1 OPERATOR(pg_catalog.=) ""id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange FOR KEY SHARE OF y) y2), false) FOR KEY SHARE OF x"
0e1,"Parent DELETE (Check Only, With Index)",,-6873348994332248717,1000,0.7281729999999941,1000,2000,0,0,0,0,0,0,SELECT EXISTS (SELECT 1 FROM public.projects AS fk WHERE fk.legal_unit_id = $1)
83c,Parent DELETE (No Index),,-2355103134172566288,1,945.8474580000001,1000,136044,4,0,0,0,1000,54000,DELETE FROM legal_unit WHERE id BETWEEN 15001 AND 16000
edf,Parent DELETE (No Index),,476854885423386359,1000,925.1811249999996,0,130000,0,0,0,0,0,0,"SELECT 1 FROM ONLY ""public"".""establishment"" x WHERE $1 OPERATOR(pg_catalog.=) ""legal_unit_id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange AND NOT coalesce(  (  ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.*) $2::pg_catalog.anyrange)::pg_catalog.anyrange OPERATOR(pg_catalog.<@) (SELECT pg_catalog.range_agg(r) FROM (SELECT y.""valid_range"" r FROM ONLY ""public"".""legal_unit"" y WHERE $1 OPERATOR(pg_catalog.=) ""id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange FOR KEY SHARE OF y) y2), false) FOR KEY SHARE OF x"
f68,Parent DELETE (No Index),,-6873348994332248717,1000,1.3164789999999975,1000,2000,0,0,0,0,0,0,SELECT EXISTS (SELECT 1 FROM public.projects AS fk WHERE fk.legal_unit_id = $1)
1ad,Parent DELETE (With Index),,-2355103134172566288,1,14.652334,1000,7020,0,0,0,0,1000,54000,DELETE FROM legal_unit WHERE id BETWEEN 16001 AND 17000
fc8,Parent DELETE (With Index),,476854885423386359,1000,1.5844229999999977,0,1000,0,0,0,0,0,0,"SELECT 1 FROM ONLY ""public"".""establishment"" x WHERE $1 OPERATOR(pg_catalog.=) ""legal_unit_id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange AND NOT coalesce(  (  ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.*) $2::pg_catalog.anyrange)::pg_catalog.anyrange OPERATOR(pg_catalog.<@) (SELECT pg_catalog.range_agg(r) FROM (SELECT y.""valid_range"" r FROM ONLY ""public"".""legal_unit"" y WHERE $1 OPERATOR(pg_catalog.=) ""id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange FOR KEY SHARE OF y) y2), false) FOR KEY SHARE OF x"
92b,Parent DELETE (With Index),,-6873348994332248717,1000,0.721796999999995,1000,2000,0,0,0,0,0,0,SELECT EXISTS (SELECT 1 FROM public.projects AS fk WHERE fk.legal_unit_id = $1)
a22,Parent INSERT (No Index),,-6962160005659942149,1,29.674792,1000,13029,1,0,0,0,6020,614944,"INSERT INTO legal_unit (id, valid_range, name) SELECT i, daterange('2015-01-01', 'infinity', '[)'), 'New Company ' || i FROM generate_series(20001, 21000) i"
b12,Parent INSERT (Plain),,-6962160005659942149,1,18.774416,1000,6028,0,0,0,0,3009,323528,"INSERT INTO legal_unit (id, valid_range, name) SELECT i, daterange('2015-01-01', 'infinity', '[)'), 'New Company ' || i FROM generate_series(20001, 21000) i"
113,Parent INSERT (With Index),,-6962160005659942149,1,30.409208,1000,13038,0,0,0,0,6020,621576,"INSERT INTO legal_unit (id, valid_range, name) SELECT i, daterange('2015-01-01', 'infinity', '[)'), 'New Company ' || i FROM generate_series(21001, 22000) i"
654,Parent UPDATE Key (No Index),,-5008329604151558703,1,966.7262920000001,1000,154891,4,0,0,0,6042,529094,"UPDATE legal_unit SET valid_range = daterange('2014-01-01', upper(valid_range), '[)') WHERE id BETWEEN 1 AND 1000"
cca,Parent UPDATE Key (No Index),,476854885423386359,1000,932.6191810000004,0,134774,0,0,0,0,1000,54000,"SELECT 1 FROM ONLY ""public"".""establishment"" x WHERE $1 OPERATOR(pg_catalog.=) ""legal_unit_id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange AND NOT coalesce(  (  ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.*) $2::pg_catalog.anyrange)::pg_catalog.anyrange OPERATOR(pg_catalog.<@) (SELECT pg_catalog.range_agg(r) FROM (SELECT y.""valid_range"" r FROM ONLY ""public"".""legal_unit"" y WHERE $1 OPERATOR(pg_catalog.=) ""id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange FOR KEY SHARE OF y) y2), false) FOR KEY SHARE OF x"
05a,Parent UPDATE Key (With Index),,-5008329604151558703,1,40.719541,1000,27939,7,0,0,0,6004,518840,"UPDATE legal_unit SET valid_range = daterange('2013-01-01', upper(valid_range), '[)') WHERE id BETWEEN 2001 AND 3000"
b89,Parent UPDATE Key (With Index),,476854885423386359,1000,11.652670999999986,0,7957,7,0,0,0,1001,54192,"SELECT 1 FROM ONLY ""public"".""establishment"" x WHERE $1 OPERATOR(pg_catalog.=) ""legal_unit_id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange AND NOT coalesce(  (  ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.*) $2::pg_catalog.anyrange)::pg_catalog.anyrange OPERATOR(pg_catalog.<@) (SELECT pg_catalog.range_agg(r) FROM (SELECT y.""valid_range"" r FROM ONLY ""public"".""legal_unit"" y WHERE $1 OPERATOR(pg_catalog.=) ""id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange FOR KEY SHARE OF y) y2), false) FOR KEY SHARE OF x"
e8b,Parent UPDATE Non-Key (No Index),,4340914437108901275,1,17.429958,1000,17458,3,0,0,0,4866,442880,UPDATE legal_unit SET name = 'Updated Company' WHERE id BETWEEN 1001 AND 2000
54e,Parent UPDATE Non-Key (With Index),,4340914437108901275,1,20.155876,1000,17976,0,0,0,0,4995,462554,UPDATE legal_unit SET name = 'Updated Again Company' WHERE id BETWEEN 3001 AND 4000
134,Regular INSERT (No Index),,-8805169522762314890,1,11.009458,1000,9051,0,0,0,0,3034,217010,"INSERT INTO projects (name, legal_unit_id) SELECT 'New Project ' || i, i FROM generate_series(10001, 11000) i"
f48,Regular INSERT (No Index),,-1640871935848111309,1000,5.706032999999999,1000,3000,0,0,0,0,0,0,SELECT EXISTS (SELECT 1 FROM public.legal_unit AS uk WHERE uk.id = $1)
afe,Regular INSERT (With Index),,-8805169522762314890,1,11.266458,1000,9020,0,0,0,0,3036,218530,"INSERT INTO projects (name, legal_unit_id) SELECT 'New Project ' || i, i FROM generate_series(11001, 12000) i"
c69,Regular INSERT (With Index),,-1640871935848111309,1000,6.099311999999979,1000,3000,0,0,0,0,0,0,                 SELECT EXISTS (SELECT 1 FROM public.legal_unit AS uk WHERE uk.id = $1);             
32d,temporal_merge Child (With Index),,3129647334844679530,1,6066.858459,0,251884,66,0,0,0,12298,1395109,"CALL sql_saga.temporal_merge('establishment'::regclass, 'establishment_source'::regclass, ARRAY['id'])"
39f,temporal_merge Child (With Index),,-5150911365674690020,1,5779.622458,0,235463,65,0,0,0,8162,886158,"CALL sql_saga.temporal_merge_execute(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         identity_columns => v_identity_cols_discovered,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         update_source_with_identity => temporal_merge.update_source_with_identity,         lookup_columns => v_natural_identity_cols_discovered,         delete_mode => temporal_merge.delete_mode,         update_source_with_feedback => temporal_merge.update_source_with_feedback,         feedback_status_column => temporal_merge.feedback_status_column,         feedback_status_key => temporal_merge.feedback_status_key,         feedback_error_column => temporal_merge.feedback_error_column,         feedback_error_key => temporal_merge.feedback_error_key,         ephemeral_columns => temporal_merge.ephemeral_columns,         delay_constraints => temporal_merge.delay_constraints     )"
ca0,temporal_merge Child (With Index),,-875214823954012780,1,5769.487042,1000,233625,65,0,0,0,7890,854592,"UPDATE establishment t SET valid_range = daterange(p.new_valid_from::date, p.new_valid_until::date, '[)'), legal_unit_id = CASE WHEN p.data ? 'legal_unit_id' THEN (p.data->>'legal_unit_id')::integer ELSE t.legal_unit_id END, postal_place = CASE WHEN p.data ? 'postal_place' THEN (p.data->>'postal_place')::text ELSE t.postal_place END                                 FROM (SELECT * FROM temporal_merge_plan WHERE operation = 'UPDATE' AND statement_seq = 1 ORDER BY plan_op_seq) p,                                      LATERAL jsonb_populate_record(null::establishment, p.entity_keys) AS jpr_entity                                 WHERE (t.id = jpr_entity.id OR (t.id IS NULL AND jpr_entity.id IS NULL)) AND t.valid_range = daterange(p.old_valid_from::date, p.old_valid_until::date, '[)')"
ea9,temporal_merge Child (With Index),,5938474169747182753,1,284.993917,1000,15597,1,0,0,0,3961,490035,"INSERT INTO temporal_merge_plan     SELECT * FROM sql_saga.temporal_merge_plan(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         identity_columns => v_identity_cols_discovered,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         delete_mode => temporal_merge.delete_mode,         lookup_keys => v_natural_identity_keys_discovered,         ephemeral_columns => temporal_merge.ephemeral_columns,         p_log_trace => v_log_trace,         p_log_sql => v_log_sql     )"
e7b,temporal_merge Child (With Index),,4748073848864616921,1,96.435959,1000,407,0,0,0,0,125,14981,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.natural_identity_column_values_are_null, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON (target_row.id = seg.id OR (target_row.id IS NULL AND seg.id IS NULL))                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                 WHERE NOT seg.is_new_entity"
b78,temporal_merge Child (With Index),,-4685191513584255900,1,95.976083,1000,313,0,0,0,0,125,14981,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.natural_identity_column_values_are_null, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON (target_row.id = seg.id OR (target_row.id IS NULL AND seg.id IS NULL))                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                 WHERE NOT seg.is_new_entity"
cff,temporal_merge Child (With Index),,6861769497996543887,1,35.669125,1000,429,0,0,0,0,117,13017,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         COALESCE(sql_saga.covers_without_gaps(daterange(s2.valid_from, s2.valid_until), daterange(s1.valid_from, s1.valid_until) ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.natural_identity_column_values_are_null AND (s1.id IS NOT DISTINCT FROM s2.id))                             OR                             (s1.natural_identity_column_values_are_null AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info"
1d0,temporal_merge Child (With Index),,-7728234800695806957,1,35.181291,1000,299,0,0,0,0,115,12871,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         COALESCE(sql_saga.covers_without_gaps(daterange(s2.valid_from, s2.valid_until), daterange(s1.valid_from, s1.valid_until) ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.natural_identity_column_values_are_null AND (s1.id IS NOT DISTINCT FROM s2.id))                             OR                             (s1.natural_identity_column_values_are_null AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info;"
599,temporal_merge Child (With Index),,-408891117950312342,1,28.470125,1000,389,0,0,0,0,120,14251,"CREATE TEMP TABLE source_rows_with_matches ON COMMIT DROP AS                 SELECT                     source_row.*,                     target_row.stable_pk_payload as discovered_stable_pk_payload,                     target_row.id AS discovered_id_1 /* v_propagated_id_cols_list */                 FROM source_with_eclipsed_flag source_row                 LEFT JOIN target_rows target_row ON (((source_row.id IS NOT DISTINCT FROM target_row.id)) /* v_source_rows_exists_join_expr */)"
973,temporal_merge Child (With Index),,3626869770245442582,1,28.095041000000002,1000,305,0,0,0,0,120,14251,"CREATE TEMP TABLE source_rows_with_matches ON COMMIT DROP AS                 SELECT                     source_row.*,                     target_row.stable_pk_payload as discovered_stable_pk_payload,                     target_row.id AS discovered_id_1 /* v_propagated_id_cols_list */                 FROM source_with_eclipsed_flag source_row                 LEFT JOIN target_rows target_row ON (((source_row.id IS NOT DISTINCT FROM target_row.id)) /* v_source_rows_exists_join_expr */)"
a17,temporal_merge Child (With Index),,-2046183703977100040,1,10.600584,4000,362,0,0,0,0,116,13093,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
4f0,temporal_merge Child (With Index),,5813186476201306677,1,10.190417,4000,294,0,0,0,0,116,13093,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || CASE WHEN canonical_nk_json IS NOT NULL AND canonical_nk_json <> '{}'::jsonb THEN COALESCE(canonical_nk_json->>'id', '_NULL_') ELSE COALESCE(id::text, '_NULL_') END                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
9e9,temporal_merge Parent (With Index),,3129647334844679530,1,11713.877584,0,364037,90,0,0,0,11321,1240980,"CALL sql_saga.temporal_merge('legal_unit'::regclass, 'legal_unit_source'::regclass, ARRAY['id'])"
f2b,temporal_merge Parent (With Index),,-5150911365674690020,1,11274.529458,0,348083,89,0,0,0,7071,724264,"CALL sql_saga.temporal_merge_execute(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         identity_columns => v_identity_cols_discovered,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         update_source_with_identity => temporal_merge.update_source_with_identity,         lookup_columns => v_natural_identity_cols_discovered,         delete_mode => temporal_merge.delete_mode,         update_source_with_feedback => temporal_merge.update_source_with_feedback,         feedback_status_column => temporal_merge.feedback_status_column,         feedback_status_key => temporal_merge.feedback_status_key,         feedback_error_column => temporal_merge.feedback_error_column,         feedback_error_key => temporal_merge.feedback_error_key,         ephemeral_columns => temporal_merge.ephemeral_columns,         delay_constraints => temporal_merge.delay_constraints     )"
c11,temporal_merge Parent (With Index),,6310308972176971051,1,11262.785291,1000,346552,89,0,0,0,6803,694577,"UPDATE legal_unit t SET valid_range = daterange(p.new_valid_from::date, p.new_valid_until::date, '[)'), name = CASE WHEN p.data ? 'name' THEN (p.data->>'name')::character varying ELSE t.name END                                 FROM (SELECT * FROM temporal_merge_plan WHERE operation = 'UPDATE' AND statement_seq = 1 ORDER BY plan_op_seq) p,                                      LATERAL jsonb_populate_record(null::legal_unit, p.entity_keys) AS jpr_entity                                 WHERE (t.id = jpr_entity.id OR (t.id IS NULL AND jpr_entity.id IS NULL)) AND t.valid_range = daterange(p.old_valid_from::date, p.old_valid_until::date, '[)')"
6e9,temporal_merge Parent (With Index),,5938474169747182753,1,436.93929199999997,1000,15213,1,0,0,0,4078,498036,"INSERT INTO temporal_merge_plan     SELECT * FROM sql_saga.temporal_merge_plan(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         identity_columns => v_identity_cols_discovered,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         delete_mode => temporal_merge.delete_mode,         lookup_keys => v_natural_identity_keys_discovered,         ephemeral_columns => temporal_merge.ephemeral_columns,         p_log_trace => v_log_trace,         p_log_sql => v_log_sql     )"
b0d,temporal_merge Parent (With Index),,6154451618595993138,1,171.663625,1000,496,0,0,0,0,144,17375,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     with_base_payload.*,                     with_base_payload.stable_pk_payload as propagated_stable_pk_payload                 FROM (                     SELECT                         seg.*, source_payloads.source_row_id, source_payloads.contributing_row_ids,                          source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                         source_payloads.causal_id as s_causal_id, source_payloads.causal_id as direct_source_causal_id,                         source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until                     FROM all_segments seg                                              LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE                  ((seg.is_new_entity AND source_row.grouping_key = seg.grouping_key)                 OR                 (NOT seg.is_new_entity AND (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))))              -- v_lateral_join_sr_to_seg                                 AND daterange(seg.valid_from, seg.valid_until) <@ daterange(source_row.valid_from, source_row.valid_until)                             ),                             running"
24a,temporal_merge Parent (With Index),,4536585701180346213,1,170.922001,1000,352,0,0,0,0,144,17375,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     with_base_payload.*,                     with_base_payload.stable_pk_payload as propagated_stable_pk_payload                 FROM (                     SELECT                         seg.*, source_payloads.source_row_id, source_payloads.contributing_row_ids,                          source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                         source_payloads.causal_id as s_causal_id, source_payloads.causal_id as direct_source_causal_id,                         source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until                     FROM all_segments seg                                              LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE                  ((seg.is_new_entity AND source_row.grouping_key = seg.grouping_key)                 OR                 (NOT seg.is_new_entity AND (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))))              -- v_lateral_join_sr_to_seg                                 AND daterange(seg.valid_from, seg.valid_until) <@ daterange(source_row.valid_from, source_row.valid_until)                             ),                             running"
650,temporal_merge Parent (With Index),,4748073848864616921,1,93.946917,1000,396,0,0,0,0,126,14959,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.natural_identity_column_values_are_null, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON (target_row.id = seg.id OR (target_row.id IS NULL AND seg.id IS NULL))                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                 WHERE NOT seg.is_new_entity"
730,temporal_merge Parent (With Index),,-4685191513584255900,1,93.48720900000001,1000,314,0,0,0,0,126,14959,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.natural_identity_column_values_are_null, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON (target_row.id = seg.id OR (target_row.id IS NULL AND seg.id IS NULL))                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                 WHERE NOT seg.is_new_entity"
eae,temporal_merge Parent (With Index),,6861769497996543887,1,34.221208,1000,410,0,0,0,0,115,12899,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         COALESCE(sql_saga.covers_without_gaps(daterange(s2.valid_from, s2.valid_until), daterange(s1.valid_from, s1.valid_until) ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.natural_identity_column_values_are_null AND (s1.id IS NOT DISTINCT FROM s2.id))                             OR                             (s1.natural_identity_column_values_are_null AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info"
4e9,temporal_merge Parent (With Index),,-7728234800695806957,1,33.727208000000005,1000,288,0,0,0,0,115,12899,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         COALESCE(sql_saga.covers_without_gaps(daterange(s2.valid_from, s2.valid_until), daterange(s1.valid_from, s1.valid_until) ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.natural_identity_column_values_are_null AND (s1.id IS NOT DISTINCT FROM s2.id))                             OR                             (s1.natural_identity_column_values_are_null AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info;"
fe5,temporal_merge Parent (With Index),,-408891117950312342,1,27.954083,1000,367,0,0,0,0,119,13511,"CREATE TEMP TABLE source_rows_with_matches ON COMMIT DROP AS                 SELECT                     source_row.*,                     target_row.stable_pk_payload as discovered_stable_pk_payload,                     target_row.id AS discovered_id_1 /* v_propagated_id_cols_list */                 FROM source_with_eclipsed_flag source_row                 LEFT JOIN target_rows target_row ON (((source_row.id IS NOT DISTINCT FROM target_row.id)) /* v_source_rows_exists_join_expr */)"
d76,temporal_merge Parent (With Index),,3626869770245442582,1,27.592958,1000,293,0,0,0,0,119,13511,"CREATE TEMP TABLE source_rows_with_matches ON COMMIT DROP AS                 SELECT                     source_row.*,                     target_row.stable_pk_payload as discovered_stable_pk_payload,                     target_row.id AS discovered_id_1 /* v_propagated_id_cols_list */                 FROM source_with_eclipsed_flag source_row                 LEFT JOIN target_rows target_row ON (((source_row.id IS NOT DISTINCT FROM target_row.id)) /* v_source_rows_exists_join_expr */)"
