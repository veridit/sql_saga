log_id,event,label,queryid,calls,total_exec_time,rows,shared_blks_hit,shared_blks_read,temp_blks_read,temp_blks_written,total_plan_time,wal_records,wal_bytes,query
30d,Generate Test Data - 10000 entities,,6543231661289968569,1,1227.752958,1,1010817,3,0,0,0,604326,54844151,"SELECT etl_bench.generate_test_data(v_dataset_size, 3, 5)"
e4e,Generate Test Data - 10000 entities,,1750016048022143304,1,1225.754333,150000,1010359,3,0,0,0,604272,54840161,"INSERT INTO etl_bench.data_table (         row_id, batch, identity_correlation, comment,         tax_ident, lu_name, physical_address, postal_address,         activity_code, employees, turnover, valid_from, valid_until     )     SELECT          row_number() OVER () as row_id,         batch_num,         entity_num as identity_correlation,         format('Entity %s batch %s row %s', entity_num, batch_num, row_in_batch_num) as comment,         CASE WHEN row_in_batch_num = 1 THEN format('TAX%s', entity_num) END as tax_ident,         CASE WHEN row_in_batch_num = 1 THEN format('Company-%s', entity_num) END as lu_name,         CASE WHEN row_in_batch_num <= 2 THEN format('%s Main St, City %s', entity_num, entity_num) END as physical_address,         CASE WHEN row_in_batch_num <= 3 THEN format('PO Box %s', entity_num) END as postal_address,         CASE WHEN row_in_batch_num <= 4 THEN (CASE WHEN entity_num % 2 = 0 THEN 'manufacturing' ELSE 'retail' END) END as activity_code,         CASE WHEN row_in_batch_num <= 4 THEN (entity_num % 100) + 10 END as employees,         CASE WHEN row_in_batch_num <= 5 THEN (entity_num % 1000) * 1000 + 50000 END as turnover,         ('2024-01-01'::date + ((batch_num - 1) * 90 + (row_in_batch_num - 1) * 30)) as valid_from,         'infinity'::date as valid_until     FROM          generate_series(1, p_total_entities) as entity_num,         generate_series(1, p_batches_per_entity) as batch_num,         generate_series(1, p_rows_per_entity_per_batch) as row_in_batch_num"
87f,Process Legal Units - Batch 1,,7104651493870380753,1,27230.189708,0,2186165,6,0,0,0,911553,83544818,CALL etl_bench.process_legal_units(v_batch_id)
ae0,Process Legal Units - Batch 1,,-5532412991206003072,1,25552.670125,0,430284,5,0,0,0,175567,17806620,"CALL sql_saga.temporal_merge(         target_table => 'etl_bench.legal_unit',         source_table => 'source_view_lu',         primary_identity_columns => ARRAY['id'],         ephemeral_columns => ARRAY['comment'],         mode => 'MERGE_ENTITY_PATCH',         founding_id_column => 'founding_id',         update_source_with_identity => true,         update_source_with_feedback => true,         feedback_status_column => 'merge_statuses',         feedback_status_key => 'legal_unit',         feedback_error_column => 'merge_errors',         feedback_error_key => 'legal_unit'     )"
a33,Process Legal Units - Batch 1,,-4634225613452528969,1,20296.205583,10000,17934,2,0,0,0,4105,505530,"INSERT INTO temporal_merge_plan     SELECT * FROM sql_saga.temporal_merge_plan(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         identity_columns => v_identity_cols_discovered,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         delete_mode => temporal_merge.delete_mode,         lookup_keys => v_natural_identity_keys_discovered,         ephemeral_columns => temporal_merge.ephemeral_columns,         p_log_trace => v_log_trace,         p_log_sql => v_log_sql     )"
78b,Process Legal Units - Batch 1,,6020602004421484228,1,17083.734041,10000,487,0,0,0,0,140,19809,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     with_base_payload.*,                     with_base_payload.stable_pk_payload as propagated_stable_pk_payload                 FROM (                     SELECT                         seg.*, source_payloads.source_row_id, source_payloads.contributing_row_ids,                          source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                         source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until                     FROM all_segments seg                                              LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE                  ((seg.is_new_entity AND source_row.grouping_key = seg.grouping_key)                 OR                 (NOT seg.is_new_entity AND (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))))              -- v_lateral_join_sr_to_seg                                 AND daterange(seg.valid_from, seg.valid_until) <@ daterange(source_row.valid_from, source_row.valid_until)                             ),                             running_payload AS (                                 SELECT rn, source_row_id, data_payload, ephemeral_payload, valid_from, val"
a34,Process Legal Units - Batch 1,,-4153295300979878628,1,17082.841542000002,10000,341,0,0,0,0,140,19809,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     with_base_payload.*,                     with_base_payload.stable_pk_payload as propagated_stable_pk_payload                 FROM (                     SELECT                         seg.*, source_payloads.source_row_id, source_payloads.contributing_row_ids,                          source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                         source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until                     FROM all_segments seg                                              LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE                  ((seg.is_new_entity AND source_row.grouping_key = seg.grouping_key)                 OR                 (NOT seg.is_new_entity AND (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))))              -- v_lateral_join_sr_to_seg                                 AND daterange(seg.valid_from, seg.valid_until) <@ daterange(source_row.valid_from, source_row.valid_until)                             ),                             running_payload AS (                                 SELECT rn, source_row_id, data_payload, ephemeral_payload, valid_from, val"
320,Process Legal Units - Batch 1,,4313330175016020501,1,5253.518667,0,411584,3,0,0,0,171279,17277576,"CALL sql_saga.temporal_merge_execute(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         identity_columns => v_identity_cols_discovered,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         update_source_with_identity => temporal_merge.update_source_with_identity,         lookup_columns => v_natural_identity_cols_discovered,         delete_mode => temporal_merge.delete_mode,         update_source_with_feedback => temporal_merge.update_source_with_feedback,         feedback_status_column => temporal_merge.feedback_status_column,         feedback_status_key => temporal_merge.feedback_status_key,         feedback_error_column => temporal_merge.feedback_error_column,         feedback_error_key => temporal_merge.feedback_error_key,         ephemeral_columns => temporal_merge.ephemeral_columns,         delay_constraints => temporal_merge.delay_constraints     )"
3ff,Process Legal Units - Batch 1,,-7386894901326954567,1,4688.083833000001,10000,123732,0,0,0,0,50001,4668240,"WITH map_row_to_entity AS (                                     SELECT DISTINCT ON (s.source_row_id)                                         s.source_row_id,                                         p.entity_keys                                     FROM (SELECT DISTINCT unnest(row_ids) AS source_row_id FROM temporal_merge_plan WHERE operation = 'INSERT') s                                     JOIN temporal_merge_plan p ON s.source_row_id = ANY(p.row_ids)                                     WHERE p.entity_keys IS NOT NULL                                     ORDER BY s.source_row_id, p.plan_op_seq                                 )                                 UPDATE source_view_lu s                                 SET id = (p.entity_keys->>'id')::integer                                 FROM map_row_to_entity p                                 WHERE s.row_id = p.source_row_id"
95e,Process Legal Units - Batch 1,,-788747283814772468,1,2538.71025,10000,470,0,0,0,0,121,14083,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         -- OPTIMIZATION: Use pre-computed valid_range instead of repeated daterange() calls                         -- Combined with composite index, this provides 30-40 percent total performance improvement                         COALESCE(sql_saga.covers_without_gaps(s2.valid_range, s1.valid_range ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.lookup_columns_unavailable AND (false))                             OR                             (s1.lookup_columns_unavailable AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info"
78a,Process Legal Units - Batch 1,,4573562956278615873,1,2538.072417,10000,295,0,0,0,0,121,14083,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         -- OPTIMIZATION: Use pre-computed valid_range instead of repeated daterange() calls                         -- Combined with composite index, this provides 30-40 percent total performance improvement                         COALESCE(sql_saga.covers_without_gaps(s2.valid_range, s1.valid_range ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.lookup_columns_unavailable AND (false))                             OR                             (s1.lookup_columns_unavailable AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info;"
244,Process Legal Units - Batch 1,,-3169870935594387745,1,1611.089667,140000,1693373,0,0,0,0,705878,63822867,UPDATE etl_bench.data_table dt     SET legal_unit_id = ir.legal_unit_id     FROM etl_bench.identity_resolution ir     WHERE dt.identity_correlation = ir.identity_correlation       AND dt.legal_unit_id IS NULL
cc2,Process Legal Units - Batch 1,,6226936418218099458,1,388.381666,10000,148692,3,0,0,0,70372,7471053,"WITH founding_plan_ops AS (                                     SELECT DISTINCT ON (p.grouping_key)                                         p.plan_op_seq,                                         p.causal_id,                                         p.grouping_key,                                         p.new_valid_range,                                         p.entity_keys || p.data as full_data                                     FROM temporal_merge_plan p                                     WHERE p.operation = 'INSERT' AND p.is_new_entity                                     ORDER BY p.grouping_key, p.plan_op_seq                                 ),                                 id_map_cte AS (                                     MERGE INTO etl_bench.legal_unit t                                     USING founding_plan_ops s ON false                                     WHEN NOT MATCHED THEN                                         INSERT (id, name, comment, valid_range)                                         VALUES (COALESCE((s.full_data->>'id')::integer, nextval('etl_bench.legal_unit_id_seq'::regclass)), (s.full_data->>'name')::text, (s.full_data->>'comment')::text, s.new_valid_range::daterange)                                     RETURNING t.*, s.causal_id, s.grouping_key                                 )                                 INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)                                 SELECT                                     ir.grouping_key,                                     ir.causal_id,                                     jsonb_build_object('id', ir.id)                                 FROM id_map_cte ir"
f6f,Process Legal Units - Batch 1,,-6251707813684716315,1,85.610626,10000,133534,0,0,0,0,50410,5072976,"UPDATE source_view_lu s             SET merge_statuses = COALESCE(s.merge_statuses, '{}'::jsonb) || jsonb_build_object('legal_unit', f.status), merge_errors = CASE WHEN f.error_message IS NOT NULL THEN COALESCE(s.merge_errors, '{}'::jsonb) || jsonb_build_object('legal_unit', f.error_message) ELSE COALESCE(s.merge_errors, '{}'::jsonb) - 'legal_unit' END             FROM pg_temp.temporal_merge_feedback f             WHERE s.row_id = f.source_row_id"
dd0,Process Legal Units - Batch 1,,7295163325594009324,1,64.625458,10000,62277,1,0,0,0,30037,1906828,"INSERT INTO etl_bench.identity_resolution (identity_correlation, legal_unit_id, resolved_batch)     SELECT DISTINCT          identity_correlation,         legal_unit_id,         p_batch_id     FROM etl_bench.data_table     WHERE batch = p_batch_id AND legal_unit_id IS NOT NULL     ON CONFLICT (identity_correlation) DO UPDATE SET         legal_unit_id = EXCLUDED.legal_unit_id,         resolved_batch = EXCLUDED.resolved_batch"
bbb,Process Legal Units - Batch 1,,9079426233396750581,1,64.485333,10000,494,0,0,0,0,154,18709,"CREATE TEMP TABLE resolved_atomic_segments_with_propagated_ids ON COMMIT DROP AS                 SELECT                     *,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY grouping_key ORDER BY valid_from) as unified_canonical_nk_json,                     COALESCE(                         contributing_row_ids,                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as causal_source_row_ids,                     COALESCE(                         s_valid_from,                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_from,                     COALESCE(                         s_valid_until,                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_until                 FROM (                     SELECT                         *,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from) AS look_behind_grp,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from DESC) AS look_ahead_grp                     FROM resolved_atomic_segments_with_payloads /* v_resolver_from */                 ) with_grp"
058,Process Legal Units - Batch 1,,8086196219516147042,1,63.779292,10000,364,0,0,0,0,152,18589,"CREATE TEMP TABLE resolved_atomic_segments_with_propagated_ids ON COMMIT DROP AS                 SELECT                     *,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY grouping_key ORDER BY valid_from) as unified_canonical_nk_json,                     COALESCE(                         contributing_row_ids,                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as causal_source_row_ids,                     COALESCE(                         s_valid_from,                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_from,                     COALESCE(                         s_valid_until,                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_until                 FROM (                     SELECT                         *,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from) AS look_behind_grp,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from DESC) AS look_ahead_grp                     FROM resolved_atomic_segments_with_payloads /* v_resolver_from */                 ) with_grp"
83e,Process Legal Units - Batch 1,,2973456759399252638,1,61.06875,10000,435,0,0,0,0,127,14342,"CREATE TEMP TABLE coalesced_final_segments ON COMMIT DROP AS                 SELECT                     grouping_key, max(id) as id,                     sql_saga.first(causal_id ORDER BY valid_from) as causal_id,                     sql_saga.first(stable_identity_columns_are_null ORDER BY valid_from) as stable_identity_columns_are_null,                     sql_saga.first(lookup_columns_unavailable ORDER BY valid_from) as lookup_columns_unavailable,                     sql_saga.first(is_new_entity ORDER BY valid_from) as is_new_entity,                     sql_saga.first(is_identifiable ORDER BY valid_from) as is_identifiable,                     sql_saga.first(is_ambiguous ORDER BY valid_from) as is_ambiguous,                     sql_saga.first(conflicting_ids ORDER BY valid_from) as conflicting_ids,                     sql_saga.first(unified_canonical_nk_json ORDER BY valid_from) as canonical_nk_json,                     sql_saga.first(orig_source_target_relation ORDER BY valid_from) as orig_source_target_relation,                     sql_saga.first(t_valid_from ORDER BY valid_from) as ancestor_valid_from,                     MIN(valid_from) as valid_from,                     MAX(valid_until) as valid_until,                     (sql_saga.first(data_payload ORDER BY valid_from DESC) || sql_saga.first(ephemeral_payload ORDER BY valid_from DESC)) as final_payload,                     sql_saga.first(stable_pk_payload ORDER BY valid_from DESC) as stable_pk_payload,                     bool_and(unaffected_target_only_segment) as unaffected_target_only_segment,                     (SELECT array_agg(DISTINCT e) FROM unnest(array_concat_agg(causal_source_row_ids)) e WHERE e IS NOT NULL) as row_ids,                     CASE WHEN 'f'::boolean                         THEN jsonb_build_object( 'cte', 'coalesced', 'island_group_id', island_group_id, 'coalesced_stable_pk', sql_saga.first(stable_pk_payload ORDER BY valid_from DESC), 'final_payload', sql_saga.first(data_payload ORDER BY valid_from DESC), 'final_payload_sans_epheme"
783,Process Legal Units - Batch 1,,-8237077405251109710,1,60.580041,10000,317,0,0,0,0,127,14342,"CREATE TEMP TABLE coalesced_final_segments ON COMMIT DROP AS                 SELECT                     grouping_key, max(id) as id,                     sql_saga.first(causal_id ORDER BY valid_from) as causal_id,                     sql_saga.first(stable_identity_columns_are_null ORDER BY valid_from) as stable_identity_columns_are_null,                     sql_saga.first(lookup_columns_unavailable ORDER BY valid_from) as lookup_columns_unavailable,                     sql_saga.first(is_new_entity ORDER BY valid_from) as is_new_entity,                     sql_saga.first(is_identifiable ORDER BY valid_from) as is_identifiable,                     sql_saga.first(is_ambiguous ORDER BY valid_from) as is_ambiguous,                     sql_saga.first(conflicting_ids ORDER BY valid_from) as conflicting_ids,                     sql_saga.first(unified_canonical_nk_json ORDER BY valid_from) as canonical_nk_json,                     sql_saga.first(orig_source_target_relation ORDER BY valid_from) as orig_source_target_relation,                     sql_saga.first(t_valid_from ORDER BY valid_from) as ancestor_valid_from,                     MIN(valid_from) as valid_from,                     MAX(valid_until) as valid_until,                     (sql_saga.first(data_payload ORDER BY valid_from DESC) || sql_saga.first(ephemeral_payload ORDER BY valid_from DESC)) as final_payload,                     sql_saga.first(stable_pk_payload ORDER BY valid_from DESC) as stable_pk_payload,                     bool_and(unaffected_target_only_segment) as unaffected_target_only_segment,                     (SELECT array_agg(DISTINCT e) FROM unnest(array_concat_agg(causal_source_row_ids)) e WHERE e IS NOT NULL) as row_ids,                     CASE WHEN 'f'::boolean                         THEN jsonb_build_object( 'cte', 'coalesced', 'island_group_id', island_group_id, 'coalesced_stable_pk', sql_saga.first(stable_pk_payload ORDER BY valid_from DESC), 'final_payload', sql_saga.first(data_payload ORDER BY valid_from DESC), 'final_payload_sans_epheme"
320,Process Legal Units - Batch 1,,5432145740772416088,1,47.981542,0,209,0,0,0,0,48,10084,ANALYZE active_source_rows
4d4,Process Legal Units - Batch 1,,8679993553546922744,1,47.021459,20000,352,0,0,0,0,116,13077,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
749,Process Legal Units - Batch 1,,2335399437257891460,1,46.634,20000,292,0,0,0,0,116,13077,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
e71,Process Legal Units - Batch 1,,4156395469617828009,1,39.288126,10000,0,0,0,0,0,0,0,"WITH RECURSIVE ordered_plan AS (                     SELECT                         row_number() OVER ( ORDER BY p.grouping_key, p.id, CASE p.operation WHEN 'DELETE' THEN 1 WHEN 'UPDATE' THEN 2 WHEN 'INSERT' THEN 3 ELSE 4 END, p.update_effect NULLS FIRST, CASE WHEN p.update_effect = 'MOVE' THEN 1 ELSE 0 END, CASE WHEN p.update_effect = 'MOVE' THEN COALESCE(p.old_valid_from, p.new_valid_from) END DESC NULLS LAST, COALESCE(p.old_valid_from, p.new_valid_from), (p.row_ids[1]) )::BIGINT as plan_op_seq,                         p.*                     FROM plan p                 ),                 -- For MOVE operations, group into the largest possible batches that can execute together.                 -- Within a single UPDATE statement, all rows see the pre-update state (MVCC snapshot).                 -- So if MOVE A's new_range overlaps MOVE B's old_range, they cannot be in the same statement.                 --                 -- Algorithm: Process MOVEs in plan_op_seq order (which is old_valid_from DESC).                 -- Track a multirange of old_ranges in the current batch. For each MOVE:                 -- - If new_range overlaps the batch's multirange, start a new batch                 -- - Add this MOVE's old_range to the batch's multirange                 --                 -- We use a recursive CTE to accumulate the multirange with reset-on-conflict logic.                 moves_ordered AS (                     SELECT                         o.plan_op_seq,                         o.grouping_key,                         o.old_valid_from,                         o.old_valid_until,                         o.new_valid_from,                         o.new_valid_until,                         row_number() OVER (PARTITION BY o.grouping_key ORDER BY o.plan_op_seq) AS move_seq                     FROM ordered_plan o                     WHERE o.operation = 'UPDATE' AND o.update_effect = 'MOVE'                 ),                 moves_with_batch AS (                     -- Base case: first MOVE in each entity starts b"
2e7,Process Legal Units - Batch 1,,-518691661278450688,1,37.936459,0,272,0,0,0,0,40,7674,ANALYZE source_rows_with_nk_json
9d8,Process Legal Units - Batch 1,,5039860120774769872,1,34.207792,0,255,0,0,0,0,26,6246,ANALYZE source_initial
9ad,Process Legal Units - Batch 1,,-3117954689326007662,1,29.503416,10000,478,0,0,0,0,142,16692,"CREATE TEMP TABLE resolved_atomic_segments ON COMMIT DROP AS                 SELECT                     grouping_key, id,  stable_identity_columns_are_null, lookup_columns_unavailable, is_new_entity, is_identifiable, is_ambiguous, conflicting_ids, unified_canonical_nk_json,                     valid_from, valid_until, t_valid_from, t_valid_until, propagated_s_valid_from, propagated_s_valid_until, causal_source_row_ids, causal_id, propagated_stable_pk_payload as stable_pk_payload,                     causal_source_row_ids IS NULL AS unaffected_target_only_segment,                     s_data_payload, t_data_payload,                     sql_saga.get_allen_relation(propagated_s_valid_from, propagated_s_valid_until, t_valid_from, t_valid_until) AS orig_source_target_relation,                     COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb) as data_payload,                     md5((jsonb_strip_nulls(COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb)))::text) as data_hash,                     CASE                          WHEN s_data_payload IS NULL THEN t_ephemeral_payload                         ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb)                     END as ephemeral_payload,                     CASE WHEN 'f'::boolean                         THEN trace || jsonb_build_object( 'cte', 'ras', 'segment_stable_pk', propagated_stable_pk_payload, 'final_data_payload', COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb), 'final_ephemeral_payload', CASE WHEN s_data_payload IS NULL THEN t_ephemeral_payload ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb) END )                         ELSE NULL                     END as trace                 FROM resolved_atomic_segments_with_propagated_ids"
ad9,Process Legal Units - Batch 1,,-694293067803121576,1,28.986375000000002,10000,342,0,0,0,0,142,16692,"CREATE TEMP TABLE resolved_atomic_segments ON COMMIT DROP AS                 SELECT                     grouping_key, id,  stable_identity_columns_are_null, lookup_columns_unavailable, is_new_entity, is_identifiable, is_ambiguous, conflicting_ids, unified_canonical_nk_json,                     valid_from, valid_until, t_valid_from, t_valid_until, propagated_s_valid_from, propagated_s_valid_until, causal_source_row_ids, causal_id, propagated_stable_pk_payload as stable_pk_payload,                     causal_source_row_ids IS NULL AS unaffected_target_only_segment,                     s_data_payload, t_data_payload,                     sql_saga.get_allen_relation(propagated_s_valid_from, propagated_s_valid_until, t_valid_from, t_valid_until) AS orig_source_target_relation,                     COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb) as data_payload,                     md5((jsonb_strip_nulls(COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb)))::text) as data_hash,                     CASE                          WHEN s_data_payload IS NULL THEN t_ephemeral_payload                         ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb)                     END as ephemeral_payload,                     CASE WHEN 'f'::boolean                         THEN trace || jsonb_build_object( 'cte', 'ras', 'segment_stable_pk', propagated_stable_pk_payload, 'final_data_payload', COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb), 'final_ephemeral_payload', CASE WHEN s_data_payload IS NULL THEN t_ephemeral_payload ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb) END )                         ELSE NULL                     END as trace                 FROM resolved_atomic_segments_with_propagated_ids"
23d,Process Legal Units - Batch 1,,-1333289396016535139,1,25.942083,10000,2665,0,0,0,0,0,0,"WITH             all_source_rows AS (                 SELECT t.row_id AS source_row_id FROM source_view_lu t             ),             plan_unnested AS (                 SELECT unnest(p.row_ids) as source_row_id, p.plan_op_seq, p.entity_keys, p.operation, p.data, p.feedback                 FROM temporal_merge_plan p             ),             feedback_groups AS (                 SELECT                     asr.source_row_id,                     -- Aggregate all distinct operations for this source row.                     array_agg(DISTINCT pu.operation) FILTER (WHERE pu.operation IS NOT NULL) as operations,                     -- Aggregate all distinct entity IDs this source row touched.                     COALESCE(jsonb_agg(DISTINCT pu.entity_keys) FILTER (WHERE pu.entity_keys IS NOT NULL), '[]'::jsonb) AS target_entity_keys,                     -- Extract the specific error message from the plan's feedback payload if present.                     (array_agg(pu.feedback->>'error') FILTER (WHERE pu.operation = 'ERROR' AND pu.feedback ? 'error'))[1] as error_message_from_plan                 FROM all_source_rows asr                 LEFT JOIN plan_unnested pu ON asr.source_row_id = pu.source_row_id                 GROUP BY asr.source_row_id             )             INSERT INTO temporal_merge_feedback                 SELECT                     fg.source_row_id,                     fg.target_entity_keys,                     CASE                         -- This CASE statement must be ordered from most to least specific to correctly classify outcomes.                         -- This CASE statement directly translates the plan's actions into a final feedback status.                         -- It is ordered from most to least specific to ensure correctness.                         WHEN 'ERROR'::sql_saga.temporal_merge_plan_action = ANY(fg.operations) THEN 'ERROR'                         WHEN 'INSERT'::sql_saga.temporal_merge_plan_action = ANY(fg.operations)                           OR 'UPDATE'::sql_saga.temporal_merge_"
5dd,Process Legal Units - Batch 1,,4494928315034638917,1,24.381042,10000,458,0,0,0,0,152,17512,"CREATE TEMP TABLE island_group ON COMMIT DROP AS                 SELECT                     *,                     SUM(is_island_start) OVER (PARTITION BY grouping_key ORDER BY valid_from) as island_group_id                 FROM (                     SELECT                         *,                         CASE                             WHEN prev_valid_until IS NULL                             OR prev_valid_until <> valid_from                             OR (prev_data_hash IS DISTINCT FROM data_hash)                             THEN 1                             ELSE 0                         END as is_island_start                     FROM (                         SELECT                             *,                             LAG(valid_until) OVER w as prev_valid_until,                             LAG(data_hash) OVER w as prev_data_hash,                             LAG(data_payload) OVER w as prev_data_payload                         FROM resolved_atomic_segments ras                         WHERE ras.data_payload IS NOT NULL                         WINDOW w AS (PARTITION BY grouping_key ORDER BY valid_from)                     ) s1                 ) s2"
c73,Process Legal Units - Batch 1,,-2675794321567617346,1,23.9005,10000,366,0,0,0,0,152,17512,"CREATE TEMP TABLE island_group ON COMMIT DROP AS                 SELECT                     *,                     SUM(is_island_start) OVER (PARTITION BY grouping_key ORDER BY valid_from) as island_group_id                 FROM (                     SELECT                         *,                         CASE                             WHEN prev_valid_until IS NULL                             OR prev_valid_until <> valid_from                             OR (prev_data_hash IS DISTINCT FROM data_hash)                             THEN 1                             ELSE 0                         END as is_island_start                     FROM (                         SELECT                             *,                             LAG(valid_until) OVER w as prev_valid_until,                             LAG(data_hash) OVER w as prev_data_hash,                             LAG(data_payload) OVER w as prev_data_payload                         FROM resolved_atomic_segments ras                         WHERE ras.data_payload IS NOT NULL                         WINDOW w AS (PARTITION BY grouping_key ORDER BY valid_from)                     ) s1                 ) s2"
db1,Process Legal Units - Batch 1,,1965474688105448427,1,22.30525,10000,2782,0,0,0,0,113,12592,"CREATE TEMP TABLE source_initial ON COMMIT DROP AS                 WITH source_data AS (                     SELECT                         source_table.row_id /* row_id_column */ as source_row_id,                         COALESCE(source_table.founding_id, source_table.row_id::integer) /* v_causal_select_expr */ as causal_id,                         source_table.id,  -- v_non_temporal_lookup_cols_select_list_prefix                         source_table.valid_from as valid_from, source_table.valid_until as valid_until, /* v_source_temporal_cols_expr */                         jsonb_strip_nulls(jsonb_build_object('name', source_table.name)) /* v_source_data_payload_expr */ AS data_payload,                         jsonb_strip_nulls(jsonb_build_object('comment', source_table.comment)) /* v_source_ephemeral_payload_expr */ AS ephemeral_payload,                         jsonb_build_object('id', source_table.id) /* v_stable_pk_cols_jsonb_build_source */ as stable_pk_payload,                         source_table.id IS NULL /* v_entity_id_check_is_null_expr */ as stable_identity_columns_are_null,                         (true) /* v_lookup_cols_are_null_expr */ as lookup_columns_unavailable,                         true /* v_is_identifiable_expr */ as is_identifiable,                         true /* v_consistency_check_expr */ as temporal_columns_are_consistent                     FROM source_view_lu /* v_source_table_ident */ source_table                 )                 SELECT                      *,                     -- OPTIMIZATION: Pre-compute range column to avoid repeated daterange() calls                     -- This provides ~10-15% performance improvement in eclipse detection                     daterange(valid_from, valid_until) as valid_range                 FROM source_data"
1d3,Process Legal Units - Batch 1,,2115514670139824758,1,21.889209,10000,2745,0,0,0,0,113,12592,"CREATE TEMP TABLE source_initial ON COMMIT DROP AS                 WITH source_data AS (                     SELECT                         source_table.row_id /* row_id_column */ as source_row_id,                         COALESCE(source_table.founding_id, source_table.row_id::integer) /* v_causal_select_expr */ as causal_id,                         source_table.id,  -- v_non_temporal_lookup_cols_select_list_prefix                         source_table.valid_from as valid_from, source_table.valid_until as valid_until, /* v_source_temporal_cols_expr */                         jsonb_strip_nulls(jsonb_build_object('name', source_table.name)) /* v_source_data_payload_expr */ AS data_payload,                         jsonb_strip_nulls(jsonb_build_object('comment', source_table.comment)) /* v_source_ephemeral_payload_expr */ AS ephemeral_payload,                         jsonb_build_object('id', source_table.id) /* v_stable_pk_cols_jsonb_build_source */ as stable_pk_payload,                         source_table.id IS NULL /* v_entity_id_check_is_null_expr */ as stable_identity_columns_are_null,                         (true) /* v_lookup_cols_are_null_expr */ as lookup_columns_unavailable,                         true /* v_is_identifiable_expr */ as is_identifiable,                         true /* v_consistency_check_expr */ as temporal_columns_are_consistent                     FROM source_view_lu /* v_source_table_ident */ source_table                 )                 SELECT                      *,                     -- OPTIMIZATION: Pre-compute range column to avoid repeated daterange() calls                     -- This provides ~10-15% performance improvement in eclipse detection                     daterange(valid_from, valid_until) as valid_range                 FROM source_data;"
5db,Process Legal Units - Batch 1,,-5465740686636543570,1,21.7015,10000,0,0,0,0,0,0,0,UPDATE temporal_merge_plan p                                 SET entity_keys = p.entity_keys || m.new_entity_keys                                 FROM temporal_merge_entity_id_map m                                 WHERE p.grouping_key = m.grouping_key
b8f,Process Legal Units - Batch 1,,-8259425963603516266,1,21.546375,0,303,0,0,0,0,57,14207,ANALYZE resolved_atomic_segments_with_payloads
fa8,Process Legal Units - Batch 1,,6779487562696088383,1,17.587167,10000,351,0,0,0,0,114,16377,"CREATE TEMP TABLE atomic_segments ON COMMIT DROP AS                 SELECT grouping_key, id, causal_id, point as valid_from, next_point as valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json                 FROM (                     SELECT *, LEAD(point) OVER (PARTITION BY grouping_key ORDER BY point) as next_point                     FROM time_points                 ) with_lead                 WHERE point IS NOT NULL AND next_point IS NOT NULL AND point < next_point"
c75,Process Legal Units - Batch 1,,-7556227097878634121,1,17.206916,0,283,0,0,0,0,50,13970,ANALYZE temporal_merge_plan
02a,Process Legal Units - Batch 1,,-7375841108639655790,1,17.194917,10000,289,0,0,0,0,114,16377,"CREATE TEMP TABLE atomic_segments ON COMMIT DROP AS                 SELECT grouping_key, id, causal_id, point as valid_from, next_point as valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json                 FROM (                     SELECT *, LEAD(point) OVER (PARTITION BY grouping_key ORDER BY point) as next_point                     FROM time_points                 ) with_lead                 WHERE point IS NOT NULL AND next_point IS NOT NULL AND point < next_point"
711,Process Legal Units - Batch 1,,1428552154429020267,1,16.512417,20000,342,0,0,0,0,110,12251,"CREATE TEMP TABLE time_points ON COMMIT DROP AS                 SELECT DISTINCT ON (grouping_key, point) *                 FROM time_points_with_unified_ids                 ORDER BY grouping_key, point, causal_id DESC NULLS LAST"
65c,Process Legal Units - Batch 1,,4895990506256861755,10000,16.355073000000313,10000,0,0,0,0,0,0,0,SELECT array_agg(DISTINCT v)                    FROM unnest(from_sources) AS v
a0a,Process Legal Units - Batch 1,,6254436778457358929,1,16.126291000000002,20000,280,0,0,0,0,110,12251,"CREATE TEMP TABLE time_points ON COMMIT DROP AS                 SELECT DISTINCT ON (grouping_key, point) *                 FROM time_points_with_unified_ids                 ORDER BY grouping_key, point, causal_id DESC NULLS LAST"
b3e,Process Legal Units - Batch 1,,-2068467933451381777,1,15.313625,10000,414,0,0,0,0,134,15340,"CREATE TEMP TABLE plan_with_op ON COMMIT DROP AS                 (                     SELECT * FROM (                         SELECT                             d.f_row_ids as row_ids, d.orig_source_target_relation, d.is_new_entity,                             CASE                                 WHEN d.is_ambiguous THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.is_new_entity AND NOT d.is_identifiable THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.t_from IS NULL THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.f_from IS NULL THEN 'DELETE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank = 1 THEN 'UPDATE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank > 1 THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank IS NULL THEN                                     CASE                                         WHEN d.unaffected_target_only_segment THEN NULL                                         ELSE 'SKIP_IDENTICAL'::sql_saga.temporal_merge_plan_action                                     END                                 ELSE 'ERROR'::sql_saga.temporal_merge_plan_action                             END as operation,                             id,                             CASE                                 WHEN d.is_new_entity AND d.canonical_nk_json IS NOT NULL                                 THEN d.canonical_nk_json || COALESCE(d.stable_pk_payload, '{}'::jsonb)                                 ELSE jsonb_build_object('id', d.id) || COALESCE(d.stable_pk_payload, '{}'::jsonb)                             END as entity_keys_json,                             jsonb_build_object('id', d.id) as identity_keys,                             jsonb_build_object() as lookup_keys,                             d.causal_id, d.t_from as old_valid_from, d.t_until as old_valid_until, d.f"
cd4,Process Legal Units - Batch 1,,9187673216027458375,1,15.042292,10000,432,0,0,0,0,136,14929,"CREATE TEMP TABLE plan ON COMMIT DROP AS                 SELECT                     p.row_ids, p.operation, p.causal_id, p.is_new_entity,                     p.id,                     p.entity_keys_json as entity_keys,                     p.identity_keys, p.lookup_keys,                     p.orig_source_target_relation, p.b_a_relation, p.old_valid_from, p.old_valid_until,                     p.new_valid_from, p.new_valid_until, p.data, p.feedback, p.trace,                     p.grouping_key,                     CASE                         WHEN p.operation <> 'UPDATE' THEN NULL::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from = p.old_valid_from AND p.new_valid_until = p.old_valid_until THEN 'NONE'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from <= p.old_valid_from AND p.new_valid_until >= p.old_valid_until THEN 'GROW'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from >= p.old_valid_from AND p.new_valid_until <= p.old_valid_until THEN 'SHRINK'::sql_saga.temporal_merge_update_effect                         ELSE 'MOVE'::sql_saga.temporal_merge_update_effect                     END AS update_effect                 FROM plan_with_op p                 LEFT JOIN source_rows_with_new_flag source_row ON source_row.source_row_id = p.row_ids[1]"
d1b,Process Legal Units - Batch 1,,-2354556386023983324,1,14.732626,10000,323,0,0,0,0,134,15340,"CREATE TEMP TABLE plan_with_op ON COMMIT DROP AS                 (                     SELECT * FROM (                         SELECT                             d.f_row_ids as row_ids, d.orig_source_target_relation, d.is_new_entity,                             CASE                                 WHEN d.is_ambiguous THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.is_new_entity AND NOT d.is_identifiable THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.t_from IS NULL THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.f_from IS NULL THEN 'DELETE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank = 1 THEN 'UPDATE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank > 1 THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank IS NULL THEN                                     CASE                                         WHEN d.unaffected_target_only_segment THEN NULL                                         ELSE 'SKIP_IDENTICAL'::sql_saga.temporal_merge_plan_action                                     END                                 ELSE 'ERROR'::sql_saga.temporal_merge_plan_action                             END as operation,                             id,                             CASE                                 WHEN d.is_new_entity AND d.canonical_nk_json IS NOT NULL                                 THEN d.canonical_nk_json || COALESCE(d.stable_pk_payload, '{}'::jsonb)                                 ELSE jsonb_build_object('id', d.id) || COALESCE(d.stable_pk_payload, '{}'::jsonb)                             END as entity_keys_json,                             jsonb_build_object('id', d.id) as identity_keys,                             jsonb_build_object() as lookup_keys,                             d.causal_id, d.t_from as old_valid_from, d.t_until as old_valid_until, d.f"
c8f,Process Legal Units - Batch 1,,5055573923988817461,1,14.533709,10000,330,0,0,0,0,136,14929,"CREATE TEMP TABLE plan ON COMMIT DROP AS                 SELECT                     p.row_ids, p.operation, p.causal_id, p.is_new_entity,                     p.id,                     p.entity_keys_json as entity_keys,                     p.identity_keys, p.lookup_keys,                     p.orig_source_target_relation, p.b_a_relation, p.old_valid_from, p.old_valid_until,                     p.new_valid_from, p.new_valid_until, p.data, p.feedback, p.trace,                     p.grouping_key,                     CASE                         WHEN p.operation <> 'UPDATE' THEN NULL::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from = p.old_valid_from AND p.new_valid_until = p.old_valid_until THEN 'NONE'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from <= p.old_valid_from AND p.new_valid_until >= p.old_valid_until THEN 'GROW'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from >= p.old_valid_from AND p.new_valid_until <= p.old_valid_until THEN 'SHRINK'::sql_saga.temporal_merge_update_effect                         ELSE 'MOVE'::sql_saga.temporal_merge_update_effect                     END AS update_effect                 FROM plan_with_op p                 LEFT JOIN source_rows_with_new_flag source_row ON source_row.source_row_id = p.row_ids[1]"
41c,Process Legal Units - Batch 1,,5147944785677299242,1,14.062042,10000,427,0,0,0,0,141,19371,"CREATE TEMP TABLE diff_ranked ON COMMIT DROP AS                 SELECT                     d.*,                     CASE                         WHEN d.t_from IS NULL OR d.f_from IS NULL THEN NULL                         WHEN d.f_from = d.t_from AND d.f_until = d.t_until AND d.f_payload IS NOT DISTINCT FROM d.t_payload THEN NULL                         ELSE                             row_number() OVER (                                 PARTITION BY d.grouping_key, d.t_from                                 ORDER BY                                     CASE WHEN d.f_from = d.t_from THEN 1 ELSE 2 END,                                     CASE WHEN d.f_payload - '{comment}'::text[] IS NOT DISTINCT FROM d.t_payload - '{comment}'::text[] THEN 1 ELSE 2 END,                                     d.f_from,                                     d.f_until                             )                     END as update_rank                 FROM diff d"
cf0,Process Legal Units - Batch 1,,6259880232974284115,1,13.648916,10000,343,0,0,0,0,141,19371,"CREATE TEMP TABLE diff_ranked ON COMMIT DROP AS                 SELECT                     d.*,                     CASE                         WHEN d.t_from IS NULL OR d.f_from IS NULL THEN NULL                         WHEN d.f_from = d.t_from AND d.f_until = d.t_until AND d.f_payload IS NOT DISTINCT FROM d.t_payload THEN NULL                         ELSE                             row_number() OVER (                                 PARTITION BY d.grouping_key, d.t_from                                 ORDER BY                                     CASE WHEN d.f_from = d.t_from THEN 1 ELSE 2 END,                                     CASE WHEN d.f_payload - '{comment}'::text[] IS NOT DISTINCT FROM d.t_payload - '{comment}'::text[] THEN 1 ELSE 2 END,                                     d.f_from,                                     d.f_until                             )                     END as update_rank                 FROM diff d"
d4a,Process Legal Units - Batch 1,,7743831913079285872,10000,13.427241000000432,10000,0,0,0,0,0,0,0,SELECT array_agg(DISTINCT v)                     FROM unnest(until_sources) AS v
af1,Process Legal Units - Batch 1,,7000426517880687954,1,13.07725,10000,440,0,0,0,0,131,14997,"CREATE TEMP TABLE source_rows_with_canonical_key ON COMMIT DROP AS                 SELECT *, (CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END /* v_grouping_key_expr */) as grouping_key                 FROM (                     SELECT                         s1.*,                         s2.nk_json as canonical_nk_json                     FROM source_rows_with_nk_json s1                     LEFT JOIN LATERAL (                         SELECT s2_inner.nk_json, s2_inner.nk_non_null_keys_array                         FROM source_rows_with_nk_json s2_inner                         WHERE s1.is_new_entity AND s2_inner.is_new_entity AND s2_inner.nk_json @> s1.nk_json                         ORDER BY array_length(s2_inner.nk_non_null_keys_array, 1) DESC, s2_inner.nk_non_null_keys_array::text DESC                         LIMIT 1                     ) s2 ON true                 ) s"
9db,Process Legal Units - Batch 1,,8118870935825291626,1,12.55025,10000,320,0,0,0,0,130,14935,"CREATE TEMP TABLE source_rows_with_canonical_key ON COMMIT DROP AS                 SELECT *, (CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END /* v_grouping_key_expr */) as grouping_key                 FROM (                     SELECT                         s1.*,                         s2.nk_json as canonical_nk_json                     FROM source_rows_with_nk_json s1                     LEFT JOIN LATERAL (                         SELECT s2_inner.nk_json, s2_inner.nk_non_null_keys_array                         FROM source_rows_with_nk_json s2_inner                         WHERE s1.is_new_entity AND s2_inner.is_new_entity AND s2_inner.nk_json @> s1.nk_json                         ORDER BY array_length(s2_inner.nk_non_null_keys_array, 1) DESC, s2_inner.nk_non_null_keys_array::text DESC                         LIMIT 1                     ) s2 ON true                 ) s"
5fc,Process Legal Units - Batch 2,,7104651493870380753,1,4808.266584,0,488107,0,3066,3071,0,176692,16143187,CALL etl_bench.process_legal_units(v_batch_id)
79b,Process Legal Units - Batch 2,,-5532412991206003072,1,4698.428875,0,387471,0,3066,3071,0,136466,13397842,"CALL sql_saga.temporal_merge(         target_table => 'etl_bench.legal_unit',         source_table => 'source_view_lu',         primary_identity_columns => ARRAY['id'],         ephemeral_columns => ARRAY['comment'],         mode => 'MERGE_ENTITY_PATCH',         founding_id_column => 'founding_id',         update_source_with_identity => true,         update_source_with_feedback => true,         feedback_status_column => 'merge_statuses',         feedback_status_key => 'legal_unit',         feedback_error_column => 'merge_errors',         feedback_error_key => 'legal_unit'     )"
fa8,Process Legal Units - Batch 2,,-4634225613452528969,1,4028.018251,10000,24955,0,3066,3071,0,5525,596213,"INSERT INTO temporal_merge_plan     SELECT * FROM sql_saga.temporal_merge_plan(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         identity_columns => v_identity_cols_discovered,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         delete_mode => temporal_merge.delete_mode,         lookup_keys => v_natural_identity_keys_discovered,         ephemeral_columns => temporal_merge.ephemeral_columns,         p_log_trace => v_log_trace,         p_log_sql => v_log_sql     )"
606,Process Legal Units - Batch 2,,-788747283814772468,1,2578.185708,10000,383,0,0,0,0,117,13129,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         -- OPTIMIZATION: Use pre-computed valid_range instead of repeated daterange() calls                         -- Combined with composite index, this provides 30-40 percent total performance improvement                         COALESCE(sql_saga.covers_without_gaps(s2.valid_range, s1.valid_range ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.lookup_columns_unavailable AND (false))                             OR                             (s1.lookup_columns_unavailable AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info"
d6b,Process Legal Units - Batch 2,,4573562956278615873,1,2577.476666,10000,297,0,0,0,0,116,13061,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         -- OPTIMIZATION: Use pre-computed valid_range instead of repeated daterange() calls                         -- Combined with composite index, this provides 30-40 percent total performance improvement                         COALESCE(sql_saga.covers_without_gaps(s2.valid_range, s1.valid_range ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.lookup_columns_unavailable AND (false))                             OR                             (s1.lookup_columns_unavailable AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info;"
338,Process Legal Units - Batch 2,,4313330175016020501,1,666.250875,0,361608,0,0,0,0,130677,12777661,"CALL sql_saga.temporal_merge_execute(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         identity_columns => v_identity_cols_discovered,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         update_source_with_identity => temporal_merge.update_source_with_identity,         lookup_columns => v_natural_identity_cols_discovered,         delete_mode => temporal_merge.delete_mode,         update_source_with_feedback => temporal_merge.update_source_with_feedback,         feedback_status_column => temporal_merge.feedback_status_column,         feedback_status_key => temporal_merge.feedback_status_key,         feedback_error_column => temporal_merge.feedback_error_column,         feedback_error_key => temporal_merge.feedback_error_key,         ephemeral_columns => temporal_merge.ephemeral_columns,         delay_constraints => temporal_merge.delay_constraints     )"
ca5,Process Legal Units - Batch 2,,-723802098106927723,1,419.54583299999996,10000,220603,0,0,0,0,80368,7702592,"UPDATE etl_bench.legal_unit t SET valid_range = p.new_valid_range::daterange, name = CASE WHEN p.data ? 'name' THEN (p.data->>'name')::text ELSE t.name END, comment = CASE WHEN p.data ? 'comment' THEN (p.data->>'comment')::text ELSE t.comment END                                 FROM (SELECT *, (entity_keys->>'id')::integer AS id_ek FROM temporal_merge_plan WHERE operation = 'UPDATE' AND statement_seq = 1 ORDER BY plan_op_seq) p                                 WHERE t.id = p.id_ek AND t.valid_range = p.old_valid_range::daterange"
42e,Process Legal Units - Batch 2,,-8259425963603516266,1,213.244125,0,247,0,0,0,0,57,25579,ANALYZE resolved_atomic_segments_with_payloads
259,Process Legal Units - Batch 2,,-6251707813684716315,1,152.77599999999998,10000,135320,0,0,0,0,50127,5047360,"UPDATE source_view_lu s             SET merge_statuses = COALESCE(s.merge_statuses, '{}'::jsonb) || jsonb_build_object('legal_unit', f.status), merge_errors = CASE WHEN f.error_message IS NOT NULL THEN COALESCE(s.merge_errors, '{}'::jsonb) || jsonb_build_object('legal_unit', f.error_message) ELSE COALESCE(s.merge_errors, '{}'::jsonb) - 'legal_unit' END             FROM pg_temp.temporal_merge_feedback f             WHERE s.row_id = f.source_row_id"
3d5,Process Legal Units - Batch 2,,9079426233396750581,1,127.689542,20000,505,0,747,748,0,153,18533,"CREATE TEMP TABLE resolved_atomic_segments_with_propagated_ids ON COMMIT DROP AS                 SELECT                     *,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY grouping_key ORDER BY valid_from) as unified_canonical_nk_json,                     COALESCE(                         contributing_row_ids,                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as causal_source_row_ids,                     COALESCE(                         s_valid_from,                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_from,                     COALESCE(                         s_valid_until,                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_until                 FROM (                     SELECT                         *,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from) AS look_behind_grp,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from DESC) AS look_ahead_grp                     FROM resolved_atomic_segments_with_payloads /* v_resolver_from */                 ) with_grp"
823,Process Legal Units - Batch 2,,8086196219516147042,1,126.04416600000002,20000,372,0,747,748,0,153,18533,"CREATE TEMP TABLE resolved_atomic_segments_with_propagated_ids ON COMMIT DROP AS                 SELECT                     *,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY grouping_key ORDER BY valid_from) as unified_canonical_nk_json,                     COALESCE(                         contributing_row_ids,                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as causal_source_row_ids,                     COALESCE(                         s_valid_from,                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_from,                     COALESCE(                         s_valid_until,                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_until                 FROM (                     SELECT                         *,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from) AS look_behind_grp,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from DESC) AS look_ahead_grp                     FROM resolved_atomic_segments_with_payloads /* v_resolver_from */                 ) with_grp"
28f,Process Legal Units - Batch 2,,6020602004421484228,1,121.530333,20000,483,0,0,0,0,138,16023,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     with_base_payload.*,                     with_base_payload.stable_pk_payload as propagated_stable_pk_payload                 FROM (                     SELECT                         seg.*, source_payloads.source_row_id, source_payloads.contributing_row_ids,                          source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                         source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until                     FROM all_segments seg                                              LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE                  ((seg.is_new_entity AND source_row.grouping_key = seg.grouping_key)                 OR                 (NOT seg.is_new_entity AND (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))))              -- v_lateral_join_sr_to_seg                                 AND daterange(seg.valid_from, seg.valid_until) <@ daterange(source_row.valid_from, source_row.valid_until)                             ),                             running_payload AS (                                 SELECT rn, source_row_id, data_payload, ephemeral_payload, valid_from, val"
d5e,Process Legal Units - Batch 2,,-4153295300979878628,1,120.800875,20000,341,0,0,0,0,138,16023,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     with_base_payload.*,                     with_base_payload.stable_pk_payload as propagated_stable_pk_payload                 FROM (                     SELECT                         seg.*, source_payloads.source_row_id, source_payloads.contributing_row_ids,                          source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                         source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until                     FROM all_segments seg                                              LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE                  ((seg.is_new_entity AND source_row.grouping_key = seg.grouping_key)                 OR                 (NOT seg.is_new_entity AND (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))))              -- v_lateral_join_sr_to_seg                                 AND daterange(seg.valid_from, seg.valid_until) <@ daterange(source_row.valid_from, source_row.valid_until)                             ),                             running_payload AS (                                 SELECT rn, source_row_id, data_payload, ephemeral_payload, valid_from, val"
ab3,Process Legal Units - Batch 2,,8679993553546922744,1,108.64575,40000,371,0,494,495,0,117,13119,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
39e,Process Legal Units - Batch 2,,2335399437257891460,1,107.41704200000001,40000,302,0,494,495,0,117,13119,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
5f1,Process Legal Units - Batch 2,,2973456759399252638,1,104.053708,10000,431,0,556,557,0,127,14354,"CREATE TEMP TABLE coalesced_final_segments ON COMMIT DROP AS                 SELECT                     grouping_key, max(id) as id,                     sql_saga.first(causal_id ORDER BY valid_from) as causal_id,                     sql_saga.first(stable_identity_columns_are_null ORDER BY valid_from) as stable_identity_columns_are_null,                     sql_saga.first(lookup_columns_unavailable ORDER BY valid_from) as lookup_columns_unavailable,                     sql_saga.first(is_new_entity ORDER BY valid_from) as is_new_entity,                     sql_saga.first(is_identifiable ORDER BY valid_from) as is_identifiable,                     sql_saga.first(is_ambiguous ORDER BY valid_from) as is_ambiguous,                     sql_saga.first(conflicting_ids ORDER BY valid_from) as conflicting_ids,                     sql_saga.first(unified_canonical_nk_json ORDER BY valid_from) as canonical_nk_json,                     sql_saga.first(orig_source_target_relation ORDER BY valid_from) as orig_source_target_relation,                     sql_saga.first(t_valid_from ORDER BY valid_from) as ancestor_valid_from,                     MIN(valid_from) as valid_from,                     MAX(valid_until) as valid_until,                     (sql_saga.first(data_payload ORDER BY valid_from DESC) || sql_saga.first(ephemeral_payload ORDER BY valid_from DESC)) as final_payload,                     sql_saga.first(stable_pk_payload ORDER BY valid_from DESC) as stable_pk_payload,                     bool_and(unaffected_target_only_segment) as unaffected_target_only_segment,                     (SELECT array_agg(DISTINCT e) FROM unnest(array_concat_agg(causal_source_row_ids)) e WHERE e IS NOT NULL) as row_ids,                     CASE WHEN 'f'::boolean                         THEN jsonb_build_object( 'cte', 'coalesced', 'island_group_id', island_group_id, 'coalesced_stable_pk', sql_saga.first(stable_pk_payload ORDER BY valid_from DESC), 'final_payload', sql_saga.first(data_payload ORDER BY valid_from DESC), 'final_payload_sans_epheme"
fb0,Process Legal Units - Batch 2,,-8237077405251109710,1,102.771459,10000,318,0,556,557,0,127,14354,"CREATE TEMP TABLE coalesced_final_segments ON COMMIT DROP AS                 SELECT                     grouping_key, max(id) as id,                     sql_saga.first(causal_id ORDER BY valid_from) as causal_id,                     sql_saga.first(stable_identity_columns_are_null ORDER BY valid_from) as stable_identity_columns_are_null,                     sql_saga.first(lookup_columns_unavailable ORDER BY valid_from) as lookup_columns_unavailable,                     sql_saga.first(is_new_entity ORDER BY valid_from) as is_new_entity,                     sql_saga.first(is_identifiable ORDER BY valid_from) as is_identifiable,                     sql_saga.first(is_ambiguous ORDER BY valid_from) as is_ambiguous,                     sql_saga.first(conflicting_ids ORDER BY valid_from) as conflicting_ids,                     sql_saga.first(unified_canonical_nk_json ORDER BY valid_from) as canonical_nk_json,                     sql_saga.first(orig_source_target_relation ORDER BY valid_from) as orig_source_target_relation,                     sql_saga.first(t_valid_from ORDER BY valid_from) as ancestor_valid_from,                     MIN(valid_from) as valid_from,                     MAX(valid_until) as valid_until,                     (sql_saga.first(data_payload ORDER BY valid_from DESC) || sql_saga.first(ephemeral_payload ORDER BY valid_from DESC)) as final_payload,                     sql_saga.first(stable_pk_payload ORDER BY valid_from DESC) as stable_pk_payload,                     bool_and(unaffected_target_only_segment) as unaffected_target_only_segment,                     (SELECT array_agg(DISTINCT e) FROM unnest(array_concat_agg(causal_source_row_ids)) e WHERE e IS NOT NULL) as row_ids,                     CASE WHEN 'f'::boolean                         THEN jsonb_build_object( 'cte', 'coalesced', 'island_group_id', island_group_id, 'coalesced_stable_pk', sql_saga.first(stable_pk_payload ORDER BY valid_from DESC), 'final_payload', sql_saga.first(data_payload ORDER BY valid_from DESC), 'final_payload_sans_epheme"
e41,Process Legal Units - Batch 2,,7295163325594009324,1,99.116833,10000,95280,0,0,0,0,40184,2742060,"INSERT INTO etl_bench.identity_resolution (identity_correlation, legal_unit_id, resolved_batch)     SELECT DISTINCT          identity_correlation,         legal_unit_id,         p_batch_id     FROM etl_bench.data_table     WHERE batch = p_batch_id AND legal_unit_id IS NOT NULL     ON CONFLICT (identity_correlation) DO UPDATE SET         legal_unit_id = EXCLUDED.legal_unit_id,         resolved_batch = EXCLUDED.resolved_batch"
bad,Process Legal Units - Batch 2,,5432145740772416088,1,75.044167,0,213,0,0,0,0,48,11420,ANALYZE active_source_rows
13c,Process Legal Units - Batch 2,,-518691661278450688,1,65.548375,0,182,0,0,0,0,40,9072,ANALYZE source_rows_with_nk_json
52d,Process Legal Units - Batch 2,,4494928315034638917,1,62.731708,20000,470,0,771,772,0,153,17610,"CREATE TEMP TABLE island_group ON COMMIT DROP AS                 SELECT                     *,                     SUM(is_island_start) OVER (PARTITION BY grouping_key ORDER BY valid_from) as island_group_id                 FROM (                     SELECT                         *,                         CASE                             WHEN prev_valid_until IS NULL                             OR prev_valid_until <> valid_from                             OR (prev_data_hash IS DISTINCT FROM data_hash)                             THEN 1                             ELSE 0                         END as is_island_start                     FROM (                         SELECT                             *,                             LAG(valid_until) OVER w as prev_valid_until,                             LAG(data_hash) OVER w as prev_data_hash,                             LAG(data_payload) OVER w as prev_data_payload                         FROM resolved_atomic_segments ras                         WHERE ras.data_payload IS NOT NULL                         WINDOW w AS (PARTITION BY grouping_key ORDER BY valid_from)                     ) s1                 ) s2"
111,Process Legal Units - Batch 2,,-2675794321567617346,1,61.101833,20000,369,0,771,772,0,153,17610,"CREATE TEMP TABLE island_group ON COMMIT DROP AS                 SELECT                     *,                     SUM(is_island_start) OVER (PARTITION BY grouping_key ORDER BY valid_from) as island_group_id                 FROM (                     SELECT                         *,                         CASE                             WHEN prev_valid_until IS NULL                             OR prev_valid_until <> valid_from                             OR (prev_data_hash IS DISTINCT FROM data_hash)                             THEN 1                             ELSE 0                         END as is_island_start                     FROM (                         SELECT                             *,                             LAG(valid_until) OVER w as prev_valid_until,                             LAG(data_hash) OVER w as prev_data_hash,                             LAG(data_payload) OVER w as prev_data_payload                         FROM resolved_atomic_segments ras                         WHERE ras.data_payload IS NOT NULL                         WINDOW w AS (PARTITION BY grouping_key ORDER BY valid_from)                     ) s1                 ) s2"
0d2,Process Legal Units - Batch 2,,0,5,60.925917,0,1198,0,0,0,0,348,47673,CALL sql_saga.benchmark_reset()
7e9,Process Legal Units - Batch 2,,-3117954689326007662,1,46.725584,20000,465,0,0,0,0,144,17372,"CREATE TEMP TABLE resolved_atomic_segments ON COMMIT DROP AS                 SELECT                     grouping_key, id,  stable_identity_columns_are_null, lookup_columns_unavailable, is_new_entity, is_identifiable, is_ambiguous, conflicting_ids, unified_canonical_nk_json,                     valid_from, valid_until, t_valid_from, t_valid_until, propagated_s_valid_from, propagated_s_valid_until, causal_source_row_ids, causal_id, propagated_stable_pk_payload as stable_pk_payload,                     causal_source_row_ids IS NULL AS unaffected_target_only_segment,                     s_data_payload, t_data_payload,                     sql_saga.get_allen_relation(propagated_s_valid_from, propagated_s_valid_until, t_valid_from, t_valid_until) AS orig_source_target_relation,                     COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb) as data_payload,                     md5((jsonb_strip_nulls(COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb)))::text) as data_hash,                     CASE                          WHEN s_data_payload IS NULL THEN t_ephemeral_payload                         ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb)                     END as ephemeral_payload,                     CASE WHEN 'f'::boolean                         THEN trace || jsonb_build_object( 'cte', 'ras', 'segment_stable_pk', propagated_stable_pk_payload, 'final_data_payload', COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb), 'final_ephemeral_payload', CASE WHEN s_data_payload IS NULL THEN t_ephemeral_payload ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb) END )                         ELSE NULL                     END as trace                 FROM resolved_atomic_segments_with_propagated_ids"
160,Process Legal Units - Batch 2,,-694293067803121576,1,46.141875,20000,352,0,0,0,0,144,17372,"CREATE TEMP TABLE resolved_atomic_segments ON COMMIT DROP AS                 SELECT                     grouping_key, id,  stable_identity_columns_are_null, lookup_columns_unavailable, is_new_entity, is_identifiable, is_ambiguous, conflicting_ids, unified_canonical_nk_json,                     valid_from, valid_until, t_valid_from, t_valid_until, propagated_s_valid_from, propagated_s_valid_until, causal_source_row_ids, causal_id, propagated_stable_pk_payload as stable_pk_payload,                     causal_source_row_ids IS NULL AS unaffected_target_only_segment,                     s_data_payload, t_data_payload,                     sql_saga.get_allen_relation(propagated_s_valid_from, propagated_s_valid_until, t_valid_from, t_valid_until) AS orig_source_target_relation,                     COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb) as data_payload,                     md5((jsonb_strip_nulls(COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb)))::text) as data_hash,                     CASE                          WHEN s_data_payload IS NULL THEN t_ephemeral_payload                         ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb)                     END as ephemeral_payload,                     CASE WHEN 'f'::boolean                         THEN trace || jsonb_build_object( 'cte', 'ras', 'segment_stable_pk', propagated_stable_pk_payload, 'final_data_payload', COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb), 'final_ephemeral_payload', CASE WHEN s_data_payload IS NULL THEN t_ephemeral_payload ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb) END )                         ELSE NULL                     END as trace                 FROM resolved_atomic_segments_with_propagated_ids"
9a5,Process Legal Units - Batch 2,,5039860120774769872,1,44.702166,0,124,0,0,0,0,26,7165,ANALYZE source_initial
b07,Process Legal Units - Batch 2,,4156395469617828009,1,41.431000000000004,10000,0,0,0,0,0,0,0,"WITH RECURSIVE ordered_plan AS (                     SELECT                         row_number() OVER ( ORDER BY p.grouping_key, p.id, CASE p.operation WHEN 'DELETE' THEN 1 WHEN 'UPDATE' THEN 2 WHEN 'INSERT' THEN 3 ELSE 4 END, p.update_effect NULLS FIRST, CASE WHEN p.update_effect = 'MOVE' THEN 1 ELSE 0 END, CASE WHEN p.update_effect = 'MOVE' THEN COALESCE(p.old_valid_from, p.new_valid_from) END DESC NULLS LAST, COALESCE(p.old_valid_from, p.new_valid_from), (p.row_ids[1]) )::BIGINT as plan_op_seq,                         p.*                     FROM plan p                 ),                 -- For MOVE operations, group into the largest possible batches that can execute together.                 -- Within a single UPDATE statement, all rows see the pre-update state (MVCC snapshot).                 -- So if MOVE A's new_range overlaps MOVE B's old_range, they cannot be in the same statement.                 --                 -- Algorithm: Process MOVEs in plan_op_seq order (which is old_valid_from DESC).                 -- Track a multirange of old_ranges in the current batch. For each MOVE:                 -- - If new_range overlaps the batch's multirange, start a new batch                 -- - Add this MOVE's old_range to the batch's multirange                 --                 -- We use a recursive CTE to accumulate the multirange with reset-on-conflict logic.                 moves_ordered AS (                     SELECT                         o.plan_op_seq,                         o.grouping_key,                         o.old_valid_from,                         o.old_valid_until,                         o.new_valid_from,                         o.new_valid_until,                         row_number() OVER (PARTITION BY o.grouping_key ORDER BY o.plan_op_seq) AS move_seq                     FROM ordered_plan o                     WHERE o.operation = 'UPDATE' AND o.update_effect = 'MOVE'                 ),                 moves_with_batch AS (                     -- Base case: first MOVE in each entity starts b"
b8e,Process Legal Units - Batch 2,,1428552154429020267,1,37.986291,30000,367,0,498,499,0,112,14367,"CREATE TEMP TABLE time_points ON COMMIT DROP AS                 SELECT DISTINCT ON (grouping_key, point) *                 FROM time_points_with_unified_ids                 ORDER BY grouping_key, point, causal_id DESC NULLS LAST"
f0f,Process Legal Units - Batch 2,,6254436778457358929,1,36.874708999999996,30000,294,0,498,499,0,112,14367,"CREATE TEMP TABLE time_points ON COMMIT DROP AS                 SELECT DISTINCT ON (grouping_key, point) *                 FROM time_points_with_unified_ids                 ORDER BY grouping_key, point, causal_id DESC NULLS LAST"
32f,Process Legal Units - Batch 2,,1965474688105448427,1,32.649208,10000,5039,0,0,0,0,114,13527,"CREATE TEMP TABLE source_initial ON COMMIT DROP AS                 WITH source_data AS (                     SELECT                         source_table.row_id /* row_id_column */ as source_row_id,                         COALESCE(source_table.founding_id, source_table.row_id::integer) /* v_causal_select_expr */ as causal_id,                         source_table.id,  -- v_non_temporal_lookup_cols_select_list_prefix                         source_table.valid_from as valid_from, source_table.valid_until as valid_until, /* v_source_temporal_cols_expr */                         jsonb_strip_nulls(jsonb_build_object('name', source_table.name)) /* v_source_data_payload_expr */ AS data_payload,                         jsonb_strip_nulls(jsonb_build_object('comment', source_table.comment)) /* v_source_ephemeral_payload_expr */ AS ephemeral_payload,                         jsonb_build_object('id', source_table.id) /* v_stable_pk_cols_jsonb_build_source */ as stable_pk_payload,                         source_table.id IS NULL /* v_entity_id_check_is_null_expr */ as stable_identity_columns_are_null,                         (true) /* v_lookup_cols_are_null_expr */ as lookup_columns_unavailable,                         true /* v_is_identifiable_expr */ as is_identifiable,                         true /* v_consistency_check_expr */ as temporal_columns_are_consistent                     FROM source_view_lu /* v_source_table_ident */ source_table                 )                 SELECT                      *,                     -- OPTIMIZATION: Pre-compute range column to avoid repeated daterange() calls                     -- This provides ~10-15% performance improvement in eclipse detection                     daterange(valid_from, valid_until) as valid_range                 FROM source_data"
02a,Process Legal Units - Batch 2,,2115514670139824758,1,32.203625,10000,4996,0,0,0,0,114,13527,"CREATE TEMP TABLE source_initial ON COMMIT DROP AS                 WITH source_data AS (                     SELECT                         source_table.row_id /* row_id_column */ as source_row_id,                         COALESCE(source_table.founding_id, source_table.row_id::integer) /* v_causal_select_expr */ as causal_id,                         source_table.id,  -- v_non_temporal_lookup_cols_select_list_prefix                         source_table.valid_from as valid_from, source_table.valid_until as valid_until, /* v_source_temporal_cols_expr */                         jsonb_strip_nulls(jsonb_build_object('name', source_table.name)) /* v_source_data_payload_expr */ AS data_payload,                         jsonb_strip_nulls(jsonb_build_object('comment', source_table.comment)) /* v_source_ephemeral_payload_expr */ AS ephemeral_payload,                         jsonb_build_object('id', source_table.id) /* v_stable_pk_cols_jsonb_build_source */ as stable_pk_payload,                         source_table.id IS NULL /* v_entity_id_check_is_null_expr */ as stable_identity_columns_are_null,                         (true) /* v_lookup_cols_are_null_expr */ as lookup_columns_unavailable,                         true /* v_is_identifiable_expr */ as is_identifiable,                         true /* v_consistency_check_expr */ as temporal_columns_are_consistent                     FROM source_view_lu /* v_source_table_ident */ source_table                 )                 SELECT                      *,                     -- OPTIMIZATION: Pre-compute range column to avoid repeated daterange() calls                     -- This provides ~10-15% performance improvement in eclipse detection                     daterange(valid_from, valid_until) as valid_range                 FROM source_data;"
8d8,Process Legal Units - Batch 2,,-6981167301158104206,1,28.57175,10000,429,0,0,0,0,137,15307,"CREATE TEMP TABLE diff ON COMMIT DROP AS                 SELECT                     final_seg.grouping_key, COALESCE(final_seg.id, target_seg.id) as id, COALESCE(final_seg.causal_id, target_seg.causal_id) as causal_id,                     COALESCE(final_seg.is_new_entity, false) as is_new_entity,                     COALESCE(final_seg.is_identifiable, true) as is_identifiable,                     COALESCE(final_seg.is_ambiguous, false) as is_ambiguous,                     final_seg.conflicting_ids,                     final_seg.canonical_nk_json,                     COALESCE(final_seg.stable_identity_columns_are_null, false) as stable_identity_columns_are_null,                     COALESCE(final_seg.lookup_columns_unavailable, false) as lookup_columns_unavailable,                     final_seg.valid_from AS f_from, final_seg.valid_until AS f_until, final_seg.final_payload AS f_payload, final_seg.row_ids AS f_row_ids, final_seg.stable_pk_payload, final_seg.orig_source_target_relation,                     CASE WHEN 'f'::boolean                         THEN final_seg.trace || jsonb_build_object('cte', 'diff', 'diff_stable_pk', final_seg.stable_pk_payload, 'final_seg_causal_id', final_seg.causal_id, 'final_payload_vs_target_payload', jsonb_build_object('f', final_seg.final_payload, 't', target_seg.data_payload))                         ELSE NULL                     END as trace,                     final_seg.unaffected_target_only_segment,                     target_seg.valid_from as t_from, target_seg.valid_until as t_until, (target_seg.data_payload || target_seg.ephemeral_payload) as t_payload,                     sql_saga.get_allen_relation(target_seg.valid_from, target_seg.valid_until, final_seg.valid_from, final_seg.valid_until) as b_a_relation                 FROM coalesced_final_segments AS final_seg                 FULL OUTER JOIN target_rows AS target_seg ON final_seg.grouping_key = ('existing_entity__' || COALESCE(target_seg.id::text, '_NULL_')) AND final_seg.ancestor_valid_from = target_seg.valid_from"
f8b,Process Legal Units - Batch 2,,-5654698104857404724,1,28.007709,10000,340,0,0,0,0,137,15307,"CREATE TEMP TABLE diff ON COMMIT DROP AS                 SELECT                     final_seg.grouping_key, COALESCE(final_seg.id, target_seg.id) as id, COALESCE(final_seg.causal_id, target_seg.causal_id) as causal_id,                     COALESCE(final_seg.is_new_entity, false) as is_new_entity,                     COALESCE(final_seg.is_identifiable, true) as is_identifiable,                     COALESCE(final_seg.is_ambiguous, false) as is_ambiguous,                     final_seg.conflicting_ids,                     final_seg.canonical_nk_json,                     COALESCE(final_seg.stable_identity_columns_are_null, false) as stable_identity_columns_are_null,                     COALESCE(final_seg.lookup_columns_unavailable, false) as lookup_columns_unavailable,                     final_seg.valid_from AS f_from, final_seg.valid_until AS f_until, final_seg.final_payload AS f_payload, final_seg.row_ids AS f_row_ids, final_seg.stable_pk_payload, final_seg.orig_source_target_relation,                     CASE WHEN 'f'::boolean                         THEN final_seg.trace || jsonb_build_object('cte', 'diff', 'diff_stable_pk', final_seg.stable_pk_payload, 'final_seg_causal_id', final_seg.causal_id, 'final_payload_vs_target_payload', jsonb_build_object('f', final_seg.final_payload, 't', target_seg.data_payload))                         ELSE NULL                     END as trace,                     final_seg.unaffected_target_only_segment,                     target_seg.valid_from as t_from, target_seg.valid_until as t_until, (target_seg.data_payload || target_seg.ephemeral_payload) as t_payload,                     sql_saga.get_allen_relation(target_seg.valid_from, target_seg.valid_until, final_seg.valid_from, final_seg.valid_until) as b_a_relation                 FROM coalesced_final_segments AS final_seg                 FULL OUTER JOIN target_rows AS target_seg ON final_seg.grouping_key = ('existing_entity__' || COALESCE(target_seg.id::text, '_NULL_')) AND final_seg.ancestor_valid_from = target_seg.valid_from"
005,Process Legal Units - Batch 2,,-1333289396016535139,1,26.365375,10000,4703,0,0,0,0,0,0,"WITH             all_source_rows AS (                 SELECT t.row_id AS source_row_id FROM source_view_lu t             ),             plan_unnested AS (                 SELECT unnest(p.row_ids) as source_row_id, p.plan_op_seq, p.entity_keys, p.operation, p.data, p.feedback                 FROM temporal_merge_plan p             ),             feedback_groups AS (                 SELECT                     asr.source_row_id,                     -- Aggregate all distinct operations for this source row.                     array_agg(DISTINCT pu.operation) FILTER (WHERE pu.operation IS NOT NULL) as operations,                     -- Aggregate all distinct entity IDs this source row touched.                     COALESCE(jsonb_agg(DISTINCT pu.entity_keys) FILTER (WHERE pu.entity_keys IS NOT NULL), '[]'::jsonb) AS target_entity_keys,                     -- Extract the specific error message from the plan's feedback payload if present.                     (array_agg(pu.feedback->>'error') FILTER (WHERE pu.operation = 'ERROR' AND pu.feedback ? 'error'))[1] as error_message_from_plan                 FROM all_source_rows asr                 LEFT JOIN plan_unnested pu ON asr.source_row_id = pu.source_row_id                 GROUP BY asr.source_row_id             )             INSERT INTO temporal_merge_feedback                 SELECT                     fg.source_row_id,                     fg.target_entity_keys,                     CASE                         -- This CASE statement must be ordered from most to least specific to correctly classify outcomes.                         -- This CASE statement directly translates the plan's actions into a final feedback status.                         -- It is ordered from most to least specific to ensure correctness.                         WHEN 'ERROR'::sql_saga.temporal_merge_plan_action = ANY(fg.operations) THEN 'ERROR'                         WHEN 'INSERT'::sql_saga.temporal_merge_plan_action = ANY(fg.operations)                           OR 'UPDATE'::sql_saga.temporal_merge_"
587,Process Legal Units - Batch 2,,6779487562696088383,1,23.797541,20000,366,0,0,0,0,112,12521,"CREATE TEMP TABLE atomic_segments ON COMMIT DROP AS                 SELECT grouping_key, id, causal_id, point as valid_from, next_point as valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json                 FROM (                     SELECT *, LEAD(point) OVER (PARTITION BY grouping_key ORDER BY point) as next_point                     FROM time_points                 ) with_lead                 WHERE point IS NOT NULL AND next_point IS NOT NULL AND point < next_point"
efa,Process Legal Units - Batch 2,,-7375841108639655790,1,23.335917000000002,20000,293,0,0,0,0,112,12521,"CREATE TEMP TABLE atomic_segments ON COMMIT DROP AS                 SELECT grouping_key, id, causal_id, point as valid_from, next_point as valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json                 FROM (                     SELECT *, LEAD(point) OVER (PARTITION BY grouping_key ORDER BY point) as next_point                     FROM time_points                 ) with_lead                 WHERE point IS NOT NULL AND next_point IS NOT NULL AND point < next_point"
ab5,Process Legal Units - Batch 2,,0,1,22.398125,0,6165,0,0,0,0,1539,83106,CALL sql_saga.temporal_merge_drop_temp_tables()
534,Process Legal Units - Batch 2,,-9107887341698301624,1,21.9435,20000,406,0,0,0,0,125,14167,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.lookup_columns_unavailable, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON target_row.id = seg.id                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                 WHERE NOT seg.is_new_entity"
aba,Process Legal Units - Batch 2,,7253058932029092145,1,21.470708000000002,20000,319,0,0,0,0,125,14167,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.lookup_columns_unavailable, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON target_row.id = seg.id                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                 WHERE NOT seg.is_new_entity"
d05,Process Legal Units - Batch 2,,-2522301903109079185,1,21.442167,40000,380,0,0,0,0,114,12735,"CREATE TEMP TABLE time_points_with_unified_ids ON COMMIT DROP AS                 SELECT                     tpu.grouping_key,                     tpu.id,                     tpu.unified_causal_id as causal_id,                     tpu.point,                     tpu.is_new_entity,                     tpu.unified_stable_pk_payload as stable_pk_payload,                     tpu.stable_identity_columns_are_null,                     tpu.lookup_columns_unavailable,                     tpu.is_identifiable,                     tpu.is_ambiguous,                     tpu.conflicting_ids,                     tpu.unified_canonical_nk_json as canonical_nk_json                 FROM time_points_unified tpu"
cc5,Process Legal Units - Batch 2,,-6189425232530816533,1,21.339041,10000,438,0,0,0,0,104,12011,"CREATE TEMP TABLE target_rows ON COMMIT DROP AS                 SELECT                     id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ -- (non-temporal identity columns)                     lower(t.valid_range) as valid_from, -- The temporal identity column (e.g., valid_from)                     NULL::integer /* v_causal_column_type */ as causal_id, -- Target rows do not originate from a source row, so causal_id is NULL. Type is introspected.                     jsonb_build_object('id', id) /* v_stable_pk_cols_jsonb_build_bare */ as stable_pk_payload,                     upper(t.valid_range) as valid_until,                     jsonb_build_object('name', name) /* v_target_data_cols_jsonb_build_bare */ AS data_payload,                     jsonb_build_object('comment', comment) /* v_target_ephemeral_cols_jsonb_build_bare */ AS ephemeral_payload,                     jsonb_strip_nulls(jsonb_build_object()) /* v_target_nk_json_expr */ AS canonical_nk_json                 FROM (                         SELECT * FROM (                             SELECT DISTINCT ON (u.id, u.valid_from) * FROM (                                 (                                     SELECT * FROM etl_bench.legal_unit inner_t                                     WHERE (inner_t.id) IN (SELECT DISTINCT si.id FROM source_initial si WHERE (si.id) IS NOT NULL)                                 )                             ) u                         )                     ) AS t  /* v_target_rows_filter */"
929,Process Legal Units - Batch 2,,-2381107599654639950,1,21.032834,40000,301,0,0,0,0,114,12735,"CREATE TEMP TABLE time_points_with_unified_ids ON COMMIT DROP AS                 SELECT                     tpu.grouping_key,                     tpu.id,                     tpu.unified_causal_id as causal_id,                     tpu.point,                     tpu.is_new_entity,                     tpu.unified_stable_pk_payload as stable_pk_payload,                     tpu.stable_identity_columns_are_null,                     tpu.lookup_columns_unavailable,                     tpu.is_identifiable,                     tpu.is_ambiguous,                     tpu.conflicting_ids,                     tpu.unified_canonical_nk_json as canonical_nk_json                 FROM time_points_unified tpu"
c08,Process Legal Units - Batch 2,,-2068467933451381777,1,20.998625,10000,425,0,0,0,0,133,18306,"CREATE TEMP TABLE plan_with_op ON COMMIT DROP AS                 (                     SELECT * FROM (                         SELECT                             d.f_row_ids as row_ids, d.orig_source_target_relation, d.is_new_entity,                             CASE                                 WHEN d.is_ambiguous THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.is_new_entity AND NOT d.is_identifiable THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.t_from IS NULL THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.f_from IS NULL THEN 'DELETE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank = 1 THEN 'UPDATE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank > 1 THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank IS NULL THEN                                     CASE                                         WHEN d.unaffected_target_only_segment THEN NULL                                         ELSE 'SKIP_IDENTICAL'::sql_saga.temporal_merge_plan_action                                     END                                 ELSE 'ERROR'::sql_saga.temporal_merge_plan_action                             END as operation,                             id,                             CASE                                 WHEN d.is_new_entity AND d.canonical_nk_json IS NOT NULL                                 THEN d.canonical_nk_json || COALESCE(d.stable_pk_payload, '{}'::jsonb)                                 ELSE jsonb_build_object('id', d.id) || COALESCE(d.stable_pk_payload, '{}'::jsonb)                             END as entity_keys_json,                             jsonb_build_object('id', d.id) as identity_keys,                             jsonb_build_object() as lookup_keys,                             d.causal_id, d.t_from as old_valid_from, d.t_until as old_valid_until, d.f"
f3b,Process Legal Units - Batch 2,,-4193415169867768194,1,20.855583,10000,395,0,0,0,0,104,12011,"CREATE TEMP TABLE target_rows ON COMMIT DROP AS                 SELECT                     id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ -- (non-temporal identity columns)                     lower(t.valid_range) as valid_from, -- The temporal identity column (e.g., valid_from)                     NULL::integer /* v_causal_column_type */ as causal_id, -- Target rows do not originate from a source row, so causal_id is NULL. Type is introspected.                     jsonb_build_object('id', id) /* v_stable_pk_cols_jsonb_build_bare */ as stable_pk_payload,                     upper(t.valid_range) as valid_until,                     jsonb_build_object('name', name) /* v_target_data_cols_jsonb_build_bare */ AS data_payload,                     jsonb_build_object('comment', comment) /* v_target_ephemeral_cols_jsonb_build_bare */ AS ephemeral_payload,                     jsonb_strip_nulls(jsonb_build_object()) /* v_target_nk_json_expr */ AS canonical_nk_json                 FROM (                         SELECT * FROM (                             SELECT DISTINCT ON (u.id, u.valid_from) * FROM (                                 (                                     SELECT * FROM etl_bench.legal_unit inner_t                                     WHERE (inner_t.id) IN (SELECT DISTINCT si.id FROM source_initial si WHERE (si.id) IS NOT NULL)                                 )                             ) u                         )                     ) AS t  /* v_target_rows_filter */"
576,Process Legal Units - Batch 2,,5147944785677299242,1,20.602708,10000,450,0,0,0,0,144,16171,"CREATE TEMP TABLE diff_ranked ON COMMIT DROP AS                 SELECT                     d.*,                     CASE                         WHEN d.t_from IS NULL OR d.f_from IS NULL THEN NULL                         WHEN d.f_from = d.t_from AND d.f_until = d.t_until AND d.f_payload IS NOT DISTINCT FROM d.t_payload THEN NULL                         ELSE                             row_number() OVER (                                 PARTITION BY d.grouping_key, d.t_from                                 ORDER BY                                     CASE WHEN d.f_from = d.t_from THEN 1 ELSE 2 END,                                     CASE WHEN d.f_payload - '{comment}'::text[] IS NOT DISTINCT FROM d.t_payload - '{comment}'::text[] THEN 1 ELSE 2 END,                                     d.f_from,                                     d.f_until                             )                     END as update_rank                 FROM diff d"
592,Process Legal Units - Batch 2,,-2354556386023983324,1,20.341084,10000,326,0,0,0,0,133,18306,"CREATE TEMP TABLE plan_with_op ON COMMIT DROP AS                 (                     SELECT * FROM (                         SELECT                             d.f_row_ids as row_ids, d.orig_source_target_relation, d.is_new_entity,                             CASE                                 WHEN d.is_ambiguous THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.is_new_entity AND NOT d.is_identifiable THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.t_from IS NULL THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.f_from IS NULL THEN 'DELETE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank = 1 THEN 'UPDATE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank > 1 THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank IS NULL THEN                                     CASE                                         WHEN d.unaffected_target_only_segment THEN NULL                                         ELSE 'SKIP_IDENTICAL'::sql_saga.temporal_merge_plan_action                                     END                                 ELSE 'ERROR'::sql_saga.temporal_merge_plan_action                             END as operation,                             id,                             CASE                                 WHEN d.is_new_entity AND d.canonical_nk_json IS NOT NULL                                 THEN d.canonical_nk_json || COALESCE(d.stable_pk_payload, '{}'::jsonb)                                 ELSE jsonb_build_object('id', d.id) || COALESCE(d.stable_pk_payload, '{}'::jsonb)                             END as entity_keys_json,                             jsonb_build_object('id', d.id) as identity_keys,                             jsonb_build_object() as lookup_keys,                             d.causal_id, d.t_from as old_valid_from, d.t_until as old_valid_until, d.f"
37c,Process Legal Units - Batch 2,,6259880232974284115,1,20.131542,10000,355,0,0,0,0,144,16171,"CREATE TEMP TABLE diff_ranked ON COMMIT DROP AS                 SELECT                     d.*,                     CASE                         WHEN d.t_from IS NULL OR d.f_from IS NULL THEN NULL                         WHEN d.f_from = d.t_from AND d.f_until = d.t_until AND d.f_payload IS NOT DISTINCT FROM d.t_payload THEN NULL                         ELSE                             row_number() OVER (                                 PARTITION BY d.grouping_key, d.t_from                                 ORDER BY                                     CASE WHEN d.f_from = d.t_from THEN 1 ELSE 2 END,                                     CASE WHEN d.f_payload - '{comment}'::text[] IS NOT DISTINCT FROM d.t_payload - '{comment}'::text[] THEN 1 ELSE 2 END,                                     d.f_from,                                     d.f_until                             )                     END as update_rank                 FROM diff d"
58e,Process Legal Units - Batch 2,,9187673216027458375,1,15.642167,10000,432,0,0,0,0,141,19853,"CREATE TEMP TABLE plan ON COMMIT DROP AS                 SELECT                     p.row_ids, p.operation, p.causal_id, p.is_new_entity,                     p.id,                     p.entity_keys_json as entity_keys,                     p.identity_keys, p.lookup_keys,                     p.orig_source_target_relation, p.b_a_relation, p.old_valid_from, p.old_valid_until,                     p.new_valid_from, p.new_valid_until, p.data, p.feedback, p.trace,                     p.grouping_key,                     CASE                         WHEN p.operation <> 'UPDATE' THEN NULL::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from = p.old_valid_from AND p.new_valid_until = p.old_valid_until THEN 'NONE'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from <= p.old_valid_from AND p.new_valid_until >= p.old_valid_until THEN 'GROW'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from >= p.old_valid_from AND p.new_valid_until <= p.old_valid_until THEN 'SHRINK'::sql_saga.temporal_merge_update_effect                         ELSE 'MOVE'::sql_saga.temporal_merge_update_effect                     END AS update_effect                 FROM plan_with_op p                 LEFT JOIN source_rows_with_new_flag source_row ON source_row.source_row_id = p.row_ids[1]"
e13,Process Legal Units - Batch 2,,5055573923988817461,1,15.16875,10000,341,0,0,0,0,141,19853,"CREATE TEMP TABLE plan ON COMMIT DROP AS                 SELECT                     p.row_ids, p.operation, p.causal_id, p.is_new_entity,                     p.id,                     p.entity_keys_json as entity_keys,                     p.identity_keys, p.lookup_keys,                     p.orig_source_target_relation, p.b_a_relation, p.old_valid_from, p.old_valid_until,                     p.new_valid_from, p.new_valid_until, p.data, p.feedback, p.trace,                     p.grouping_key,                     CASE                         WHEN p.operation <> 'UPDATE' THEN NULL::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from = p.old_valid_from AND p.new_valid_until = p.old_valid_until THEN 'NONE'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from <= p.old_valid_from AND p.new_valid_until >= p.old_valid_until THEN 'GROW'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from >= p.old_valid_from AND p.new_valid_until <= p.old_valid_until THEN 'SHRINK'::sql_saga.temporal_merge_update_effect                         ELSE 'MOVE'::sql_saga.temporal_merge_update_effect                     END AS update_effect                 FROM plan_with_op p                 LEFT JOIN source_rows_with_new_flag source_row ON source_row.source_row_id = p.row_ids[1]"
4d1,Process Legal Units - Batch 2,,2346888588666524139,1,14.453542,40000,352,0,0,0,0,108,12005,"CREATE TEMP TABLE time_points_raw ON COMMIT DROP AS                 SELECT id, causal_id, valid_from AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows                 UNION ALL                 SELECT id, causal_id, valid_until AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows"
380,Process Legal Units - Batch 2,,3254511572182529394,1,14.095124,40000,281,0,0,0,0,108,12005,"CREATE TEMP TABLE time_points_raw ON COMMIT DROP AS                 SELECT id, causal_id, valid_from AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows                 UNION ALL                 SELECT id, causal_id, valid_until AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows"
b52,Process Legal Units - Batch 2,,5849653773365333279,1,11.301958,10000,392,0,0,0,0,121,13661,"CREATE TEMP TABLE source_rows_with_matches ON COMMIT DROP AS                 SELECT                     source_row.*,                     target_row.stable_pk_payload as discovered_stable_pk_payload,                     target_row.id AS discovered_id_1 /* v_propagated_id_cols_list */                 FROM source_with_eclipsed_flag source_row                 LEFT JOIN target_rows target_row ON (source_row.id = target_row.id /* v_source_rows_exists_join_expr */)"
181,Process Legal Units - Batch 2,,1995507501247956172,1,10.831498999999999,10000,305,0,0,0,0,120,13601,"CREATE TEMP TABLE source_rows_with_matches ON COMMIT DROP AS                 SELECT                     source_row.*,                     target_row.stable_pk_payload as discovered_stable_pk_payload,                     target_row.id AS discovered_id_1 /* v_propagated_id_cols_list */                 FROM source_with_eclipsed_flag source_row                 LEFT JOIN target_rows target_row ON (source_row.id = target_row.id /* v_source_rows_exists_join_expr */)"
a51,Process Legal Units - Batch 2,,-8767491607573256645,1,10.527292,10000,393,0,0,0,0,123,13909,"CREATE TEMP TABLE source_rows_with_new_flag ON COMMIT DROP AS                 SELECT *, NOT target_entity_exists as is_new_entity                 FROM source_rows"
1f7,Process Legal Units - Batch 2,,5012345967240423926,1,10.368542,10000,426,0,0,0,0,135,19849,"CREATE TEMP TABLE source_rows_with_early_feedback ON COMMIT DROP AS                 SELECT                     s.*,                     CASE                         WHEN s.is_ambiguous                         THEN jsonb_build_object( 'operation', 'ERROR'::text, 'message', 'Source row is ambiguous. It matches multiple distinct target entities: ' || s.conflicting_ids::text )                         WHEN NOT s.is_identifiable AND s.is_new_entity                         THEN jsonb_build_object( 'operation', 'ERROR'::text, 'message', 'Source row is unidentifiable. It has NULL for all stable identity columns ' || replace('{id}'::text, '""', '') || ' and all natural keys ' || replace(NULL::text, '""', '') )                         WHEN NOT s.temporal_columns_are_consistent                         THEN jsonb_build_object( 'operation', 'ERROR'::text, 'message', 'Source row has inconsistent temporal columns. Column ""' || 'valid_until' || '"" must be equal to column ""' || NULL || '"" + ' || NULL || '.' )                         WHEN s.is_eclipsed                         THEN jsonb_build_object( 'operation', 'SKIP_ECLIPSED'::text, 'message', 'Source row was eclipsed by row_ids=' || s.eclipsed_by::text || ' in the same batch.' )                         ELSE NULL                     END as early_feedback                 FROM source_rows_with_canonical_key s"
24c,Process Legal Units - Batch 2,,-957741634502868070,1,10.358833,10000,402,0,0,0,0,126,14387,"CREATE TEMP TABLE source_rows_with_nk_json ON COMMIT DROP AS                 SELECT source_row.*, jsonb_strip_nulls(jsonb_build_object()) /* v_lookup_keys_as_jsonb_expr */ as nk_json, ARRAY(SELECT e FROM unnest(ARRAY[]::TEXT[]) e WHERE e IS NOT NULL ORDER BY e) /* v_lookup_keys_as_array_expr */ as nk_non_null_keys_array                 FROM source_rows_with_new_flag source_row"
91a,Process Legal Units - Batch 2,,8689595743856886431,1,10.311416,0,134,0,0,0,0,15,1597,CREATE INDEX ON active_source_rows (grouping_key)
e6d,Process Legal Units - Batch 2,,-257287304656928252,1,10.175042000000001,10000,312,0,0,0,0,123,13909,"CREATE TEMP TABLE source_rows_with_new_flag ON COMMIT DROP AS                 SELECT *, NOT target_entity_exists as is_new_entity                 FROM source_rows"
dd5,Process Legal Units - Batch 2,,2613701250391606255,1,10.075833,10000,389,0,0,0,0,130,22391,"CREATE TEMP TABLE source_rows_with_discovery ON COMMIT DROP AS                 SELECT                     m.*,                     a.match_count,                     a.conflicting_ids,                     (a.match_count > 1) as is_ambiguous                 FROM source_rows_with_matches m                 JOIN source_rows_with_aggregates a ON m.source_row_id = a.source_row_id"
12b,Process Legal Units - Batch 2,,4895990506256861755,10000,8.364205000000068,10000,0,0,0,0,0,0,0,SELECT array_agg(DISTINCT v)                    FROM unnest(from_sources) AS v
476,Process Legal Units - Batch 2,,7743831913079285872,10000,7.009177000000146,10000,0,0,0,0,0,0,0,SELECT array_agg(DISTINCT v)                     FROM unnest(until_sources) AS v
ee0,Process Legal Units - Batch 2,,725758841111022991,144,5.138914000000001,144,1922,0,0,0,0,0,0,"EXISTS (         SELECT 1 FROM pg_event_trigger_ddl_commands() ddl         JOIN pg_class c ON c.oid = ddl.objid         JOIN pg_namespace n ON n.oid = c.relnamespace         WHERE EXISTS (SELECT 1 FROM sql_saga.era e WHERE (e.table_schema, e.table_name) = (n.nspname, c.relname))            OR EXISTS (SELECT 1 FROM sql_saga.updatable_view v JOIN pg_class vc ON vc.relname = v.view_name JOIN pg_namespace vn ON vn.oid = vc.relnamespace AND vn.nspname = v.view_schema WHERE vc.oid = c.oid)            -- Also check system_versioning objects (history table, view)            OR EXISTS (SELECT 1 FROM sql_saga.system_versioning sv WHERE (sv.history_schema_name, sv.history_table_name) = (n.nspname, c.relname))            OR EXISTS (SELECT 1 FROM sql_saga.system_versioning sv WHERE (sv.view_schema_name, sv.view_table_name) = (n.nspname, c.relname))     )"
2b3,Process Legal Units - Batch 2,,1464568031695687146,144,0.630328,144,40,0,0,0,0,0,0,SELECT array_agg(command_tag)           FROM pg_event_trigger_ddl_commands()
057,Process Legal Units - Batch 2,,-8708312726399770535,155,0.46654199999999946,155,0,0,0,0,0,0,0,"EXISTS (             SELECT 1 FROM pg_event_trigger_dropped_objects() dobj             WHERE dobj.object_type = 'table'               AND (dobj.schema_name, dobj.object_name) = (r.table_schema, r.table_name)         )"
1b9,Process Legal Units - Batch 2,,-1465262961312880621,155,0.25332599999999955,155,465,0,0,0,0,0,0,"NOT EXISTS (                 SELECT FROM pg_catalog.pg_constraint AS c                 WHERE (c.conrelid, c.conname) = (r.table_oid, r.unique_constraint)             )"
64b,Process Legal Units - Batch 2,,8008625629997484951,144,0.23420099999999974,0,0,0,0,0,0,0,0,SELECT * FROM pg_event_trigger_ddl_commands()
d0a,Process Legal Units - Batch 2,,-8889318315713072803,155,0.034961000000000034,155,0,0,0,0,0,0,0,"r.exclude_constraint IS NOT NULL AND NOT EXISTS (             SELECT FROM pg_catalog.pg_constraint AS c             WHERE (c.conrelid, c.conname) = (r.table_oid, r.exclude_constraint)         )"
cae,Process Legal Units - Batch 3,,7104651493870380753,1,4886.9465,0,529192,0,3066,3071,0,176760,16481376,CALL etl_bench.process_legal_units(v_batch_id)
5dc,Process Legal Units - Batch 3,,-5532412991206003072,1,4781.117375,0,408405,0,3066,3071,0,136693,13882147,"CALL sql_saga.temporal_merge(         target_table => 'etl_bench.legal_unit',         source_table => 'source_view_lu',         primary_identity_columns => ARRAY['id'],         ephemeral_columns => ARRAY['comment'],         mode => 'MERGE_ENTITY_PATCH',         founding_id_column => 'founding_id',         update_source_with_identity => true,         update_source_with_feedback => true,         feedback_status_column => 'merge_statuses',         feedback_status_key => 'legal_unit',         feedback_error_column => 'merge_errors',         feedback_error_key => 'legal_unit'     )"
641,Process Legal Units - Batch 3,,-4634225613452528969,1,4069.1159580000003,10000,25624,0,3066,3071,0,5525,581702,"INSERT INTO temporal_merge_plan     SELECT * FROM sql_saga.temporal_merge_plan(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         identity_columns => v_identity_cols_discovered,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         delete_mode => temporal_merge.delete_mode,         lookup_keys => v_natural_identity_keys_discovered,         ephemeral_columns => temporal_merge.ephemeral_columns,         p_log_trace => v_log_trace,         p_log_sql => v_log_sql     )"
026,Process Legal Units - Batch 3,,-788747283814772468,1,2563.740875,10000,395,0,0,0,0,116,13061,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         -- OPTIMIZATION: Use pre-computed valid_range instead of repeated daterange() calls                         -- Combined with composite index, this provides 30-40 percent total performance improvement                         COALESCE(sql_saga.covers_without_gaps(s2.valid_range, s1.valid_range ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.lookup_columns_unavailable AND (false))                             OR                             (s1.lookup_columns_unavailable AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info"
32d,Process Legal Units - Batch 3,,4573562956278615873,1,2563.2271659999997,10000,302,0,0,0,0,116,13061,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         -- OPTIMIZATION: Use pre-computed valid_range instead of repeated daterange() calls                         -- Combined with composite index, this provides 30-40 percent total performance improvement                         COALESCE(sql_saga.covers_without_gaps(s2.valid_range, s1.valid_range ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.lookup_columns_unavailable AND (false))                             OR                             (s1.lookup_columns_unavailable AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info;"
5b8,Process Legal Units - Batch 3,,4313330175016020501,1,708.955041,0,381876,0,0,0,0,130903,13276453,"CALL sql_saga.temporal_merge_execute(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         identity_columns => v_identity_cols_discovered,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         update_source_with_identity => temporal_merge.update_source_with_identity,         lookup_columns => v_natural_identity_cols_discovered,         delete_mode => temporal_merge.delete_mode,         update_source_with_feedback => temporal_merge.update_source_with_feedback,         feedback_status_column => temporal_merge.feedback_status_column,         feedback_status_key => temporal_merge.feedback_status_key,         feedback_error_column => temporal_merge.feedback_error_column,         feedback_error_key => temporal_merge.feedback_error_key,         ephemeral_columns => temporal_merge.ephemeral_columns,         delay_constraints => temporal_merge.delay_constraints     )"
4df,Process Legal Units - Batch 3,,-723802098106927723,1,501.15687499999996,10000,240677,0,0,0,0,80577,8194534,"UPDATE etl_bench.legal_unit t SET valid_range = p.new_valid_range::daterange, name = CASE WHEN p.data ? 'name' THEN (p.data->>'name')::text ELSE t.name END, comment = CASE WHEN p.data ? 'comment' THEN (p.data->>'comment')::text ELSE t.comment END                                 FROM (SELECT *, (entity_keys->>'id')::integer AS id_ek FROM temporal_merge_plan WHERE operation = 'UPDATE' AND statement_seq = 1 ORDER BY plan_op_seq) p                                 WHERE t.id = p.id_ek AND t.valid_range = p.old_valid_range::daterange"
0aa,Process Legal Units - Batch 3,,-8259425963603516266,1,216.4455,0,248,0,0,0,0,57,25581,ANALYZE resolved_atomic_segments_with_payloads
c3d,Process Legal Units - Batch 3,,6020602004421484228,1,128.219625,20000,501,0,0,0,0,140,16111,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     with_base_payload.*,                     with_base_payload.stable_pk_payload as propagated_stable_pk_payload                 FROM (                     SELECT                         seg.*, source_payloads.source_row_id, source_payloads.contributing_row_ids,                          source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                         source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until                     FROM all_segments seg                                              LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE                  ((seg.is_new_entity AND source_row.grouping_key = seg.grouping_key)                 OR                 (NOT seg.is_new_entity AND (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))))              -- v_lateral_join_sr_to_seg                                 AND daterange(seg.valid_from, seg.valid_until) <@ daterange(source_row.valid_from, source_row.valid_until)                             ),                             running_payload AS (                                 SELECT rn, source_row_id, data_payload, ephemeral_payload, valid_from, val"
c9a,Process Legal Units - Batch 3,,9079426233396750581,1,128.031542,20000,518,0,747,748,0,152,18429,"CREATE TEMP TABLE resolved_atomic_segments_with_propagated_ids ON COMMIT DROP AS                 SELECT                     *,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY grouping_key ORDER BY valid_from) as unified_canonical_nk_json,                     COALESCE(                         contributing_row_ids,                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as causal_source_row_ids,                     COALESCE(                         s_valid_from,                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_from,                     COALESCE(                         s_valid_until,                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_until                 FROM (                     SELECT                         *,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from) AS look_behind_grp,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from DESC) AS look_ahead_grp                     FROM resolved_atomic_segments_with_payloads /* v_resolver_from */                 ) with_grp"
d57,Process Legal Units - Batch 3,,-4153295300979878628,1,127.40316700000001,20000,352,0,0,0,0,140,16111,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     with_base_payload.*,                     with_base_payload.stable_pk_payload as propagated_stable_pk_payload                 FROM (                     SELECT                         seg.*, source_payloads.source_row_id, source_payloads.contributing_row_ids,                          source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                         source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until                     FROM all_segments seg                                              LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE                  ((seg.is_new_entity AND source_row.grouping_key = seg.grouping_key)                 OR                 (NOT seg.is_new_entity AND (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))))              -- v_lateral_join_sr_to_seg                                 AND daterange(seg.valid_from, seg.valid_until) <@ daterange(source_row.valid_from, source_row.valid_until)                             ),                             running_payload AS (                                 SELECT rn, source_row_id, data_payload, ephemeral_payload, valid_from, val"
2d5,Process Legal Units - Batch 3,,8086196219516147042,1,126.463459,20000,378,0,747,748,0,152,18429,"CREATE TEMP TABLE resolved_atomic_segments_with_propagated_ids ON COMMIT DROP AS                 SELECT                     *,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY grouping_key ORDER BY valid_from) as unified_canonical_nk_json,                     COALESCE(                         contributing_row_ids,                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as causal_source_row_ids,                     COALESCE(                         s_valid_from,                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_from,                     COALESCE(                         s_valid_until,                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_until                 FROM (                     SELECT                         *,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from) AS look_behind_grp,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from DESC) AS look_ahead_grp                     FROM resolved_atomic_segments_with_payloads /* v_resolver_from */                 ) with_grp"
c5a,Process Legal Units - Batch 3,,2973456759399252638,1,111.126875,10000,443,0,556,557,0,127,14354,"CREATE TEMP TABLE coalesced_final_segments ON COMMIT DROP AS                 SELECT                     grouping_key, max(id) as id,                     sql_saga.first(causal_id ORDER BY valid_from) as causal_id,                     sql_saga.first(stable_identity_columns_are_null ORDER BY valid_from) as stable_identity_columns_are_null,                     sql_saga.first(lookup_columns_unavailable ORDER BY valid_from) as lookup_columns_unavailable,                     sql_saga.first(is_new_entity ORDER BY valid_from) as is_new_entity,                     sql_saga.first(is_identifiable ORDER BY valid_from) as is_identifiable,                     sql_saga.first(is_ambiguous ORDER BY valid_from) as is_ambiguous,                     sql_saga.first(conflicting_ids ORDER BY valid_from) as conflicting_ids,                     sql_saga.first(unified_canonical_nk_json ORDER BY valid_from) as canonical_nk_json,                     sql_saga.first(orig_source_target_relation ORDER BY valid_from) as orig_source_target_relation,                     sql_saga.first(t_valid_from ORDER BY valid_from) as ancestor_valid_from,                     MIN(valid_from) as valid_from,                     MAX(valid_until) as valid_until,                     (sql_saga.first(data_payload ORDER BY valid_from DESC) || sql_saga.first(ephemeral_payload ORDER BY valid_from DESC)) as final_payload,                     sql_saga.first(stable_pk_payload ORDER BY valid_from DESC) as stable_pk_payload,                     bool_and(unaffected_target_only_segment) as unaffected_target_only_segment,                     (SELECT array_agg(DISTINCT e) FROM unnest(array_concat_agg(causal_source_row_ids)) e WHERE e IS NOT NULL) as row_ids,                     CASE WHEN 'f'::boolean                         THEN jsonb_build_object( 'cte', 'coalesced', 'island_group_id', island_group_id, 'coalesced_stable_pk', sql_saga.first(stable_pk_payload ORDER BY valid_from DESC), 'final_payload', sql_saga.first(data_payload ORDER BY valid_from DESC), 'final_payload_sans_epheme"
aa5,Process Legal Units - Batch 3,,-8237077405251109710,1,109.706374,10000,323,0,556,557,0,127,14354,"CREATE TEMP TABLE coalesced_final_segments ON COMMIT DROP AS                 SELECT                     grouping_key, max(id) as id,                     sql_saga.first(causal_id ORDER BY valid_from) as causal_id,                     sql_saga.first(stable_identity_columns_are_null ORDER BY valid_from) as stable_identity_columns_are_null,                     sql_saga.first(lookup_columns_unavailable ORDER BY valid_from) as lookup_columns_unavailable,                     sql_saga.first(is_new_entity ORDER BY valid_from) as is_new_entity,                     sql_saga.first(is_identifiable ORDER BY valid_from) as is_identifiable,                     sql_saga.first(is_ambiguous ORDER BY valid_from) as is_ambiguous,                     sql_saga.first(conflicting_ids ORDER BY valid_from) as conflicting_ids,                     sql_saga.first(unified_canonical_nk_json ORDER BY valid_from) as canonical_nk_json,                     sql_saga.first(orig_source_target_relation ORDER BY valid_from) as orig_source_target_relation,                     sql_saga.first(t_valid_from ORDER BY valid_from) as ancestor_valid_from,                     MIN(valid_from) as valid_from,                     MAX(valid_until) as valid_until,                     (sql_saga.first(data_payload ORDER BY valid_from DESC) || sql_saga.first(ephemeral_payload ORDER BY valid_from DESC)) as final_payload,                     sql_saga.first(stable_pk_payload ORDER BY valid_from DESC) as stable_pk_payload,                     bool_and(unaffected_target_only_segment) as unaffected_target_only_segment,                     (SELECT array_agg(DISTINCT e) FROM unnest(array_concat_agg(causal_source_row_ids)) e WHERE e IS NOT NULL) as row_ids,                     CASE WHEN 'f'::boolean                         THEN jsonb_build_object( 'cte', 'coalesced', 'island_group_id', island_group_id, 'coalesced_stable_pk', sql_saga.first(stable_pk_payload ORDER BY valid_from DESC), 'final_payload', sql_saga.first(data_payload ORDER BY valid_from DESC), 'final_payload_sans_epheme"
011,Process Legal Units - Batch 3,,8679993553546922744,1,108.0245,40000,380,0,494,495,0,116,13071,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
779,Process Legal Units - Batch 3,,2335399437257891460,1,106.88825,40000,304,0,494,495,0,116,13071,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
775,Process Legal Units - Batch 3,,-6251707813684716315,1,106.386667,10000,135437,0,0,0,0,50142,5050488,"UPDATE source_view_lu s             SET merge_statuses = COALESCE(s.merge_statuses, '{}'::jsonb) || jsonb_build_object('legal_unit', f.status), merge_errors = CASE WHEN f.error_message IS NOT NULL THEN COALESCE(s.merge_errors, '{}'::jsonb) || jsonb_build_object('legal_unit', f.error_message) ELSE COALESCE(s.merge_errors, '{}'::jsonb) - 'legal_unit' END             FROM pg_temp.temporal_merge_feedback f             WHERE s.row_id = f.source_row_id"
98e,Process Legal Units - Batch 3,,0,36,98.04217,0,7930,0,0,0,0,2022,141653,CALL sql_saga.benchmark_reset()
1f4,Process Legal Units - Batch 3,,7295163325594009324,1,94.371791,10000,115168,0,0,0,0,40025,2595944,"INSERT INTO etl_bench.identity_resolution (identity_correlation, legal_unit_id, resolved_batch)     SELECT DISTINCT          identity_correlation,         legal_unit_id,         p_batch_id     FROM etl_bench.data_table     WHERE batch = p_batch_id AND legal_unit_id IS NOT NULL     ON CONFLICT (identity_correlation) DO UPDATE SET         legal_unit_id = EXCLUDED.legal_unit_id,         resolved_batch = EXCLUDED.resolved_batch"
827,Process Legal Units - Batch 3,,5432145740772416088,1,76.862459,0,211,0,0,0,0,48,11420,ANALYZE active_source_rows
cf8,Process Legal Units - Batch 3,,-518691661278450688,1,67.365792,0,183,0,0,0,0,40,9072,ANALYZE source_rows_with_nk_json
d67,Process Legal Units - Batch 3,,4494928315034638917,1,67.065291,20000,483,0,771,772,0,153,18572,"CREATE TEMP TABLE island_group ON COMMIT DROP AS                 SELECT                     *,                     SUM(is_island_start) OVER (PARTITION BY grouping_key ORDER BY valid_from) as island_group_id                 FROM (                     SELECT                         *,                         CASE                             WHEN prev_valid_until IS NULL                             OR prev_valid_until <> valid_from                             OR (prev_data_hash IS DISTINCT FROM data_hash)                             THEN 1                             ELSE 0                         END as is_island_start                     FROM (                         SELECT                             *,                             LAG(valid_until) OVER w as prev_valid_until,                             LAG(data_hash) OVER w as prev_data_hash,                             LAG(data_payload) OVER w as prev_data_payload                         FROM resolved_atomic_segments ras                         WHERE ras.data_payload IS NOT NULL                         WINDOW w AS (PARTITION BY grouping_key ORDER BY valid_from)                     ) s1                 ) s2"
2d6,Process Legal Units - Batch 3,,-2675794321567617346,1,65.49662500000001,20000,375,0,771,772,0,153,18572,"CREATE TEMP TABLE island_group ON COMMIT DROP AS                 SELECT                     *,                     SUM(is_island_start) OVER (PARTITION BY grouping_key ORDER BY valid_from) as island_group_id                 FROM (                     SELECT                         *,                         CASE                             WHEN prev_valid_until IS NULL                             OR prev_valid_until <> valid_from                             OR (prev_data_hash IS DISTINCT FROM data_hash)                             THEN 1                             ELSE 0                         END as is_island_start                     FROM (                         SELECT                             *,                             LAG(valid_until) OVER w as prev_valid_until,                             LAG(data_hash) OVER w as prev_data_hash,                             LAG(data_payload) OVER w as prev_data_payload                         FROM resolved_atomic_segments ras                         WHERE ras.data_payload IS NOT NULL                         WINDOW w AS (PARTITION BY grouping_key ORDER BY valid_from)                     ) s1                 ) s2"
099,Process Legal Units - Batch 3,,-3117954689326007662,1,47.69025,20000,474,0,0,0,0,142,16260,"CREATE TEMP TABLE resolved_atomic_segments ON COMMIT DROP AS                 SELECT                     grouping_key, id,  stable_identity_columns_are_null, lookup_columns_unavailable, is_new_entity, is_identifiable, is_ambiguous, conflicting_ids, unified_canonical_nk_json,                     valid_from, valid_until, t_valid_from, t_valid_until, propagated_s_valid_from, propagated_s_valid_until, causal_source_row_ids, causal_id, propagated_stable_pk_payload as stable_pk_payload,                     causal_source_row_ids IS NULL AS unaffected_target_only_segment,                     s_data_payload, t_data_payload,                     sql_saga.get_allen_relation(propagated_s_valid_from, propagated_s_valid_until, t_valid_from, t_valid_until) AS orig_source_target_relation,                     COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb) as data_payload,                     md5((jsonb_strip_nulls(COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb)))::text) as data_hash,                     CASE                          WHEN s_data_payload IS NULL THEN t_ephemeral_payload                         ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb)                     END as ephemeral_payload,                     CASE WHEN 'f'::boolean                         THEN trace || jsonb_build_object( 'cte', 'ras', 'segment_stable_pk', propagated_stable_pk_payload, 'final_data_payload', COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb), 'final_ephemeral_payload', CASE WHEN s_data_payload IS NULL THEN t_ephemeral_payload ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb) END )                         ELSE NULL                     END as trace                 FROM resolved_atomic_segments_with_propagated_ids"
3f1,Process Legal Units - Batch 3,,-694293067803121576,1,47.154001,20000,354,0,0,0,0,142,16260,"CREATE TEMP TABLE resolved_atomic_segments ON COMMIT DROP AS                 SELECT                     grouping_key, id,  stable_identity_columns_are_null, lookup_columns_unavailable, is_new_entity, is_identifiable, is_ambiguous, conflicting_ids, unified_canonical_nk_json,                     valid_from, valid_until, t_valid_from, t_valid_until, propagated_s_valid_from, propagated_s_valid_until, causal_source_row_ids, causal_id, propagated_stable_pk_payload as stable_pk_payload,                     causal_source_row_ids IS NULL AS unaffected_target_only_segment,                     s_data_payload, t_data_payload,                     sql_saga.get_allen_relation(propagated_s_valid_from, propagated_s_valid_until, t_valid_from, t_valid_until) AS orig_source_target_relation,                     COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb) as data_payload,                     md5((jsonb_strip_nulls(COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb)))::text) as data_hash,                     CASE                          WHEN s_data_payload IS NULL THEN t_ephemeral_payload                         ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb)                     END as ephemeral_payload,                     CASE WHEN 'f'::boolean                         THEN trace || jsonb_build_object( 'cte', 'ras', 'segment_stable_pk', propagated_stable_pk_payload, 'final_data_payload', COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb), 'final_ephemeral_payload', CASE WHEN s_data_payload IS NULL THEN t_ephemeral_payload ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb) END )                         ELSE NULL                     END as trace                 FROM resolved_atomic_segments_with_propagated_ids"
e48,Process Legal Units - Batch 3,,5039860120774769872,1,44.12025,0,122,0,0,0,0,26,7165,ANALYZE source_initial
580,Process Legal Units - Batch 3,,4156395469617828009,1,42.218626,10000,0,0,0,0,0,0,0,"WITH RECURSIVE ordered_plan AS (                     SELECT                         row_number() OVER ( ORDER BY p.grouping_key, p.id, CASE p.operation WHEN 'DELETE' THEN 1 WHEN 'UPDATE' THEN 2 WHEN 'INSERT' THEN 3 ELSE 4 END, p.update_effect NULLS FIRST, CASE WHEN p.update_effect = 'MOVE' THEN 1 ELSE 0 END, CASE WHEN p.update_effect = 'MOVE' THEN COALESCE(p.old_valid_from, p.new_valid_from) END DESC NULLS LAST, COALESCE(p.old_valid_from, p.new_valid_from), (p.row_ids[1]) )::BIGINT as plan_op_seq,                         p.*                     FROM plan p                 ),                 -- For MOVE operations, group into the largest possible batches that can execute together.                 -- Within a single UPDATE statement, all rows see the pre-update state (MVCC snapshot).                 -- So if MOVE A's new_range overlaps MOVE B's old_range, they cannot be in the same statement.                 --                 -- Algorithm: Process MOVEs in plan_op_seq order (which is old_valid_from DESC).                 -- Track a multirange of old_ranges in the current batch. For each MOVE:                 -- - If new_range overlaps the batch's multirange, start a new batch                 -- - Add this MOVE's old_range to the batch's multirange                 --                 -- We use a recursive CTE to accumulate the multirange with reset-on-conflict logic.                 moves_ordered AS (                     SELECT                         o.plan_op_seq,                         o.grouping_key,                         o.old_valid_from,                         o.old_valid_until,                         o.new_valid_from,                         o.new_valid_until,                         row_number() OVER (PARTITION BY o.grouping_key ORDER BY o.plan_op_seq) AS move_seq                     FROM ordered_plan o                     WHERE o.operation = 'UPDATE' AND o.update_effect = 'MOVE'                 ),                 moves_with_batch AS (                     -- Base case: first MOVE in each entity starts b"
f43,Process Legal Units - Batch 3,,1428552154429020267,1,37.462166,30000,374,0,498,499,0,110,12245,"CREATE TEMP TABLE time_points ON COMMIT DROP AS                 SELECT DISTINCT ON (grouping_key, point) *                 FROM time_points_with_unified_ids                 ORDER BY grouping_key, point, causal_id DESC NULLS LAST"
e5f,Process Legal Units - Batch 3,,6254436778457358929,1,36.242749999999994,30000,294,0,498,499,0,110,12245,"CREATE TEMP TABLE time_points ON COMMIT DROP AS                 SELECT DISTINCT ON (grouping_key, point) *                 FROM time_points_with_unified_ids                 ORDER BY grouping_key, point, causal_id DESC NULLS LAST"
3bf,Process Legal Units - Batch 3,,-2068467933451381777,1,33.736292,10000,435,0,0,0,0,132,14650,"CREATE TEMP TABLE plan_with_op ON COMMIT DROP AS                 (                     SELECT * FROM (                         SELECT                             d.f_row_ids as row_ids, d.orig_source_target_relation, d.is_new_entity,                             CASE                                 WHEN d.is_ambiguous THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.is_new_entity AND NOT d.is_identifiable THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.t_from IS NULL THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.f_from IS NULL THEN 'DELETE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank = 1 THEN 'UPDATE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank > 1 THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank IS NULL THEN                                     CASE                                         WHEN d.unaffected_target_only_segment THEN NULL                                         ELSE 'SKIP_IDENTICAL'::sql_saga.temporal_merge_plan_action                                     END                                 ELSE 'ERROR'::sql_saga.temporal_merge_plan_action                             END as operation,                             id,                             CASE                                 WHEN d.is_new_entity AND d.canonical_nk_json IS NOT NULL                                 THEN d.canonical_nk_json || COALESCE(d.stable_pk_payload, '{}'::jsonb)                                 ELSE jsonb_build_object('id', d.id) || COALESCE(d.stable_pk_payload, '{}'::jsonb)                             END as entity_keys_json,                             jsonb_build_object('id', d.id) as identity_keys,                             jsonb_build_object() as lookup_keys,                             d.causal_id, d.t_from as old_valid_from, d.t_until as old_valid_until, d.f"
4f5,Process Legal Units - Batch 3,,-2354556386023983324,1,33.08775,10000,329,0,0,0,0,132,14650,"CREATE TEMP TABLE plan_with_op ON COMMIT DROP AS                 (                     SELECT * FROM (                         SELECT                             d.f_row_ids as row_ids, d.orig_source_target_relation, d.is_new_entity,                             CASE                                 WHEN d.is_ambiguous THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.is_new_entity AND NOT d.is_identifiable THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.t_from IS NULL THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.f_from IS NULL THEN 'DELETE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank = 1 THEN 'UPDATE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank > 1 THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank IS NULL THEN                                     CASE                                         WHEN d.unaffected_target_only_segment THEN NULL                                         ELSE 'SKIP_IDENTICAL'::sql_saga.temporal_merge_plan_action                                     END                                 ELSE 'ERROR'::sql_saga.temporal_merge_plan_action                             END as operation,                             id,                             CASE                                 WHEN d.is_new_entity AND d.canonical_nk_json IS NOT NULL                                 THEN d.canonical_nk_json || COALESCE(d.stable_pk_payload, '{}'::jsonb)                                 ELSE jsonb_build_object('id', d.id) || COALESCE(d.stable_pk_payload, '{}'::jsonb)                             END as entity_keys_json,                             jsonb_build_object('id', d.id) as identity_keys,                             jsonb_build_object() as lookup_keys,                             d.causal_id, d.t_from as old_valid_from, d.t_until as old_valid_until, d.f"
d57,Process Legal Units - Batch 3,,0,1,32.376875,0,6183,0,0,0,0,1548,83592,CALL sql_saga.temporal_merge_drop_temp_tables()
53d,Process Legal Units - Batch 3,,-1333289396016535139,1,31.236874,10000,4765,0,0,0,0,0,0,"WITH             all_source_rows AS (                 SELECT t.row_id AS source_row_id FROM source_view_lu t             ),             plan_unnested AS (                 SELECT unnest(p.row_ids) as source_row_id, p.plan_op_seq, p.entity_keys, p.operation, p.data, p.feedback                 FROM temporal_merge_plan p             ),             feedback_groups AS (                 SELECT                     asr.source_row_id,                     -- Aggregate all distinct operations for this source row.                     array_agg(DISTINCT pu.operation) FILTER (WHERE pu.operation IS NOT NULL) as operations,                     -- Aggregate all distinct entity IDs this source row touched.                     COALESCE(jsonb_agg(DISTINCT pu.entity_keys) FILTER (WHERE pu.entity_keys IS NOT NULL), '[]'::jsonb) AS target_entity_keys,                     -- Extract the specific error message from the plan's feedback payload if present.                     (array_agg(pu.feedback->>'error') FILTER (WHERE pu.operation = 'ERROR' AND pu.feedback ? 'error'))[1] as error_message_from_plan                 FROM all_source_rows asr                 LEFT JOIN plan_unnested pu ON asr.source_row_id = pu.source_row_id                 GROUP BY asr.source_row_id             )             INSERT INTO temporal_merge_feedback                 SELECT                     fg.source_row_id,                     fg.target_entity_keys,                     CASE                         -- This CASE statement must be ordered from most to least specific to correctly classify outcomes.                         -- This CASE statement directly translates the plan's actions into a final feedback status.                         -- It is ordered from most to least specific to ensure correctness.                         WHEN 'ERROR'::sql_saga.temporal_merge_plan_action = ANY(fg.operations) THEN 'ERROR'                         WHEN 'INSERT'::sql_saga.temporal_merge_plan_action = ANY(fg.operations)                           OR 'UPDATE'::sql_saga.temporal_merge_"
e5c,Process Legal Units - Batch 3,,-6981167301158104206,1,29.190417,10000,441,0,0,0,0,137,15327,"CREATE TEMP TABLE diff ON COMMIT DROP AS                 SELECT                     final_seg.grouping_key, COALESCE(final_seg.id, target_seg.id) as id, COALESCE(final_seg.causal_id, target_seg.causal_id) as causal_id,                     COALESCE(final_seg.is_new_entity, false) as is_new_entity,                     COALESCE(final_seg.is_identifiable, true) as is_identifiable,                     COALESCE(final_seg.is_ambiguous, false) as is_ambiguous,                     final_seg.conflicting_ids,                     final_seg.canonical_nk_json,                     COALESCE(final_seg.stable_identity_columns_are_null, false) as stable_identity_columns_are_null,                     COALESCE(final_seg.lookup_columns_unavailable, false) as lookup_columns_unavailable,                     final_seg.valid_from AS f_from, final_seg.valid_until AS f_until, final_seg.final_payload AS f_payload, final_seg.row_ids AS f_row_ids, final_seg.stable_pk_payload, final_seg.orig_source_target_relation,                     CASE WHEN 'f'::boolean                         THEN final_seg.trace || jsonb_build_object('cte', 'diff', 'diff_stable_pk', final_seg.stable_pk_payload, 'final_seg_causal_id', final_seg.causal_id, 'final_payload_vs_target_payload', jsonb_build_object('f', final_seg.final_payload, 't', target_seg.data_payload))                         ELSE NULL                     END as trace,                     final_seg.unaffected_target_only_segment,                     target_seg.valid_from as t_from, target_seg.valid_until as t_until, (target_seg.data_payload || target_seg.ephemeral_payload) as t_payload,                     sql_saga.get_allen_relation(target_seg.valid_from, target_seg.valid_until, final_seg.valid_from, final_seg.valid_until) as b_a_relation                 FROM coalesced_final_segments AS final_seg                 FULL OUTER JOIN target_rows AS target_seg ON final_seg.grouping_key = ('existing_entity__' || COALESCE(target_seg.id::text, '_NULL_')) AND final_seg.ancestor_valid_from = target_seg.valid_from"
539,Process Legal Units - Batch 3,,-5654698104857404724,1,28.585167000000002,10000,345,0,0,0,0,137,15327,"CREATE TEMP TABLE diff ON COMMIT DROP AS                 SELECT                     final_seg.grouping_key, COALESCE(final_seg.id, target_seg.id) as id, COALESCE(final_seg.causal_id, target_seg.causal_id) as causal_id,                     COALESCE(final_seg.is_new_entity, false) as is_new_entity,                     COALESCE(final_seg.is_identifiable, true) as is_identifiable,                     COALESCE(final_seg.is_ambiguous, false) as is_ambiguous,                     final_seg.conflicting_ids,                     final_seg.canonical_nk_json,                     COALESCE(final_seg.stable_identity_columns_are_null, false) as stable_identity_columns_are_null,                     COALESCE(final_seg.lookup_columns_unavailable, false) as lookup_columns_unavailable,                     final_seg.valid_from AS f_from, final_seg.valid_until AS f_until, final_seg.final_payload AS f_payload, final_seg.row_ids AS f_row_ids, final_seg.stable_pk_payload, final_seg.orig_source_target_relation,                     CASE WHEN 'f'::boolean                         THEN final_seg.trace || jsonb_build_object('cte', 'diff', 'diff_stable_pk', final_seg.stable_pk_payload, 'final_seg_causal_id', final_seg.causal_id, 'final_payload_vs_target_payload', jsonb_build_object('f', final_seg.final_payload, 't', target_seg.data_payload))                         ELSE NULL                     END as trace,                     final_seg.unaffected_target_only_segment,                     target_seg.valid_from as t_from, target_seg.valid_until as t_until, (target_seg.data_payload || target_seg.ephemeral_payload) as t_payload,                     sql_saga.get_allen_relation(target_seg.valid_from, target_seg.valid_until, final_seg.valid_from, final_seg.valid_until) as b_a_relation                 FROM coalesced_final_segments AS final_seg                 FULL OUTER JOIN target_rows AS target_seg ON final_seg.grouping_key = ('existing_entity__' || COALESCE(target_seg.id::text, '_NULL_')) AND final_seg.ancestor_valid_from = target_seg.valid_from"
edb,Process Legal Units - Batch 3,,1965474688105448427,1,26.99,10000,5113,0,0,0,0,115,13529,"CREATE TEMP TABLE source_initial ON COMMIT DROP AS                 WITH source_data AS (                     SELECT                         source_table.row_id /* row_id_column */ as source_row_id,                         COALESCE(source_table.founding_id, source_table.row_id::integer) /* v_causal_select_expr */ as causal_id,                         source_table.id,  -- v_non_temporal_lookup_cols_select_list_prefix                         source_table.valid_from as valid_from, source_table.valid_until as valid_until, /* v_source_temporal_cols_expr */                         jsonb_strip_nulls(jsonb_build_object('name', source_table.name)) /* v_source_data_payload_expr */ AS data_payload,                         jsonb_strip_nulls(jsonb_build_object('comment', source_table.comment)) /* v_source_ephemeral_payload_expr */ AS ephemeral_payload,                         jsonb_build_object('id', source_table.id) /* v_stable_pk_cols_jsonb_build_source */ as stable_pk_payload,                         source_table.id IS NULL /* v_entity_id_check_is_null_expr */ as stable_identity_columns_are_null,                         (true) /* v_lookup_cols_are_null_expr */ as lookup_columns_unavailable,                         true /* v_is_identifiable_expr */ as is_identifiable,                         true /* v_consistency_check_expr */ as temporal_columns_are_consistent                     FROM source_view_lu /* v_source_table_ident */ source_table                 )                 SELECT                      *,                     -- OPTIMIZATION: Pre-compute range column to avoid repeated daterange() calls                     -- This provides ~10-15% performance improvement in eclipse detection                     daterange(valid_from, valid_until) as valid_range                 FROM source_data"
5f0,Process Legal Units - Batch 3,,2115514670139824758,1,26.533625,10000,5063,0,0,0,0,115,13529,"CREATE TEMP TABLE source_initial ON COMMIT DROP AS                 WITH source_data AS (                     SELECT                         source_table.row_id /* row_id_column */ as source_row_id,                         COALESCE(source_table.founding_id, source_table.row_id::integer) /* v_causal_select_expr */ as causal_id,                         source_table.id,  -- v_non_temporal_lookup_cols_select_list_prefix                         source_table.valid_from as valid_from, source_table.valid_until as valid_until, /* v_source_temporal_cols_expr */                         jsonb_strip_nulls(jsonb_build_object('name', source_table.name)) /* v_source_data_payload_expr */ AS data_payload,                         jsonb_strip_nulls(jsonb_build_object('comment', source_table.comment)) /* v_source_ephemeral_payload_expr */ AS ephemeral_payload,                         jsonb_build_object('id', source_table.id) /* v_stable_pk_cols_jsonb_build_source */ as stable_pk_payload,                         source_table.id IS NULL /* v_entity_id_check_is_null_expr */ as stable_identity_columns_are_null,                         (true) /* v_lookup_cols_are_null_expr */ as lookup_columns_unavailable,                         true /* v_is_identifiable_expr */ as is_identifiable,                         true /* v_consistency_check_expr */ as temporal_columns_are_consistent                     FROM source_view_lu /* v_source_table_ident */ source_table                 )                 SELECT                      *,                     -- OPTIMIZATION: Pre-compute range column to avoid repeated daterange() calls                     -- This provides ~10-15% performance improvement in eclipse detection                     daterange(valid_from, valid_until) as valid_range                 FROM source_data;"
6f5,Process Legal Units - Batch 3,,-9107887341698301624,1,23.293166,20000,419,0,0,0,0,126,15019,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.lookup_columns_unavailable, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON target_row.id = seg.id                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                 WHERE NOT seg.is_new_entity"
f8e,Process Legal Units - Batch 3,,6779487562696088383,1,23.119042,20000,374,0,0,0,0,112,12521,"CREATE TEMP TABLE atomic_segments ON COMMIT DROP AS                 SELECT grouping_key, id, causal_id, point as valid_from, next_point as valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json                 FROM (                     SELECT *, LEAD(point) OVER (PARTITION BY grouping_key ORDER BY point) as next_point                     FROM time_points                 ) with_lead                 WHERE point IS NOT NULL AND next_point IS NOT NULL AND point < next_point"
97a,Process Legal Units - Batch 3,,7253058932029092145,1,22.795625,20000,325,0,0,0,0,126,15019,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.lookup_columns_unavailable, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON target_row.id = seg.id                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                 WHERE NOT seg.is_new_entity"
4d9,Process Legal Units - Batch 3,,-7375841108639655790,1,22.676542,20000,294,0,0,0,0,112,12521,"CREATE TEMP TABLE atomic_segments ON COMMIT DROP AS                 SELECT grouping_key, id, causal_id, point as valid_from, next_point as valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json                 FROM (                     SELECT *, LEAD(point) OVER (PARTITION BY grouping_key ORDER BY point) as next_point                     FROM time_points                 ) with_lead                 WHERE point IS NOT NULL AND next_point IS NOT NULL AND point < next_point"
a20,Process Legal Units - Batch 3,,-6189425232530816533,1,21.600125,10000,571,0,0,0,0,103,11213,"CREATE TEMP TABLE target_rows ON COMMIT DROP AS                 SELECT                     id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ -- (non-temporal identity columns)                     lower(t.valid_range) as valid_from, -- The temporal identity column (e.g., valid_from)                     NULL::integer /* v_causal_column_type */ as causal_id, -- Target rows do not originate from a source row, so causal_id is NULL. Type is introspected.                     jsonb_build_object('id', id) /* v_stable_pk_cols_jsonb_build_bare */ as stable_pk_payload,                     upper(t.valid_range) as valid_until,                     jsonb_build_object('name', name) /* v_target_data_cols_jsonb_build_bare */ AS data_payload,                     jsonb_build_object('comment', comment) /* v_target_ephemeral_cols_jsonb_build_bare */ AS ephemeral_payload,                     jsonb_strip_nulls(jsonb_build_object()) /* v_target_nk_json_expr */ AS canonical_nk_json                 FROM (                         SELECT * FROM (                             SELECT DISTINCT ON (u.id, u.valid_from) * FROM (                                 (                                     SELECT * FROM etl_bench.legal_unit inner_t                                     WHERE (inner_t.id) IN (SELECT DISTINCT si.id FROM source_initial si WHERE (si.id) IS NOT NULL)                                 )                             ) u                         )                     ) AS t  /* v_target_rows_filter */"
59d,Process Legal Units - Batch 3,,-4193415169867768194,1,21.030125,10000,521,0,0,0,0,103,11213,"CREATE TEMP TABLE target_rows ON COMMIT DROP AS                 SELECT                     id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ -- (non-temporal identity columns)                     lower(t.valid_range) as valid_from, -- The temporal identity column (e.g., valid_from)                     NULL::integer /* v_causal_column_type */ as causal_id, -- Target rows do not originate from a source row, so causal_id is NULL. Type is introspected.                     jsonb_build_object('id', id) /* v_stable_pk_cols_jsonb_build_bare */ as stable_pk_payload,                     upper(t.valid_range) as valid_until,                     jsonb_build_object('name', name) /* v_target_data_cols_jsonb_build_bare */ AS data_payload,                     jsonb_build_object('comment', comment) /* v_target_ephemeral_cols_jsonb_build_bare */ AS ephemeral_payload,                     jsonb_strip_nulls(jsonb_build_object()) /* v_target_nk_json_expr */ AS canonical_nk_json                 FROM (                         SELECT * FROM (                             SELECT DISTINCT ON (u.id, u.valid_from) * FROM (                                 (                                     SELECT * FROM etl_bench.legal_unit inner_t                                     WHERE (inner_t.id) IN (SELECT DISTINCT si.id FROM source_initial si WHERE (si.id) IS NOT NULL)                                 )                             ) u                         )                     ) AS t  /* v_target_rows_filter */"
ace,Process Legal Units - Batch 3,,5147944785677299242,1,20.796333,10000,466,0,0,0,0,143,15993,"CREATE TEMP TABLE diff_ranked ON COMMIT DROP AS                 SELECT                     d.*,                     CASE                         WHEN d.t_from IS NULL OR d.f_from IS NULL THEN NULL                         WHEN d.f_from = d.t_from AND d.f_until = d.t_until AND d.f_payload IS NOT DISTINCT FROM d.t_payload THEN NULL                         ELSE                             row_number() OVER (                                 PARTITION BY d.grouping_key, d.t_from                                 ORDER BY                                     CASE WHEN d.f_from = d.t_from THEN 1 ELSE 2 END,                                     CASE WHEN d.f_payload - '{comment}'::text[] IS NOT DISTINCT FROM d.t_payload - '{comment}'::text[] THEN 1 ELSE 2 END,                                     d.f_from,                                     d.f_until                             )                     END as update_rank                 FROM diff d"
a02,Process Legal Units - Batch 3,,6259880232974284115,1,20.333917,10000,363,0,0,0,0,143,15993,"CREATE TEMP TABLE diff_ranked ON COMMIT DROP AS                 SELECT                     d.*,                     CASE                         WHEN d.t_from IS NULL OR d.f_from IS NULL THEN NULL                         WHEN d.f_from = d.t_from AND d.f_until = d.t_until AND d.f_payload IS NOT DISTINCT FROM d.t_payload THEN NULL                         ELSE                             row_number() OVER (                                 PARTITION BY d.grouping_key, d.t_from                                 ORDER BY                                     CASE WHEN d.f_from = d.t_from THEN 1 ELSE 2 END,                                     CASE WHEN d.f_payload - '{comment}'::text[] IS NOT DISTINCT FROM d.t_payload - '{comment}'::text[] THEN 1 ELSE 2 END,                                     d.f_from,                                     d.f_until                             )                     END as update_rank                 FROM diff d"
d30,Process Legal Units - Batch 3,,-2522301903109079185,1,19.030708,40000,394,0,0,0,0,114,12737,"CREATE TEMP TABLE time_points_with_unified_ids ON COMMIT DROP AS                 SELECT                     tpu.grouping_key,                     tpu.id,                     tpu.unified_causal_id as causal_id,                     tpu.point,                     tpu.is_new_entity,                     tpu.unified_stable_pk_payload as stable_pk_payload,                     tpu.stable_identity_columns_are_null,                     tpu.lookup_columns_unavailable,                     tpu.is_identifiable,                     tpu.is_ambiguous,                     tpu.conflicting_ids,                     tpu.unified_canonical_nk_json as canonical_nk_json                 FROM time_points_unified tpu"
627,Process Legal Units - Batch 3,,-2381107599654639950,1,18.623625,40000,307,0,0,0,0,114,12737,"CREATE TEMP TABLE time_points_with_unified_ids ON COMMIT DROP AS                 SELECT                     tpu.grouping_key,                     tpu.id,                     tpu.unified_causal_id as causal_id,                     tpu.point,                     tpu.is_new_entity,                     tpu.unified_stable_pk_payload as stable_pk_payload,                     tpu.stable_identity_columns_are_null,                     tpu.lookup_columns_unavailable,                     tpu.is_identifiable,                     tpu.is_ambiguous,                     tpu.conflicting_ids,                     tpu.unified_canonical_nk_json as canonical_nk_json                 FROM time_points_unified tpu"
f5b,Process Legal Units - Batch 3,,9187673216027458375,1,16.371792,10000,443,0,0,0,0,139,18909,"CREATE TEMP TABLE plan ON COMMIT DROP AS                 SELECT                     p.row_ids, p.operation, p.causal_id, p.is_new_entity,                     p.id,                     p.entity_keys_json as entity_keys,                     p.identity_keys, p.lookup_keys,                     p.orig_source_target_relation, p.b_a_relation, p.old_valid_from, p.old_valid_until,                     p.new_valid_from, p.new_valid_until, p.data, p.feedback, p.trace,                     p.grouping_key,                     CASE                         WHEN p.operation <> 'UPDATE' THEN NULL::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from = p.old_valid_from AND p.new_valid_until = p.old_valid_until THEN 'NONE'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from <= p.old_valid_from AND p.new_valid_until >= p.old_valid_until THEN 'GROW'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from >= p.old_valid_from AND p.new_valid_until <= p.old_valid_until THEN 'SHRINK'::sql_saga.temporal_merge_update_effect                         ELSE 'MOVE'::sql_saga.temporal_merge_update_effect                     END AS update_effect                 FROM plan_with_op p                 LEFT JOIN source_rows_with_new_flag source_row ON source_row.source_row_id = p.row_ids[1]"
052,Process Legal Units - Batch 3,,5055573923988817461,1,15.865292,10000,345,0,0,0,0,139,18909,"CREATE TEMP TABLE plan ON COMMIT DROP AS                 SELECT                     p.row_ids, p.operation, p.causal_id, p.is_new_entity,                     p.id,                     p.entity_keys_json as entity_keys,                     p.identity_keys, p.lookup_keys,                     p.orig_source_target_relation, p.b_a_relation, p.old_valid_from, p.old_valid_until,                     p.new_valid_from, p.new_valid_until, p.data, p.feedback, p.trace,                     p.grouping_key,                     CASE                         WHEN p.operation <> 'UPDATE' THEN NULL::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from = p.old_valid_from AND p.new_valid_until = p.old_valid_until THEN 'NONE'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from <= p.old_valid_from AND p.new_valid_until >= p.old_valid_until THEN 'GROW'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from >= p.old_valid_from AND p.new_valid_until <= p.old_valid_until THEN 'SHRINK'::sql_saga.temporal_merge_update_effect                         ELSE 'MOVE'::sql_saga.temporal_merge_update_effect                     END AS update_effect                 FROM plan_with_op p                 LEFT JOIN source_rows_with_new_flag source_row ON source_row.source_row_id = p.row_ids[1]"
56e,Process Legal Units - Batch 3,,2346888588666524139,1,14.270042,40000,364,0,0,0,0,108,12005,"CREATE TEMP TABLE time_points_raw ON COMMIT DROP AS                 SELECT id, causal_id, valid_from AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows                 UNION ALL                 SELECT id, causal_id, valid_until AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows"
80b,Process Legal Units - Batch 3,,3254511572182529394,1,13.858459,40000,286,0,0,0,0,108,12005,"CREATE TEMP TABLE time_points_raw ON COMMIT DROP AS                 SELECT id, causal_id, valid_from AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows                 UNION ALL                 SELECT id, causal_id, valid_until AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows"
8fc,Process Legal Units - Batch 3,,-1318097777820228,1,13.399708,10000,407,0,0,0,0,122,13717,"CREATE TEMP TABLE source_rows ON COMMIT DROP AS                 SELECT DISTINCT ON (p.source_row_id)                     p.source_row_id, p.causal_id, p.valid_from, p.valid_until, p.data_payload, p.ephemeral_payload,                     (p.stable_identity_columns_are_null AND p.discovered_stable_pk_payload IS NULL) as stable_identity_columns_are_null,                     p.lookup_columns_unavailable, p.is_identifiable,                     p.is_ambiguous, p.conflicting_ids, p.is_eclipsed, p.eclipsed_by,                     p.temporal_columns_are_consistent,                     COALESCE(p.stable_pk_payload, p.discovered_stable_pk_payload) as stable_pk_payload,                     (p.discovered_stable_pk_payload IS NOT NULL) /* v_target_entity_exists_expr */ as target_entity_exists,                     COALESCE(p.id, p.discovered_id_1) AS id /* v_coalesced_id_cols_list */                 FROM source_rows_with_discovery p                 ORDER BY p.source_row_id, p.discovered_stable_pk_payload"
74c,Process Legal Units - Batch 3,,-957741634502868070,1,13.08925,10000,419,0,0,0,0,127,14409,"CREATE TEMP TABLE source_rows_with_nk_json ON COMMIT DROP AS                 SELECT source_row.*, jsonb_strip_nulls(jsonb_build_object()) /* v_lookup_keys_as_jsonb_expr */ as nk_json, ARRAY(SELECT e FROM unnest(ARRAY[]::TEXT[]) e WHERE e IS NOT NULL ORDER BY e) /* v_lookup_keys_as_array_expr */ as nk_non_null_keys_array                 FROM source_rows_with_new_flag source_row"
117,Process Legal Units - Batch 3,,2284106485190769639,1,12.95225,10000,313,0,0,0,0,122,13717,"CREATE TEMP TABLE source_rows ON COMMIT DROP AS                 SELECT DISTINCT ON (p.source_row_id)                     p.source_row_id, p.causal_id, p.valid_from, p.valid_until, p.data_payload, p.ephemeral_payload,                     (p.stable_identity_columns_are_null AND p.discovered_stable_pk_payload IS NULL) as stable_identity_columns_are_null,                     p.lookup_columns_unavailable, p.is_identifiable,                     p.is_ambiguous, p.conflicting_ids, p.is_eclipsed, p.eclipsed_by,                     p.temporal_columns_are_consistent,                     COALESCE(p.stable_pk_payload, p.discovered_stable_pk_payload) as stable_pk_payload,                     (p.discovered_stable_pk_payload IS NOT NULL) /* v_target_entity_exists_expr */ as target_entity_exists,                     COALESCE(p.id, p.discovered_id_1) AS id /* v_coalesced_id_cols_list */                 FROM source_rows_with_discovery p                 ORDER BY p.source_row_id, p.discovered_stable_pk_payload"
62a,Process Legal Units - Batch 3,,7625827313856663095,1,12.649459,10000,328,0,0,0,0,127,14409,"CREATE TEMP TABLE source_rows_with_nk_json ON COMMIT DROP AS                 SELECT source_row.*, jsonb_strip_nulls(jsonb_build_object()) /* v_lookup_keys_as_jsonb_expr */ as nk_json, ARRAY(SELECT e FROM unnest(ARRAY[]::TEXT[]) e WHERE e IS NOT NULL ORDER BY e) /* v_lookup_keys_as_array_expr */ as nk_non_null_keys_array                 FROM source_rows_with_new_flag source_row"
c05,Process Legal Units - Batch 3,,-8767491607573256645,1,11.977583,10000,404,0,0,0,0,122,13863,"CREATE TEMP TABLE source_rows_with_new_flag ON COMMIT DROP AS                 SELECT *, NOT target_entity_exists as is_new_entity                 FROM source_rows"
436,Process Legal Units - Batch 3,,7000426517880687954,1,11.76475,10000,449,0,0,0,0,132,15079,"CREATE TEMP TABLE source_rows_with_canonical_key ON COMMIT DROP AS                 SELECT *, (CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END /* v_grouping_key_expr */) as grouping_key                 FROM (                     SELECT                         s1.*,                         s2.nk_json as canonical_nk_json                     FROM source_rows_with_nk_json s1                     LEFT JOIN LATERAL (                         SELECT s2_inner.nk_json, s2_inner.nk_non_null_keys_array                         FROM source_rows_with_nk_json s2_inner                         WHERE s1.is_new_entity AND s2_inner.is_new_entity AND s2_inner.nk_json @> s1.nk_json                         ORDER BY array_length(s2_inner.nk_non_null_keys_array, 1) DESC, s2_inner.nk_non_null_keys_array::text DESC                         LIMIT 1                     ) s2 ON true                 ) s"
a1f,Process Legal Units - Batch 3,,-257287304656928252,1,11.549917,10000,316,0,0,0,0,122,13863,"CREATE TEMP TABLE source_rows_with_new_flag ON COMMIT DROP AS                 SELECT *, NOT target_entity_exists as is_new_entity                 FROM source_rows"
977,Process Legal Units - Batch 3,,8118870935825291626,1,11.205916,10000,333,0,0,0,0,131,14981,"CREATE TEMP TABLE source_rows_with_canonical_key ON COMMIT DROP AS                 SELECT *, (CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END /* v_grouping_key_expr */) as grouping_key                 FROM (                     SELECT                         s1.*,                         s2.nk_json as canonical_nk_json                     FROM source_rows_with_nk_json s1                     LEFT JOIN LATERAL (                         SELECT s2_inner.nk_json, s2_inner.nk_non_null_keys_array                         FROM source_rows_with_nk_json s2_inner                         WHERE s1.is_new_entity AND s2_inner.is_new_entity AND s2_inner.nk_json @> s1.nk_json                         ORDER BY array_length(s2_inner.nk_non_null_keys_array, 1) DESC, s2_inner.nk_non_null_keys_array::text DESC                         LIMIT 1                     ) s2 ON true                 ) s"
7ec,Process Legal Units - Batch 3,,8689595743856886431,1,10.719542,0,146,0,0,0,0,15,1597,CREATE INDEX ON active_source_rows (grouping_key)
28a,Process Legal Units - Batch 3,,5494611821061557908,1,10.5545,20000,399,0,0,0,0,111,12283,"CREATE TEMP TABLE all_rows ON COMMIT DROP AS                 SELECT id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ causal_id, valid_from, valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM active_source_rows                 UNION ALL                 SELECT                     target_row.id,  /* v_non_temporal_tr_qualified_lookup_cols_prefix */                     target_row.causal_id,                     target_row.valid_from,                     target_row.valid_until,                     false as is_new_entity,                     target_row.stable_pk_payload,                     false as stable_identity_columns_are_null,                     false as lookup_columns_unavailable,                     true as is_identifiable,                     false as is_ambiguous,                     NULL::jsonb as conflicting_ids,                     target_row.canonical_nk_json                 FROM target_rows target_row"
7e7,Process Legal Units - Batch 3,,5012345967240423926,1,10.499166,10000,433,0,0,0,0,133,15925,"CREATE TEMP TABLE source_rows_with_early_feedback ON COMMIT DROP AS                 SELECT                     s.*,                     CASE                         WHEN s.is_ambiguous                         THEN jsonb_build_object( 'operation', 'ERROR'::text, 'message', 'Source row is ambiguous. It matches multiple distinct target entities: ' || s.conflicting_ids::text )                         WHEN NOT s.is_identifiable AND s.is_new_entity                         THEN jsonb_build_object( 'operation', 'ERROR'::text, 'message', 'Source row is unidentifiable. It has NULL for all stable identity columns ' || replace('{id}'::text, '""', '') || ' and all natural keys ' || replace(NULL::text, '""', '') )                         WHEN NOT s.temporal_columns_are_consistent                         THEN jsonb_build_object( 'operation', 'ERROR'::text, 'message', 'Source row has inconsistent temporal columns. Column ""' || 'valid_until' || '"" must be equal to column ""' || NULL || '"" + ' || NULL || '.' )                         WHEN s.is_eclipsed                         THEN jsonb_build_object( 'operation', 'SKIP_ECLIPSED'::text, 'message', 'Source row was eclipsed by row_ids=' || s.eclipsed_by::text || ' in the same batch.' )                         ELSE NULL                     END as early_feedback                 FROM source_rows_with_canonical_key s"
457,Process Legal Units - Batch 3,,-3169870935594387745,1,10.479000000000001,0,5466,0,0,0,0,0,0,UPDATE etl_bench.data_table dt     SET legal_unit_id = ir.legal_unit_id     FROM etl_bench.identity_resolution ir     WHERE dt.identity_correlation = ir.identity_correlation       AND dt.legal_unit_id IS NULL
4de,Process Legal Units - Batch 3,,2613701250391606255,1,10.472083,10000,404,0,0,0,0,131,18497,"CREATE TEMP TABLE source_rows_with_discovery ON COMMIT DROP AS                 SELECT                     m.*,                     a.match_count,                     a.conflicting_ids,                     (a.match_count > 1) as is_ambiguous                 FROM source_rows_with_matches m                 JOIN source_rows_with_aggregates a ON m.source_row_id = a.source_row_id"
127,Process Legal Units - Batch 3,,-8525577533969057774,1,10.079291000000001,20000,297,0,0,0,0,111,12283,"CREATE TEMP TABLE all_rows ON COMMIT DROP AS                 SELECT id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ causal_id, valid_from, valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM active_source_rows                 UNION ALL                 SELECT                     target_row.id,  /* v_non_temporal_tr_qualified_lookup_cols_prefix */                     target_row.causal_id,                     target_row.valid_from,                     target_row.valid_until,                     false as is_new_entity,                     target_row.stable_pk_payload,                     false as stable_identity_columns_are_null,                     false as lookup_columns_unavailable,                     true as is_identifiable,                     false as is_ambiguous,                     NULL::jsonb as conflicting_ids,                     target_row.canonical_nk_json                 FROM target_rows target_row"
2cb,Process Legal Units - Batch 3,,8473430400440557908,1,10.04975,10000,341,0,0,0,0,131,18497,"CREATE TEMP TABLE source_rows_with_discovery ON COMMIT DROP AS                 SELECT                     m.*,                     a.match_count,                     a.conflicting_ids,                     (a.match_count > 1) as is_ambiguous                 FROM source_rows_with_matches m                 JOIN source_rows_with_aggregates a ON m.source_row_id = a.source_row_id"
6b8,Process Legal Units - Batch 3,,-72630411978071912,1,10.048334,10000,335,0,0,0,0,133,15925,"CREATE TEMP TABLE source_rows_with_early_feedback ON COMMIT DROP AS                 SELECT                     s.*,                     CASE                         WHEN s.is_ambiguous                         THEN jsonb_build_object( 'operation', 'ERROR'::text, 'message', 'Source row is ambiguous. It matches multiple distinct target entities: ' || s.conflicting_ids::text )                         WHEN NOT s.is_identifiable AND s.is_new_entity                         THEN jsonb_build_object( 'operation', 'ERROR'::text, 'message', 'Source row is unidentifiable. It has NULL for all stable identity columns ' || replace('{id}'::text, '""', '') || ' and all natural keys ' || replace(NULL::text, '""', '') )                         WHEN NOT s.temporal_columns_are_consistent                         THEN jsonb_build_object( 'operation', 'ERROR'::text, 'message', 'Source row has inconsistent temporal columns. Column ""' || 'valid_until' || '"" must be equal to column ""' || NULL || '"" + ' || NULL || '.' )                         WHEN s.is_eclipsed                         THEN jsonb_build_object( 'operation', 'SKIP_ECLIPSED'::text, 'message', 'Source row was eclipsed by row_ids=' || s.eclipsed_by::text || ' in the same batch.' )                         ELSE NULL                     END as early_feedback                 FROM source_rows_with_canonical_key s"
f4a,Process Legal Units - Batch 3,,4895990506256861755,10000,8.42455900000007,10000,0,0,0,0,0,0,0,SELECT array_agg(DISTINCT v)                    FROM unnest(from_sources) AS v
bbc,Process Legal Units - Batch 3,,7743831913079285872,10000,6.997042000000209,10000,0,0,0,0,0,0,0,SELECT array_agg(DISTINCT v)                     FROM unnest(until_sources) AS v
d20,Process Legal Units - Batch 3,,725758841111022991,144,5.684832,144,2168,0,0,0,0,0,0,"EXISTS (         SELECT 1 FROM pg_event_trigger_ddl_commands() ddl         JOIN pg_class c ON c.oid = ddl.objid         JOIN pg_namespace n ON n.oid = c.relnamespace         WHERE EXISTS (SELECT 1 FROM sql_saga.era e WHERE (e.table_schema, e.table_name) = (n.nspname, c.relname))            OR EXISTS (SELECT 1 FROM sql_saga.updatable_view v JOIN pg_class vc ON vc.relname = v.view_name JOIN pg_namespace vn ON vn.oid = vc.relnamespace AND vn.nspname = v.view_schema WHERE vc.oid = c.oid)            -- Also check system_versioning objects (history table, view)            OR EXISTS (SELECT 1 FROM sql_saga.system_versioning sv WHERE (sv.history_schema_name, sv.history_table_name) = (n.nspname, c.relname))            OR EXISTS (SELECT 1 FROM sql_saga.system_versioning sv WHERE (sv.view_schema_name, sv.view_table_name) = (n.nspname, c.relname))     )"
1c3,Process Legal Units - Batch 3,,1464568031695687146,144,0.7020459999999998,144,41,0,0,0,0,0,0,SELECT array_agg(command_tag)           FROM pg_event_trigger_ddl_commands()
12c,Process Legal Units - Batch 3,,-8708312726399770535,155,0.47249999999999953,155,0,0,0,0,0,0,0,"EXISTS (             SELECT 1 FROM pg_event_trigger_dropped_objects() dobj             WHERE dobj.object_type = 'table'               AND (dobj.schema_name, dobj.object_name) = (r.table_schema, r.table_name)         )"
d2f,Process Legal Units - Batch 3,,-1465262961312880621,155,0.26533599999999957,155,465,0,0,0,0,0,0,"NOT EXISTS (                 SELECT FROM pg_catalog.pg_constraint AS c                 WHERE (c.conrelid, c.conname) = (r.table_oid, r.unique_constraint)             )"
b27,Process Legal Units - Batch 3,,8008625629997484951,144,0.24727999999999986,0,0,0,0,0,0,0,0,SELECT * FROM pg_event_trigger_ddl_commands()
957,Process Legal Units - Batch 3,,-8889318315713072803,155,0.03562700000000002,155,0,0,0,0,0,0,0,"r.exclude_constraint IS NOT NULL AND NOT EXISTS (             SELECT FROM pg_catalog.pg_constraint AS c             WHERE (c.conrelid, c.conname) = (r.table_oid, r.exclude_constraint)         )"
