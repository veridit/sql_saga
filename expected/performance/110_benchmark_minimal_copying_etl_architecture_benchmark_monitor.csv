log_id,event,label,queryid,calls,total_exec_time,rows,shared_blks_hit,shared_blks_read,temp_blks_read,temp_blks_written,total_plan_time,wal_records,wal_bytes,query
486,Generate Test Data - 10000 entities,,-1502838493080581352,1,1529.525625,1,1420889,7,0,0,0,755396,73218124,"SELECT etl_bench.generate_test_data(v_dataset_size, 3, 5)"
364,Generate Test Data - 10000 entities,,1750016048022143304,1,1411.850333,150000,1417425,4,0,0,0,755288,73196239,"INSERT INTO etl_bench.data_table (         row_id, batch, identity_correlation, comment,         tax_ident, lu_name, physical_address, postal_address,         activity_code, employees, turnover, valid_from, valid_until     )     SELECT          row_number() OVER () as row_id,         batch_num,         entity_num as identity_correlation,         format('Entity %s batch %s row %s', entity_num, batch_num, row_in_batch_num) as comment,         CASE WHEN row_in_batch_num = 1 THEN format('TAX%s', entity_num) END as tax_ident,         CASE WHEN row_in_batch_num = 1 THEN format('Company-%s', entity_num) END as lu_name,         CASE WHEN row_in_batch_num <= 2 THEN format('%s Main St, City %s', entity_num, entity_num) END as physical_address,         CASE WHEN row_in_batch_num <= 3 THEN format('PO Box %s', entity_num) END as postal_address,         CASE WHEN row_in_batch_num <= 4 THEN (CASE WHEN entity_num % 2 = 0 THEN 'manufacturing' ELSE 'retail' END) END as activity_code,         CASE WHEN row_in_batch_num <= 4 THEN (entity_num % 100) + 10 END as employees,         CASE WHEN row_in_batch_num <= 5 THEN (entity_num % 1000) * 1000 + 50000 END as turnover,         ('2024-01-01'::date + ((batch_num - 1) * 90 + (row_in_batch_num - 1) * 30)) as valid_from,         'infinity'::date as valid_until     FROM          generate_series(1, p_total_entities) as entity_num,         generate_series(1, p_batches_per_entity) as batch_num,         generate_series(1, p_rows_per_entity_per_batch) as row_in_batch_num"
102,Generate Test Data - 10000 entities,,760596586349204572,1,115.093959,0,2852,3,0,0,0,41,16197,ANALYZE etl_bench.data_table
3af,Process Legal Units - Batch 1,,-4212605005101232050,1,8450.64675,0,2729780,19,0,0,0,1072496,103166584,CALL etl_bench.process_legal_units(v_batch_id)
82d,Process Legal Units - Batch 1,,2508743807545342814,1,6425.198584,0,553355,18,0,0,0,195861,20358279,"CALL sql_saga.temporal_merge(         target_table => 'etl_bench.legal_unit',         source_table => 'source_view_lu',         primary_identity_columns => ARRAY['id'],         ephemeral_columns => ARRAY['comment'],         mode => 'MERGE_ENTITY_PATCH',         founding_id_column => 'founding_id',         update_source_with_identity => true,         update_source_with_feedback => true,         feedback_status_column => 'merge_statuses',         feedback_status_key => 'legal_unit',         feedback_error_column => 'merge_errors',         feedback_error_key => 'legal_unit'     )"
e51,Process Legal Units - Batch 1,,9062296240809330110,1,5652.985375,0,478386,3,0,0,0,191417,19813690,"CALL sql_saga.temporal_merge_execute(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         identity_columns => v_identity_cols_discovered,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         update_source_with_identity => temporal_merge.update_source_with_identity,         lookup_columns => v_natural_identity_cols_discovered,         delete_mode => temporal_merge.delete_mode,         update_source_with_feedback => temporal_merge.update_source_with_feedback,         feedback_status_column => temporal_merge.feedback_status_column,         feedback_status_key => temporal_merge.feedback_status_key,         feedback_error_column => temporal_merge.feedback_error_column,         feedback_error_key => temporal_merge.feedback_error_key,         ephemeral_columns => temporal_merge.ephemeral_columns,         delay_constraints => temporal_merge.delay_constraints     )"
393,Process Legal Units - Batch 1,,8376419507953077340,1,4950.060332,10000,153731,0,0,0,0,60078,5957096,"WITH map_row_to_entity AS (                                     SELECT DISTINCT ON (s.source_row_id)                                         s.source_row_id,                                         p.entity_keys                                     FROM (SELECT DISTINCT unnest(row_ids) AS source_row_id FROM temporal_merge_plan WHERE operation = 'INSERT') s                                     JOIN temporal_merge_plan p ON s.source_row_id = ANY(p.row_ids)                                     WHERE p.entity_keys IS NOT NULL                                     ORDER BY s.source_row_id, p.plan_op_seq                                 )                                 UPDATE source_view_lu s                                 SET id = (p.entity_keys->>'id')::integer                                 FROM map_row_to_entity p                                 WHERE s.row_id = p.source_row_id"
335,Process Legal Units - Batch 1,,-3169870935594387745,1,1985.886416,140000,2112476,0,0,0,0,846537,80989183,UPDATE etl_bench.data_table dt     SET legal_unit_id = ir.legal_unit_id     FROM etl_bench.identity_resolution ir     WHERE dt.identity_correlation = ir.identity_correlation       AND dt.legal_unit_id IS NULL
665,Process Legal Units - Batch 1,,-4094074925611420334,1,769.103875,10000,72844,15,0,0,0,4260,524075,"INSERT INTO temporal_merge_plan     SELECT * FROM sql_saga.temporal_merge_plan(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         identity_columns => v_identity_cols_discovered,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         delete_mode => temporal_merge.delete_mode,         lookup_keys => v_natural_identity_keys_discovered,         ephemeral_columns => temporal_merge.ephemeral_columns,         p_log_trace => v_log_trace,         p_log_sql => v_log_sql     )"
d5c,Process Legal Units - Batch 1,,-8499634898917945493,1,410.18258299999997,10000,148706,3,0,0,0,70372,7471053,"WITH founding_plan_ops AS (                                     SELECT DISTINCT ON (p.grouping_key)                                         p.plan_op_seq,                                         p.causal_id,                                         p.grouping_key,                                         p.new_valid_range,                                         p.entity_keys || p.data as full_data                                     FROM temporal_merge_plan p                                     WHERE p.operation = 'INSERT' AND p.is_new_entity                                     ORDER BY p.grouping_key, p.plan_op_seq                                 ),                                 id_map_cte AS (                                     MERGE INTO etl_bench.legal_unit t                                     USING founding_plan_ops s ON false                                     WHEN NOT MATCHED THEN                                         INSERT (id, name, comment, valid_range)                                         VALUES (COALESCE((s.full_data->>'id')::integer, nextval('etl_bench.legal_unit_id_seq'::regclass)), (s.full_data->>'name')::text, (s.full_data->>'comment')::text, s.new_valid_range::daterange)                                     RETURNING t.*, s.causal_id, s.grouping_key                                 )                                 INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)                                 SELECT                                     ir.grouping_key,                                     ir.causal_id,                                     jsonb_build_object('id', ir.id)                                 FROM id_map_cte ir"
1e6,Process Legal Units - Batch 1,,-6251707813684716315,1,179.14966600000002,10000,163534,0,0,0,0,60482,6326192,"UPDATE source_view_lu s             SET merge_statuses = COALESCE(s.merge_statuses, '{}'::jsonb) || jsonb_build_object('legal_unit', f.status), merge_errors = CASE WHEN f.error_message IS NOT NULL THEN COALESCE(s.merge_errors, '{}'::jsonb) || jsonb_build_object('legal_unit', f.error_message) ELSE COALESCE(s.merge_errors, '{}'::jsonb) - 'legal_unit' END             FROM pg_temp.temporal_merge_feedback f             WHERE s.row_id = f.source_row_id"
7d2,Process Legal Units - Batch 1,,-8581391324505025071,1,63.000458,10000,1703,1,0,0,0,131,15623,"CREATE TEMP TABLE coalesced_final_segments ON COMMIT DROP AS                 SELECT                     grouping_key, max(id) as id,                     sql_saga.first(causal_id ORDER BY valid_from) as causal_id,                     sql_saga.first(stable_identity_columns_are_null ORDER BY valid_from) as stable_identity_columns_are_null,                     sql_saga.first(lookup_columns_unavailable ORDER BY valid_from) as lookup_columns_unavailable,                     sql_saga.first(is_new_entity ORDER BY valid_from) as is_new_entity,                     sql_saga.first(is_identifiable ORDER BY valid_from) as is_identifiable,                     sql_saga.first(is_ambiguous ORDER BY valid_from) as is_ambiguous,                     sql_saga.first(conflicting_ids ORDER BY valid_from) as conflicting_ids,                     sql_saga.first(unified_canonical_nk_json ORDER BY valid_from) as canonical_nk_json,                     sql_saga.first(orig_source_target_relation ORDER BY valid_from) as orig_source_target_relation,                     sql_saga.first(t_valid_from ORDER BY valid_from) as ancestor_valid_from,                     MIN(valid_from) as valid_from,                     MAX(valid_until) as valid_until,                     (sql_saga.first(data_payload ORDER BY valid_from DESC) || sql_saga.first(ephemeral_payload ORDER BY valid_from DESC)) as final_payload,                     sql_saga.first(stable_pk_payload ORDER BY valid_from DESC) as stable_pk_payload,                     bool_and(unaffected_target_only_segment) as unaffected_target_only_segment,                     (SELECT array_agg(DISTINCT e) FROM unnest(array_concat_agg(causal_source_row_ids)) e WHERE e IS NOT NULL) as row_ids,                     CASE WHEN 'f'::boolean                         THEN jsonb_build_object( 'cte', 'coalesced', 'island_group_id', island_group_id, 'coalesced_stable_pk', sql_saga.first(stable_pk_payload ORDER BY valid_from DESC), 'final_payload', sql_saga.first(data_payload ORDER BY valid_from DESC), 'final_payload_sans_epheme"
12f,Process Legal Units - Batch 1,,3295832470614201853,1,62.147792,10000,285,1,0,0,0,131,15623,"CREATE TEMP TABLE coalesced_final_segments ON COMMIT DROP AS                 SELECT                     grouping_key, max(id) as id,                     sql_saga.first(causal_id ORDER BY valid_from) as causal_id,                     sql_saga.first(stable_identity_columns_are_null ORDER BY valid_from) as stable_identity_columns_are_null,                     sql_saga.first(lookup_columns_unavailable ORDER BY valid_from) as lookup_columns_unavailable,                     sql_saga.first(is_new_entity ORDER BY valid_from) as is_new_entity,                     sql_saga.first(is_identifiable ORDER BY valid_from) as is_identifiable,                     sql_saga.first(is_ambiguous ORDER BY valid_from) as is_ambiguous,                     sql_saga.first(conflicting_ids ORDER BY valid_from) as conflicting_ids,                     sql_saga.first(unified_canonical_nk_json ORDER BY valid_from) as canonical_nk_json,                     sql_saga.first(orig_source_target_relation ORDER BY valid_from) as orig_source_target_relation,                     sql_saga.first(t_valid_from ORDER BY valid_from) as ancestor_valid_from,                     MIN(valid_from) as valid_from,                     MAX(valid_until) as valid_until,                     (sql_saga.first(data_payload ORDER BY valid_from DESC) || sql_saga.first(ephemeral_payload ORDER BY valid_from DESC)) as final_payload,                     sql_saga.first(stable_pk_payload ORDER BY valid_from DESC) as stable_pk_payload,                     bool_and(unaffected_target_only_segment) as unaffected_target_only_segment,                     (SELECT array_agg(DISTINCT e) FROM unnest(array_concat_agg(causal_source_row_ids)) e WHERE e IS NOT NULL) as row_ids,                     CASE WHEN 'f'::boolean                         THEN jsonb_build_object( 'cte', 'coalesced', 'island_group_id', island_group_id, 'coalesced_stable_pk', sql_saga.first(stable_pk_payload ORDER BY valid_from DESC), 'final_payload', sql_saga.first(data_payload ORDER BY valid_from DESC), 'final_payload_sans_epheme"
bba,Process Legal Units - Batch 1,,6446111097803510451,1,55.053709,10000,1630,0,0,0,0,139,16637,"CREATE TEMP TABLE new_segments_no_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.lookup_columns_unavailable, seg.valid_from, seg.valid_until,                     NULL::date as t_valid_from, NULL::date as t_valid_until,                     NULL::jsonb as t_data_payload, NULL::jsonb as t_ephemeral_payload, seg.stable_pk_payload,                     NULL::jsonb as target_stable_pk_payload,                     source_payloads.source_row_id, source_payloads.contributing_row_ids,                     source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                     source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until,                     NULL::jsonb as trace                 FROM atomic_segments seg                                          LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE source_row.grouping_key = seg.grouping_key                                 AND daterange(seg.valid_from, seg.valid_until) <@ daterange(source_row.valid_from, source_row.valid_until)                             ),                             running_payload AS (                                 SELECT rn, source_row_id, data_payload, ephemeral_payload, valid_from, valid_until, causal_id, ARRAY[source_row_id::BIGINT] as contributing_row_ids                 "
2dd,Process Legal Units - Batch 1,,2265156188269693366,1,54.196125,10000,1723,0,0,0,0,151,17701,"CREATE TEMP TABLE resolved_atomic_segments_with_propagated_ids ON COMMIT DROP AS                 SELECT                     *,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY grouping_key ORDER BY valid_from) as unified_canonical_nk_json,                     COALESCE(                         contributing_row_ids,                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as causal_source_row_ids,                     COALESCE(                         s_valid_from,                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_from,                     COALESCE(                         s_valid_until,                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_until                 FROM (                     SELECT                         *,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from) AS look_behind_grp,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from DESC) AS look_ahead_grp                     FROM resolved_atomic_segments_with_payloads /* v_resolver_from */                 ) with_grp"
ab2,Process Legal Units - Batch 1,,-1988355907103003074,1,54.145582999999995,10000,287,0,0,0,0,139,16637,"CREATE TEMP TABLE new_segments_no_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.lookup_columns_unavailable, seg.valid_from, seg.valid_until,                     NULL::date as t_valid_from, NULL::date as t_valid_until,                     NULL::jsonb as t_data_payload, NULL::jsonb as t_ephemeral_payload, seg.stable_pk_payload,                     NULL::jsonb as target_stable_pk_payload,                     source_payloads.source_row_id, source_payloads.contributing_row_ids,                     source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                     source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until,                     NULL::jsonb as trace                 FROM atomic_segments seg                                          LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE source_row.grouping_key = seg.grouping_key                                 AND daterange(seg.valid_from, seg.valid_until) <@ daterange(source_row.valid_from, source_row.valid_until)                             ),                             running_payload AS (                                 SELECT rn, source_row_id, data_payload, ephemeral_payload, valid_from, valid_until, causal_id, ARRAY[source_row_id::BIGINT] as contributing_row_ids                 "
297,Process Legal Units - Batch 1,,-4229863592495449365,1,53.286708000000004,10000,292,0,0,0,0,151,17701,"CREATE TEMP TABLE resolved_atomic_segments_with_propagated_ids ON COMMIT DROP AS                 SELECT                     *,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY grouping_key ORDER BY valid_from) as unified_canonical_nk_json,                     COALESCE(                         contributing_row_ids,                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as causal_source_row_ids,                     COALESCE(                         s_valid_from,                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_from,                     COALESCE(                         s_valid_until,                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_until                 FROM (                     SELECT                         *,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from) AS look_behind_grp,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from DESC) AS look_ahead_grp                     FROM resolved_atomic_segments_with_payloads /* v_resolver_from */                 ) with_grp"
5d7,Process Legal Units - Batch 1,,5432145740772416088,1,48.687167,0,239,1,0,0,0,48,10084,ANALYZE active_source_rows
1da,Process Legal Units - Batch 1,,7828285074499428853,1,48.658584,10000,2666,0,0,0,0,0,0,"WITH             all_source_rows AS (                 SELECT t.row_id AS source_row_id FROM source_view_lu t             ),             plan_unnested AS (                 SELECT unnest(p.row_ids) as source_row_id, p.plan_op_seq, p.entity_keys, p.operation, p.data, p.feedback                 FROM temporal_merge_plan p             ),             feedback_groups AS (                 SELECT                     asr.source_row_id,                     -- Aggregate all distinct operations for this source row.                     array_agg(DISTINCT pu.operation) FILTER (WHERE pu.operation IS NOT NULL) as operations,                     -- Aggregate all distinct entity IDs this source row touched.                     COALESCE(jsonb_agg(DISTINCT pu.entity_keys) FILTER (WHERE pu.entity_keys IS NOT NULL), '[]'::jsonb) AS target_entity_keys,                     -- Extract the specific error message from the plan's feedback payload if present.                     (array_agg(pu.feedback->>'error') FILTER (WHERE pu.operation = 'ERROR' AND pu.feedback ? 'error'))[1] as error_message_from_plan                 FROM all_source_rows asr                 LEFT JOIN plan_unnested pu ON asr.source_row_id = pu.source_row_id                 GROUP BY asr.source_row_id             )             INSERT INTO temporal_merge_feedback                 SELECT                     fg.source_row_id,                     fg.target_entity_keys,                     CASE                         -- This CASE statement must be ordered from most to least specific to correctly classify outcomes.                         -- This CASE statement directly translates the plan's actions into a final feedback status.                         -- It is ordered from most to least specific to ensure correctness.                         WHEN 'ERROR'::sql_saga.temporal_merge_plan_action = ANY(fg.operations) THEN 'ERROR'                         WHEN 'INSERT'::sql_saga.temporal_merge_plan_action = ANY(fg.operations)                           OR 'UPDATE'::sql_saga.temporal_merge_"
967,Process Legal Units - Batch 1,,8679993553546922744,1,46.954667,20000,1616,0,0,0,0,116,13077,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
5c6,Process Legal Units - Batch 1,,2335399437257891460,1,45.997499999999995,20000,252,0,0,0,0,116,13077,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
683,Process Legal Units - Batch 1,,-518691661278450688,1,37.97625,0,296,0,0,0,0,40,7674,ANALYZE source_rows_with_nk_json
b71,Process Legal Units - Batch 1,,7295163325594009324,1,36.8705,10000,62234,1,0,0,0,30028,1810660,"INSERT INTO etl_bench.identity_resolution (identity_correlation, legal_unit_id, resolved_batch)     SELECT DISTINCT          identity_correlation,         legal_unit_id,         p_batch_id     FROM etl_bench.data_table     WHERE batch = p_batch_id AND legal_unit_id IS NOT NULL     ON CONFLICT (identity_correlation) DO UPDATE SET         legal_unit_id = EXCLUDED.legal_unit_id,         resolved_batch = EXCLUDED.resolved_batch"
bbf,Process Legal Units - Batch 1,,-337330954754935537,1,35.316333,10000,0,0,0,0,0,0,0,"WITH RECURSIVE ordered_plan AS (                     SELECT                         row_number() OVER ( ORDER BY p.grouping_key, p.id, CASE p.operation WHEN 'DELETE' THEN 1 WHEN 'UPDATE' THEN 2 WHEN 'INSERT' THEN 3 ELSE 4 END, p.update_effect NULLS FIRST, CASE WHEN p.update_effect = 'MOVE' THEN 1 ELSE 0 END, CASE WHEN p.update_effect = 'MOVE' THEN COALESCE(p.old_valid_from, p.new_valid_from) END DESC NULLS LAST, COALESCE(p.old_valid_from, p.new_valid_from), (p.row_ids[1]) )::BIGINT as plan_op_seq,                         p.*                     FROM plan p                 ),                 -- For MOVE operations, group into the largest possible batches that can execute together.                 -- Within a single UPDATE statement, all rows see the pre-update state (MVCC snapshot).                 -- So if MOVE A's new_range overlaps MOVE B's old_range, they cannot be in the same statement.                 --                 -- Algorithm: Process MOVEs in plan_op_seq order (which is old_valid_from DESC).                 -- Track a multirange of old_ranges in the current batch. For each MOVE:                 -- - If new_range overlaps the batch's multirange, start a new batch                 -- - Add this MOVE's old_range to the batch's multirange                 --                 -- We use a recursive CTE to accumulate the multirange with reset-on-conflict logic.                 moves_ordered AS (                     SELECT                         o.plan_op_seq,                         o.grouping_key,                         o.old_valid_from,                         o.old_valid_until,                         o.new_valid_from,                         o.new_valid_until,                         row_number() OVER (PARTITION BY o.grouping_key ORDER BY o.plan_op_seq) AS move_seq                     FROM ordered_plan o                     WHERE o.operation = 'UPDATE' AND o.update_effect = 'MOVE'                 ),                 moves_with_batch AS (                     -- Base case: first MOVE in each entity starts b"
92e,Process Legal Units - Batch 1,,5039860120774769872,1,34.724542,0,180,0,0,0,0,26,6246,ANALYZE source_initial
326,Process Legal Units - Batch 1,,4494928315034638917,1,23.4605,10000,1694,1,0,0,0,154,21417,"CREATE TEMP TABLE island_group ON COMMIT DROP AS                 SELECT                     *,                     SUM(is_island_start) OVER (PARTITION BY grouping_key ORDER BY valid_from) as island_group_id                 FROM (                     SELECT                         *,                         CASE                             WHEN prev_valid_until IS NULL                             OR prev_valid_until <> valid_from                             OR (prev_data_hash IS DISTINCT FROM data_hash)                             THEN 1                             ELSE 0                         END as is_island_start                     FROM (                         SELECT                             *,                             LAG(valid_until) OVER w as prev_valid_until,                             LAG(data_hash) OVER w as prev_data_hash,                             LAG(data_payload) OVER w as prev_data_payload                         FROM resolved_atomic_segments ras                         WHERE ras.data_payload IS NOT NULL                         WINDOW w AS (PARTITION BY grouping_key ORDER BY valid_from)                     ) s1                 ) s2"
35c,Process Legal Units - Batch 1,,-2675794321567617346,1,22.65,10000,300,1,0,0,0,154,21417,"CREATE TEMP TABLE island_group ON COMMIT DROP AS                 SELECT                     *,                     SUM(is_island_start) OVER (PARTITION BY grouping_key ORDER BY valid_from) as island_group_id                 FROM (                     SELECT                         *,                         CASE                             WHEN prev_valid_until IS NULL                             OR prev_valid_until <> valid_from                             OR (prev_data_hash IS DISTINCT FROM data_hash)                             THEN 1                             ELSE 0                         END as is_island_start                     FROM (                         SELECT                             *,                             LAG(valid_until) OVER w as prev_valid_until,                             LAG(data_hash) OVER w as prev_data_hash,                             LAG(data_payload) OVER w as prev_data_payload                         FROM resolved_atomic_segments ras                         WHERE ras.data_payload IS NOT NULL                         WINDOW w AS (PARTITION BY grouping_key ORDER BY valid_from)                     ) s1                 ) s2"
70e,Process Legal Units - Batch 1,,1965474688105448427,1,22.612584,10000,4074,0,0,0,0,113,12579,"CREATE TEMP TABLE source_initial ON COMMIT DROP AS                 WITH source_data AS (                     SELECT                         source_table.row_id /* row_id_column */ as source_row_id,                         COALESCE(source_table.founding_id, source_table.row_id::integer) /* v_causal_select_expr */ as causal_id,                         source_table.id,  -- v_non_temporal_lookup_cols_select_list_prefix                         source_table.valid_from as valid_from, source_table.valid_until as valid_until, /* v_source_temporal_cols_expr */                         jsonb_strip_nulls(jsonb_build_object('name', source_table.name)) /* v_source_data_payload_expr */ AS data_payload,                         jsonb_strip_nulls(jsonb_build_object('comment', source_table.comment)) /* v_source_ephemeral_payload_expr */ AS ephemeral_payload,                         jsonb_build_object('id', source_table.id) /* v_stable_pk_cols_jsonb_build_source */ as stable_pk_payload,                         source_table.id IS NULL /* v_entity_id_check_is_null_expr */ as stable_identity_columns_are_null,                         (true) /* v_lookup_cols_are_null_expr */ as lookup_columns_unavailable,                         true /* v_is_identifiable_expr */ as is_identifiable,                         true /* v_consistency_check_expr */ as temporal_columns_are_consistent                     FROM source_view_lu /* v_source_table_ident */ source_table                 )                 SELECT                      *,                     -- OPTIMIZATION: Pre-compute range column to avoid repeated daterange() calls                     -- This provides ~10-15% performance improvement in eclipse detection                     daterange(valid_from, valid_until) as valid_range                 FROM source_data"
414,Process Legal Units - Batch 1,,2115514670139824758,1,21.900291999999997,10000,2713,0,0,0,0,113,12579,"CREATE TEMP TABLE source_initial ON COMMIT DROP AS                 WITH source_data AS (                     SELECT                         source_table.row_id /* row_id_column */ as source_row_id,                         COALESCE(source_table.founding_id, source_table.row_id::integer) /* v_causal_select_expr */ as causal_id,                         source_table.id,  -- v_non_temporal_lookup_cols_select_list_prefix                         source_table.valid_from as valid_from, source_table.valid_until as valid_until, /* v_source_temporal_cols_expr */                         jsonb_strip_nulls(jsonb_build_object('name', source_table.name)) /* v_source_data_payload_expr */ AS data_payload,                         jsonb_strip_nulls(jsonb_build_object('comment', source_table.comment)) /* v_source_ephemeral_payload_expr */ AS ephemeral_payload,                         jsonb_build_object('id', source_table.id) /* v_stable_pk_cols_jsonb_build_source */ as stable_pk_payload,                         source_table.id IS NULL /* v_entity_id_check_is_null_expr */ as stable_identity_columns_are_null,                         (true) /* v_lookup_cols_are_null_expr */ as lookup_columns_unavailable,                         true /* v_is_identifiable_expr */ as is_identifiable,                         true /* v_consistency_check_expr */ as temporal_columns_are_consistent                     FROM source_view_lu /* v_source_table_ident */ source_table                 )                 SELECT                      *,                     -- OPTIMIZATION: Pre-compute range column to avoid repeated daterange() calls                     -- This provides ~10-15% performance improvement in eclipse detection                     daterange(valid_from, valid_until) as valid_range                 FROM source_data;"
ed4,Process Legal Units - Batch 1,,-5465740686636543570,1,21.8765,10000,0,0,0,0,0,0,0,UPDATE temporal_merge_plan p                                 SET entity_keys = p.entity_keys || m.new_entity_keys                                 FROM temporal_merge_entity_id_map m                                 WHERE p.grouping_key = m.grouping_key
a4e,Process Legal Units - Batch 1,,7743831913079285872,10000,21.02265499999838,10000,0,0,0,0,0,0,0,SELECT array_agg(DISTINCT v)                     FROM unnest(until_sources) AS v
9e3,Process Legal Units - Batch 1,,-8259425963603516266,1,20.361333,0,274,0,0,0,0,57,14207,ANALYZE resolved_atomic_segments_with_payloads
2d8,Process Legal Units - Batch 1,,-1239421672540476202,1,19.097583,0,270,0,0,0,0,55,13917,ANALYZE new_segments_no_target
2ec,Process Legal Units - Batch 1,,-1014204856229529622,1,18.544292,10000,1749,1,0,0,0,145,17165,"CREATE TEMP TABLE resolved_atomic_segments ON COMMIT DROP AS                 SELECT                     grouping_key, id,  stable_identity_columns_are_null, lookup_columns_unavailable, is_new_entity, is_identifiable, is_ambiguous, conflicting_ids, unified_canonical_nk_json,                     valid_from, valid_until, t_valid_from, t_valid_until, propagated_s_valid_from, propagated_s_valid_until, causal_source_row_ids, causal_id, propagated_stable_pk_payload as stable_pk_payload,                     causal_source_row_ids IS NULL AS unaffected_target_only_segment,                     s_data_payload, t_data_payload,                     sql_saga.get_allen_relation(propagated_s_valid_from, propagated_s_valid_until, t_valid_from, t_valid_until) AS orig_source_target_relation,                     COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb) as data_payload,                     md5((jsonb_strip_nulls(COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb)))::text) as data_hash,                     CASE                          WHEN s_data_payload IS NULL THEN t_ephemeral_payload                         ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb)                     END as ephemeral_payload,                     CASE WHEN 'f'::boolean                         THEN trace || jsonb_build_object( 'cte', 'ras', 'segment_stable_pk', propagated_stable_pk_payload, 'final_data_payload', COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb), 'final_ephemeral_payload', CASE WHEN s_data_payload IS NULL THEN t_ephemeral_payload ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb) END )                         ELSE NULL                     END as trace                 FROM resolved_atomic_segments_with_propagated_ids"
5e6,Process Legal Units - Batch 1,,725758841111022991,100,18.099418999999997,100,65666,0,0,0,0,0,0,"EXISTS (         SELECT 1 FROM pg_event_trigger_ddl_commands() ddl         JOIN pg_class c ON c.oid = ddl.objid         JOIN pg_namespace n ON n.oid = c.relnamespace         WHERE EXISTS (SELECT 1 FROM sql_saga.era e WHERE (e.table_schema, e.table_name) = (n.nspname, c.relname))            OR EXISTS (SELECT 1 FROM sql_saga.updatable_view v JOIN pg_class vc ON vc.relname = v.view_name JOIN pg_namespace vn ON vn.oid = vc.relnamespace AND vn.nspname = v.view_schema WHERE vc.oid = c.oid)            -- Also check system_versioning objects (history table, view)            OR EXISTS (SELECT 1 FROM sql_saga.system_versioning sv WHERE (sv.history_schema_name, sv.history_table_name) = (n.nspname, c.relname))            OR EXISTS (SELECT 1 FROM sql_saga.system_versioning sv WHERE (sv.view_schema_name, sv.view_table_name) = (n.nspname, c.relname))     )"
c91,Process Legal Units - Batch 1,,4895990506256861755,10000,17.952261000000853,10000,0,0,0,0,0,0,0,SELECT array_agg(DISTINCT v)                    FROM unnest(from_sources) AS v
c63,Process Legal Units - Batch 1,,-5024370260775748889,1,17.931125,10000,1636,0,0,0,0,116,13061,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT * FROM (                     -- Path 1: Existing Entities (Window Function on Lookup Keys)                     SELECT                         s1.*,                         COALESCE(                             range_agg(valid_range) OVER (                                 PARTITION BY id                                 ORDER BY source_row_id DESC                                 ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                             ) @> valid_range,                             false                         ) as is_eclipsed,                         array_agg(source_row_id) OVER (                             PARTITION BY id                             ORDER BY source_row_id DESC                             ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                         ) as eclipsed_by                     FROM source_initial s1                     WHERE NOT s1.lookup_columns_unavailable                      UNION ALL                      -- Path 2: New Entities (Window Function on Causal ID)                     SELECT                         s1.*,                         COALESCE(                             range_agg(valid_range) OVER (                                 PARTITION BY causal_id                                 ORDER BY source_row_id DESC                                 ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                             ) @> valid_range,                             false                         ) as is_eclipsed,                         array_agg(source_row_id) OVER (                             PARTITION BY causal_id                             ORDER BY source_row_id DESC                             ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                         ) as eclipsed_by                     FROM source_initial s1                     WHERE s1.lookup_columns_unavailable                 ) t"
4da,Process Legal Units - Batch 1,,227465300178923650,1,17.719374,10000,298,1,0,0,0,145,17165,"CREATE TEMP TABLE resolved_atomic_segments ON COMMIT DROP AS                 SELECT                     grouping_key, id,  stable_identity_columns_are_null, lookup_columns_unavailable, is_new_entity, is_identifiable, is_ambiguous, conflicting_ids, unified_canonical_nk_json,                     valid_from, valid_until, t_valid_from, t_valid_until, propagated_s_valid_from, propagated_s_valid_until, causal_source_row_ids, causal_id, propagated_stable_pk_payload as stable_pk_payload,                     causal_source_row_ids IS NULL AS unaffected_target_only_segment,                     s_data_payload, t_data_payload,                     sql_saga.get_allen_relation(propagated_s_valid_from, propagated_s_valid_until, t_valid_from, t_valid_until) AS orig_source_target_relation,                     COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb) as data_payload,                     md5((jsonb_strip_nulls(COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb)))::text) as data_hash,                     CASE                          WHEN s_data_payload IS NULL THEN t_ephemeral_payload                         ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb)                     END as ephemeral_payload,                     CASE WHEN 'f'::boolean                         THEN trace || jsonb_build_object( 'cte', 'ras', 'segment_stable_pk', propagated_stable_pk_payload, 'final_data_payload', COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb), 'final_ephemeral_payload', CASE WHEN s_data_payload IS NULL THEN t_ephemeral_payload ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb) END )                         ELSE NULL                     END as trace                 FROM resolved_atomic_segments_with_propagated_ids"
f0d,Process Legal Units - Batch 1,,7110079446970253207,1,17.403792,10000,1705,1,0,0,0,140,18782,"CREATE TEMP TABLE plan ON COMMIT DROP AS                 SELECT                     p.row_ids, p.operation, p.causal_id, p.is_new_entity,                     p.id,                     p.entity_keys_json as entity_keys,                     p.identity_keys, p.lookup_keys,                     p.orig_source_target_relation, p.b_a_relation, p.old_valid_from, p.old_valid_until,                     p.new_valid_from, p.new_valid_until, p.data, p.feedback, p.trace,                     p.grouping_key,                     CASE                         WHEN p.operation <> 'UPDATE' THEN NULL::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from = p.old_valid_from AND p.new_valid_until = p.old_valid_until THEN 'NONE'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from <= p.old_valid_from AND p.new_valid_until >= p.old_valid_until THEN 'GROW'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from >= p.old_valid_from AND p.new_valid_until <= p.old_valid_until THEN 'SHRINK'::sql_saga.temporal_merge_update_effect                         ELSE 'MOVE'::sql_saga.temporal_merge_update_effect                     END AS update_effect                 FROM plan_with_op p                 LEFT JOIN source_rows_with_new_flag source_row ON source_row.source_row_id = p.row_ids[1]"
ee3,Process Legal Units - Batch 1,,1428552154429020267,1,17.219875,20000,1612,0,0,0,0,110,12251,"CREATE TEMP TABLE time_points ON COMMIT DROP AS                 SELECT DISTINCT ON (grouping_key, point) *                 FROM time_points_with_unified_ids                 ORDER BY grouping_key, point, causal_id DESC NULLS LAST"
810,Process Legal Units - Batch 1,,3167307580342175303,1,16.960209,10000,255,0,0,0,0,116,13061,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT * FROM (                     -- Path 1: Existing Entities (Window Function on Lookup Keys)                     SELECT                         s1.*,                         COALESCE(                             range_agg(valid_range) OVER (                                 PARTITION BY id                                 ORDER BY source_row_id DESC                                 ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                             ) @> valid_range,                             false                         ) as is_eclipsed,                         array_agg(source_row_id) OVER (                             PARTITION BY id                             ORDER BY source_row_id DESC                             ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                         ) as eclipsed_by                     FROM source_initial s1                     WHERE NOT s1.lookup_columns_unavailable                      UNION ALL                      -- Path 2: New Entities (Window Function on Causal ID)                     SELECT                         s1.*,                         COALESCE(                             range_agg(valid_range) OVER (                                 PARTITION BY causal_id                                 ORDER BY source_row_id DESC                                 ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                             ) @> valid_range,                             false                         ) as is_eclipsed,                         array_agg(source_row_id) OVER (                             PARTITION BY causal_id                             ORDER BY source_row_id DESC                             ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                         ) as eclipsed_by                     FROM source_initial s1                     WHERE s1.lookup_columns_unavailable                 ) t;"
64b,Process Legal Units - Batch 1,,7371826089573494947,1,16.584208999999998,10000,301,1,0,0,0,140,18782,"CREATE TEMP TABLE plan ON COMMIT DROP AS                 SELECT                     p.row_ids, p.operation, p.causal_id, p.is_new_entity,                     p.id,                     p.entity_keys_json as entity_keys,                     p.identity_keys, p.lookup_keys,                     p.orig_source_target_relation, p.b_a_relation, p.old_valid_from, p.old_valid_until,                     p.new_valid_from, p.new_valid_until, p.data, p.feedback, p.trace,                     p.grouping_key,                     CASE                         WHEN p.operation <> 'UPDATE' THEN NULL::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from = p.old_valid_from AND p.new_valid_until = p.old_valid_until THEN 'NONE'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from <= p.old_valid_from AND p.new_valid_until >= p.old_valid_until THEN 'GROW'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from >= p.old_valid_from AND p.new_valid_until <= p.old_valid_until THEN 'SHRINK'::sql_saga.temporal_merge_update_effect                         ELSE 'MOVE'::sql_saga.temporal_merge_update_effect                     END AS update_effect                 FROM plan_with_op p                 LEFT JOIN source_rows_with_new_flag source_row ON source_row.source_row_id = p.row_ids[1]"
ea6,Process Legal Units - Batch 1,,6254436778457358929,1,16.525748999999998,20000,246,0,0,0,0,110,12251,"CREATE TEMP TABLE time_points ON COMMIT DROP AS                 SELECT DISTINCT ON (grouping_key, point) *                 FROM time_points_with_unified_ids                 ORDER BY grouping_key, point, causal_id DESC NULLS LAST"
ed6,Process Legal Units - Batch 1,,5147944785677299242,1,16.414958,10000,1668,0,0,0,0,138,15551,"CREATE TEMP TABLE diff_ranked ON COMMIT DROP AS                 SELECT                     d.*,                     CASE                         WHEN d.t_from IS NULL OR d.f_from IS NULL THEN NULL                         WHEN d.f_from = d.t_from AND d.f_until = d.t_until AND d.f_payload IS NOT DISTINCT FROM d.t_payload THEN NULL                         ELSE                             row_number() OVER (                                 PARTITION BY d.grouping_key, d.t_from                                 ORDER BY                                     CASE WHEN d.f_from = d.t_from THEN 1 ELSE 2 END,                                     CASE WHEN d.f_payload - '{comment}'::text[] IS NOT DISTINCT FROM d.t_payload - '{comment}'::text[] THEN 1 ELSE 2 END,                                     d.f_from,                                     d.f_until                             )                     END as update_rank                 FROM diff d"
2a3,Process Legal Units - Batch 1,,-7556227097878634121,1,16.170792,0,308,0,0,0,0,50,13970,ANALYZE temporal_merge_plan
384,Process Legal Units - Batch 1,,6259880232974284115,1,15.678666000000002,10000,282,0,0,0,0,138,15551,"CREATE TEMP TABLE diff_ranked ON COMMIT DROP AS                 SELECT                     d.*,                     CASE                         WHEN d.t_from IS NULL OR d.f_from IS NULL THEN NULL                         WHEN d.f_from = d.t_from AND d.f_until = d.t_until AND d.f_payload IS NOT DISTINCT FROM d.t_payload THEN NULL                         ELSE                             row_number() OVER (                                 PARTITION BY d.grouping_key, d.t_from                                 ORDER BY                                     CASE WHEN d.f_from = d.t_from THEN 1 ELSE 2 END,                                     CASE WHEN d.f_payload - '{comment}'::text[] IS NOT DISTINCT FROM d.t_payload - '{comment}'::text[] THEN 1 ELSE 2 END,                                     d.f_from,                                     d.f_until                             )                     END as update_rank                 FROM diff d"
41e,Process Legal Units - Batch 1,,6779487562696088383,1,14.749834,10000,1620,0,0,0,0,112,12521,"CREATE TEMP TABLE atomic_segments ON COMMIT DROP AS                 SELECT grouping_key, id, causal_id, point as valid_from, next_point as valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json                 FROM (                     SELECT *, LEAD(point) OVER (PARTITION BY grouping_key ORDER BY point) as next_point                     FROM time_points                 ) with_lead                 WHERE point IS NOT NULL AND next_point IS NOT NULL AND point < next_point"
c0a,Process Legal Units - Batch 1,,-7375841108639655790,1,14.012125000000001,10000,254,0,0,0,0,112,12521,"CREATE TEMP TABLE atomic_segments ON COMMIT DROP AS                 SELECT grouping_key, id, causal_id, point as valid_from, next_point as valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json                 FROM (                     SELECT *, LEAD(point) OVER (PARTITION BY grouping_key ORDER BY point) as next_point                     FROM time_points                 ) with_lead                 WHERE point IS NOT NULL AND next_point IS NOT NULL AND point < next_point"
05e,Process Legal Units - Batch 1,,-6278565976310229931,1,13.112583,10000,1677,1,0,0,0,132,14520,"CREATE TEMP TABLE plan_with_op ON COMMIT DROP AS                 (                     SELECT * FROM (                         SELECT                             d.f_row_ids as row_ids, d.orig_source_target_relation, d.is_new_entity,                             CASE                                 WHEN d.is_ambiguous THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.is_new_entity AND NOT d.is_identifiable THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.t_from IS NULL THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.f_from IS NULL THEN 'DELETE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank = 1 THEN 'UPDATE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank > 1 THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank IS NULL THEN                                     CASE                                         WHEN d.unaffected_target_only_segment THEN NULL                                         ELSE 'SKIP_IDENTICAL'::sql_saga.temporal_merge_plan_action                                     END                                 ELSE 'ERROR'::sql_saga.temporal_merge_plan_action                             END as operation,                             id,                             CASE                                 WHEN d.is_new_entity AND d.canonical_nk_json IS NOT NULL                                 THEN d.canonical_nk_json || COALESCE(d.stable_pk_payload, '{}'::jsonb)                                 ELSE jsonb_build_object('id', d.id) || COALESCE(d.stable_pk_payload, '{}'::jsonb)                             END as entity_keys_json,                             jsonb_build_object('id', d.id) as identity_keys,                             jsonb_build_object() as lookup_keys,                             d.causal_id, d.t_from as old_valid_from, d.t_until as old_valid_until, d.f"
150,Process Legal Units - Batch 1,,7000426517880687954,1,12.893791,10000,1734,0,0,0,0,134,15357,"CREATE TEMP TABLE source_rows_with_canonical_key ON COMMIT DROP AS                 SELECT *, (CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END /* v_grouping_key_expr */) as grouping_key                 FROM (                     SELECT                         s1.*,                         s2.nk_json as canonical_nk_json                     FROM source_rows_with_nk_json s1                     LEFT JOIN LATERAL (                         SELECT s2_inner.nk_json, s2_inner.nk_non_null_keys_array                         FROM source_rows_with_nk_json s2_inner                         WHERE s1.is_new_entity AND s2_inner.is_new_entity AND s2_inner.nk_json @> s1.nk_json                         ORDER BY array_length(s2_inner.nk_non_null_keys_array, 1) DESC, s2_inner.nk_non_null_keys_array::text DESC                         LIMIT 1                     ) s2 ON true                 ) s"
32d,Process Legal Units - Batch 1,,8461913458038132941,1,12.235084,10000,284,1,0,0,0,132,14520,"CREATE TEMP TABLE plan_with_op ON COMMIT DROP AS                 (                     SELECT * FROM (                         SELECT                             d.f_row_ids as row_ids, d.orig_source_target_relation, d.is_new_entity,                             CASE                                 WHEN d.is_ambiguous THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.is_new_entity AND NOT d.is_identifiable THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.t_from IS NULL THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.f_from IS NULL THEN 'DELETE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank = 1 THEN 'UPDATE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank > 1 THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank IS NULL THEN                                     CASE                                         WHEN d.unaffected_target_only_segment THEN NULL                                         ELSE 'SKIP_IDENTICAL'::sql_saga.temporal_merge_plan_action                                     END                                 ELSE 'ERROR'::sql_saga.temporal_merge_plan_action                             END as operation,                             id,                             CASE                                 WHEN d.is_new_entity AND d.canonical_nk_json IS NOT NULL                                 THEN d.canonical_nk_json || COALESCE(d.stable_pk_payload, '{}'::jsonb)                                 ELSE jsonb_build_object('id', d.id) || COALESCE(d.stable_pk_payload, '{}'::jsonb)                             END as entity_keys_json,                             jsonb_build_object('id', d.id) as identity_keys,                             jsonb_build_object() as lookup_keys,                             d.causal_id, d.t_from as old_valid_from, d.t_until as old_valid_until, d.f"
05a,Process Legal Units - Batch 1,,8118870935825291626,1,11.901250000000001,10000,279,0,0,0,0,134,15357,"CREATE TEMP TABLE source_rows_with_canonical_key ON COMMIT DROP AS                 SELECT *, (CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END /* v_grouping_key_expr */) as grouping_key                 FROM (                     SELECT                         s1.*,                         s2.nk_json as canonical_nk_json                     FROM source_rows_with_nk_json s1                     LEFT JOIN LATERAL (                         SELECT s2_inner.nk_json, s2_inner.nk_non_null_keys_array                         FROM source_rows_with_nk_json s2_inner                         WHERE s1.is_new_entity AND s2_inner.is_new_entity AND s2_inner.nk_json @> s1.nk_json                         ORDER BY array_length(s2_inner.nk_non_null_keys_array, 1) DESC, s2_inner.nk_non_null_keys_array::text DESC                         LIMIT 1                     ) s2 ON true                 ) s"
367,Process Legal Units - Batch 1,,-3276528771796910273,1,10.83675,10000,1757,0,0,0,0,139,16073,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     seg.*,                     seg.stable_pk_payload as propagated_stable_pk_payload                 FROM all_segments seg                 WHERE (seg.s_data_payload IS NOT NULL OR seg.t_data_payload IS NOT NULL)                 AND CASE 'MERGE_ENTITY_PATCH'::sql_saga.temporal_merge_mode                     WHEN 'PATCH_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'REPLACE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'DELETE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'UPDATE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     ELSE true                 END"
d87,Process Legal Units - Batch 1,,8689595743856886431,1,10.535416,0,1436,0,0,0,0,15,1597,CREATE INDEX ON active_source_rows (grouping_key)
b29,Process Legal Units - Batch 1,,-1318097777820228,1,10.074542,10000,1648,1,0,0,0,122,14516,"CREATE TEMP TABLE source_rows ON COMMIT DROP AS                 SELECT DISTINCT ON (p.source_row_id)                     p.source_row_id, p.causal_id, p.valid_from, p.valid_until, p.data_payload, p.ephemeral_payload,                     (p.stable_identity_columns_are_null AND p.discovered_stable_pk_payload IS NULL) as stable_identity_columns_are_null,                     p.lookup_columns_unavailable, p.is_identifiable,                     p.is_ambiguous, p.conflicting_ids, p.is_eclipsed, p.eclipsed_by,                     p.temporal_columns_are_consistent,                     COALESCE(p.stable_pk_payload, p.discovered_stable_pk_payload) as stable_pk_payload,                     (p.discovered_stable_pk_payload IS NOT NULL) /* v_target_entity_exists_expr */ as target_entity_exists,                     COALESCE(p.id, p.discovered_id_1) AS id /* v_coalesced_id_cols_list */                 FROM source_rows_with_discovery p                 ORDER BY p.source_row_id, p.discovered_stable_pk_payload"
8cb,Process Legal Units - Batch 2,,-4212605005101232050,1,2768.193833,0,576166,12,3066,3071,0,186935,17418083,CALL etl_bench.process_legal_units(v_batch_id)
455,Process Legal Units - Batch 2,,2508743807545342814,1,2699.095417,0,474261,12,3066,3071,0,146757,14710765,"CALL sql_saga.temporal_merge(         target_table => 'etl_bench.legal_unit',         source_table => 'source_view_lu',         primary_identity_columns => ARRAY['id'],         ephemeral_columns => ARRAY['comment'],         mode => 'MERGE_ENTITY_PATCH',         founding_id_column => 'founding_id',         update_source_with_identity => true,         update_source_with_feedback => true,         feedback_status_column => 'merge_statuses',         feedback_status_key => 'legal_unit',         feedback_error_column => 'merge_errors',         feedback_error_key => 'legal_unit'     )"
b6a,Process Legal Units - Batch 2,,-4094074925611420334,1,1962.4794590000001,10000,78974,11,3066,3071,0,5738,626567,"INSERT INTO temporal_merge_plan     SELECT * FROM sql_saga.temporal_merge_plan(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         identity_columns => v_identity_cols_discovered,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         delete_mode => temporal_merge.delete_mode,         lookup_keys => v_natural_identity_keys_discovered,         ephemeral_columns => temporal_merge.ephemeral_columns,         p_log_trace => v_log_trace,         p_log_sql => v_log_sql     )"
a61,Process Legal Units - Batch 2,,9062296240809330110,1,731.510083,0,393050,1,0,0,0,140753,14059363,"CALL sql_saga.temporal_merge_execute(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         identity_columns => v_identity_cols_discovered,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         update_source_with_identity => temporal_merge.update_source_with_identity,         lookup_columns => v_natural_identity_cols_discovered,         delete_mode => temporal_merge.delete_mode,         update_source_with_feedback => temporal_merge.update_source_with_feedback,         feedback_status_column => temporal_merge.feedback_status_column,         feedback_status_key => temporal_merge.feedback_status_key,         feedback_error_column => temporal_merge.feedback_error_column,         feedback_error_key => temporal_merge.feedback_error_key,         ephemeral_columns => temporal_merge.ephemeral_columns,         delay_constraints => temporal_merge.delay_constraints     )"
ae7,Process Legal Units - Batch 2,,-5023945640903832763,1,448.145417,10000,220606,0,0,0,0,80367,7695464,"UPDATE etl_bench.legal_unit t SET valid_range = p.new_valid_range::daterange, name = CASE WHEN p.data ? 'name' THEN (p.data->>'name')::text ELSE t.name END, comment = CASE WHEN p.data ? 'comment' THEN (p.data->>'comment')::text ELSE t.comment END                                 FROM (SELECT *, (entity_keys->>'id')::integer AS id_ek FROM temporal_merge_plan WHERE operation = 'UPDATE' AND statement_seq = 1 ORDER BY plan_op_seq) p                                 WHERE t.id = p.id_ek AND t.valid_range = p.old_valid_range::daterange"
a93,Process Legal Units - Batch 2,,-8259425963603516266,1,216.067292,0,272,2,0,0,0,57,25579,ANALYZE resolved_atomic_segments_with_payloads
529,Process Legal Units - Batch 2,,-5685077514497051452,1,193.159166,0,267,3,0,0,0,55,23934,ANALYZE existing_segments_with_target
b56,Process Legal Units - Batch 2,,-6251707813684716315,1,173.513208,10000,165320,0,0,0,0,60204,6336190,"UPDATE source_view_lu s             SET merge_statuses = COALESCE(s.merge_statuses, '{}'::jsonb) || jsonb_build_object('legal_unit', f.status), merge_errors = CASE WHEN f.error_message IS NOT NULL THEN COALESCE(s.merge_errors, '{}'::jsonb) || jsonb_build_object('legal_unit', f.error_message) ELSE COALESCE(s.merge_errors, '{}'::jsonb) - 'legal_unit' END             FROM pg_temp.temporal_merge_feedback f             WHERE s.row_id = f.source_row_id"
bbc,Process Legal Units - Batch 2,,2265156188269693366,1,132.665042,20000,1732,0,747,748,0,154,18696,"CREATE TEMP TABLE resolved_atomic_segments_with_propagated_ids ON COMMIT DROP AS                 SELECT                     *,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY grouping_key ORDER BY valid_from) as unified_canonical_nk_json,                     COALESCE(                         contributing_row_ids,                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as causal_source_row_ids,                     COALESCE(                         s_valid_from,                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_from,                     COALESCE(                         s_valid_until,                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_until                 FROM (                     SELECT                         *,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from) AS look_behind_grp,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from DESC) AS look_ahead_grp                     FROM resolved_atomic_segments_with_payloads /* v_resolver_from */                 ) with_grp"
659,Process Legal Units - Batch 2,,-4229863592495449365,1,130.421626,20000,304,0,747,748,0,154,18696,"CREATE TEMP TABLE resolved_atomic_segments_with_propagated_ids ON COMMIT DROP AS                 SELECT                     *,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY grouping_key ORDER BY valid_from) as unified_canonical_nk_json,                     COALESCE(                         contributing_row_ids,                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as causal_source_row_ids,                     COALESCE(                         s_valid_from,                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_from,                     COALESCE(                         s_valid_until,                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_until                 FROM (                     SELECT                         *,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from) AS look_behind_grp,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from DESC) AS look_ahead_grp                     FROM resolved_atomic_segments_with_payloads /* v_resolver_from */                 ) with_grp"
4b8,Process Legal Units - Batch 2,,-5479635516521171982,1,129.665958,20000,1687,0,0,0,0,136,15721,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.lookup_columns_unavailable, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     source_payloads.source_row_id, source_payloads.contributing_row_ids,                     source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                     source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON target_row.id = seg.id                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                                          LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))                                 AND daterange(seg.valid_from, seg.valid_until) <@ date"
bfe,Process Legal Units - Batch 2,,-6429604085756835998,1,128.50275,20000,277,0,0,0,0,136,15721,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.lookup_columns_unavailable, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     source_payloads.source_row_id, source_payloads.contributing_row_ids,                     source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                     source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON target_row.id = seg.id                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                                          LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))                                 AND daterange(seg.valid_from, seg.valid_until) <@ date"
efd,Process Legal Units - Batch 2,,8679993553546922744,1,116.206333,40000,1624,0,494,495,0,116,13077,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
2a2,Process Legal Units - Batch 2,,2335399437257891460,1,114.556542,40000,257,0,494,495,0,116,13077,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
913,Process Legal Units - Batch 2,,-8581391324505025071,1,107.59075,10000,1698,0,556,557,0,130,15375,"CREATE TEMP TABLE coalesced_final_segments ON COMMIT DROP AS                 SELECT                     grouping_key, max(id) as id,                     sql_saga.first(causal_id ORDER BY valid_from) as causal_id,                     sql_saga.first(stable_identity_columns_are_null ORDER BY valid_from) as stable_identity_columns_are_null,                     sql_saga.first(lookup_columns_unavailable ORDER BY valid_from) as lookup_columns_unavailable,                     sql_saga.first(is_new_entity ORDER BY valid_from) as is_new_entity,                     sql_saga.first(is_identifiable ORDER BY valid_from) as is_identifiable,                     sql_saga.first(is_ambiguous ORDER BY valid_from) as is_ambiguous,                     sql_saga.first(conflicting_ids ORDER BY valid_from) as conflicting_ids,                     sql_saga.first(unified_canonical_nk_json ORDER BY valid_from) as canonical_nk_json,                     sql_saga.first(orig_source_target_relation ORDER BY valid_from) as orig_source_target_relation,                     sql_saga.first(t_valid_from ORDER BY valid_from) as ancestor_valid_from,                     MIN(valid_from) as valid_from,                     MAX(valid_until) as valid_until,                     (sql_saga.first(data_payload ORDER BY valid_from DESC) || sql_saga.first(ephemeral_payload ORDER BY valid_from DESC)) as final_payload,                     sql_saga.first(stable_pk_payload ORDER BY valid_from DESC) as stable_pk_payload,                     bool_and(unaffected_target_only_segment) as unaffected_target_only_segment,                     (SELECT array_agg(DISTINCT e) FROM unnest(array_concat_agg(causal_source_row_ids)) e WHERE e IS NOT NULL) as row_ids,                     CASE WHEN 'f'::boolean                         THEN jsonb_build_object( 'cte', 'coalesced', 'island_group_id', island_group_id, 'coalesced_stable_pk', sql_saga.first(stable_pk_payload ORDER BY valid_from DESC), 'final_payload', sql_saga.first(data_payload ORDER BY valid_from DESC), 'final_payload_sans_epheme"
918,Process Legal Units - Batch 2,,3295832470614201853,1,105.738959,10000,289,0,556,557,0,130,15375,"CREATE TEMP TABLE coalesced_final_segments ON COMMIT DROP AS                 SELECT                     grouping_key, max(id) as id,                     sql_saga.first(causal_id ORDER BY valid_from) as causal_id,                     sql_saga.first(stable_identity_columns_are_null ORDER BY valid_from) as stable_identity_columns_are_null,                     sql_saga.first(lookup_columns_unavailable ORDER BY valid_from) as lookup_columns_unavailable,                     sql_saga.first(is_new_entity ORDER BY valid_from) as is_new_entity,                     sql_saga.first(is_identifiable ORDER BY valid_from) as is_identifiable,                     sql_saga.first(is_ambiguous ORDER BY valid_from) as is_ambiguous,                     sql_saga.first(conflicting_ids ORDER BY valid_from) as conflicting_ids,                     sql_saga.first(unified_canonical_nk_json ORDER BY valid_from) as canonical_nk_json,                     sql_saga.first(orig_source_target_relation ORDER BY valid_from) as orig_source_target_relation,                     sql_saga.first(t_valid_from ORDER BY valid_from) as ancestor_valid_from,                     MIN(valid_from) as valid_from,                     MAX(valid_until) as valid_until,                     (sql_saga.first(data_payload ORDER BY valid_from DESC) || sql_saga.first(ephemeral_payload ORDER BY valid_from DESC)) as final_payload,                     sql_saga.first(stable_pk_payload ORDER BY valid_from DESC) as stable_pk_payload,                     bool_and(unaffected_target_only_segment) as unaffected_target_only_segment,                     (SELECT array_agg(DISTINCT e) FROM unnest(array_concat_agg(causal_source_row_ids)) e WHERE e IS NOT NULL) as row_ids,                     CASE WHEN 'f'::boolean                         THEN jsonb_build_object( 'cte', 'coalesced', 'island_group_id', island_group_id, 'coalesced_stable_pk', sql_saga.first(stable_pk_payload ORDER BY valid_from DESC), 'final_payload', sql_saga.first(data_payload ORDER BY valid_from DESC), 'final_payload_sans_epheme"
1ca,Process Legal Units - Batch 2,,5432145740772416088,1,78.976,0,233,1,0,0,0,48,11420,ANALYZE active_source_rows
ebd,Process Legal Units - Batch 2,,2346888588666524139,1,78.204083,40000,1622,0,0,0,0,109,12055,"CREATE TEMP TABLE time_points_raw ON COMMIT DROP AS                 SELECT id, causal_id, valid_from AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows                 UNION ALL                 SELECT id, causal_id, valid_until AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows"
e14,Process Legal Units - Batch 2,,3254511572182529394,1,77.449708,40000,253,0,0,0,0,109,12055,"CREATE TEMP TABLE time_points_raw ON COMMIT DROP AS                 SELECT id, causal_id, valid_from AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows                 UNION ALL                 SELECT id, causal_id, valid_until AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows"
213,Process Legal Units - Batch 2,,-518691661278450688,1,69.32225,0,202,1,0,0,0,40,9072,ANALYZE source_rows_with_nk_json
a85,Process Legal Units - Batch 2,,4494928315034638917,1,64.891958,20000,1699,0,771,772,0,153,17740,"CREATE TEMP TABLE island_group ON COMMIT DROP AS                 SELECT                     *,                     SUM(is_island_start) OVER (PARTITION BY grouping_key ORDER BY valid_from) as island_group_id                 FROM (                     SELECT                         *,                         CASE                             WHEN prev_valid_until IS NULL                             OR prev_valid_until <> valid_from                             OR (prev_data_hash IS DISTINCT FROM data_hash)                             THEN 1                             ELSE 0                         END as is_island_start                     FROM (                         SELECT                             *,                             LAG(valid_until) OVER w as prev_valid_until,                             LAG(data_hash) OVER w as prev_data_hash,                             LAG(data_payload) OVER w as prev_data_payload                         FROM resolved_atomic_segments ras                         WHERE ras.data_payload IS NOT NULL                         WINDOW w AS (PARTITION BY grouping_key ORDER BY valid_from)                     ) s1                 ) s2"
f7f,Process Legal Units - Batch 2,,0,5,64.608251,0,3805,1,0,0,0,350,48540,CALL sql_saga.benchmark_reset()
0ea,Process Legal Units - Batch 2,,-2675794321567617346,1,62.923666000000004,20000,302,0,771,772,0,153,17740,"CREATE TEMP TABLE island_group ON COMMIT DROP AS                 SELECT                     *,                     SUM(is_island_start) OVER (PARTITION BY grouping_key ORDER BY valid_from) as island_group_id                 FROM (                     SELECT                         *,                         CASE                             WHEN prev_valid_until IS NULL                             OR prev_valid_until <> valid_from                             OR (prev_data_hash IS DISTINCT FROM data_hash)                             THEN 1                             ELSE 0                         END as is_island_start                     FROM (                         SELECT                             *,                             LAG(valid_until) OVER w as prev_valid_until,                             LAG(data_hash) OVER w as prev_data_hash,                             LAG(data_payload) OVER w as prev_data_payload                         FROM resolved_atomic_segments ras                         WHERE ras.data_payload IS NOT NULL                         WINDOW w AS (PARTITION BY grouping_key ORDER BY valid_from)                     ) s1                 ) s2"
87f,Process Legal Units - Batch 2,,1965474688105448427,1,62.549208,10000,6316,0,0,0,0,115,13278,"CREATE TEMP TABLE source_initial ON COMMIT DROP AS                 WITH source_data AS (                     SELECT                         source_table.row_id /* row_id_column */ as source_row_id,                         COALESCE(source_table.founding_id, source_table.row_id::integer) /* v_causal_select_expr */ as causal_id,                         source_table.id,  -- v_non_temporal_lookup_cols_select_list_prefix                         source_table.valid_from as valid_from, source_table.valid_until as valid_until, /* v_source_temporal_cols_expr */                         jsonb_strip_nulls(jsonb_build_object('name', source_table.name)) /* v_source_data_payload_expr */ AS data_payload,                         jsonb_strip_nulls(jsonb_build_object('comment', source_table.comment)) /* v_source_ephemeral_payload_expr */ AS ephemeral_payload,                         jsonb_build_object('id', source_table.id) /* v_stable_pk_cols_jsonb_build_source */ as stable_pk_payload,                         source_table.id IS NULL /* v_entity_id_check_is_null_expr */ as stable_identity_columns_are_null,                         (true) /* v_lookup_cols_are_null_expr */ as lookup_columns_unavailable,                         true /* v_is_identifiable_expr */ as is_identifiable,                         true /* v_consistency_check_expr */ as temporal_columns_are_consistent                     FROM source_view_lu /* v_source_table_ident */ source_table                 )                 SELECT                      *,                     -- OPTIMIZATION: Pre-compute range column to avoid repeated daterange() calls                     -- This provides ~10-15% performance improvement in eclipse detection                     daterange(valid_from, valid_until) as valid_range                 FROM source_data"
301,Process Legal Units - Batch 2,,2115514670139824758,1,61.791667000000004,10000,4973,0,0,0,0,115,13278,"CREATE TEMP TABLE source_initial ON COMMIT DROP AS                 WITH source_data AS (                     SELECT                         source_table.row_id /* row_id_column */ as source_row_id,                         COALESCE(source_table.founding_id, source_table.row_id::integer) /* v_causal_select_expr */ as causal_id,                         source_table.id,  -- v_non_temporal_lookup_cols_select_list_prefix                         source_table.valid_from as valid_from, source_table.valid_until as valid_until, /* v_source_temporal_cols_expr */                         jsonb_strip_nulls(jsonb_build_object('name', source_table.name)) /* v_source_data_payload_expr */ AS data_payload,                         jsonb_strip_nulls(jsonb_build_object('comment', source_table.comment)) /* v_source_ephemeral_payload_expr */ AS ephemeral_payload,                         jsonb_build_object('id', source_table.id) /* v_stable_pk_cols_jsonb_build_source */ as stable_pk_payload,                         source_table.id IS NULL /* v_entity_id_check_is_null_expr */ as stable_identity_columns_are_null,                         (true) /* v_lookup_cols_are_null_expr */ as lookup_columns_unavailable,                         true /* v_is_identifiable_expr */ as is_identifiable,                         true /* v_consistency_check_expr */ as temporal_columns_are_consistent                     FROM source_view_lu /* v_source_table_ident */ source_table                 )                 SELECT                      *,                     -- OPTIMIZATION: Pre-compute range column to avoid repeated daterange() calls                     -- This provides ~10-15% performance improvement in eclipse detection                     daterange(valid_from, valid_until) as valid_range                 FROM source_data;"
5bb,Process Legal Units - Batch 2,,1525269309137858814,1,58.216375,0,139,1,0,0,0,26,9453,ANALYZE atomic_segments
ea1,Process Legal Units - Batch 2,,7295163325594009324,1,53.172458,10000,95222,0,0,0,0,40135,2703984,"INSERT INTO etl_bench.identity_resolution (identity_correlation, legal_unit_id, resolved_batch)     SELECT DISTINCT          identity_correlation,         legal_unit_id,         p_batch_id     FROM etl_bench.data_table     WHERE batch = p_batch_id AND legal_unit_id IS NOT NULL     ON CONFLICT (identity_correlation) DO UPDATE SET         legal_unit_id = EXCLUDED.legal_unit_id,         resolved_batch = EXCLUDED.resolved_batch"
591,Process Legal Units - Batch 2,,-1014204856229529622,1,52.43775,20000,1703,1,0,0,0,144,20011,"CREATE TEMP TABLE resolved_atomic_segments ON COMMIT DROP AS                 SELECT                     grouping_key, id,  stable_identity_columns_are_null, lookup_columns_unavailable, is_new_entity, is_identifiable, is_ambiguous, conflicting_ids, unified_canonical_nk_json,                     valid_from, valid_until, t_valid_from, t_valid_until, propagated_s_valid_from, propagated_s_valid_until, causal_source_row_ids, causal_id, propagated_stable_pk_payload as stable_pk_payload,                     causal_source_row_ids IS NULL AS unaffected_target_only_segment,                     s_data_payload, t_data_payload,                     sql_saga.get_allen_relation(propagated_s_valid_from, propagated_s_valid_until, t_valid_from, t_valid_until) AS orig_source_target_relation,                     COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb) as data_payload,                     md5((jsonb_strip_nulls(COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb)))::text) as data_hash,                     CASE                          WHEN s_data_payload IS NULL THEN t_ephemeral_payload                         ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb)                     END as ephemeral_payload,                     CASE WHEN 'f'::boolean                         THEN trace || jsonb_build_object( 'cte', 'ras', 'segment_stable_pk', propagated_stable_pk_payload, 'final_data_payload', COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb), 'final_ephemeral_payload', CASE WHEN s_data_payload IS NULL THEN t_ephemeral_payload ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb) END )                         ELSE NULL                     END as trace                 FROM resolved_atomic_segments_with_propagated_ids"
527,Process Legal Units - Batch 2,,227465300178923650,1,51.569334000000005,20000,294,1,0,0,0,144,20011,"CREATE TEMP TABLE resolved_atomic_segments ON COMMIT DROP AS                 SELECT                     grouping_key, id,  stable_identity_columns_are_null, lookup_columns_unavailable, is_new_entity, is_identifiable, is_ambiguous, conflicting_ids, unified_canonical_nk_json,                     valid_from, valid_until, t_valid_from, t_valid_until, propagated_s_valid_from, propagated_s_valid_until, causal_source_row_ids, causal_id, propagated_stable_pk_payload as stable_pk_payload,                     causal_source_row_ids IS NULL AS unaffected_target_only_segment,                     s_data_payload, t_data_payload,                     sql_saga.get_allen_relation(propagated_s_valid_from, propagated_s_valid_until, t_valid_from, t_valid_until) AS orig_source_target_relation,                     COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb) as data_payload,                     md5((jsonb_strip_nulls(COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb)))::text) as data_hash,                     CASE                          WHEN s_data_payload IS NULL THEN t_ephemeral_payload                         ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb)                     END as ephemeral_payload,                     CASE WHEN 'f'::boolean                         THEN trace || jsonb_build_object( 'cte', 'ras', 'segment_stable_pk', propagated_stable_pk_payload, 'final_data_payload', COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb), 'final_ephemeral_payload', CASE WHEN s_data_payload IS NULL THEN t_ephemeral_payload ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb) END )                         ELSE NULL                     END as trace                 FROM resolved_atomic_segments_with_propagated_ids"
f76,Process Legal Units - Batch 2,,5039860120774769872,1,45.197625,0,142,0,0,0,0,26,7165,ANALYZE source_initial
fde,Process Legal Units - Batch 2,,1428552154429020267,1,44.588042,30000,1623,0,498,499,0,110,12251,"CREATE TEMP TABLE time_points ON COMMIT DROP AS                 SELECT DISTINCT ON (grouping_key, point) *                 FROM time_points_with_unified_ids                 ORDER BY grouping_key, point, causal_id DESC NULLS LAST"
f8d,Process Legal Units - Batch 2,,6254436778457358929,1,43.010041,30000,254,0,498,499,0,110,12251,"CREATE TEMP TABLE time_points ON COMMIT DROP AS                 SELECT DISTINCT ON (grouping_key, point) *                 FROM time_points_with_unified_ids                 ORDER BY grouping_key, point, causal_id DESC NULLS LAST"
41e,Process Legal Units - Batch 2,,-337330954754935537,1,42.842084,10000,0,0,0,0,0,0,0,"WITH RECURSIVE ordered_plan AS (                     SELECT                         row_number() OVER ( ORDER BY p.grouping_key, p.id, CASE p.operation WHEN 'DELETE' THEN 1 WHEN 'UPDATE' THEN 2 WHEN 'INSERT' THEN 3 ELSE 4 END, p.update_effect NULLS FIRST, CASE WHEN p.update_effect = 'MOVE' THEN 1 ELSE 0 END, CASE WHEN p.update_effect = 'MOVE' THEN COALESCE(p.old_valid_from, p.new_valid_from) END DESC NULLS LAST, COALESCE(p.old_valid_from, p.new_valid_from), (p.row_ids[1]) )::BIGINT as plan_op_seq,                         p.*                     FROM plan p                 ),                 -- For MOVE operations, group into the largest possible batches that can execute together.                 -- Within a single UPDATE statement, all rows see the pre-update state (MVCC snapshot).                 -- So if MOVE A's new_range overlaps MOVE B's old_range, they cannot be in the same statement.                 --                 -- Algorithm: Process MOVEs in plan_op_seq order (which is old_valid_from DESC).                 -- Track a multirange of old_ranges in the current batch. For each MOVE:                 -- - If new_range overlaps the batch's multirange, start a new batch                 -- - Add this MOVE's old_range to the batch's multirange                 --                 -- We use a recursive CTE to accumulate the multirange with reset-on-conflict logic.                 moves_ordered AS (                     SELECT                         o.plan_op_seq,                         o.grouping_key,                         o.old_valid_from,                         o.old_valid_until,                         o.new_valid_from,                         o.new_valid_until,                         row_number() OVER (PARTITION BY o.grouping_key ORDER BY o.plan_op_seq) AS move_seq                     FROM ordered_plan o                     WHERE o.operation = 'UPDATE' AND o.update_effect = 'MOVE'                 ),                 moves_with_batch AS (                     -- Base case: first MOVE in each entity starts b"
a79,Process Legal Units - Batch 2,,7828285074499428853,1,38.544250000000005,10000,4703,0,0,0,0,0,0,"WITH             all_source_rows AS (                 SELECT t.row_id AS source_row_id FROM source_view_lu t             ),             plan_unnested AS (                 SELECT unnest(p.row_ids) as source_row_id, p.plan_op_seq, p.entity_keys, p.operation, p.data, p.feedback                 FROM temporal_merge_plan p             ),             feedback_groups AS (                 SELECT                     asr.source_row_id,                     -- Aggregate all distinct operations for this source row.                     array_agg(DISTINCT pu.operation) FILTER (WHERE pu.operation IS NOT NULL) as operations,                     -- Aggregate all distinct entity IDs this source row touched.                     COALESCE(jsonb_agg(DISTINCT pu.entity_keys) FILTER (WHERE pu.entity_keys IS NOT NULL), '[]'::jsonb) AS target_entity_keys,                     -- Extract the specific error message from the plan's feedback payload if present.                     (array_agg(pu.feedback->>'error') FILTER (WHERE pu.operation = 'ERROR' AND pu.feedback ? 'error'))[1] as error_message_from_plan                 FROM all_source_rows asr                 LEFT JOIN plan_unnested pu ON asr.source_row_id = pu.source_row_id                 GROUP BY asr.source_row_id             )             INSERT INTO temporal_merge_feedback                 SELECT                     fg.source_row_id,                     fg.target_entity_keys,                     CASE                         -- This CASE statement must be ordered from most to least specific to correctly classify outcomes.                         -- This CASE statement directly translates the plan's actions into a final feedback status.                         -- It is ordered from most to least specific to ensure correctness.                         WHEN 'ERROR'::sql_saga.temporal_merge_plan_action = ANY(fg.operations) THEN 'ERROR'                         WHEN 'INSERT'::sql_saga.temporal_merge_plan_action = ANY(fg.operations)                           OR 'UPDATE'::sql_saga.temporal_merge_"
a6d,Process Legal Units - Batch 2,,-6189425232530816533,1,35.526375,10000,1708,0,0,0,0,102,11171,"CREATE TEMP TABLE target_rows ON COMMIT DROP AS                 SELECT                     id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ -- (non-temporal identity columns)                     lower(t.valid_range) as valid_from, -- The temporal identity column (e.g., valid_from)                     NULL::integer /* v_causal_column_type */ as causal_id, -- Target rows do not originate from a source row, so causal_id is NULL. Type is introspected.                     jsonb_build_object('id', id) /* v_stable_pk_cols_jsonb_build_bare */ as stable_pk_payload,                     upper(t.valid_range) as valid_until,                     jsonb_build_object('name', name) /* v_target_data_cols_jsonb_build_bare */ AS data_payload,                     jsonb_build_object('comment', comment) /* v_target_ephemeral_cols_jsonb_build_bare */ AS ephemeral_payload,                     jsonb_strip_nulls(jsonb_build_object()) /* v_target_nk_json_expr */ AS canonical_nk_json                 FROM (                         SELECT * FROM (                             SELECT DISTINCT ON (u.id, u.valid_from) * FROM (                                 (                                     SELECT * FROM etl_bench.legal_unit inner_t                                     WHERE (inner_t.id) IN (SELECT DISTINCT si.id FROM source_initial si WHERE (si.id) IS NOT NULL)                                 )                             ) u                         )                     ) AS t  /* v_target_rows_filter */"
aab,Process Legal Units - Batch 2,,-4193415169867768194,1,34.740916,10000,365,0,0,0,0,102,11171,"CREATE TEMP TABLE target_rows ON COMMIT DROP AS                 SELECT                     id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ -- (non-temporal identity columns)                     lower(t.valid_range) as valid_from, -- The temporal identity column (e.g., valid_from)                     NULL::integer /* v_causal_column_type */ as causal_id, -- Target rows do not originate from a source row, so causal_id is NULL. Type is introspected.                     jsonb_build_object('id', id) /* v_stable_pk_cols_jsonb_build_bare */ as stable_pk_payload,                     upper(t.valid_range) as valid_until,                     jsonb_build_object('name', name) /* v_target_data_cols_jsonb_build_bare */ AS data_payload,                     jsonb_build_object('comment', comment) /* v_target_ephemeral_cols_jsonb_build_bare */ AS ephemeral_payload,                     jsonb_strip_nulls(jsonb_build_object()) /* v_target_nk_json_expr */ AS canonical_nk_json                 FROM (                         SELECT * FROM (                             SELECT DISTINCT ON (u.id, u.valid_from) * FROM (                                 (                                     SELECT * FROM etl_bench.legal_unit inner_t                                     WHERE (inner_t.id) IN (SELECT DISTINCT si.id FROM source_initial si WHERE (si.id) IS NOT NULL)                                 )                             ) u                         )                     ) AS t  /* v_target_rows_filter */"
cf2,Process Legal Units - Batch 2,,-4175887684797196426,1,32.92175,0,1447,0,0,0,0,16,1855,CREATE INDEX ON source_initial (source_row_id)
8aa,Process Legal Units - Batch 2,,0,1,32.1045,0,7003,0,0,0,0,1605,86670,CALL sql_saga.temporal_merge_drop_temp_tables()
6c9,Process Legal Units - Batch 2,,1690235038614940568,1,29.007958,10000,1674,0,0,0,0,137,15339,"CREATE TEMP TABLE diff ON COMMIT DROP AS                 SELECT                     final_seg.grouping_key, COALESCE(final_seg.id, target_seg.id) as id, COALESCE(final_seg.causal_id, target_seg.causal_id) as causal_id,                     COALESCE(final_seg.is_new_entity, false) as is_new_entity,                     COALESCE(final_seg.is_identifiable, true) as is_identifiable,                     COALESCE(final_seg.is_ambiguous, false) as is_ambiguous,                     final_seg.conflicting_ids,                     final_seg.canonical_nk_json,                     COALESCE(final_seg.stable_identity_columns_are_null, false) as stable_identity_columns_are_null,                     COALESCE(final_seg.lookup_columns_unavailable, false) as lookup_columns_unavailable,                     final_seg.valid_from AS f_from, final_seg.valid_until AS f_until, final_seg.final_payload AS f_payload, final_seg.row_ids AS f_row_ids, final_seg.stable_pk_payload, final_seg.orig_source_target_relation,                     CASE WHEN 'f'::boolean                         THEN final_seg.trace || jsonb_build_object('cte', 'diff', 'diff_stable_pk', final_seg.stable_pk_payload, 'final_seg_causal_id', final_seg.causal_id, 'final_payload_vs_target_payload', jsonb_build_object('f', final_seg.final_payload, 't', target_seg.data_payload))                         ELSE NULL                     END as trace,                     final_seg.unaffected_target_only_segment,                     target_seg.valid_from as t_from, target_seg.valid_until as t_until, (target_seg.data_payload || target_seg.ephemeral_payload) as t_payload,                     sql_saga.get_allen_relation(target_seg.valid_from, target_seg.valid_until, final_seg.valid_from, final_seg.valid_until) as b_a_relation                 FROM coalesced_final_segments AS final_seg                 FULL OUTER JOIN target_rows AS target_seg ON final_seg.grouping_key = ('existing_entity__' || COALESCE(target_seg.id::text, '_NULL_')) AND final_seg.ancestor_valid_from = target_seg.valid_from"
960,Process Legal Units - Batch 2,,-5024370260775748889,1,28.365958,10000,1644,0,0,0,0,116,13061,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT * FROM (                     -- Path 1: Existing Entities (Window Function on Lookup Keys)                     SELECT                         s1.*,                         COALESCE(                             range_agg(valid_range) OVER (                                 PARTITION BY id                                 ORDER BY source_row_id DESC                                 ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                             ) @> valid_range,                             false                         ) as is_eclipsed,                         array_agg(source_row_id) OVER (                             PARTITION BY id                             ORDER BY source_row_id DESC                             ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                         ) as eclipsed_by                     FROM source_initial s1                     WHERE NOT s1.lookup_columns_unavailable                      UNION ALL                      -- Path 2: New Entities (Window Function on Causal ID)                     SELECT                         s1.*,                         COALESCE(                             range_agg(valid_range) OVER (                                 PARTITION BY causal_id                                 ORDER BY source_row_id DESC                                 ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                             ) @> valid_range,                             false                         ) as is_eclipsed,                         array_agg(source_row_id) OVER (                             PARTITION BY causal_id                             ORDER BY source_row_id DESC                             ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                         ) as eclipsed_by                     FROM source_initial s1                     WHERE s1.lookup_columns_unavailable                 ) t"
e8c,Process Legal Units - Batch 2,,6223146894373634837,1,28.162333,10000,289,0,0,0,0,137,15339,"CREATE TEMP TABLE diff ON COMMIT DROP AS                 SELECT                     final_seg.grouping_key, COALESCE(final_seg.id, target_seg.id) as id, COALESCE(final_seg.causal_id, target_seg.causal_id) as causal_id,                     COALESCE(final_seg.is_new_entity, false) as is_new_entity,                     COALESCE(final_seg.is_identifiable, true) as is_identifiable,                     COALESCE(final_seg.is_ambiguous, false) as is_ambiguous,                     final_seg.conflicting_ids,                     final_seg.canonical_nk_json,                     COALESCE(final_seg.stable_identity_columns_are_null, false) as stable_identity_columns_are_null,                     COALESCE(final_seg.lookup_columns_unavailable, false) as lookup_columns_unavailable,                     final_seg.valid_from AS f_from, final_seg.valid_until AS f_until, final_seg.final_payload AS f_payload, final_seg.row_ids AS f_row_ids, final_seg.stable_pk_payload, final_seg.orig_source_target_relation,                     CASE WHEN 'f'::boolean                         THEN final_seg.trace || jsonb_build_object('cte', 'diff', 'diff_stable_pk', final_seg.stable_pk_payload, 'final_seg_causal_id', final_seg.causal_id, 'final_payload_vs_target_payload', jsonb_build_object('f', final_seg.final_payload, 't', target_seg.data_payload))                         ELSE NULL                     END as trace,                     final_seg.unaffected_target_only_segment,                     target_seg.valid_from as t_from, target_seg.valid_until as t_until, (target_seg.data_payload || target_seg.ephemeral_payload) as t_payload,                     sql_saga.get_allen_relation(target_seg.valid_from, target_seg.valid_until, final_seg.valid_from, final_seg.valid_until) as b_a_relation                 FROM coalesced_final_segments AS final_seg                 FULL OUTER JOIN target_rows AS target_seg ON final_seg.grouping_key = ('existing_entity__' || COALESCE(target_seg.id::text, '_NULL_')) AND final_seg.ancestor_valid_from = target_seg.valid_from"
0cb,Process Legal Units - Batch 2,,3167307580342175303,1,24.938166000000002,10000,260,0,0,0,0,116,13061,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT * FROM (                     -- Path 1: Existing Entities (Window Function on Lookup Keys)                     SELECT                         s1.*,                         COALESCE(                             range_agg(valid_range) OVER (                                 PARTITION BY id                                 ORDER BY source_row_id DESC                                 ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                             ) @> valid_range,                             false                         ) as is_eclipsed,                         array_agg(source_row_id) OVER (                             PARTITION BY id                             ORDER BY source_row_id DESC                             ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                         ) as eclipsed_by                     FROM source_initial s1                     WHERE NOT s1.lookup_columns_unavailable                      UNION ALL                      -- Path 2: New Entities (Window Function on Causal ID)                     SELECT                         s1.*,                         COALESCE(                             range_agg(valid_range) OVER (                                 PARTITION BY causal_id                                 ORDER BY source_row_id DESC                                 ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                             ) @> valid_range,                             false                         ) as is_eclipsed,                         array_agg(source_row_id) OVER (                             PARTITION BY causal_id                             ORDER BY source_row_id DESC                             ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                         ) as eclipsed_by                     FROM source_initial s1                     WHERE s1.lookup_columns_unavailable                 ) t;"
38d,Process Legal Units - Batch 2,,-3276528771796910273,1,23.857333,20000,1769,0,0,0,0,139,16073,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     seg.*,                     seg.stable_pk_payload as propagated_stable_pk_payload                 FROM all_segments seg                 WHERE (seg.s_data_payload IS NOT NULL OR seg.t_data_payload IS NOT NULL)                 AND CASE 'MERGE_ENTITY_PATCH'::sql_saga.temporal_merge_mode                     WHEN 'PATCH_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'REPLACE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'DELETE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'UPDATE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     ELSE true                 END"
51c,Process Legal Units - Batch 2,,6779487562696088383,1,23.093,20000,1633,0,0,0,0,113,12571,"CREATE TEMP TABLE atomic_segments ON COMMIT DROP AS                 SELECT grouping_key, id, causal_id, point as valid_from, next_point as valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json                 FROM (                     SELECT *, LEAD(point) OVER (PARTITION BY grouping_key ORDER BY point) as next_point                     FROM time_points                 ) with_lead                 WHERE point IS NOT NULL AND next_point IS NOT NULL AND point < next_point"
aac,Process Legal Units - Batch 2,,5739678101431501439,1,22.950709,20000,288,0,0,0,0,139,16073,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     seg.*,                     seg.stable_pk_payload as propagated_stable_pk_payload                 FROM all_segments seg                 WHERE (seg.s_data_payload IS NOT NULL OR seg.t_data_payload IS NOT NULL)                 AND CASE 'MERGE_ENTITY_PATCH'::sql_saga.temporal_merge_mode                     WHEN 'PATCH_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'REPLACE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'DELETE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'UPDATE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     ELSE true                 END"
ba7,Process Legal Units - Batch 2,,-7375841108639655790,1,22.409792000000003,20000,264,0,0,0,0,113,12571,"CREATE TEMP TABLE atomic_segments ON COMMIT DROP AS                 SELECT grouping_key, id, causal_id, point as valid_from, next_point as valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json                 FROM (                     SELECT *, LEAD(point) OVER (PARTITION BY grouping_key ORDER BY point) as next_point                     FROM time_points                 ) with_lead                 WHERE point IS NOT NULL AND next_point IS NOT NULL AND point < next_point"
5ad,Process Legal Units - Batch 2,,5849653773365333279,1,21.834,10000,1651,0,0,0,0,120,13601,"CREATE TEMP TABLE source_rows_with_matches ON COMMIT DROP AS                 SELECT                     source_row.*,                     target_row.stable_pk_payload as discovered_stable_pk_payload,                     target_row.id AS discovered_id_1 /* v_propagated_id_cols_list */                 FROM source_with_eclipsed_flag source_row                 LEFT JOIN target_rows target_row ON (source_row.id = target_row.id /* v_source_rows_exists_join_expr */)"
81f,Process Legal Units - Batch 2,,-2522301903109079185,1,21.75175,40000,1634,0,0,0,0,112,12589,"CREATE TEMP TABLE time_points_with_unified_ids ON COMMIT DROP AS                 SELECT                     tpu.grouping_key,                     tpu.id,                     tpu.unified_causal_id as causal_id,                     tpu.point,                     tpu.is_new_entity,                     tpu.unified_stable_pk_payload as stable_pk_payload,                     tpu.stable_identity_columns_are_null,                     tpu.lookup_columns_unavailable,                     tpu.is_identifiable,                     tpu.is_ambiguous,                     tpu.conflicting_ids,                     tpu.unified_canonical_nk_json as canonical_nk_json                 FROM time_points_unified tpu"
c5a,Process Legal Units - Batch 2,,1995507501247956172,1,21.075416999999998,10000,264,0,0,0,0,120,13601,"CREATE TEMP TABLE source_rows_with_matches ON COMMIT DROP AS                 SELECT                     source_row.*,                     target_row.stable_pk_payload as discovered_stable_pk_payload,                     target_row.id AS discovered_id_1 /* v_propagated_id_cols_list */                 FROM source_with_eclipsed_flag source_row                 LEFT JOIN target_rows target_row ON (source_row.id = target_row.id /* v_source_rows_exists_join_expr */)"
941,Process Legal Units - Batch 2,,-2381107599654639950,1,20.922583000000003,40000,259,0,0,0,0,112,12589,"CREATE TEMP TABLE time_points_with_unified_ids ON COMMIT DROP AS                 SELECT                     tpu.grouping_key,                     tpu.id,                     tpu.unified_causal_id as causal_id,                     tpu.point,                     tpu.is_new_entity,                     tpu.unified_stable_pk_payload as stable_pk_payload,                     tpu.stable_identity_columns_are_null,                     tpu.lookup_columns_unavailable,                     tpu.is_identifiable,                     tpu.is_ambiguous,                     tpu.conflicting_ids,                     tpu.unified_canonical_nk_json as canonical_nk_json                 FROM time_points_unified tpu"
3ac,Process Legal Units - Batch 2,,5147944785677299242,1,20.408875,10000,1682,1,0,0,0,142,19402,"CREATE TEMP TABLE diff_ranked ON COMMIT DROP AS                 SELECT                     d.*,                     CASE                         WHEN d.t_from IS NULL OR d.f_from IS NULL THEN NULL                         WHEN d.f_from = d.t_from AND d.f_until = d.t_until AND d.f_payload IS NOT DISTINCT FROM d.t_payload THEN NULL                         ELSE                             row_number() OVER (                                 PARTITION BY d.grouping_key, d.t_from                                 ORDER BY                                     CASE WHEN d.f_from = d.t_from THEN 1 ELSE 2 END,                                     CASE WHEN d.f_payload - '{comment}'::text[] IS NOT DISTINCT FROM d.t_payload - '{comment}'::text[] THEN 1 ELSE 2 END,                                     d.f_from,                                     d.f_until                             )                     END as update_rank                 FROM diff d"
79d,Process Legal Units - Batch 2,,-6278565976310229931,1,20.031166,10000,1683,0,0,0,0,132,14520,"CREATE TEMP TABLE plan_with_op ON COMMIT DROP AS                 (                     SELECT * FROM (                         SELECT                             d.f_row_ids as row_ids, d.orig_source_target_relation, d.is_new_entity,                             CASE                                 WHEN d.is_ambiguous THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.is_new_entity AND NOT d.is_identifiable THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.t_from IS NULL THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.f_from IS NULL THEN 'DELETE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank = 1 THEN 'UPDATE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank > 1 THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank IS NULL THEN                                     CASE                                         WHEN d.unaffected_target_only_segment THEN NULL                                         ELSE 'SKIP_IDENTICAL'::sql_saga.temporal_merge_plan_action                                     END                                 ELSE 'ERROR'::sql_saga.temporal_merge_plan_action                             END as operation,                             id,                             CASE                                 WHEN d.is_new_entity AND d.canonical_nk_json IS NOT NULL                                 THEN d.canonical_nk_json || COALESCE(d.stable_pk_payload, '{}'::jsonb)                                 ELSE jsonb_build_object('id', d.id) || COALESCE(d.stable_pk_payload, '{}'::jsonb)                             END as entity_keys_json,                             jsonb_build_object('id', d.id) as identity_keys,                             jsonb_build_object() as lookup_keys,                             d.causal_id, d.t_from as old_valid_from, d.t_until as old_valid_until, d.f"
efe,Process Legal Units - Batch 2,,6259880232974284115,1,19.632792,10000,293,1,0,0,0,142,19402,"CREATE TEMP TABLE diff_ranked ON COMMIT DROP AS                 SELECT                     d.*,                     CASE                         WHEN d.t_from IS NULL OR d.f_from IS NULL THEN NULL                         WHEN d.f_from = d.t_from AND d.f_until = d.t_until AND d.f_payload IS NOT DISTINCT FROM d.t_payload THEN NULL                         ELSE                             row_number() OVER (                                 PARTITION BY d.grouping_key, d.t_from                                 ORDER BY                                     CASE WHEN d.f_from = d.t_from THEN 1 ELSE 2 END,                                     CASE WHEN d.f_payload - '{comment}'::text[] IS NOT DISTINCT FROM d.t_payload - '{comment}'::text[] THEN 1 ELSE 2 END,                                     d.f_from,                                     d.f_until                             )                     END as update_rank                 FROM diff d"
db5,Process Legal Units - Batch 2,,8461913458038132941,1,19.081750000000003,10000,290,0,0,0,0,132,14520,"CREATE TEMP TABLE plan_with_op ON COMMIT DROP AS                 (                     SELECT * FROM (                         SELECT                             d.f_row_ids as row_ids, d.orig_source_target_relation, d.is_new_entity,                             CASE                                 WHEN d.is_ambiguous THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.is_new_entity AND NOT d.is_identifiable THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.t_from IS NULL THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.f_from IS NULL THEN 'DELETE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank = 1 THEN 'UPDATE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank > 1 THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank IS NULL THEN                                     CASE                                         WHEN d.unaffected_target_only_segment THEN NULL                                         ELSE 'SKIP_IDENTICAL'::sql_saga.temporal_merge_plan_action                                     END                                 ELSE 'ERROR'::sql_saga.temporal_merge_plan_action                             END as operation,                             id,                             CASE                                 WHEN d.is_new_entity AND d.canonical_nk_json IS NOT NULL                                 THEN d.canonical_nk_json || COALESCE(d.stable_pk_payload, '{}'::jsonb)                                 ELSE jsonb_build_object('id', d.id) || COALESCE(d.stable_pk_payload, '{}'::jsonb)                             END as entity_keys_json,                             jsonb_build_object('id', d.id) as identity_keys,                             jsonb_build_object() as lookup_keys,                             d.causal_id, d.t_from as old_valid_from, d.t_until as old_valid_until, d.f"
eb6,Process Legal Units - Batch 2,,725758841111022991,150,18.669041999999997,150,59146,0,0,0,0,0,0,"EXISTS (         SELECT 1 FROM pg_event_trigger_ddl_commands() ddl         JOIN pg_class c ON c.oid = ddl.objid         JOIN pg_namespace n ON n.oid = c.relnamespace         WHERE EXISTS (SELECT 1 FROM sql_saga.era e WHERE (e.table_schema, e.table_name) = (n.nspname, c.relname))            OR EXISTS (SELECT 1 FROM sql_saga.updatable_view v JOIN pg_class vc ON vc.relname = v.view_name JOIN pg_namespace vn ON vn.oid = vc.relnamespace AND vn.nspname = v.view_schema WHERE vc.oid = c.oid)            -- Also check system_versioning objects (history table, view)            OR EXISTS (SELECT 1 FROM sql_saga.system_versioning sv WHERE (sv.history_schema_name, sv.history_table_name) = (n.nspname, c.relname))            OR EXISTS (SELECT 1 FROM sql_saga.system_versioning sv WHERE (sv.view_schema_name, sv.view_table_name) = (n.nspname, c.relname))     )"
894,Process Legal Units - Batch 2,,7110079446970253207,1,17.415375,10000,1678,0,0,0,0,136,14929,"CREATE TEMP TABLE plan ON COMMIT DROP AS                 SELECT                     p.row_ids, p.operation, p.causal_id, p.is_new_entity,                     p.id,                     p.entity_keys_json as entity_keys,                     p.identity_keys, p.lookup_keys,                     p.orig_source_target_relation, p.b_a_relation, p.old_valid_from, p.old_valid_until,                     p.new_valid_from, p.new_valid_until, p.data, p.feedback, p.trace,                     p.grouping_key,                     CASE                         WHEN p.operation <> 'UPDATE' THEN NULL::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from = p.old_valid_from AND p.new_valid_until = p.old_valid_until THEN 'NONE'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from <= p.old_valid_from AND p.new_valid_until >= p.old_valid_until THEN 'GROW'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from >= p.old_valid_from AND p.new_valid_until <= p.old_valid_until THEN 'SHRINK'::sql_saga.temporal_merge_update_effect                         ELSE 'MOVE'::sql_saga.temporal_merge_update_effect                     END AS update_effect                 FROM plan_with_op p                 LEFT JOIN source_rows_with_new_flag source_row ON source_row.source_row_id = p.row_ids[1]"
9ec,Process Legal Units - Batch 2,,7371826089573494947,1,16.64725,10000,293,0,0,0,0,136,14929,"CREATE TEMP TABLE plan ON COMMIT DROP AS                 SELECT                     p.row_ids, p.operation, p.causal_id, p.is_new_entity,                     p.id,                     p.entity_keys_json as entity_keys,                     p.identity_keys, p.lookup_keys,                     p.orig_source_target_relation, p.b_a_relation, p.old_valid_from, p.old_valid_until,                     p.new_valid_from, p.new_valid_until, p.data, p.feedback, p.trace,                     p.grouping_key,                     CASE                         WHEN p.operation <> 'UPDATE' THEN NULL::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from = p.old_valid_from AND p.new_valid_until = p.old_valid_until THEN 'NONE'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from <= p.old_valid_from AND p.new_valid_until >= p.old_valid_until THEN 'GROW'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from >= p.old_valid_from AND p.new_valid_until <= p.old_valid_until THEN 'SHRINK'::sql_saga.temporal_merge_update_effect                         ELSE 'MOVE'::sql_saga.temporal_merge_update_effect                     END AS update_effect                 FROM plan_with_op p                 LEFT JOIN source_rows_with_new_flag source_row ON source_row.source_row_id = p.row_ids[1]"
848,Process Legal Units - Batch 2,,2613701250391606255,1,13.354583,10000,1630,0,0,0,0,127,14429,"CREATE TEMP TABLE source_rows_with_discovery ON COMMIT DROP AS                 SELECT                     m.*,                     a.match_count,                     a.conflicting_ids,                     (a.match_count > 1) as is_ambiguous                 FROM source_rows_with_matches m                 JOIN source_rows_with_aggregates a ON m.source_row_id = a.source_row_id"
b94,Process Legal Units - Batch 2,,-957741634502868070,1,12.911625,10000,1648,0,0,0,0,126,14387,"CREATE TEMP TABLE source_rows_with_nk_json ON COMMIT DROP AS                 SELECT source_row.*, jsonb_strip_nulls(jsonb_build_object()) /* v_lookup_keys_as_jsonb_expr */ as nk_json, ARRAY(SELECT e FROM unnest(ARRAY[]::TEXT[]) e WHERE e IS NOT NULL ORDER BY e) /* v_lookup_keys_as_array_expr */ as nk_non_null_keys_array                 FROM source_rows_with_new_flag source_row"
c51,Process Legal Units - Batch 2,,8473430400440557908,1,12.664209,10000,276,0,0,0,0,127,14429,"CREATE TEMP TABLE source_rows_with_discovery ON COMMIT DROP AS                 SELECT                     m.*,                     a.match_count,                     a.conflicting_ids,                     (a.match_count > 1) as is_ambiguous                 FROM source_rows_with_matches m                 JOIN source_rows_with_aggregates a ON m.source_row_id = a.source_row_id"
4e4,Process Legal Units - Batch 2,,7625827313856663095,1,11.983958,10000,267,0,0,0,0,126,14387,"CREATE TEMP TABLE source_rows_with_nk_json ON COMMIT DROP AS                 SELECT source_row.*, jsonb_strip_nulls(jsonb_build_object()) /* v_lookup_keys_as_jsonb_expr */ as nk_json, ARRAY(SELECT e FROM unnest(ARRAY[]::TEXT[]) e WHERE e IS NOT NULL ORDER BY e) /* v_lookup_keys_as_array_expr */ as nk_non_null_keys_array                 FROM source_rows_with_new_flag source_row"
b66,Process Legal Units - Batch 2,,-3169870935594387745,1,11.649666,0,5216,0,0,0,0,0,0,UPDATE etl_bench.data_table dt     SET legal_unit_id = ir.legal_unit_id     FROM etl_bench.identity_resolution ir     WHERE dt.identity_correlation = ir.identity_correlation       AND dt.legal_unit_id IS NULL
81f,Process Legal Units - Batch 2,,8689595743856886431,1,10.693208,0,1440,0,0,0,0,15,1597,CREATE INDEX ON active_source_rows (grouping_key)
8d2,Process Legal Units - Batch 2,,5494611821061557908,1,10.158292,20000,1657,0,0,0,0,112,13142,"CREATE TEMP TABLE all_rows ON COMMIT DROP AS                 SELECT id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ causal_id, valid_from, valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM active_source_rows                 UNION ALL                 SELECT                     target_row.id,  /* v_non_temporal_tr_qualified_lookup_cols_prefix */                     target_row.causal_id,                     target_row.valid_from,                     target_row.valid_until,                     false as is_new_entity,                     target_row.stable_pk_payload,                     false as stable_identity_columns_are_null,                     false as lookup_columns_unavailable,                     true as is_identifiable,                     false as is_ambiguous,                     NULL::jsonb as conflicting_ids,                     target_row.canonical_nk_json                 FROM target_rows target_row"
b46,Process Legal Units - Batch 2,,-1318097777820228,1,10.117708,10000,1657,0,0,0,0,122,14380,"CREATE TEMP TABLE source_rows ON COMMIT DROP AS                 SELECT DISTINCT ON (p.source_row_id)                     p.source_row_id, p.causal_id, p.valid_from, p.valid_until, p.data_payload, p.ephemeral_payload,                     (p.stable_identity_columns_are_null AND p.discovered_stable_pk_payload IS NULL) as stable_identity_columns_are_null,                     p.lookup_columns_unavailable, p.is_identifiable,                     p.is_ambiguous, p.conflicting_ids, p.is_eclipsed, p.eclipsed_by,                     p.temporal_columns_are_consistent,                     COALESCE(p.stable_pk_payload, p.discovered_stable_pk_payload) as stable_pk_payload,                     (p.discovered_stable_pk_payload IS NOT NULL) /* v_target_entity_exists_expr */ as target_entity_exists,                     COALESCE(p.id, p.discovered_id_1) AS id /* v_coalesced_id_cols_list */                 FROM source_rows_with_discovery p                 ORDER BY p.source_row_id, p.discovered_stable_pk_payload"
5d4,Process Legal Units - Batch 2,,4895990506256861755,10000,8.794752000000134,10000,0,0,0,0,0,0,0,SELECT array_agg(DISTINCT v)                    FROM unnest(from_sources) AS v
372,Process Legal Units - Batch 2,,7743831913079285872,10000,7.197918000000112,10000,0,0,0,0,0,0,0,SELECT array_agg(DISTINCT v)                     FROM unnest(until_sources) AS v
0a9,Process Legal Units - Batch 2,,1464568031695687146,150,0.752084,150,49,0,0,0,0,0,0,SELECT array_agg(command_tag)           FROM pg_event_trigger_ddl_commands()
978,Process Legal Units - Batch 2,,-8708312726399770535,155,0.4902329999999995,155,0,0,0,0,0,0,0,"EXISTS (             SELECT 1 FROM pg_event_trigger_dropped_objects() dobj             WHERE dobj.object_type = 'table'               AND (dobj.schema_name, dobj.object_name) = (r.table_schema, r.table_name)         )"
95f,Process Legal Units - Batch 2,,-1465262961312880621,155,0.2954589999999996,155,465,0,0,0,0,0,0,"NOT EXISTS (                 SELECT FROM pg_catalog.pg_constraint AS c                 WHERE (c.conrelid, c.conname) = (r.table_oid, r.unique_constraint)             )"
51b,Process Legal Units - Batch 2,,8008625629997484951,150,0.2494559999999997,0,0,0,0,0,0,0,0,SELECT * FROM pg_event_trigger_ddl_commands()
0c9,Process Legal Units - Batch 2,,-8889318315713072803,155,0.03589300000000003,155,0,0,0,0,0,0,0,"r.exclude_constraint IS NOT NULL AND NOT EXISTS (             SELECT FROM pg_catalog.pg_constraint AS c             WHERE (c.conrelid, c.conname) = (r.table_oid, r.exclude_constraint)         )"
5bd,Process Legal Units - Batch 3,,-4212605005101232050,1,2678.5205,0,617385,50,3066,3071,0,187336,17823481,CALL etl_bench.process_legal_units(v_batch_id)
467,Process Legal Units - Batch 3,,2508743807545342814,1,2599.719667,0,494981,50,3066,3071,0,146997,15097722,"CALL sql_saga.temporal_merge(         target_table => 'etl_bench.legal_unit',         source_table => 'source_view_lu',         primary_identity_columns => ARRAY['id'],         ephemeral_columns => ARRAY['comment'],         mode => 'MERGE_ENTITY_PATCH',         founding_id_column => 'founding_id',         update_source_with_identity => true,         update_source_with_feedback => true,         feedback_status_column => 'merge_statuses',         feedback_status_key => 'legal_unit',         feedback_error_column => 'merge_errors',         feedback_error_key => 'legal_unit'     )"
78c,Process Legal Units - Batch 3,,-4094074925611420334,1,1823.298624,10000,79437,47,3066,3071,0,5766,646777,"INSERT INTO temporal_merge_plan     SELECT * FROM sql_saga.temporal_merge_plan(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         identity_columns => v_identity_cols_discovered,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         delete_mode => temporal_merge.delete_mode,         lookup_keys => v_natural_identity_keys_discovered,         ephemeral_columns => temporal_merge.ephemeral_columns,         p_log_trace => v_log_trace,         p_log_sql => v_log_sql     )"
88c,Process Legal Units - Batch 3,,9062296240809330110,1,773.498,0,413319,2,0,0,0,140963,14426571,"CALL sql_saga.temporal_merge_execute(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         identity_columns => v_identity_cols_discovered,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         update_source_with_identity => temporal_merge.update_source_with_identity,         lookup_columns => v_natural_identity_cols_discovered,         delete_mode => temporal_merge.delete_mode,         update_source_with_feedback => temporal_merge.update_source_with_feedback,         feedback_status_column => temporal_merge.feedback_status_column,         feedback_status_key => temporal_merge.feedback_status_key,         feedback_error_column => temporal_merge.feedback_error_column,         feedback_error_key => temporal_merge.feedback_error_key,         ephemeral_columns => temporal_merge.ephemeral_columns,         delay_constraints => temporal_merge.delay_constraints     )"
83f,Process Legal Units - Batch 3,,-5023945640903832763,1,510.742167,10000,240677,0,0,0,0,80578,8201662,"UPDATE etl_bench.legal_unit t SET valid_range = p.new_valid_range::daterange, name = CASE WHEN p.data ? 'name' THEN (p.data->>'name')::text ELSE t.name END, comment = CASE WHEN p.data ? 'comment' THEN (p.data->>'comment')::text ELSE t.comment END                                 FROM (SELECT *, (entity_keys->>'id')::integer AS id_ek FROM temporal_merge_plan WHERE operation = 'UPDATE' AND statement_seq = 1 ORDER BY plan_op_seq) p                                 WHERE t.id = p.id_ek AND t.valid_range = p.old_valid_range::daterange"
353,Process Legal Units - Batch 3,,-8259425963603516266,1,214.275708,0,275,3,0,0,0,57,25581,ANALYZE resolved_atomic_segments_with_payloads
130,Process Legal Units - Batch 3,,-5685077514497051452,1,191.273833,0,277,3,0,0,0,58,25004,ANALYZE existing_segments_with_target
3eb,Process Legal Units - Batch 3,,-6251707813684716315,1,143.585083,10000,165437,0,0,0,0,60199,6196784,"UPDATE source_view_lu s             SET merge_statuses = COALESCE(s.merge_statuses, '{}'::jsonb) || jsonb_build_object('legal_unit', f.status), merge_errors = CASE WHEN f.error_message IS NOT NULL THEN COALESCE(s.merge_errors, '{}'::jsonb) || jsonb_build_object('legal_unit', f.error_message) ELSE COALESCE(s.merge_errors, '{}'::jsonb) - 'legal_unit' END             FROM pg_temp.temporal_merge_feedback f             WHERE s.row_id = f.source_row_id"
e29,Process Legal Units - Batch 3,,2265156188269693366,1,134.0375,20000,1738,2,747,748,0,153,18624,"CREATE TEMP TABLE resolved_atomic_segments_with_propagated_ids ON COMMIT DROP AS                 SELECT                     *,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY grouping_key ORDER BY valid_from) as unified_canonical_nk_json,                     COALESCE(                         contributing_row_ids,                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as causal_source_row_ids,                     COALESCE(                         s_valid_from,                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_from,                     COALESCE(                         s_valid_until,                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_until                 FROM (                     SELECT                         *,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from) AS look_behind_grp,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from DESC) AS look_ahead_grp                     FROM resolved_atomic_segments_with_payloads /* v_resolver_from */                 ) with_grp"
0d7,Process Legal Units - Batch 3,,-4229863592495449365,1,131.437625,20000,309,2,747,748,0,153,18624,"CREATE TEMP TABLE resolved_atomic_segments_with_propagated_ids ON COMMIT DROP AS                 SELECT                     *,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY grouping_key ORDER BY valid_from) as unified_canonical_nk_json,                     COALESCE(                         contributing_row_ids,                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (array_concat_agg(contributing_row_ids) FILTER (WHERE contributing_row_ids IS NOT NULL) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as causal_source_row_ids,                     COALESCE(                         s_valid_from,                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_from) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_from,                     COALESCE(                         s_valid_until,                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_behind_grp)),                         (max(s_valid_until) OVER (PARTITION BY grouping_key, t_valid_from, look_ahead_grp))                     ) as propagated_s_valid_until                 FROM (                     SELECT                         *,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from) AS look_behind_grp,                         sum(CASE WHEN source_row_id IS NOT NULL THEN 1 ELSE 0 END) OVER (PARTITION BY grouping_key, t_valid_from ORDER BY valid_from DESC) AS look_ahead_grp                     FROM resolved_atomic_segments_with_payloads /* v_resolver_from */                 ) with_grp"
b97,Process Legal Units - Batch 3,,-5479635516521171982,1,126.063334,20000,1710,1,0,0,0,141,16193,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.lookup_columns_unavailable, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     source_payloads.source_row_id, source_payloads.contributing_row_ids,                     source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                     source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON target_row.id = seg.id                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                                          LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))                                 AND daterange(seg.valid_from, seg.valid_until) <@ date"
89b,Process Legal Units - Batch 3,,0,36,125.433289,0,11424,3,0,0,0,2093,142293,CALL sql_saga.benchmark_reset()
933,Process Legal Units - Batch 3,,-6429604085756835998,1,124.885625,20000,302,1,0,0,0,141,16193,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.lookup_columns_unavailable, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     source_payloads.source_row_id, source_payloads.contributing_row_ids,                     source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                     source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON target_row.id = seg.id                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                                          LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))                                 AND daterange(seg.valid_from, seg.valid_until) <@ date"
09b,Process Legal Units - Batch 3,,-8581391324505025071,1,124.162125,10000,1692,1,556,557,0,128,14404,"CREATE TEMP TABLE coalesced_final_segments ON COMMIT DROP AS                 SELECT                     grouping_key, max(id) as id,                     sql_saga.first(causal_id ORDER BY valid_from) as causal_id,                     sql_saga.first(stable_identity_columns_are_null ORDER BY valid_from) as stable_identity_columns_are_null,                     sql_saga.first(lookup_columns_unavailable ORDER BY valid_from) as lookup_columns_unavailable,                     sql_saga.first(is_new_entity ORDER BY valid_from) as is_new_entity,                     sql_saga.first(is_identifiable ORDER BY valid_from) as is_identifiable,                     sql_saga.first(is_ambiguous ORDER BY valid_from) as is_ambiguous,                     sql_saga.first(conflicting_ids ORDER BY valid_from) as conflicting_ids,                     sql_saga.first(unified_canonical_nk_json ORDER BY valid_from) as canonical_nk_json,                     sql_saga.first(orig_source_target_relation ORDER BY valid_from) as orig_source_target_relation,                     sql_saga.first(t_valid_from ORDER BY valid_from) as ancestor_valid_from,                     MIN(valid_from) as valid_from,                     MAX(valid_until) as valid_until,                     (sql_saga.first(data_payload ORDER BY valid_from DESC) || sql_saga.first(ephemeral_payload ORDER BY valid_from DESC)) as final_payload,                     sql_saga.first(stable_pk_payload ORDER BY valid_from DESC) as stable_pk_payload,                     bool_and(unaffected_target_only_segment) as unaffected_target_only_segment,                     (SELECT array_agg(DISTINCT e) FROM unnest(array_concat_agg(causal_source_row_ids)) e WHERE e IS NOT NULL) as row_ids,                     CASE WHEN 'f'::boolean                         THEN jsonb_build_object( 'cte', 'coalesced', 'island_group_id', island_group_id, 'coalesced_stable_pk', sql_saga.first(stable_pk_payload ORDER BY valid_from DESC), 'final_payload', sql_saga.first(data_payload ORDER BY valid_from DESC), 'final_payload_sans_epheme"
c63,Process Legal Units - Batch 3,,8679993553546922744,1,111.501,40000,1645,2,494,495,0,120,14891,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
ebf,Process Legal Units - Batch 3,,2335399437257891460,1,109.807376,40000,277,2,494,495,0,120,14891,"CREATE TEMP TABLE time_points_unified ON COMMIT DROP AS                 SELECT                     *,                     CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END AS grouping_key,                     CASE                         WHEN is_new_entity THEN causal_id                         ELSE FIRST_VALUE(causal_id) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS LAST)                     END as unified_causal_id,                     FIRST_VALUE(stable_pk_payload) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_stable_pk_payload,                     FIRST_VALUE(canonical_nk_json) OVER (PARTITION BY CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END ORDER BY causal_id ASC NULLS FIRST) as unified_canonical_nk_json                 FROM time_points_raw"
0d1,Process Legal Units - Batch 3,,3295832470614201853,1,106.989834,10000,282,1,556,557,0,128,14404,"CREATE TEMP TABLE coalesced_final_segments ON COMMIT DROP AS                 SELECT                     grouping_key, max(id) as id,                     sql_saga.first(causal_id ORDER BY valid_from) as causal_id,                     sql_saga.first(stable_identity_columns_are_null ORDER BY valid_from) as stable_identity_columns_are_null,                     sql_saga.first(lookup_columns_unavailable ORDER BY valid_from) as lookup_columns_unavailable,                     sql_saga.first(is_new_entity ORDER BY valid_from) as is_new_entity,                     sql_saga.first(is_identifiable ORDER BY valid_from) as is_identifiable,                     sql_saga.first(is_ambiguous ORDER BY valid_from) as is_ambiguous,                     sql_saga.first(conflicting_ids ORDER BY valid_from) as conflicting_ids,                     sql_saga.first(unified_canonical_nk_json ORDER BY valid_from) as canonical_nk_json,                     sql_saga.first(orig_source_target_relation ORDER BY valid_from) as orig_source_target_relation,                     sql_saga.first(t_valid_from ORDER BY valid_from) as ancestor_valid_from,                     MIN(valid_from) as valid_from,                     MAX(valid_until) as valid_until,                     (sql_saga.first(data_payload ORDER BY valid_from DESC) || sql_saga.first(ephemeral_payload ORDER BY valid_from DESC)) as final_payload,                     sql_saga.first(stable_pk_payload ORDER BY valid_from DESC) as stable_pk_payload,                     bool_and(unaffected_target_only_segment) as unaffected_target_only_segment,                     (SELECT array_agg(DISTINCT e) FROM unnest(array_concat_agg(causal_source_row_ids)) e WHERE e IS NOT NULL) as row_ids,                     CASE WHEN 'f'::boolean                         THEN jsonb_build_object( 'cte', 'coalesced', 'island_group_id', island_group_id, 'coalesced_stable_pk', sql_saga.first(stable_pk_payload ORDER BY valid_from DESC), 'final_payload', sql_saga.first(data_payload ORDER BY valid_from DESC), 'final_payload_sans_epheme"
1cd,Process Legal Units - Batch 3,,5432145740772416088,1,77.802,0,234,1,0,0,0,48,11420,ANALYZE active_source_rows
002,Process Legal Units - Batch 3,,-518691661278450688,1,67.198834,0,206,1,0,0,0,40,9072,ANALYZE source_rows_with_nk_json
29e,Process Legal Units - Batch 3,,7295163325594009324,1,65.139583,10000,115467,0,0,0,0,40297,2722452,"INSERT INTO etl_bench.identity_resolution (identity_correlation, legal_unit_id, resolved_batch)     SELECT DISTINCT          identity_correlation,         legal_unit_id,         p_batch_id     FROM etl_bench.data_table     WHERE batch = p_batch_id AND legal_unit_id IS NOT NULL     ON CONFLICT (identity_correlation) DO UPDATE SET         legal_unit_id = EXCLUDED.legal_unit_id,         resolved_batch = EXCLUDED.resolved_batch"
0cd,Process Legal Units - Batch 3,,4494928315034638917,1,64.297917,20000,1699,0,771,772,0,152,17682,"CREATE TEMP TABLE island_group ON COMMIT DROP AS                 SELECT                     *,                     SUM(is_island_start) OVER (PARTITION BY grouping_key ORDER BY valid_from) as island_group_id                 FROM (                     SELECT                         *,                         CASE                             WHEN prev_valid_until IS NULL                             OR prev_valid_until <> valid_from                             OR (prev_data_hash IS DISTINCT FROM data_hash)                             THEN 1                             ELSE 0                         END as is_island_start                     FROM (                         SELECT                             *,                             LAG(valid_until) OVER w as prev_valid_until,                             LAG(data_hash) OVER w as prev_data_hash,                             LAG(data_payload) OVER w as prev_data_payload                         FROM resolved_atomic_segments ras                         WHERE ras.data_payload IS NOT NULL                         WINDOW w AS (PARTITION BY grouping_key ORDER BY valid_from)                     ) s1                 ) s2"
5f0,Process Legal Units - Batch 3,,-2675794321567617346,1,59.947542,20000,301,0,771,772,0,152,17682,"CREATE TEMP TABLE island_group ON COMMIT DROP AS                 SELECT                     *,                     SUM(is_island_start) OVER (PARTITION BY grouping_key ORDER BY valid_from) as island_group_id                 FROM (                     SELECT                         *,                         CASE                             WHEN prev_valid_until IS NULL                             OR prev_valid_until <> valid_from                             OR (prev_data_hash IS DISTINCT FROM data_hash)                             THEN 1                             ELSE 0                         END as is_island_start                     FROM (                         SELECT                             *,                             LAG(valid_until) OVER w as prev_valid_until,                             LAG(data_hash) OVER w as prev_data_hash,                             LAG(data_payload) OVER w as prev_data_payload                         FROM resolved_atomic_segments ras                         WHERE ras.data_payload IS NOT NULL                         WINDOW w AS (PARTITION BY grouping_key ORDER BY valid_from)                     ) s1                 ) s2"
281,Process Legal Units - Batch 3,,1525269309137858814,1,58.122334,0,140,1,0,0,0,26,9453,ANALYZE atomic_segments
365,Process Legal Units - Batch 3,,0,1,50.27575,0,7018,0,0,0,0,1614,87156,CALL sql_saga.temporal_merge_drop_temp_tables()
e64,Process Legal Units - Batch 3,,5039860120774769872,1,48.787208,0,144,1,0,0,0,26,7165,ANALYZE source_initial
97c,Process Legal Units - Batch 3,,-1014204856229529622,1,47.959417,20000,1706,1,0,0,0,143,16458,"CREATE TEMP TABLE resolved_atomic_segments ON COMMIT DROP AS                 SELECT                     grouping_key, id,  stable_identity_columns_are_null, lookup_columns_unavailable, is_new_entity, is_identifiable, is_ambiguous, conflicting_ids, unified_canonical_nk_json,                     valid_from, valid_until, t_valid_from, t_valid_until, propagated_s_valid_from, propagated_s_valid_until, causal_source_row_ids, causal_id, propagated_stable_pk_payload as stable_pk_payload,                     causal_source_row_ids IS NULL AS unaffected_target_only_segment,                     s_data_payload, t_data_payload,                     sql_saga.get_allen_relation(propagated_s_valid_from, propagated_s_valid_until, t_valid_from, t_valid_until) AS orig_source_target_relation,                     COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb) as data_payload,                     md5((jsonb_strip_nulls(COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb)))::text) as data_hash,                     CASE                          WHEN s_data_payload IS NULL THEN t_ephemeral_payload                         ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb)                     END as ephemeral_payload,                     CASE WHEN 'f'::boolean                         THEN trace || jsonb_build_object( 'cte', 'ras', 'segment_stable_pk', propagated_stable_pk_payload, 'final_data_payload', COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb), 'final_ephemeral_payload', CASE WHEN s_data_payload IS NULL THEN t_ephemeral_payload ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb) END )                         ELSE NULL                     END as trace                 FROM resolved_atomic_segments_with_propagated_ids"
6d8,Process Legal Units - Batch 3,,227465300178923650,1,47.137083000000004,20000,296,1,0,0,0,143,16458,"CREATE TEMP TABLE resolved_atomic_segments ON COMMIT DROP AS                 SELECT                     grouping_key, id,  stable_identity_columns_are_null, lookup_columns_unavailable, is_new_entity, is_identifiable, is_ambiguous, conflicting_ids, unified_canonical_nk_json,                     valid_from, valid_until, t_valid_from, t_valid_until, propagated_s_valid_from, propagated_s_valid_until, causal_source_row_ids, causal_id, propagated_stable_pk_payload as stable_pk_payload,                     causal_source_row_ids IS NULL AS unaffected_target_only_segment,                     s_data_payload, t_data_payload,                     sql_saga.get_allen_relation(propagated_s_valid_from, propagated_s_valid_until, t_valid_from, t_valid_until) AS orig_source_target_relation,                     COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb) as data_payload,                     md5((jsonb_strip_nulls(COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb)))::text) as data_hash,                     CASE                          WHEN s_data_payload IS NULL THEN t_ephemeral_payload                         ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb)                     END as ephemeral_payload,                     CASE WHEN 'f'::boolean                         THEN trace || jsonb_build_object( 'cte', 'ras', 'segment_stable_pk', propagated_stable_pk_payload, 'final_data_payload', COALESCE(t_data_payload, '{}'::jsonb) || COALESCE(s_data_payload, '{}'::jsonb), 'final_ephemeral_payload', CASE WHEN s_data_payload IS NULL THEN t_ephemeral_payload ELSE COALESCE(t_ephemeral_payload, '{}'::jsonb) || COALESCE(s_ephemeral_payload, '{}'::jsonb) END )                         ELSE NULL                     END as trace                 FROM resolved_atomic_segments_with_propagated_ids"
2b2,Process Legal Units - Batch 3,,-337330954754935537,1,42.923375,10000,0,0,0,0,0,0,0,"WITH RECURSIVE ordered_plan AS (                     SELECT                         row_number() OVER ( ORDER BY p.grouping_key, p.id, CASE p.operation WHEN 'DELETE' THEN 1 WHEN 'UPDATE' THEN 2 WHEN 'INSERT' THEN 3 ELSE 4 END, p.update_effect NULLS FIRST, CASE WHEN p.update_effect = 'MOVE' THEN 1 ELSE 0 END, CASE WHEN p.update_effect = 'MOVE' THEN COALESCE(p.old_valid_from, p.new_valid_from) END DESC NULLS LAST, COALESCE(p.old_valid_from, p.new_valid_from), (p.row_ids[1]) )::BIGINT as plan_op_seq,                         p.*                     FROM plan p                 ),                 -- For MOVE operations, group into the largest possible batches that can execute together.                 -- Within a single UPDATE statement, all rows see the pre-update state (MVCC snapshot).                 -- So if MOVE A's new_range overlaps MOVE B's old_range, they cannot be in the same statement.                 --                 -- Algorithm: Process MOVEs in plan_op_seq order (which is old_valid_from DESC).                 -- Track a multirange of old_ranges in the current batch. For each MOVE:                 -- - If new_range overlaps the batch's multirange, start a new batch                 -- - Add this MOVE's old_range to the batch's multirange                 --                 -- We use a recursive CTE to accumulate the multirange with reset-on-conflict logic.                 moves_ordered AS (                     SELECT                         o.plan_op_seq,                         o.grouping_key,                         o.old_valid_from,                         o.old_valid_until,                         o.new_valid_from,                         o.new_valid_until,                         row_number() OVER (PARTITION BY o.grouping_key ORDER BY o.plan_op_seq) AS move_seq                     FROM ordered_plan o                     WHERE o.operation = 'UPDATE' AND o.update_effect = 'MOVE'                 ),                 moves_with_batch AS (                     -- Base case: first MOVE in each entity starts b"
56f,Process Legal Units - Batch 3,,1428552154429020267,1,39.68475,30000,1626,0,498,499,0,110,12251,"CREATE TEMP TABLE time_points ON COMMIT DROP AS                 SELECT DISTINCT ON (grouping_key, point) *                 FROM time_points_with_unified_ids                 ORDER BY grouping_key, point, causal_id DESC NULLS LAST"
c7d,Process Legal Units - Batch 3,,7828285074499428853,1,37.672166,10000,4765,0,0,0,0,0,0,"WITH             all_source_rows AS (                 SELECT t.row_id AS source_row_id FROM source_view_lu t             ),             plan_unnested AS (                 SELECT unnest(p.row_ids) as source_row_id, p.plan_op_seq, p.entity_keys, p.operation, p.data, p.feedback                 FROM temporal_merge_plan p             ),             feedback_groups AS (                 SELECT                     asr.source_row_id,                     -- Aggregate all distinct operations for this source row.                     array_agg(DISTINCT pu.operation) FILTER (WHERE pu.operation IS NOT NULL) as operations,                     -- Aggregate all distinct entity IDs this source row touched.                     COALESCE(jsonb_agg(DISTINCT pu.entity_keys) FILTER (WHERE pu.entity_keys IS NOT NULL), '[]'::jsonb) AS target_entity_keys,                     -- Extract the specific error message from the plan's feedback payload if present.                     (array_agg(pu.feedback->>'error') FILTER (WHERE pu.operation = 'ERROR' AND pu.feedback ? 'error'))[1] as error_message_from_plan                 FROM all_source_rows asr                 LEFT JOIN plan_unnested pu ON asr.source_row_id = pu.source_row_id                 GROUP BY asr.source_row_id             )             INSERT INTO temporal_merge_feedback                 SELECT                     fg.source_row_id,                     fg.target_entity_keys,                     CASE                         -- This CASE statement must be ordered from most to least specific to correctly classify outcomes.                         -- This CASE statement directly translates the plan's actions into a final feedback status.                         -- It is ordered from most to least specific to ensure correctness.                         WHEN 'ERROR'::sql_saga.temporal_merge_plan_action = ANY(fg.operations) THEN 'ERROR'                         WHEN 'INSERT'::sql_saga.temporal_merge_plan_action = ANY(fg.operations)                           OR 'UPDATE'::sql_saga.temporal_merge_"
af1,Process Legal Units - Batch 3,,6254436778457358929,1,37.602083,30000,256,0,498,499,0,110,12251,"CREATE TEMP TABLE time_points ON COMMIT DROP AS                 SELECT DISTINCT ON (grouping_key, point) *                 FROM time_points_with_unified_ids                 ORDER BY grouping_key, point, causal_id DESC NULLS LAST"
81c,Process Legal Units - Batch 3,,1690235038614940568,1,31.884916,10000,1688,2,0,0,0,138,16180,"CREATE TEMP TABLE diff ON COMMIT DROP AS                 SELECT                     final_seg.grouping_key, COALESCE(final_seg.id, target_seg.id) as id, COALESCE(final_seg.causal_id, target_seg.causal_id) as causal_id,                     COALESCE(final_seg.is_new_entity, false) as is_new_entity,                     COALESCE(final_seg.is_identifiable, true) as is_identifiable,                     COALESCE(final_seg.is_ambiguous, false) as is_ambiguous,                     final_seg.conflicting_ids,                     final_seg.canonical_nk_json,                     COALESCE(final_seg.stable_identity_columns_are_null, false) as stable_identity_columns_are_null,                     COALESCE(final_seg.lookup_columns_unavailable, false) as lookup_columns_unavailable,                     final_seg.valid_from AS f_from, final_seg.valid_until AS f_until, final_seg.final_payload AS f_payload, final_seg.row_ids AS f_row_ids, final_seg.stable_pk_payload, final_seg.orig_source_target_relation,                     CASE WHEN 'f'::boolean                         THEN final_seg.trace || jsonb_build_object('cte', 'diff', 'diff_stable_pk', final_seg.stable_pk_payload, 'final_seg_causal_id', final_seg.causal_id, 'final_payload_vs_target_payload', jsonb_build_object('f', final_seg.final_payload, 't', target_seg.data_payload))                         ELSE NULL                     END as trace,                     final_seg.unaffected_target_only_segment,                     target_seg.valid_from as t_from, target_seg.valid_until as t_until, (target_seg.data_payload || target_seg.ephemeral_payload) as t_payload,                     sql_saga.get_allen_relation(target_seg.valid_from, target_seg.valid_until, final_seg.valid_from, final_seg.valid_until) as b_a_relation                 FROM coalesced_final_segments AS final_seg                 FULL OUTER JOIN target_rows AS target_seg ON final_seg.grouping_key = ('existing_entity__' || COALESCE(target_seg.id::text, '_NULL_')) AND final_seg.ancestor_valid_from = target_seg.valid_from"
375,Process Legal Units - Batch 3,,6223146894373634837,1,30.981125000000002,10000,302,2,0,0,0,138,16180,"CREATE TEMP TABLE diff ON COMMIT DROP AS                 SELECT                     final_seg.grouping_key, COALESCE(final_seg.id, target_seg.id) as id, COALESCE(final_seg.causal_id, target_seg.causal_id) as causal_id,                     COALESCE(final_seg.is_new_entity, false) as is_new_entity,                     COALESCE(final_seg.is_identifiable, true) as is_identifiable,                     COALESCE(final_seg.is_ambiguous, false) as is_ambiguous,                     final_seg.conflicting_ids,                     final_seg.canonical_nk_json,                     COALESCE(final_seg.stable_identity_columns_are_null, false) as stable_identity_columns_are_null,                     COALESCE(final_seg.lookup_columns_unavailable, false) as lookup_columns_unavailable,                     final_seg.valid_from AS f_from, final_seg.valid_until AS f_until, final_seg.final_payload AS f_payload, final_seg.row_ids AS f_row_ids, final_seg.stable_pk_payload, final_seg.orig_source_target_relation,                     CASE WHEN 'f'::boolean                         THEN final_seg.trace || jsonb_build_object('cte', 'diff', 'diff_stable_pk', final_seg.stable_pk_payload, 'final_seg_causal_id', final_seg.causal_id, 'final_payload_vs_target_payload', jsonb_build_object('f', final_seg.final_payload, 't', target_seg.data_payload))                         ELSE NULL                     END as trace,                     final_seg.unaffected_target_only_segment,                     target_seg.valid_from as t_from, target_seg.valid_until as t_until, (target_seg.data_payload || target_seg.ephemeral_payload) as t_payload,                     sql_saga.get_allen_relation(target_seg.valid_from, target_seg.valid_until, final_seg.valid_from, final_seg.valid_until) as b_a_relation                 FROM coalesced_final_segments AS final_seg                 FULL OUTER JOIN target_rows AS target_seg ON final_seg.grouping_key = ('existing_entity__' || COALESCE(target_seg.id::text, '_NULL_')) AND final_seg.ancestor_valid_from = target_seg.valid_from"
56e,Process Legal Units - Batch 3,,1965474688105448427,1,28.796583,10000,6393,3,0,0,0,118,17530,"CREATE TEMP TABLE source_initial ON COMMIT DROP AS                 WITH source_data AS (                     SELECT                         source_table.row_id /* row_id_column */ as source_row_id,                         COALESCE(source_table.founding_id, source_table.row_id::integer) /* v_causal_select_expr */ as causal_id,                         source_table.id,  -- v_non_temporal_lookup_cols_select_list_prefix                         source_table.valid_from as valid_from, source_table.valid_until as valid_until, /* v_source_temporal_cols_expr */                         jsonb_strip_nulls(jsonb_build_object('name', source_table.name)) /* v_source_data_payload_expr */ AS data_payload,                         jsonb_strip_nulls(jsonb_build_object('comment', source_table.comment)) /* v_source_ephemeral_payload_expr */ AS ephemeral_payload,                         jsonb_build_object('id', source_table.id) /* v_stable_pk_cols_jsonb_build_source */ as stable_pk_payload,                         source_table.id IS NULL /* v_entity_id_check_is_null_expr */ as stable_identity_columns_are_null,                         (true) /* v_lookup_cols_are_null_expr */ as lookup_columns_unavailable,                         true /* v_is_identifiable_expr */ as is_identifiable,                         true /* v_consistency_check_expr */ as temporal_columns_are_consistent                     FROM source_view_lu /* v_source_table_ident */ source_table                 )                 SELECT                      *,                     -- OPTIMIZATION: Pre-compute range column to avoid repeated daterange() calls                     -- This provides ~10-15% performance improvement in eclipse detection                     daterange(valid_from, valid_until) as valid_range                 FROM source_data"
bf7,Process Legal Units - Batch 3,,2115514670139824758,1,28.062126,10000,5049,3,0,0,0,118,17530,"CREATE TEMP TABLE source_initial ON COMMIT DROP AS                 WITH source_data AS (                     SELECT                         source_table.row_id /* row_id_column */ as source_row_id,                         COALESCE(source_table.founding_id, source_table.row_id::integer) /* v_causal_select_expr */ as causal_id,                         source_table.id,  -- v_non_temporal_lookup_cols_select_list_prefix                         source_table.valid_from as valid_from, source_table.valid_until as valid_until, /* v_source_temporal_cols_expr */                         jsonb_strip_nulls(jsonb_build_object('name', source_table.name)) /* v_source_data_payload_expr */ AS data_payload,                         jsonb_strip_nulls(jsonb_build_object('comment', source_table.comment)) /* v_source_ephemeral_payload_expr */ AS ephemeral_payload,                         jsonb_build_object('id', source_table.id) /* v_stable_pk_cols_jsonb_build_source */ as stable_pk_payload,                         source_table.id IS NULL /* v_entity_id_check_is_null_expr */ as stable_identity_columns_are_null,                         (true) /* v_lookup_cols_are_null_expr */ as lookup_columns_unavailable,                         true /* v_is_identifiable_expr */ as is_identifiable,                         true /* v_consistency_check_expr */ as temporal_columns_are_consistent                     FROM source_view_lu /* v_source_table_ident */ source_table                 )                 SELECT                      *,                     -- OPTIMIZATION: Pre-compute range column to avoid repeated daterange() calls                     -- This provides ~10-15% performance improvement in eclipse detection                     daterange(valid_from, valid_until) as valid_range                 FROM source_data;"
5db,Process Legal Units - Batch 3,,6779487562696088383,1,24.857667,20000,1631,1,0,0,0,113,12571,"CREATE TEMP TABLE atomic_segments ON COMMIT DROP AS                 SELECT grouping_key, id, causal_id, point as valid_from, next_point as valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json                 FROM (                     SELECT *, LEAD(point) OVER (PARTITION BY grouping_key ORDER BY point) as next_point                     FROM time_points                 ) with_lead                 WHERE point IS NOT NULL AND next_point IS NOT NULL AND point < next_point"
764,Process Legal Units - Batch 3,,-7375841108639655790,1,24.11825,20000,261,1,0,0,0,113,12571,"CREATE TEMP TABLE atomic_segments ON COMMIT DROP AS                 SELECT grouping_key, id, causal_id, point as valid_from, next_point as valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json                 FROM (                     SELECT *, LEAD(point) OVER (PARTITION BY grouping_key ORDER BY point) as next_point                     FROM time_points                 ) with_lead                 WHERE point IS NOT NULL AND next_point IS NOT NULL AND point < next_point"
6d7,Process Legal Units - Batch 3,,-6189425232530816533,1,22.874291,10000,1836,0,0,0,0,102,11171,"CREATE TEMP TABLE target_rows ON COMMIT DROP AS                 SELECT                     id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ -- (non-temporal identity columns)                     lower(t.valid_range) as valid_from, -- The temporal identity column (e.g., valid_from)                     NULL::integer /* v_causal_column_type */ as causal_id, -- Target rows do not originate from a source row, so causal_id is NULL. Type is introspected.                     jsonb_build_object('id', id) /* v_stable_pk_cols_jsonb_build_bare */ as stable_pk_payload,                     upper(t.valid_range) as valid_until,                     jsonb_build_object('name', name) /* v_target_data_cols_jsonb_build_bare */ AS data_payload,                     jsonb_build_object('comment', comment) /* v_target_ephemeral_cols_jsonb_build_bare */ AS ephemeral_payload,                     jsonb_strip_nulls(jsonb_build_object()) /* v_target_nk_json_expr */ AS canonical_nk_json                 FROM (                         SELECT * FROM (                             SELECT DISTINCT ON (u.id, u.valid_from) * FROM (                                 (                                     SELECT * FROM etl_bench.legal_unit inner_t                                     WHERE (inner_t.id) IN (SELECT DISTINCT si.id FROM source_initial si WHERE (si.id) IS NOT NULL)                                 )                             ) u                         )                     ) AS t  /* v_target_rows_filter */"
26f,Process Legal Units - Batch 3,,-2522301903109079185,1,22.549958,40000,1635,1,0,0,0,111,12365,"CREATE TEMP TABLE time_points_with_unified_ids ON COMMIT DROP AS                 SELECT                     tpu.grouping_key,                     tpu.id,                     tpu.unified_causal_id as causal_id,                     tpu.point,                     tpu.is_new_entity,                     tpu.unified_stable_pk_payload as stable_pk_payload,                     tpu.stable_identity_columns_are_null,                     tpu.lookup_columns_unavailable,                     tpu.is_identifiable,                     tpu.is_ambiguous,                     tpu.conflicting_ids,                     tpu.unified_canonical_nk_json as canonical_nk_json                 FROM time_points_unified tpu"
5a2,Process Legal Units - Batch 3,,5147944785677299242,1,22.519916,10000,1688,1,0,0,0,142,19386,"CREATE TEMP TABLE diff_ranked ON COMMIT DROP AS                 SELECT                     d.*,                     CASE                         WHEN d.t_from IS NULL OR d.f_from IS NULL THEN NULL                         WHEN d.f_from = d.t_from AND d.f_until = d.t_until AND d.f_payload IS NOT DISTINCT FROM d.t_payload THEN NULL                         ELSE                             row_number() OVER (                                 PARTITION BY d.grouping_key, d.t_from                                 ORDER BY                                     CASE WHEN d.f_from = d.t_from THEN 1 ELSE 2 END,                                     CASE WHEN d.f_payload - '{comment}'::text[] IS NOT DISTINCT FROM d.t_payload - '{comment}'::text[] THEN 1 ELSE 2 END,                                     d.f_from,                                     d.f_until                             )                     END as update_rank                 FROM diff d"
08e,Process Legal Units - Batch 3,,-6278565976310229931,1,22.309208,10000,1694,2,0,0,0,135,18303,"CREATE TEMP TABLE plan_with_op ON COMMIT DROP AS                 (                     SELECT * FROM (                         SELECT                             d.f_row_ids as row_ids, d.orig_source_target_relation, d.is_new_entity,                             CASE                                 WHEN d.is_ambiguous THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.is_new_entity AND NOT d.is_identifiable THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.t_from IS NULL THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.f_from IS NULL THEN 'DELETE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank = 1 THEN 'UPDATE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank > 1 THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank IS NULL THEN                                     CASE                                         WHEN d.unaffected_target_only_segment THEN NULL                                         ELSE 'SKIP_IDENTICAL'::sql_saga.temporal_merge_plan_action                                     END                                 ELSE 'ERROR'::sql_saga.temporal_merge_plan_action                             END as operation,                             id,                             CASE                                 WHEN d.is_new_entity AND d.canonical_nk_json IS NOT NULL                                 THEN d.canonical_nk_json || COALESCE(d.stable_pk_payload, '{}'::jsonb)                                 ELSE jsonb_build_object('id', d.id) || COALESCE(d.stable_pk_payload, '{}'::jsonb)                             END as entity_keys_json,                             jsonb_build_object('id', d.id) as identity_keys,                             jsonb_build_object() as lookup_keys,                             d.causal_id, d.t_from as old_valid_from, d.t_until as old_valid_until, d.f"
e0e,Process Legal Units - Batch 3,,-4193415169867768194,1,22.020000000000003,10000,492,0,0,0,0,102,11171,"CREATE TEMP TABLE target_rows ON COMMIT DROP AS                 SELECT                     id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ -- (non-temporal identity columns)                     lower(t.valid_range) as valid_from, -- The temporal identity column (e.g., valid_from)                     NULL::integer /* v_causal_column_type */ as causal_id, -- Target rows do not originate from a source row, so causal_id is NULL. Type is introspected.                     jsonb_build_object('id', id) /* v_stable_pk_cols_jsonb_build_bare */ as stable_pk_payload,                     upper(t.valid_range) as valid_until,                     jsonb_build_object('name', name) /* v_target_data_cols_jsonb_build_bare */ AS data_payload,                     jsonb_build_object('comment', comment) /* v_target_ephemeral_cols_jsonb_build_bare */ AS ephemeral_payload,                     jsonb_strip_nulls(jsonb_build_object()) /* v_target_nk_json_expr */ AS canonical_nk_json                 FROM (                         SELECT * FROM (                             SELECT DISTINCT ON (u.id, u.valid_from) * FROM (                                 (                                     SELECT * FROM etl_bench.legal_unit inner_t                                     WHERE (inner_t.id) IN (SELECT DISTINCT si.id FROM source_initial si WHERE (si.id) IS NOT NULL)                                 )                             ) u                         )                     ) AS t  /* v_target_rows_filter */"
8c9,Process Legal Units - Batch 3,,6259880232974284115,1,21.785708,10000,298,1,0,0,0,142,19386,"CREATE TEMP TABLE diff_ranked ON COMMIT DROP AS                 SELECT                     d.*,                     CASE                         WHEN d.t_from IS NULL OR d.f_from IS NULL THEN NULL                         WHEN d.f_from = d.t_from AND d.f_until = d.t_until AND d.f_payload IS NOT DISTINCT FROM d.t_payload THEN NULL                         ELSE                             row_number() OVER (                                 PARTITION BY d.grouping_key, d.t_from                                 ORDER BY                                     CASE WHEN d.f_from = d.t_from THEN 1 ELSE 2 END,                                     CASE WHEN d.f_payload - '{comment}'::text[] IS NOT DISTINCT FROM d.t_payload - '{comment}'::text[] THEN 1 ELSE 2 END,                                     d.f_from,                                     d.f_until                             )                     END as update_rank                 FROM diff d"
1bd,Process Legal Units - Batch 3,,-2381107599654639950,1,21.483833,40000,259,1,0,0,0,111,12365,"CREATE TEMP TABLE time_points_with_unified_ids ON COMMIT DROP AS                 SELECT                     tpu.grouping_key,                     tpu.id,                     tpu.unified_causal_id as causal_id,                     tpu.point,                     tpu.is_new_entity,                     tpu.unified_stable_pk_payload as stable_pk_payload,                     tpu.stable_identity_columns_are_null,                     tpu.lookup_columns_unavailable,                     tpu.is_identifiable,                     tpu.is_ambiguous,                     tpu.conflicting_ids,                     tpu.unified_canonical_nk_json as canonical_nk_json                 FROM time_points_unified tpu"
c56,Process Legal Units - Batch 3,,8461913458038132941,1,21.372041000000003,10000,300,2,0,0,0,135,18303,"CREATE TEMP TABLE plan_with_op ON COMMIT DROP AS                 (                     SELECT * FROM (                         SELECT                             d.f_row_ids as row_ids, d.orig_source_target_relation, d.is_new_entity,                             CASE                                 WHEN d.is_ambiguous THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.is_new_entity AND NOT d.is_identifiable THEN 'ERROR'::sql_saga.temporal_merge_plan_action                                 WHEN d.t_from IS NULL THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.f_from IS NULL THEN 'DELETE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank = 1 THEN 'UPDATE'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank > 1 THEN 'INSERT'::sql_saga.temporal_merge_plan_action                                 WHEN d.update_rank IS NULL THEN                                     CASE                                         WHEN d.unaffected_target_only_segment THEN NULL                                         ELSE 'SKIP_IDENTICAL'::sql_saga.temporal_merge_plan_action                                     END                                 ELSE 'ERROR'::sql_saga.temporal_merge_plan_action                             END as operation,                             id,                             CASE                                 WHEN d.is_new_entity AND d.canonical_nk_json IS NOT NULL                                 THEN d.canonical_nk_json || COALESCE(d.stable_pk_payload, '{}'::jsonb)                                 ELSE jsonb_build_object('id', d.id) || COALESCE(d.stable_pk_payload, '{}'::jsonb)                             END as entity_keys_json,                             jsonb_build_object('id', d.id) as identity_keys,                             jsonb_build_object() as lookup_keys,                             d.causal_id, d.t_from as old_valid_from, d.t_until as old_valid_until, d.f"
f4f,Process Legal Units - Batch 3,,-3276528771796910273,1,21.233708,20000,1782,2,0,0,0,141,16948,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     seg.*,                     seg.stable_pk_payload as propagated_stable_pk_payload                 FROM all_segments seg                 WHERE (seg.s_data_payload IS NOT NULL OR seg.t_data_payload IS NOT NULL)                 AND CASE 'MERGE_ENTITY_PATCH'::sql_saga.temporal_merge_mode                     WHEN 'PATCH_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'REPLACE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'DELETE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'UPDATE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     ELSE true                 END"
470,Process Legal Units - Batch 3,,2346888588666524139,1,20.353625,40000,1627,1,0,0,0,109,12055,"CREATE TEMP TABLE time_points_raw ON COMMIT DROP AS                 SELECT id, causal_id, valid_from AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows                 UNION ALL                 SELECT id, causal_id, valid_until AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows"
c1a,Process Legal Units - Batch 3,,5739678101431501439,1,20.306,20000,299,2,0,0,0,141,16948,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     seg.*,                     seg.stable_pk_payload as propagated_stable_pk_payload                 FROM all_segments seg                 WHERE (seg.s_data_payload IS NOT NULL OR seg.t_data_payload IS NOT NULL)                 AND CASE 'MERGE_ENTITY_PATCH'::sql_saga.temporal_merge_mode                     WHEN 'PATCH_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'REPLACE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'DELETE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     WHEN 'UPDATE_FOR_PORTION_OF' THEN seg.t_data_payload IS NOT NULL                     ELSE true                 END"
08d,Process Legal Units - Batch 3,,3254511572182529394,1,19.4555,40000,257,1,0,0,0,109,12055,"CREATE TEMP TABLE time_points_raw ON COMMIT DROP AS                 SELECT id, causal_id, valid_from AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows                 UNION ALL                 SELECT id, causal_id, valid_until AS point, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM all_rows"
fd2,Process Legal Units - Batch 3,,725758841111022991,150,18.963299000000003,150,59146,0,0,0,0,0,0,"EXISTS (         SELECT 1 FROM pg_event_trigger_ddl_commands() ddl         JOIN pg_class c ON c.oid = ddl.objid         JOIN pg_namespace n ON n.oid = c.relnamespace         WHERE EXISTS (SELECT 1 FROM sql_saga.era e WHERE (e.table_schema, e.table_name) = (n.nspname, c.relname))            OR EXISTS (SELECT 1 FROM sql_saga.updatable_view v JOIN pg_class vc ON vc.relname = v.view_name JOIN pg_namespace vn ON vn.oid = vc.relnamespace AND vn.nspname = v.view_schema WHERE vc.oid = c.oid)            -- Also check system_versioning objects (history table, view)            OR EXISTS (SELECT 1 FROM sql_saga.system_versioning sv WHERE (sv.history_schema_name, sv.history_table_name) = (n.nspname, c.relname))            OR EXISTS (SELECT 1 FROM sql_saga.system_versioning sv WHERE (sv.view_schema_name, sv.view_table_name) = (n.nspname, c.relname))     )"
49c,Process Legal Units - Batch 3,,7110079446970253207,1,16.621084,10000,1687,1,0,0,0,137,14979,"CREATE TEMP TABLE plan ON COMMIT DROP AS                 SELECT                     p.row_ids, p.operation, p.causal_id, p.is_new_entity,                     p.id,                     p.entity_keys_json as entity_keys,                     p.identity_keys, p.lookup_keys,                     p.orig_source_target_relation, p.b_a_relation, p.old_valid_from, p.old_valid_until,                     p.new_valid_from, p.new_valid_until, p.data, p.feedback, p.trace,                     p.grouping_key,                     CASE                         WHEN p.operation <> 'UPDATE' THEN NULL::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from = p.old_valid_from AND p.new_valid_until = p.old_valid_until THEN 'NONE'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from <= p.old_valid_from AND p.new_valid_until >= p.old_valid_until THEN 'GROW'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from >= p.old_valid_from AND p.new_valid_until <= p.old_valid_until THEN 'SHRINK'::sql_saga.temporal_merge_update_effect                         ELSE 'MOVE'::sql_saga.temporal_merge_update_effect                     END AS update_effect                 FROM plan_with_op p                 LEFT JOIN source_rows_with_new_flag source_row ON source_row.source_row_id = p.row_ids[1]"
222,Process Legal Units - Batch 3,,7371826089573494947,1,15.817541,10000,301,1,0,0,0,137,14979,"CREATE TEMP TABLE plan ON COMMIT DROP AS                 SELECT                     p.row_ids, p.operation, p.causal_id, p.is_new_entity,                     p.id,                     p.entity_keys_json as entity_keys,                     p.identity_keys, p.lookup_keys,                     p.orig_source_target_relation, p.b_a_relation, p.old_valid_from, p.old_valid_until,                     p.new_valid_from, p.new_valid_until, p.data, p.feedback, p.trace,                     p.grouping_key,                     CASE                         WHEN p.operation <> 'UPDATE' THEN NULL::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from = p.old_valid_from AND p.new_valid_until = p.old_valid_until THEN 'NONE'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from <= p.old_valid_from AND p.new_valid_until >= p.old_valid_until THEN 'GROW'::sql_saga.temporal_merge_update_effect                         WHEN p.new_valid_from >= p.old_valid_from AND p.new_valid_until <= p.old_valid_until THEN 'SHRINK'::sql_saga.temporal_merge_update_effect                         ELSE 'MOVE'::sql_saga.temporal_merge_update_effect                     END AS update_effect                 FROM plan_with_op p                 LEFT JOIN source_rows_with_new_flag source_row ON source_row.source_row_id = p.row_ids[1]"
a8a,Process Legal Units - Batch 3,,-1318097777820228,1,13.994833,10000,1652,0,0,0,0,120,13561,"CREATE TEMP TABLE source_rows ON COMMIT DROP AS                 SELECT DISTINCT ON (p.source_row_id)                     p.source_row_id, p.causal_id, p.valid_from, p.valid_until, p.data_payload, p.ephemeral_payload,                     (p.stable_identity_columns_are_null AND p.discovered_stable_pk_payload IS NULL) as stable_identity_columns_are_null,                     p.lookup_columns_unavailable, p.is_identifiable,                     p.is_ambiguous, p.conflicting_ids, p.is_eclipsed, p.eclipsed_by,                     p.temporal_columns_are_consistent,                     COALESCE(p.stable_pk_payload, p.discovered_stable_pk_payload) as stable_pk_payload,                     (p.discovered_stable_pk_payload IS NOT NULL) /* v_target_entity_exists_expr */ as target_entity_exists,                     COALESCE(p.id, p.discovered_id_1) AS id /* v_coalesced_id_cols_list */                 FROM source_rows_with_discovery p                 ORDER BY p.source_row_id, p.discovered_stable_pk_payload"
4b1,Process Legal Units - Batch 3,,2284106485190769639,1,13.260208,10000,266,0,0,0,0,120,13561,"CREATE TEMP TABLE source_rows ON COMMIT DROP AS                 SELECT DISTINCT ON (p.source_row_id)                     p.source_row_id, p.causal_id, p.valid_from, p.valid_until, p.data_payload, p.ephemeral_payload,                     (p.stable_identity_columns_are_null AND p.discovered_stable_pk_payload IS NULL) as stable_identity_columns_are_null,                     p.lookup_columns_unavailable, p.is_identifiable,                     p.is_ambiguous, p.conflicting_ids, p.is_eclipsed, p.eclipsed_by,                     p.temporal_columns_are_consistent,                     COALESCE(p.stable_pk_payload, p.discovered_stable_pk_payload) as stable_pk_payload,                     (p.discovered_stable_pk_payload IS NOT NULL) /* v_target_entity_exists_expr */ as target_entity_exists,                     COALESCE(p.id, p.discovered_id_1) AS id /* v_coalesced_id_cols_list */                 FROM source_rows_with_discovery p                 ORDER BY p.source_row_id, p.discovered_stable_pk_payload"
c8f,Process Legal Units - Batch 3,,2613701250391606255,1,12.85325,10000,1631,1,0,0,0,127,14429,"CREATE TEMP TABLE source_rows_with_discovery ON COMMIT DROP AS                 SELECT                     m.*,                     a.match_count,                     a.conflicting_ids,                     (a.match_count > 1) as is_ambiguous                 FROM source_rows_with_matches m                 JOIN source_rows_with_aggregates a ON m.source_row_id = a.source_row_id"
9ad,Process Legal Units - Batch 3,,-3169870935594387745,1,12.167791000000001,0,5466,0,0,0,0,0,0,UPDATE etl_bench.data_table dt     SET legal_unit_id = ir.legal_unit_id     FROM etl_bench.identity_resolution ir     WHERE dt.identity_correlation = ir.identity_correlation       AND dt.legal_unit_id IS NULL
37f,Process Legal Units - Batch 3,,5494611821061557908,1,12.152209,20000,1660,2,0,0,0,113,24311,"CREATE TEMP TABLE all_rows ON COMMIT DROP AS                 SELECT id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ causal_id, valid_from, valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM active_source_rows                 UNION ALL                 SELECT                     target_row.id,  /* v_non_temporal_tr_qualified_lookup_cols_prefix */                     target_row.causal_id,                     target_row.valid_from,                     target_row.valid_until,                     false as is_new_entity,                     target_row.stable_pk_payload,                     false as stable_identity_columns_are_null,                     false as lookup_columns_unavailable,                     true as is_identifiable,                     false as is_ambiguous,                     NULL::jsonb as conflicting_ids,                     target_row.canonical_nk_json                 FROM target_rows target_row"
289,Process Legal Units - Batch 3,,8473430400440557908,1,12.013417,10000,276,1,0,0,0,127,14429,"CREATE TEMP TABLE source_rows_with_discovery ON COMMIT DROP AS                 SELECT                     m.*,                     a.match_count,                     a.conflicting_ids,                     (a.match_count > 1) as is_ambiguous                 FROM source_rows_with_matches m                 JOIN source_rows_with_aggregates a ON m.source_row_id = a.source_row_id"
78a,Process Legal Units - Batch 3,,7000426517880687954,1,11.885292,10000,1686,0,0,0,0,130,14935,"CREATE TEMP TABLE source_rows_with_canonical_key ON COMMIT DROP AS                 SELECT *, (CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END /* v_grouping_key_expr */) as grouping_key                 FROM (                     SELECT                         s1.*,                         s2.nk_json as canonical_nk_json                     FROM source_rows_with_nk_json s1                     LEFT JOIN LATERAL (                         SELECT s2_inner.nk_json, s2_inner.nk_non_null_keys_array                         FROM source_rows_with_nk_json s2_inner                         WHERE s1.is_new_entity AND s2_inner.is_new_entity AND s2_inner.nk_json @> s1.nk_json                         ORDER BY array_length(s2_inner.nk_non_null_keys_array, 1) DESC, s2_inner.nk_non_null_keys_array::text DESC                         LIMIT 1                     ) s2 ON true                 ) s"
a06,Process Legal Units - Batch 3,,-8525577533969057774,1,11.310250000000002,20000,265,2,0,0,0,113,24311,"CREATE TEMP TABLE all_rows ON COMMIT DROP AS                 SELECT id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ causal_id, valid_from, valid_until, is_new_entity, stable_pk_payload, stable_identity_columns_are_null, lookup_columns_unavailable, is_identifiable, is_ambiguous, conflicting_ids, canonical_nk_json FROM active_source_rows                 UNION ALL                 SELECT                     target_row.id,  /* v_non_temporal_tr_qualified_lookup_cols_prefix */                     target_row.causal_id,                     target_row.valid_from,                     target_row.valid_until,                     false as is_new_entity,                     target_row.stable_pk_payload,                     false as stable_identity_columns_are_null,                     false as lookup_columns_unavailable,                     true as is_identifiable,                     false as is_ambiguous,                     NULL::jsonb as conflicting_ids,                     target_row.canonical_nk_json                 FROM target_rows target_row"
49a,Process Legal Units - Batch 3,,8689595743856886431,1,11.19125,0,1444,0,0,0,0,16,1669,CREATE INDEX ON active_source_rows (grouping_key)
dfd,Process Legal Units - Batch 3,,8118870935825291626,1,10.969625,10000,277,0,0,0,0,130,14935,"CREATE TEMP TABLE source_rows_with_canonical_key ON COMMIT DROP AS                 SELECT *, (CASE                 WHEN is_new_entity                 THEN 'new_entity__' || causal_id::text                 ELSE 'existing_entity__' || COALESCE(id::text, '_NULL_')             END /* v_grouping_key_expr */) as grouping_key                 FROM (                     SELECT                         s1.*,                         s2.nk_json as canonical_nk_json                     FROM source_rows_with_nk_json s1                     LEFT JOIN LATERAL (                         SELECT s2_inner.nk_json, s2_inner.nk_non_null_keys_array                         FROM source_rows_with_nk_json s2_inner                         WHERE s1.is_new_entity AND s2_inner.is_new_entity AND s2_inner.nk_json @> s1.nk_json                         ORDER BY array_length(s2_inner.nk_non_null_keys_array, 1) DESC, s2_inner.nk_non_null_keys_array::text DESC                         LIMIT 1                     ) s2 ON true                 ) s"
c78,Process Legal Units - Batch 3,,-5024370260775748889,1,10.875959,10000,1653,1,0,0,0,117,13111,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT * FROM (                     -- Path 1: Existing Entities (Window Function on Lookup Keys)                     SELECT                         s1.*,                         COALESCE(                             range_agg(valid_range) OVER (                                 PARTITION BY id                                 ORDER BY source_row_id DESC                                 ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                             ) @> valid_range,                             false                         ) as is_eclipsed,                         array_agg(source_row_id) OVER (                             PARTITION BY id                             ORDER BY source_row_id DESC                             ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                         ) as eclipsed_by                     FROM source_initial s1                     WHERE NOT s1.lookup_columns_unavailable                      UNION ALL                      -- Path 2: New Entities (Window Function on Causal ID)                     SELECT                         s1.*,                         COALESCE(                             range_agg(valid_range) OVER (                                 PARTITION BY causal_id                                 ORDER BY source_row_id DESC                                 ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                             ) @> valid_range,                             false                         ) as is_eclipsed,                         array_agg(source_row_id) OVER (                             PARTITION BY causal_id                             ORDER BY source_row_id DESC                             ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING                         ) as eclipsed_by                     FROM source_initial s1                     WHERE s1.lookup_columns_unavailable                 ) t"
510,Process Legal Units - Batch 3,,-4549662675158664316,1,10.660125,10000,1620,0,0,0,0,92,9941,"CREATE TEMP TABLE source_rows_with_aggregates ON COMMIT DROP AS                 SELECT                     source_row_id,                     count(DISTINCT discovered_stable_pk_payload) as match_count,                     -- Filter out NULL to avoid [null] result for new entities with no matches                     COALESCE(jsonb_agg(DISTINCT discovered_stable_pk_payload) FILTER (WHERE discovered_stable_pk_payload IS NOT NULL), '[]'::jsonb) as conflicting_ids                 FROM source_rows_with_matches                 GROUP BY source_row_id"
2bd,Process Legal Units - Batch 3,,5012345967240423926,1,10.068916,10000,1673,1,0,0,0,133,15247,"CREATE TEMP TABLE source_rows_with_early_feedback ON COMMIT DROP AS                 SELECT                     s.*,                     CASE                         WHEN s.is_ambiguous                         THEN jsonb_build_object( 'operation', 'ERROR'::text, 'message', 'Source row is ambiguous. It matches multiple distinct target entities: ' || s.conflicting_ids::text )                         WHEN NOT s.is_identifiable AND s.is_new_entity                         THEN jsonb_build_object( 'operation', 'ERROR'::text, 'message', 'Source row is unidentifiable. It has NULL for all stable identity columns ' || replace('{id}'::text, '""', '') || ' and all natural keys ' || replace(NULL::text, '""', '') )                         WHEN NOT s.temporal_columns_are_consistent                         THEN jsonb_build_object( 'operation', 'ERROR'::text, 'message', 'Source row has inconsistent temporal columns. Column ""' || 'valid_until' || '"" must be equal to column ""' || NULL || '"" + ' || NULL || '.' )                         WHEN s.is_eclipsed                         THEN jsonb_build_object( 'operation', 'SKIP_ECLIPSED'::text, 'message', 'Source row was eclipsed by row_ids=' || s.eclipsed_by::text || ' in the same batch.' )                         ELSE NULL                     END as early_feedback                 FROM source_rows_with_canonical_key s"
a8b,Process Legal Units - Batch 3,,4895990506256861755,10000,8.65462400000014,10000,0,0,0,0,0,0,0,SELECT array_agg(DISTINCT v)                    FROM unnest(from_sources) AS v
c63,Process Legal Units - Batch 3,,7743831913079285872,10000,7.250625000000107,10000,0,0,0,0,0,0,0,SELECT array_agg(DISTINCT v)                     FROM unnest(until_sources) AS v
c34,Process Legal Units - Batch 3,,1464568031695687146,150,0.7360439999999997,150,52,0,0,0,0,0,0,SELECT array_agg(command_tag)           FROM pg_event_trigger_ddl_commands()
e86,Process Legal Units - Batch 3,,-8708312726399770535,155,0.47046099999999924,155,0,0,0,0,0,0,0,"EXISTS (             SELECT 1 FROM pg_event_trigger_dropped_objects() dobj             WHERE dobj.object_type = 'table'               AND (dobj.schema_name, dobj.object_name) = (r.table_schema, r.table_name)         )"
3db,Process Legal Units - Batch 3,,-1465262961312880621,155,0.28265799999999963,155,465,0,0,0,0,0,0,"NOT EXISTS (                 SELECT FROM pg_catalog.pg_constraint AS c                 WHERE (c.conrelid, c.conname) = (r.table_oid, r.unique_constraint)             )"
aa1,Process Legal Units - Batch 3,,8008625629997484951,150,0.25999499999999975,0,0,0,0,0,0,0,0,SELECT * FROM pg_event_trigger_ddl_commands()
e26,Process Legal Units - Batch 3,,-8889318315713072803,155,0.034872000000000014,155,0,0,0,0,0,0,0,"r.exclude_constraint IS NOT NULL AND NOT EXISTS (             SELECT FROM pg_catalog.pg_constraint AS c             WHERE (c.conrelid, c.conname) = (r.table_oid, r.exclude_constraint)         )"
