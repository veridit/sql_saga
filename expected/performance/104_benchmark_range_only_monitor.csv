log_id,event,label,queryid,calls,total_exec_time,rows,shared_blks_hit,shared_blks_read,temp_blks_read,temp_blks_written,total_plan_time,wal_records,wal_bytes,query
0a0,Range-Only Child INSERT,,-1513128718422397264,1,34.639626,1000,19029,0,0,0,0,9032,886672,"INSERT INTO child_range_only (id, valid_range, parent_id, description) SELECT i, daterange('2015-01-01', 'infinity', '[)'), i, 'New Shop ' || i FROM generate_series(10001, 11000) i"
f92,Range-Only Child INSERT,,3801168477474623637,1000,6.909663999999998,1000,4000,0,0,0,0,1000,54000,"SELECT 1 FROM (SELECT ""valid_range"" AS r FROM ONLY ""public"".""parent_range_only"" x WHERE ""id"" OPERATOR(pg_catalog.=) $1 AND ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.&&) $2::pg_catalog.anyrange FOR KEY SHARE OF x) x1 HAVING   $2::pg_catalog.anyrange OPERATOR(pg_catalog.<@) pg_catalog.range_agg(x1.r)"
12d,Range-Only Child UPDATE Key,,2032682557053950028,1,31.435209,1000,26068,0,0,0,0,8057,690605,"UPDATE child_range_only SET valid_range = daterange('2014-01-01', upper(valid_range), '[)') WHERE id BETWEEN 1 AND 1000"
0a4,Range-Only Child UPDATE Key,,3801168477474623637,1000,8.09003199999999,1000,6000,0,0,0,0,1009,56740,"SELECT 1 FROM (SELECT ""valid_range"" AS r FROM ONLY ""public"".""parent_range_only"" x WHERE ""id"" OPERATOR(pg_catalog.=) $1 AND ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.&&) $2::pg_catalog.anyrange FOR KEY SHARE OF x) x1 HAVING   $2::pg_catalog.anyrange OPERATOR(pg_catalog.<@) pg_catalog.range_agg(x1.r)"
317,Range-Only Child UPDATE Non-Key,,-7180486638484984037,1,15.605083,1000,17669,0,0,0,0,6868,623914,UPDATE child_range_only SET description = 'Updated Shop' WHERE id BETWEEN 1001 AND 2000
4a1,Range-Only Parent DELETE (no children),,-4539091173828576470,1,10.941666,1000,4014,0,0,0,0,1000,54000,DELETE FROM parent_range_only WHERE id BETWEEN 20001 AND 21000
fff,Range-Only Parent DELETE (no children),,476854885423386359,1000,2.133202000000002,0,1000,0,0,0,0,0,0,"SELECT 1 FROM ONLY ""public"".""child_range_only"" x WHERE $1 OPERATOR(pg_catalog.=) ""parent_id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange AND NOT coalesce(  (  ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.*) $2::pg_catalog.anyrange)::pg_catalog.anyrange OPERATOR(pg_catalog.<@) (SELECT pg_catalog.range_agg(r) FROM (SELECT y.""valid_range"" r FROM ONLY ""public"".""parent_range_only"" y WHERE $1 OPERATOR(pg_catalog.=) ""id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange FOR KEY SHARE OF y) y2), false) FOR KEY SHARE OF x"
54a,Range-Only Parent INSERT,,6357836274575580935,1,20.177375,1000,12057,0,0,0,0,6024,597904,"INSERT INTO parent_range_only (id, valid_range, name) SELECT i, daterange('2015-01-01', 'infinity', '[)'), 'New Company ' || i FROM generate_series(20001, 21000) i"
68a,Range-Only Parent UPDATE Key,,1252438658754027224,1,42.749583,1000,26156,0,0,0,0,7040,610350,"UPDATE parent_range_only SET valid_range = daterange('2014-01-01', upper(valid_range), '[)') WHERE id BETWEEN 1 AND 1000"
60c,Range-Only Parent UPDATE Key,,476854885423386359,1000,13.22444999999997,0,8000,0,0,0,0,1000,54000,"SELECT 1 FROM ONLY ""public"".""child_range_only"" x WHERE $1 OPERATOR(pg_catalog.=) ""parent_id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange AND NOT coalesce(  (  ""valid_range""::pg_catalog.anyrange OPERATOR(pg_catalog.*) $2::pg_catalog.anyrange)::pg_catalog.anyrange OPERATOR(pg_catalog.<@) (SELECT pg_catalog.range_agg(r) FROM (SELECT y.""valid_range"" r FROM ONLY ""public"".""parent_range_only"" y WHERE $1 OPERATOR(pg_catalog.=) ""id"" AND $2::pg_catalog.anyrange OPERATOR(pg_catalog.&&) ""valid_range""::pg_catalog.anyrange FOR KEY SHARE OF y) y2), false) FOR KEY SHARE OF x"
2b5,Range-Only Parent UPDATE Non-Key,,-7028987207714112929,1,12.624791,1000,15566,0,0,0,0,5836,543920,UPDATE parent_range_only SET name = 'Updated Company' WHERE id BETWEEN 1001 AND 2000
676,Range-Only temporal_merge Child,,-7595264539849014562,1,346.953,0,151513,0,0,0,0,11492,1200204,"CALL sql_saga.temporal_merge('child_range_only'::regclass, 'child_source_range_only'::regclass, ARRAY['id'])"
369,Range-Only temporal_merge Child,,1373489420116108232,1,313.59662399999996,1000,128365,0,0,0,0,3928,475101,"INSERT INTO temporal_merge_plan     SELECT * FROM sql_saga.temporal_merge_plan(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         identity_columns => v_identity_cols_discovered,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         delete_mode => temporal_merge.delete_mode,         lookup_keys => v_natural_identity_keys_discovered,         ephemeral_columns => temporal_merge.ephemeral_columns,         p_log_trace => v_log_trace,         p_log_sql => v_log_sql     )"
f43,Range-Only temporal_merge Child,,4748073848864616921,1,91.097625,1000,705,0,0,0,0,124,14141,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.lookup_columns_unavailable, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON (target_row.id = seg.id OR (target_row.id IS NULL AND seg.id IS NULL))                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                 WHERE NOT seg.is_new_entity"
697,Range-Only temporal_merge Child,,-4685191513584255900,1,90.54929200000001,1000,315,0,0,0,0,124,14141,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.lookup_columns_unavailable, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON (target_row.id = seg.id OR (target_row.id IS NULL AND seg.id IS NULL))                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                 WHERE NOT seg.is_new_entity"
f7d,Range-Only temporal_merge Child,,938093246872844266,1,75.366667,1000,101771,0,0,0,0,102,11171,"CREATE TEMP TABLE target_rows ON COMMIT DROP AS                 SELECT                     id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ -- (non-temporal identity columns)                     lower(t.valid_range) as valid_from, -- The temporal identity column (e.g., valid_from)                     NULL::integer /* v_causal_column_type */ as causal_id, -- Target rows do not originate from a source row, so causal_id is NULL. Type is introspected.                     jsonb_build_object('id', id) /* v_stable_pk_cols_jsonb_build_bare */ as stable_pk_payload,                     upper(t.valid_range) as valid_until,                     jsonb_build_object('parent_id', parent_id, 'description', description) /* v_target_data_cols_jsonb_build_bare */ AS data_payload,                     jsonb_build_object() /* v_target_ephemeral_cols_jsonb_build_bare */ AS ephemeral_payload,                     jsonb_strip_nulls(jsonb_build_object('id', t.id)) /* v_target_nk_json_expr */ AS canonical_nk_json                 FROM (                         SELECT * FROM (                             SELECT DISTINCT ON (u.id, u.valid_range) * FROM (                                 (                                         SELECT DISTINCT ON (inner_t.id, inner_t.valid_range) inner_t.*                                         FROM child_range_only inner_t                                         JOIN (SELECT DISTINCT si.id FROM source_initial si) AS si ON ((si.id = inner_t.id OR (si.id IS NULL AND inner_t.id IS NULL)))                                     )                             ) u                         )                     ) AS t  /* v_target_rows_filter */"
8e2,Range-Only temporal_merge Child,,-452145526644945551,1,74.514792,1000,101274,0,0,0,0,102,11171,"CREATE TEMP TABLE target_rows ON COMMIT DROP AS                 SELECT                     id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ -- (non-temporal identity columns)                     lower(t.valid_range) as valid_from, -- The temporal identity column (e.g., valid_from)                     NULL::integer /* v_causal_column_type */ as causal_id, -- Target rows do not originate from a source row, so causal_id is NULL. Type is introspected.                     jsonb_build_object('id', id) /* v_stable_pk_cols_jsonb_build_bare */ as stable_pk_payload,                     upper(t.valid_range) as valid_until,                     jsonb_build_object('parent_id', parent_id, 'description', description) /* v_target_data_cols_jsonb_build_bare */ AS data_payload,                     jsonb_build_object() /* v_target_ephemeral_cols_jsonb_build_bare */ AS ephemeral_payload,                     jsonb_strip_nulls(jsonb_build_object('id', t.id)) /* v_target_nk_json_expr */ AS canonical_nk_json                 FROM (                         SELECT * FROM (                             SELECT DISTINCT ON (u.id, u.valid_range) * FROM (                                 (                                         SELECT DISTINCT ON (inner_t.id, inner_t.valid_range) inner_t.*                                         FROM child_range_only inner_t                                         JOIN (SELECT DISTINCT si.id FROM source_initial si) AS si ON ((si.id = inner_t.id OR (si.id IS NULL AND inner_t.id IS NULL)))                                     )                             ) u                         )                     ) AS t  /* v_target_rows_filter */"
9f3,Range-Only temporal_merge Child,,8922240738035296592,1,34.076416,1000,793,0,0,0,0,118,16905,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         -- OPTIMIZATION: Use pre-computed valid_range instead of repeated daterange() calls                         -- Combined with composite index, this provides 30-40 percent total performance improvement                         COALESCE(sql_saga.covers_without_gaps(s2.valid_range, s1.valid_range ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.lookup_columns_unavailable AND (s1.id IS NOT DISTINCT FROM s2.id))                             OR                             (s1.lookup_columns_unavailable AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info"
31c,Range-Only temporal_merge Child,,5457955885903029372,1,33.469331999999994,1000,304,0,0,0,0,118,16905,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         -- OPTIMIZATION: Use pre-computed valid_range instead of repeated daterange() calls                         -- Combined with composite index, this provides 30-40 percent total performance improvement                         COALESCE(sql_saga.covers_without_gaps(s2.valid_range, s1.valid_range ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.lookup_columns_unavailable AND (s1.id IS NOT DISTINCT FROM s2.id))                             OR                             (s1.lookup_columns_unavailable AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info;"
9e7,Range-Only temporal_merge Child,,-4194607882899746148,1,30.9455,0,21658,0,0,0,0,7384,705584,"CALL sql_saga.temporal_merge_execute(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         identity_columns => v_identity_cols_discovered,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         update_source_with_identity => temporal_merge.update_source_with_identity,         lookup_columns => v_natural_identity_cols_discovered,         delete_mode => temporal_merge.delete_mode,         update_source_with_feedback => temporal_merge.update_source_with_feedback,         feedback_status_column => temporal_merge.feedback_status_column,         feedback_status_key => temporal_merge.feedback_status_key,         feedback_error_column => temporal_merge.feedback_error_column,         feedback_error_key => temporal_merge.feedback_error_key,         ephemeral_columns => temporal_merge.ephemeral_columns,         delay_constraints => temporal_merge.delay_constraints     )"
74a,Range-Only temporal_merge Child,,-7332693483277434140,1,18.690208,1000,18195,0,0,0,0,7065,660818,"UPDATE child_range_only t SET valid_range = p.new_valid_range::daterange, parent_id = CASE WHEN p.data ? 'parent_id' THEN (p.data->>'parent_id')::integer ELSE t.parent_id END, description = CASE WHEN p.data ? 'description' THEN (p.data->>'description')::text ELSE t.description END                                 FROM (SELECT *, (entity_keys->>'id')::integer AS id_ek FROM temporal_merge_plan WHERE operation = 'UPDATE' AND statement_seq = 1 ORDER BY plan_op_seq) p                                 WHERE t.id = p.id_ek AND t.valid_range = p.old_valid_range::daterange"
f0d,Range-Only temporal_merge Parent,,-7595264539849014562,1,574.12325,0,236328,0,0,0,0,10600,1119848,"CALL sql_saga.temporal_merge('parent_range_only'::regclass, 'parent_source_range_only'::regclass, ARRAY['id'])"
e03,Range-Only temporal_merge Parent,,1373489420116108232,1,537.3384169999999,1000,215912,0,0,0,0,4054,489239,"INSERT INTO temporal_merge_plan     SELECT * FROM sql_saga.temporal_merge_plan(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         identity_columns => v_identity_cols_discovered,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         delete_mode => temporal_merge.delete_mode,         lookup_keys => v_natural_identity_keys_discovered,         ephemeral_columns => temporal_merge.ephemeral_columns,         p_log_trace => v_log_trace,         p_log_sql => v_log_sql     )"
566,Range-Only temporal_merge Parent,,-6321891686248247437,1,166.987917,1000,791,0,0,0,0,139,16055,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     with_base_payload.*,                     with_base_payload.stable_pk_payload as propagated_stable_pk_payload                 FROM (                     SELECT                         seg.*, source_payloads.source_row_id, source_payloads.contributing_row_ids,                          source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                         source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until                     FROM all_segments seg                                              LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE                  ((seg.is_new_entity AND source_row.grouping_key = seg.grouping_key)                 OR                 (NOT seg.is_new_entity AND (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))))              -- v_lateral_join_sr_to_seg                                 AND daterange(seg.valid_from, seg.valid_until) <@ daterange(source_row.valid_from, source_row.valid_until)                             ),                             running_payload AS (                                 SELECT rn, source_row_id, data_payload, ephemeral_payload, valid_from, val"
2d0,Range-Only temporal_merge Parent,,8979876263928444268,1,166.081541,1000,344,0,0,0,0,139,16055,"CREATE TEMP TABLE resolved_atomic_segments_with_payloads ON COMMIT DROP AS                 WITH all_segments AS (                     SELECT * FROM existing_segments_with_target                     UNION ALL                     SELECT * FROM new_segments_no_target                 )                 SELECT                     with_base_payload.*,                     with_base_payload.stable_pk_payload as propagated_stable_pk_payload                 FROM (                     SELECT                         seg.*, source_payloads.source_row_id, source_payloads.contributing_row_ids,                          source_payloads.data_payload as s_data_payload, source_payloads.ephemeral_payload as s_ephemeral_payload,                         source_payloads.valid_from AS s_valid_from, source_payloads.valid_until AS s_valid_until                     FROM all_segments seg                                              LEFT JOIN LATERAL (                             WITH RECURSIVE ordered_sources AS (                                 SELECT                                     source_row.source_row_id, source_row.data_payload, source_row.ephemeral_payload,                                     source_row.valid_from, source_row.valid_until, source_row.causal_id,                                     row_number() OVER (ORDER BY source_row.source_row_id) as rn                                 FROM active_source_rows source_row                                 WHERE                  ((seg.is_new_entity AND source_row.grouping_key = seg.grouping_key)                 OR                 (NOT seg.is_new_entity AND (source_row.id = seg.id OR (source_row.id IS NULL AND seg.id IS NULL))))              -- v_lateral_join_sr_to_seg                                 AND daterange(seg.valid_from, seg.valid_until) <@ daterange(source_row.valid_from, source_row.valid_until)                             ),                             running_payload AS (                                 SELECT rn, source_row_id, data_payload, ephemeral_payload, valid_from, val"
dc9,Range-Only temporal_merge Parent,,-5236651202162387398,1,131.853292,1000,189666,0,0,0,0,102,11171,"CREATE TEMP TABLE target_rows ON COMMIT DROP AS                 SELECT                     id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ -- (non-temporal identity columns)                     lower(t.valid_range) as valid_from, -- The temporal identity column (e.g., valid_from)                     NULL::integer /* v_causal_column_type */ as causal_id, -- Target rows do not originate from a source row, so causal_id is NULL. Type is introspected.                     jsonb_build_object('id', id) /* v_stable_pk_cols_jsonb_build_bare */ as stable_pk_payload,                     upper(t.valid_range) as valid_until,                     jsonb_build_object('name', name) /* v_target_data_cols_jsonb_build_bare */ AS data_payload,                     jsonb_build_object() /* v_target_ephemeral_cols_jsonb_build_bare */ AS ephemeral_payload,                     jsonb_strip_nulls(jsonb_build_object('id', t.id)) /* v_target_nk_json_expr */ AS canonical_nk_json                 FROM (                         SELECT * FROM (                             SELECT DISTINCT ON (u.id, u.valid_range) * FROM (                                 (                                         SELECT DISTINCT ON (inner_t.id, inner_t.valid_range) inner_t.*                                         FROM parent_range_only inner_t                                         JOIN (SELECT DISTINCT si.id FROM source_initial si) AS si ON ((si.id = inner_t.id OR (si.id IS NULL AND inner_t.id IS NULL)))                                     )                             ) u                         )                     ) AS t  /* v_target_rows_filter */"
f9a,Range-Only temporal_merge Parent,,-1895039853511623566,1,131.089541,1000,189272,0,0,0,0,102,11171,"CREATE TEMP TABLE target_rows ON COMMIT DROP AS                 SELECT                     id,  /* v_non_temporal_lookup_cols_select_list_no_alias_prefix */ -- (non-temporal identity columns)                     lower(t.valid_range) as valid_from, -- The temporal identity column (e.g., valid_from)                     NULL::integer /* v_causal_column_type */ as causal_id, -- Target rows do not originate from a source row, so causal_id is NULL. Type is introspected.                     jsonb_build_object('id', id) /* v_stable_pk_cols_jsonb_build_bare */ as stable_pk_payload,                     upper(t.valid_range) as valid_until,                     jsonb_build_object('name', name) /* v_target_data_cols_jsonb_build_bare */ AS data_payload,                     jsonb_build_object() /* v_target_ephemeral_cols_jsonb_build_bare */ AS ephemeral_payload,                     jsonb_strip_nulls(jsonb_build_object('id', t.id)) /* v_target_nk_json_expr */ AS canonical_nk_json                 FROM (                         SELECT * FROM (                             SELECT DISTINCT ON (u.id, u.valid_range) * FROM (                                 (                                         SELECT DISTINCT ON (inner_t.id, inner_t.valid_range) inner_t.*                                         FROM parent_range_only inner_t                                         JOIN (SELECT DISTINCT si.id FROM source_initial si) AS si ON ((si.id = inner_t.id OR (si.id IS NULL AND inner_t.id IS NULL)))                                     )                             ) u                         )                     ) AS t  /* v_target_rows_filter */"
df5,Range-Only temporal_merge Parent,,4748073848864616921,1,91.413458,1000,712,0,0,0,0,130,15415,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.lookup_columns_unavailable, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON (target_row.id = seg.id OR (target_row.id IS NULL AND seg.id IS NULL))                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                 WHERE NOT seg.is_new_entity"
fb5,Range-Only temporal_merge Parent,,-4685191513584255900,1,90.89966700000001,1000,328,0,0,0,0,130,15415,"CREATE TEMP TABLE existing_segments_with_target ON COMMIT DROP AS                 SELECT                     seg.grouping_key, seg.canonical_nk_json, seg.id, seg.causal_id, seg.is_new_entity, seg.is_identifiable, seg.is_ambiguous, seg.conflicting_ids, seg.stable_identity_columns_are_null, seg.lookup_columns_unavailable, seg.valid_from, seg.valid_until,                     target_row.valid_from as t_valid_from, target_row.valid_until as t_valid_until,                     target_row.data_payload as t_data_payload, target_row.ephemeral_payload as t_ephemeral_payload, seg.stable_pk_payload,                      target_row.stable_pk_payload as target_stable_pk_payload,                     NULL::jsonb as trace                 FROM atomic_segments seg                 LEFT JOIN target_rows target_row                      ON (target_row.id = seg.id OR (target_row.id IS NULL AND seg.id IS NULL))                      AND daterange(seg.valid_from, seg.valid_until) <@ daterange(target_row.valid_from, target_row.valid_until)                 WHERE NOT seg.is_new_entity"
29b,Range-Only temporal_merge Parent,,-4194607882899746148,1,34.193292,0,19360,0,0,0,0,6364,610139,"CALL sql_saga.temporal_merge_execute(         target_table => temporal_merge.target_table,         source_table => temporal_merge.source_table,         identity_columns => v_identity_cols_discovered,         mode => temporal_merge.mode,         era_name => temporal_merge.era_name,         row_id_column => temporal_merge.row_id_column,         founding_id_column => temporal_merge.founding_id_column,         update_source_with_identity => temporal_merge.update_source_with_identity,         lookup_columns => v_natural_identity_cols_discovered,         delete_mode => temporal_merge.delete_mode,         update_source_with_feedback => temporal_merge.update_source_with_feedback,         feedback_status_column => temporal_merge.feedback_status_column,         feedback_status_key => temporal_merge.feedback_status_key,         feedback_error_column => temporal_merge.feedback_error_column,         feedback_error_key => temporal_merge.feedback_error_key,         ephemeral_columns => temporal_merge.ephemeral_columns,         delay_constraints => temporal_merge.delay_constraints     )"
b87,Range-Only temporal_merge Parent,,8922240738035296592,1,34.142042,1000,773,0,0,0,0,118,13161,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         -- OPTIMIZATION: Use pre-computed valid_range instead of repeated daterange() calls                         -- Combined with composite index, this provides 30-40 percent total performance improvement                         COALESCE(sql_saga.covers_without_gaps(s2.valid_range, s1.valid_range ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.lookup_columns_unavailable AND (s1.id IS NOT DISTINCT FROM s2.id))                             OR                             (s1.lookup_columns_unavailable AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info"
cee,Range-Only temporal_merge Parent,,5457955885903029372,1,33.502833,1000,300,0,0,0,0,117,13095,"CREATE TEMP TABLE source_with_eclipsed_flag ON COMMIT DROP AS                 SELECT                     s1.*,                     eclipse_info.is_eclipsed,                     eclipse_info.eclipsed_by                 FROM source_initial s1                 CROSS JOIN LATERAL (                     SELECT                         -- OPTIMIZATION: Use pre-computed valid_range instead of repeated daterange() calls                         -- Combined with composite index, this provides 30-40 percent total performance improvement                         COALESCE(sql_saga.covers_without_gaps(s2.valid_range, s1.valid_range ORDER BY s2.valid_from), false) as is_eclipsed,                         array_agg(s2.source_row_id) as eclipsed_by                     FROM source_initial s2                     WHERE                         (                             (NOT s1.lookup_columns_unavailable AND (s1.id IS NOT DISTINCT FROM s2.id))                             OR                             (s1.lookup_columns_unavailable AND s1.causal_id = s2.causal_id)                         )                         AND                         -- Only consider newer rows (higher row_id) as potential eclipsers.                         s2.source_row_id > s1.source_row_id                 ) eclipse_info;"
381,Range-Only temporal_merge Parent,,-9126043828788570536,1,18.863582,1000,16230,0,0,0,0,6037,561298,"UPDATE parent_range_only t SET valid_range = p.new_valid_range::daterange, name = CASE WHEN p.data ? 'name' THEN (p.data->>'name')::character varying ELSE t.name END                                 FROM (SELECT *, (entity_keys->>'id')::integer AS id_ek FROM temporal_merge_plan WHERE operation = 'UPDATE' AND statement_seq = 1 ORDER BY plan_op_seq) p                                 WHERE t.id = p.id_ek AND t.valid_range = p.old_valid_range::daterange"
