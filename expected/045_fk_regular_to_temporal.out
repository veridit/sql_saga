--
-- Test for regular-to-temporal foreign keys
--
-- The test covers the full lifecycle of the feature:
-- 1. Create a temporal table and a regular table.
-- 2. Add a unique key to the temporal table.
-- 3. Add a regular-to-temporal foreign key.
-- 4. Verify that INSERT/UPDATE on the regular table is validated.
-- 5. Verify that UPDATE/DELETE on the temporal table is restricted.
-- 6. Verify DDL protection (e.g., DROP of tables, functions, constraints).
-- 7. Verify rename_following logic for tables and columns.
-- 8. Drop the foreign key.
-- 9. Verify that restrictions are removed.
--
\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
-- 1. Create a temporal table and a regular table.
CREATE TABLE temporal_pk (
    id integer NOT NULL,
    name text,
    valid_from date,
    valid_until date
);
CREATE TABLE regular_fk (
    id integer PRIMARY KEY,
    pk_id integer,
    name text
);
-- 2. Add a unique key to the temporal table.
SELECT sql_saga.add_era('temporal_pk', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

-- Provide an explicit name for the unique key to make it easy to reference
SELECT sql_saga.add_unique_key(
    table_oid => 'temporal_pk',
    column_names => ARRAY['id'],
    unique_key_name => 'temporal_pk_id_key'
);
   add_unique_key   
--------------------
 temporal_pk_id_key
(1 row)

-- 3. Add a regular-to-temporal foreign key.
SELECT sql_saga.add_regular_foreign_key(
    fk_table_oid => 'regular_fk',
    fk_column_names => ARRAY['pk_id'],
    unique_key_name => 'temporal_pk_id_key'
);
 add_regular_foreign_key 
-------------------------
 regular_fk_pk_id_fkey
(1 row)

-- Verify helper function and CHECK constraint were created
\echo

\echo "--- After add_regular_foreign_key ---"
"--- After add_regular_foreign_key ---"
-- The helper function should be in the schema of the referenced table and have a predictable name.
\df+ public.temporal_pk_id_exists
                                                                                   List of functions
 Schema |         Name          | Result data type | Argument data types | Type | Volatility | Parallel | Owner | Security | Access privileges | Language | Internal name | Description 
--------+-----------------------+------------------+---------------------+------+------------+----------+-------+----------+-------------------+----------+---------------+-------------
 public | temporal_pk_id_exists | boolean          | integer             | func | stable     | unsafe   | jhf   | invoker  |                   | sql      |               | 
(1 row)

-- The CHECK constraint should be on the regular_fk table
\d regular_fk
             Table "public.regular_fk"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 id     | integer |           | not null | 
 pk_id  | integer |           |          | 
 name   | text    |           |          | 
Indexes:
    "regular_fk_pkey" PRIMARY KEY, btree (id)
Check constraints:
    "regular_fk_pk_id_check" CHECK (temporal_pk_id_exists(pk_id))

-- 4. Verify that INSERT/UPDATE on the regular table is validated.
\echo

\echo "--- DML Validation ---"
"--- DML Validation ---"
-- First, insert a valid row into the referenced temporal table
INSERT INTO temporal_pk (id, name, valid_from, valid_until)
VALUES (1, 'Entity One', '2023-01-01', 'infinity');
-- Test valid INSERTs
INSERT INTO regular_fk (id, pk_id, name) VALUES (101, 1, 'Link to Entity One');
INSERT INTO regular_fk (id, pk_id, name) VALUES (102, NULL, 'No link');
TABLE regular_fk ORDER BY id;
 id  | pk_id |        name        
-----+-------+--------------------
 101 |     1 | Link to Entity One
 102 |       | No link
(2 rows)

-- Test invalid INSERT
-- This should fail because pk_id=2 does not exist in temporal_pk
SAVEPOINT before_invalid_insert;
INSERT INTO regular_fk (id, pk_id, name) VALUES (103, 2, 'Link to non-existent');
ERROR:  new row for relation "regular_fk" violates check constraint "regular_fk_pk_id_check"
DETAIL:  Failing row contains (103, 2, Link to non-existent).
ROLLBACK TO SAVEPOINT before_invalid_insert;
-- Test valid UPDATE
UPDATE regular_fk SET pk_id = 1 WHERE id = 102;
TABLE regular_fk ORDER BY id;
 id  | pk_id |        name        
-----+-------+--------------------
 101 |     1 | Link to Entity One
 102 |     1 | No link
(2 rows)

-- Test invalid UPDATE
-- This should fail because pk_id=2 does not exist in temporal_pk
SAVEPOINT before_invalid_update;
UPDATE regular_fk SET pk_id = 2 WHERE id = 101;
ERROR:  new row for relation "regular_fk" violates check constraint "regular_fk_pk_id_check"
DETAIL:  Failing row contains (101, 2, Link to Entity One).
ROLLBACK TO SAVEPOINT before_invalid_update;
TABLE regular_fk ORDER BY id;
 id  | pk_id |        name        
-----+-------+--------------------
 101 |     1 | Link to Entity One
 102 |     1 | No link
(2 rows)

-- 5. Verify that UPDATE/DELETE on the temporal table is restricted.
\echo

\echo "--- UK Trigger Validation ---"
"--- UK Trigger Validation ---"
-- Test that a DELETE on the referenced table is blocked
SAVEPOINT before_uk_delete;
-- This should fail because regular_fk.pk_id = 1 references this row.
DELETE FROM temporal_pk WHERE id = 1;
ERROR:  update or delete on table "public.temporal_pk" violates foreign key constraint "regular_fk_pk_id_fkey" on table "public.regular_fk"
ROLLBACK TO SAVEPOINT before_uk_delete;
-- Test that an UPDATE of the referenced key is blocked
SAVEPOINT before_uk_update;
-- This should fail because it would orphan the reference from regular_fk.
UPDATE temporal_pk SET id = 2 WHERE id = 1;
ERROR:  update or delete on table "public.temporal_pk" violates foreign key constraint "regular_fk_pk_id_fkey" on table "public.regular_fk"
ROLLBACK TO SAVEPOINT before_uk_update;
-- Test that an UPDATE of a non-key column is allowed
UPDATE temporal_pk SET name = 'Entity One Updated' WHERE id = 1;
TABLE temporal_pk;
 id |        name        | valid_from | valid_until 
----+--------------------+------------+-------------
  1 | Entity One Updated | 2023-01-01 | infinity
(1 row)

-- Verify the row in regular_fk is unchanged
TABLE regular_fk ORDER BY id;
 id  | pk_id |        name        
-----+-------+--------------------
 101 |     1 | Link to Entity One
 102 |     1 | No link
(2 rows)

-- 6. Verify DDL protection
\echo

\echo "--- DDL Protection ---"
"--- DDL Protection ---"
SAVEPOINT before_ddl;
-- This should fail because the FK helper function depends on the table
DROP TABLE temporal_pk;
ROLLBACK TO SAVEPOINT before_ddl;
SAVEPOINT before_ddl2;
-- This should fail because the CHECK constraint depends on the helper function
DROP FUNCTION public.temporal_pk_id_exists(integer);
ERROR:  cannot drop function temporal_pk_id_exists(integer) because other objects depend on it
DETAIL:  constraint regular_fk_pk_id_check on table regular_fk depends on function temporal_pk_id_exists(integer)
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
ROLLBACK TO SAVEPOINT before_ddl2;
-- 8. Drop the foreign key
\echo

\echo "--- Drop Foreign Key ---"
"--- Drop Foreign Key ---"
SELECT sql_saga.drop_foreign_key('regular_fk'::regclass, ARRAY['pk_id']);
 drop_foreign_key 
------------------
 
(1 row)

-- 9. Verify that restrictions are removed.
\echo

\echo "--- Verify Restrictions Removed ---"
"--- Verify Restrictions Removed ---"
-- Deleting from temporal_pk should now succeed
DELETE FROM temporal_pk WHERE id = 1;
TABLE temporal_pk;
 id | name | valid_from | valid_until 
----+------+------------+-------------
(0 rows)

-- The helper function and CHECK constraint should be gone
\df+ public.temporal_pk_id_exists
                                                                           List of functions
 Schema | Name | Result data type | Argument data types | Type | Volatility | Parallel | Owner | Security | Access privileges | Language | Internal name | Description 
--------+------+------------------+---------------------+------+------------+----------+-------+----------+-------------------+----------+---------------+-------------
(0 rows)

\d regular_fk
             Table "public.regular_fk"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 id     | integer |           | not null | 
 pk_id  | integer |           |          | 
 name   | text    |           |          | 
Indexes:
    "regular_fk_pkey" PRIMARY KEY, btree (id)

-- 7. Verify rename_following logic is NOT implemented for this FK type yet.
-- This is a known limitation. Event triggers do not yet track CHECK constraints
-- or helper functions. This can be addressed in a future task.
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
