\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
CREATE SCHEMA repro;
-- 1. Define the target temporal table with an ephemeral column
CREATE TABLE repro.units (
    id int GENERATED BY DEFAULT AS IDENTITY,
    org_nr text NOT NULL,
    name text,
    activity_code text,
    edit_comment text, -- This is an ephemeral column
    valid_from date NOT NULL,
    valid_until date
);
SELECT sql_saga.add_era('repro.units');
 add_era 
---------
 t
(1 row)

-- A composite primary key is required for SCD Type 2 history. The temporal columns
-- are added automatically by the function.
SELECT sql_saga.add_unique_key('repro.units', ARRAY['id'], key_type => 'primary');
 add_unique_key 
----------------
 units_id_valid
(1 row)

SELECT sql_saga.add_unique_key('repro.units', ARRAY['org_nr'], key_type => 'natural');
   add_unique_key   
--------------------
 units_org_nr_valid
(1 row)

-- 2. Define the source table for data loading
CREATE TEMP TABLE source_units (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    org_nr text,
    name text,
    activity_code text,
    edit_comment text,
    -- These columns are set per-batch
    valid_from date,
    valid_until date,
    id int -- for the stable key
) ON COMMIT DROP;
-- Wrapper procedure to simplify the test loop
CREATE PROCEDURE repro.load_data(p_valid_from date, p_valid_until date)
LANGUAGE plpgsql AS $$
BEGIN
    UPDATE source_units SET valid_from = p_valid_from, valid_until = p_valid_until;
    RAISE NOTICE '--- Loading data for period [%, %) ---', p_valid_from, p_valid_until;

    CALL sql_saga.temporal_merge(
        target_table => 'repro.units',
        source_table => 'source_units',
        identity_columns => ARRAY['id'],
        natural_identity_columns => ARRAY['org_nr'],
        ephemeral_columns => ARRAY['edit_comment'],
        mode => 'MERGE_ENTITY_UPSERT',
        delete_mode => 'NONE'
    );
END;
$$;
-- 3. Load 2016 data: Establishes the initial state
SAVEPOINT load_2016;
TRUNCATE source_units RESTART IDENTITY;
INSERT INTO source_units (org_nr, name, activity_code, edit_comment) VALUES
    ('111', 'Unit A', '10.0', '2016 Load'), -- Will change in 2017
    ('222', 'Unit B', '30.0', '2016 Load'), -- Will be identical in 2017
    ('333', 'Unit C', '40.0', '2016 Load'); -- Will have ephemeral change in 2017
CALL repro.load_data('2016-01-01', '2017-01-01');
NOTICE:  --- Loading data for period [2016-01-01, 2017-01-01) ---
\echo '--- State after 2016 load ---'
--- State after 2016 load ---
SELECT org_nr, name, activity_code, edit_comment, valid_from, valid_until
FROM repro.units ORDER BY org_nr, valid_from;
 org_nr |  name  | activity_code | edit_comment | valid_from | valid_until 
--------+--------+---------------+--------------+------------+-------------
 111    | Unit A | 10.0          | 2016 Load    | 2016-01-01 | 2017-01-01
 222    | Unit B | 30.0          | 2016 Load    | 2016-01-01 | 2017-01-01
 333    | Unit C | 40.0          | 2016 Load    | 2016-01-01 | 2017-01-01
(3 rows)

RELEASE SAVEPOINT load_2016;
-- 4. Load 2017 data: Should trigger various changes
SAVEPOINT load_2017;
TRUNCATE source_units RESTART IDENTITY;
INSERT INTO source_units (org_nr, name, activity_code, edit_comment) VALUES
    ('111', 'Unit A', '20.0', '2017 Load'), -- Data changed -> new slice
    ('222', 'Unit B', '30.0', '2017 Load'), -- Identical data -> should coalesce
    ('333', 'Unit C', '40.0', '2017 Load (comment changed)'); -- Ephemeral change -> should update in place
CALL repro.load_data('2017-01-01', '2018-01-01');
NOTICE:  --- Loading data for period [2017-01-01, 2018-01-01) ---
\echo '--- State after 2017 load ---'
--- State after 2017 load ---
SELECT org_nr, name, activity_code, edit_comment, valid_from, valid_until
FROM repro.units ORDER BY org_nr, valid_from;
 org_nr |  name  | activity_code |        edit_comment         | valid_from | valid_until 
--------+--------+---------------+-----------------------------+------------+-------------
 111    | Unit A | 10.0          | 2016 Load                   | 2016-01-01 | 2017-01-01
 111    | Unit A | 20.0          | 2017 Load                   | 2017-01-01 | 2018-01-01
 222    | Unit B | 30.0          | 2017 Load                   | 2016-01-01 | 2018-01-01
 333    | Unit C | 40.0          | 2017 Load (comment changed) | 2016-01-01 | 2018-01-01
(4 rows)

RELEASE SAVEPOINT load_2017;
-- 5. Load 2018 data: The final, open-ended period
SAVEPOINT load_2018;
TRUNCATE source_units RESTART IDENTITY;
INSERT INTO source_units (org_nr, name, activity_code, edit_comment) VALUES
    ('111', 'Unit A', '20.0', '2018 Load'), -- Identical to 2017 -> should coalesce
    ('222', 'Unit B', '30.0', '2018 Load'), -- Identical to 2016/2017 -> should coalesce
    ('333', 'Unit C', '50.0', '2018 Load'); -- Data changed -> new slice
CALL repro.load_data('2018-01-01', 'infinity');
NOTICE:  --- Loading data for period [2018-01-01, infinity) ---
\echo '--- Final state after 2018 load (BUG REPRODUCED HERE) ---'
--- Final state after 2018 load (BUG REPRODUCED HERE) ---
RELEASE SAVEPOINT load_2018;
-- 6. Final verification: Check the complete history
-- Expected for Unit A ('111'): 2 rows. One for 2016, one for [2017, infinity)
-- Expected for Unit B ('222'): 1 row for [2016, infinity)
-- Expected for Unit C ('333'): 2 rows. One for [2016, 2018), one for [2018, infinity)
-- The bug will likely manifest as extra, un-coalesced rows.
SELECT org_nr, name, activity_code, edit_comment, valid_from, valid_until
FROM repro.units
ORDER BY org_nr, valid_from;
 org_nr |  name  | activity_code |        edit_comment         | valid_from | valid_until 
--------+--------+---------------+-----------------------------+------------+-------------
 111    | Unit A | 10.0          | 2016 Load                   | 2016-01-01 | 2017-01-01
 111    | Unit A | 20.0          | 2018 Load                   | 2017-01-01 | infinity
 222    | Unit B | 30.0          | 2018 Load                   | 2016-01-01 | infinity
 333    | Unit C | 40.0          | 2017 Load (comment changed) | 2016-01-01 | 2018-01-01
 333    | Unit C | 50.0          | 2018 Load                   | 2018-01-01 | infinity
(5 rows)

ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
