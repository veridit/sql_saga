\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
CREATE SCHEMA pk_consistency;
-- This test verifies the `enforce_consistency_with_primary_key` functionality of add_unique_key.
-- This feature adds a non-temporal EXCLUDE constraint to enforce that a natural
-- key value is permanently bound to a single primary key value throughout history.
-- Scenario 1: PK added first, then NK (default enforcement)
\echo --- Scenario 1: PK then NK (default) ---
--- Scenario 1: PK then NK (default) ---
SAVEPOINT s1;
CREATE TABLE pk_consistency.pk_first (
    id int GENERATED BY DEFAULT AS IDENTITY,
    natural_key text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.pk_first');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.pk_first', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table pk_consistency.pk_first to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_from) DEFERRABLE, ADD CONSTRAINT pk_first_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
  add_unique_key   
-------------------
 pk_first_id_valid
(1 row)

TABLE sql_saga.unique_keys;
  unique_key_name  |  table_schema  | table_name | key_type | column_names | era_name | unique_constraint |   exclude_constraint   | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
-------------------+----------------+------------+----------+--------------+----------+-------------------+------------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
 pk_first_id_valid | pk_consistency | pk_first   | primary  | {id}         | valid    | pk_first_pkey     | pk_first_id_valid_excl |                  |           |                            |                     |                                  | 
(1 row)

\echo '--- Constraints after PK only ---'
--- Constraints after PK only ---
\d pk_consistency.pk_first
                         Table "pk_consistency.pk_first"
   Column    |  Type   | Collation | Nullable |             Default              
-------------+---------+-----------+----------+----------------------------------
 id          | integer |           | not null | generated by default as identity
 natural_key | text    |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 'infinity'::date
Indexes:
    "pk_first_pkey" PRIMARY KEY, btree (id, valid_from) DEFERRABLE
    "pk_first_id_idx" btree (id)
    "pk_first_id_valid_excl" EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
Check constraints:
    "pk_first_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

SELECT sql_saga.add_unique_key('pk_consistency.pk_first', ARRAY['natural_key']); -- Use default enforcement
NOTICE:  sql_saga: altering table pk_consistency.pk_first to add constraints: ADD CONSTRAINT pk_first_natural_key_valid_uniq UNIQUE (natural_key, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT pk_first_natural_key_valid_excl EXCLUDE USING gist (natural_key WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE, ADD CONSTRAINT pk_first_natural_key_valid_pk_consistency_excl EXCLUDE USING gist (natural_key WITH =, id WITH <>)
       add_unique_key       
----------------------------
 pk_first_natural_key_valid
(1 row)

TABLE sql_saga.unique_keys;
      unique_key_name       |  table_schema  | table_name | key_type | column_names  | era_name |        unique_constraint        |       exclude_constraint        | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names |         pk_consistency_constraint_names          
----------------------------+----------------+------------+----------+---------------+----------+---------------------------------+---------------------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+--------------------------------------------------
 pk_first_id_valid          | pk_consistency | pk_first   | primary  | {id}          | valid    | pk_first_pkey                   | pk_first_id_valid_excl          |                  |           |                            |                     |                                  | 
 pk_first_natural_key_valid | pk_consistency | pk_first   | natural  | {natural_key} | valid    | pk_first_natural_key_valid_uniq | pk_first_natural_key_valid_excl |                  |           |                            |                     |                                  | {pk_first_natural_key_valid_pk_consistency_excl}
(2 rows)

\echo '--- Constraints after NK ---'
--- Constraints after NK ---
\d pk_consistency.pk_first
                         Table "pk_consistency.pk_first"
   Column    |  Type   | Collation | Nullable |             Default              
-------------+---------+-----------+----------+----------------------------------
 id          | integer |           | not null | generated by default as identity
 natural_key | text    |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 'infinity'::date
Indexes:
    "pk_first_pkey" PRIMARY KEY, btree (id, valid_from) DEFERRABLE
    "pk_first_id_idx" btree (id)
    "pk_first_id_valid_excl" EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "pk_first_natural_key_idx" btree (natural_key)
    "pk_first_natural_key_valid_excl" EXCLUDE USING gist (natural_key WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "pk_first_natural_key_valid_pk_consistency_excl" EXCLUDE USING gist (natural_key WITH =, id WITH <>)
    "pk_first_natural_key_valid_uniq" UNIQUE CONSTRAINT, btree (natural_key, valid_from, valid_until) DEFERRABLE
Check constraints:
    "pk_first_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

ROLLBACK TO SAVEPOINT s1;
-- Scenario 2: NK added first, then PK
\echo

\echo --- Scenario 2: NK then PK ---
--- Scenario 2: NK then PK ---
SAVEPOINT s2;
CREATE TABLE pk_consistency.nk_first (
    id int GENERATED BY DEFAULT AS IDENTITY,
    natural_key text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.nk_first');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.nk_first', ARRAY['natural_key']); -- Enforcement is requested by default
NOTICE:  sql_saga: altering table pk_consistency.nk_first to add constraints: ADD CONSTRAINT nk_first_natural_key_valid_uniq UNIQUE (natural_key, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT nk_first_natural_key_valid_excl EXCLUDE USING gist (natural_key WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
       add_unique_key       
----------------------------
 nk_first_natural_key_valid
(1 row)

TABLE sql_saga.unique_keys;
      unique_key_name       |  table_schema  | table_name | key_type | column_names  | era_name |        unique_constraint        |       exclude_constraint        | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
----------------------------+----------------+------------+----------+---------------+----------+---------------------------------+---------------------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
 nk_first_natural_key_valid | pk_consistency | nk_first   | natural  | {natural_key} | valid    | nk_first_natural_key_valid_uniq | nk_first_natural_key_valid_excl |                  |           |                            |                     |                                  | {}
(1 row)

\echo '--- Constraints after NK only ---'
--- Constraints after NK only ---
\d pk_consistency.nk_first
                         Table "pk_consistency.nk_first"
   Column    |  Type   | Collation | Nullable |             Default              
-------------+---------+-----------+----------+----------------------------------
 id          | integer |           | not null | generated by default as identity
 natural_key | text    |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 'infinity'::date
Indexes:
    "nk_first_natural_key_idx" btree (natural_key)
    "nk_first_natural_key_valid_excl" EXCLUDE USING gist (natural_key WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "nk_first_natural_key_valid_uniq" UNIQUE CONSTRAINT, btree (natural_key, valid_from, valid_until) DEFERRABLE
Check constraints:
    "nk_first_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

SELECT sql_saga.add_unique_key('pk_consistency.nk_first', ARRAY['id'], key_type => 'primary'); -- This should retroactively apply the constraint
NOTICE:  sql_saga: altering table pk_consistency.nk_first to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_from) DEFERRABLE, ADD CONSTRAINT nk_first_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
NOTICE:  sql_saga: retroactively applying pk consistency for table pk_consistency.nk_first: ADD CONSTRAINT nk_first_natural_key_valid_pk_consistency_excl EXCLUDE USING gist (natural_key WITH =, id WITH <>)
  add_unique_key   
-------------------
 nk_first_id_valid
(1 row)

TABLE sql_saga.unique_keys;
      unique_key_name       |  table_schema  | table_name | key_type | column_names  | era_name |        unique_constraint        |       exclude_constraint        | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
----------------------------+----------------+------------+----------+---------------+----------+---------------------------------+---------------------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
 nk_first_natural_key_valid | pk_consistency | nk_first   | natural  | {natural_key} | valid    | nk_first_natural_key_valid_uniq | nk_first_natural_key_valid_excl |                  |           |                            |                     |                                  | {}
 nk_first_id_valid          | pk_consistency | nk_first   | primary  | {id}          | valid    | nk_first_pkey                   | nk_first_id_valid_excl          |                  |           |                            |                     |                                  | 
(2 rows)

\echo '--- Constraints after PK ---'
--- Constraints after PK ---
\d pk_consistency.nk_first
                         Table "pk_consistency.nk_first"
   Column    |  Type   | Collation | Nullable |             Default              
-------------+---------+-----------+----------+----------------------------------
 id          | integer |           | not null | generated by default as identity
 natural_key | text    |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 'infinity'::date
Indexes:
    "nk_first_pkey" PRIMARY KEY, btree (id, valid_from) DEFERRABLE
    "nk_first_id_idx" btree (id)
    "nk_first_id_valid_excl" EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "nk_first_natural_key_idx" btree (natural_key)
    "nk_first_natural_key_valid_excl" EXCLUDE USING gist (natural_key WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "nk_first_natural_key_valid_pk_consistency_excl" EXCLUDE USING gist (natural_key WITH =, id WITH <>)
    "nk_first_natural_key_valid_uniq" UNIQUE CONSTRAINT, btree (natural_key, valid_from, valid_until) DEFERRABLE
Check constraints:
    "nk_first_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

-- Verify it works
INSERT INTO pk_consistency.nk_first (id, natural_key, valid_from) VALUES (1, 'NK1', '2023-01-01');
SAVEPOINT expect_error;
INSERT INTO pk_consistency.nk_first (id, natural_key, valid_from) VALUES (2, 'NK1', '2023-02-01'); -- fails
ERROR:  conflicting key value violates exclusion constraint "nk_first_natural_key_valid_pk_consistency_excl"
DETAIL:  Key (natural_key, id)=(NK1, 2) conflicts with existing key (natural_key, id)=(NK1, 1).
ROLLBACK TO SAVEPOINT expect_error;
ROLLBACK TO SAVEPOINT s2;
-- Scenario 3: Opt-out of enforcement
\echo

\echo --- Scenario 3: Opt-out ---
--- Scenario 3: Opt-out ---
SAVEPOINT s3;
CREATE TABLE pk_consistency.opt_out (
    id int GENERATED BY DEFAULT AS IDENTITY,
    natural_key text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.opt_out');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.opt_out', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table pk_consistency.opt_out to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_from) DEFERRABLE, ADD CONSTRAINT opt_out_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
  add_unique_key  
------------------
 opt_out_id_valid
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.opt_out', ARRAY['natural_key'], enforce_consistency_with_primary_key => false);
NOTICE:  sql_saga: altering table pk_consistency.opt_out to add constraints: ADD CONSTRAINT opt_out_natural_key_valid_uniq UNIQUE (natural_key, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT opt_out_natural_key_valid_excl EXCLUDE USING gist (natural_key WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
      add_unique_key       
---------------------------
 opt_out_natural_key_valid
(1 row)

TABLE sql_saga.unique_keys;
      unique_key_name      |  table_schema  | table_name | key_type | column_names  | era_name |       unique_constraint        |       exclude_constraint       | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
---------------------------+----------------+------------+----------+---------------+----------+--------------------------------+--------------------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
 opt_out_id_valid          | pk_consistency | opt_out    | primary  | {id}          | valid    | opt_out_pkey                   | opt_out_id_valid_excl          |                  |           |                            |                     |                                  | 
 opt_out_natural_key_valid | pk_consistency | opt_out    | natural  | {natural_key} | valid    | opt_out_natural_key_valid_uniq | opt_out_natural_key_valid_excl |                  |           |                            |                     |                                  | 
(2 rows)

\echo '--- Constraints after opting out ---'
--- Constraints after opting out ---
\d pk_consistency.opt_out
                         Table "pk_consistency.opt_out"
   Column    |  Type   | Collation | Nullable |             Default              
-------------+---------+-----------+----------+----------------------------------
 id          | integer |           | not null | generated by default as identity
 natural_key | text    |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 'infinity'::date
Indexes:
    "opt_out_pkey" PRIMARY KEY, btree (id, valid_from) DEFERRABLE
    "opt_out_id_idx" btree (id)
    "opt_out_id_valid_excl" EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "opt_out_natural_key_idx" btree (natural_key)
    "opt_out_natural_key_valid_excl" EXCLUDE USING gist (natural_key WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "opt_out_natural_key_valid_uniq" UNIQUE CONSTRAINT, btree (natural_key, valid_from, valid_until) DEFERRABLE
Check constraints:
    "opt_out_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

-- This would fail if the constraint existed
INSERT INTO pk_consistency.opt_out (id, natural_key, valid_from) VALUES (1, 'NK1', '2023-01-01');
INSERT INTO pk_consistency.opt_out (id, natural_key, valid_from) VALUES (2, 'NK1', '2023-02-01');
ERROR:  conflicting key value violates exclusion constraint "opt_out_natural_key_valid_excl"
DETAIL:  Key (natural_key, daterange(valid_from, valid_until))=(NK1, [2023-02-01,infinity)) conflicts with existing key (natural_key, daterange(valid_from, valid_until))=(NK1, [2023-01-01,infinity)).
TABLE pk_consistency.opt_out;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK TO SAVEPOINT s3;
-- Scenario 4: FAIL on Composite Primary Key
\echo

\echo --- Scenario 4a: Fail on adding NK to existing Composite PK ---
--- Scenario 4a: Fail on adding NK to existing Composite PK ---
SAVEPOINT s4a;
CREATE TABLE pk_consistency.composite_pk_a (
    org_id int,
    unit_id int,
    natural_key text,
    valid_from date,
    valid_until date
);
ALTER TABLE pk_consistency.composite_pk_a ADD PRIMARY KEY (org_id, unit_id);
SELECT sql_saga.add_era('pk_consistency.composite_pk_a');
WARNING:  Table "pk_consistency.composite_pk_a" has a simple PRIMARY KEY that does not include temporal columns. This schema is incompatible with SCD Type 2 history.
HINT:  If you plan to use a temporal primary key for this era, you must use a composite primary key that includes a temporal column (e.g., PRIMARY KEY (id, valid_from)).
 add_era 
---------
 t
(1 row)

SAVEPOINT expect_error;
SELECT sql_saga.add_unique_key('pk_consistency.composite_pk_a', ARRAY['natural_key']); -- fails
NOTICE:  sql_saga: altering table pk_consistency.composite_pk_a to add constraints: ADD CONSTRAINT composite_pk_a_natural_key_valid_uniq UNIQUE (natural_key, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT composite_pk_a_natural_key_valid_excl EXCLUDE USING gist (natural_key WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
          add_unique_key          
----------------------------------
 composite_pk_a_natural_key_valid
(1 row)

ROLLBACK TO SAVEPOINT expect_error;
ROLLBACK TO SAVEPOINT s4a;
\echo

\echo --- Scenario 4b: Fail on adding Composite PK to existing NK ---
--- Scenario 4b: Fail on adding Composite PK to existing NK ---
SAVEPOINT s4b;
CREATE TABLE pk_consistency.composite_pk_b (
    org_id int,
    unit_id int,
    natural_key text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.composite_pk_b');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.composite_pk_b', ARRAY['natural_key']);
NOTICE:  sql_saga: altering table pk_consistency.composite_pk_b to add constraints: ADD CONSTRAINT composite_pk_b_natural_key_valid_uniq UNIQUE (natural_key, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT composite_pk_b_natural_key_valid_excl EXCLUDE USING gist (natural_key WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
          add_unique_key          
----------------------------------
 composite_pk_b_natural_key_valid
(1 row)

SAVEPOINT expect_error;
SELECT sql_saga.add_unique_key('pk_consistency.composite_pk_b', ARRAY['org_id', 'unit_id'], key_type => 'primary'); -- fails
NOTICE:  sql_saga: altering table pk_consistency.composite_pk_b to add constraints: ALTER COLUMN org_id SET NOT NULL, ALTER COLUMN unit_id SET NOT NULL, ADD PRIMARY KEY (org_id, unit_id, valid_from) DEFERRABLE, ADD CONSTRAINT composite_pk_b_org_id_unit_id_valid_excl EXCLUDE USING gist (org_id WITH =, unit_id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
ERROR:  cannot add primary key (org_id, unit_id) to table "pk_consistency.composite_pk_b" because its stable part (org_id, unit_id) is composite, which is not supported for consistency enforcement required by existing natural keys
CONTEXT:  PL/pgSQL function sql_saga.add_unique_key(regclass,name[],name,sql_saga.unique_key_type,boolean,name,name,name,text,name[]) line 592 at RAISE
ROLLBACK TO SAVEPOINT expect_error;
ROLLBACK TO SAVEPOINT s4b;
-- Scenario 5: API Symmetry (Drop Key)
\echo

\echo --- Scenario 5a: Drop NK removes its consistency constraint ---
--- Scenario 5a: Drop NK removes its consistency constraint ---
SAVEPOINT s5a;
CREATE TABLE pk_consistency.drop_nk (
    id int GENERATED BY DEFAULT AS IDENTITY,
    natural_key text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.drop_nk');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.drop_nk', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table pk_consistency.drop_nk to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_from) DEFERRABLE, ADD CONSTRAINT drop_nk_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
  add_unique_key  
------------------
 drop_nk_id_valid
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.drop_nk', ARRAY['natural_key']);
NOTICE:  sql_saga: altering table pk_consistency.drop_nk to add constraints: ADD CONSTRAINT drop_nk_natural_key_valid_uniq UNIQUE (natural_key, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT drop_nk_natural_key_valid_excl EXCLUDE USING gist (natural_key WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE, ADD CONSTRAINT drop_nk_natural_key_valid_pk_consistency_excl EXCLUDE USING gist (natural_key WITH =, id WITH <>)
      add_unique_key       
---------------------------
 drop_nk_natural_key_valid
(1 row)

\echo '--- Constraints before drop ---'
--- Constraints before drop ---
\d pk_consistency.drop_nk
                         Table "pk_consistency.drop_nk"
   Column    |  Type   | Collation | Nullable |             Default              
-------------+---------+-----------+----------+----------------------------------
 id          | integer |           | not null | generated by default as identity
 natural_key | text    |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 'infinity'::date
Indexes:
    "drop_nk_pkey" PRIMARY KEY, btree (id, valid_from) DEFERRABLE
    "drop_nk_id_idx" btree (id)
    "drop_nk_id_valid_excl" EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "drop_nk_natural_key_idx" btree (natural_key)
    "drop_nk_natural_key_valid_excl" EXCLUDE USING gist (natural_key WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "drop_nk_natural_key_valid_pk_consistency_excl" EXCLUDE USING gist (natural_key WITH =, id WITH <>)
    "drop_nk_natural_key_valid_uniq" UNIQUE CONSTRAINT, btree (natural_key, valid_from, valid_until) DEFERRABLE
Check constraints:
    "drop_nk_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

SELECT sql_saga.drop_unique_key('pk_consistency.drop_nk', ARRAY['natural_key']);
NOTICE:  sql_saga: dropping constraint: ALTER TABLE pk_consistency.drop_nk DROP CONSTRAINT drop_nk_natural_key_valid_pk_consistency_excl
 drop_unique_key 
-----------------
 
(1 row)

\echo '--- Constraints after drop ---'
--- Constraints after drop ---
\d pk_consistency.drop_nk
                         Table "pk_consistency.drop_nk"
   Column    |  Type   | Collation | Nullable |             Default              
-------------+---------+-----------+----------+----------------------------------
 id          | integer |           | not null | generated by default as identity
 natural_key | text    |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 'infinity'::date
Indexes:
    "drop_nk_pkey" PRIMARY KEY, btree (id, valid_from) DEFERRABLE
    "drop_nk_id_idx" btree (id)
    "drop_nk_id_valid_excl" EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "drop_nk_natural_key_idx" btree (natural_key)
Check constraints:
    "drop_nk_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

ROLLBACK TO SAVEPOINT s5a;
\echo

\echo --- Scenario 5b: Drop PK removes dependent consistency constraints ---
--- Scenario 5b: Drop PK removes dependent consistency constraints ---
SAVEPOINT s5b;
CREATE TABLE pk_consistency.drop_pk (
    id int GENERATED BY DEFAULT AS IDENTITY,
    nk1 text,
    nk2 text,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.drop_pk');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.drop_pk', ARRAY['nk1']);
NOTICE:  sql_saga: altering table pk_consistency.drop_pk to add constraints: ADD CONSTRAINT drop_pk_nk1_valid_uniq UNIQUE (nk1, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT drop_pk_nk1_valid_excl EXCLUDE USING gist (nk1 WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
  add_unique_key   
-------------------
 drop_pk_nk1_valid
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.drop_pk', ARRAY['nk2']);
NOTICE:  sql_saga: altering table pk_consistency.drop_pk to add constraints: ADD CONSTRAINT drop_pk_nk2_valid_uniq UNIQUE (nk2, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT drop_pk_nk2_valid_excl EXCLUDE USING gist (nk2 WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
  add_unique_key   
-------------------
 drop_pk_nk2_valid
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.drop_pk', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table pk_consistency.drop_pk to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_from) DEFERRABLE, ADD CONSTRAINT drop_pk_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
NOTICE:  sql_saga: retroactively applying pk consistency for table pk_consistency.drop_pk: ADD CONSTRAINT drop_pk_nk1_valid_pk_consistency_excl EXCLUDE USING gist (nk1 WITH =, id WITH <>), ADD CONSTRAINT drop_pk_nk2_valid_pk_consistency_excl EXCLUDE USING gist (nk2 WITH =, id WITH <>)
  add_unique_key  
------------------
 drop_pk_id_valid
(1 row)

\echo '--- Constraints before drop ---'
--- Constraints before drop ---
\d pk_consistency.drop_pk
                         Table "pk_consistency.drop_pk"
   Column    |  Type   | Collation | Nullable |             Default              
-------------+---------+-----------+----------+----------------------------------
 id          | integer |           | not null | generated by default as identity
 nk1         | text    |           |          | 
 nk2         | text    |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 'infinity'::date
Indexes:
    "drop_pk_pkey" PRIMARY KEY, btree (id, valid_from) DEFERRABLE
    "drop_pk_id_idx" btree (id)
    "drop_pk_id_valid_excl" EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "drop_pk_nk1_idx" btree (nk1)
    "drop_pk_nk1_valid_excl" EXCLUDE USING gist (nk1 WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "drop_pk_nk1_valid_pk_consistency_excl" EXCLUDE USING gist (nk1 WITH =, id WITH <>)
    "drop_pk_nk1_valid_uniq" UNIQUE CONSTRAINT, btree (nk1, valid_from, valid_until) DEFERRABLE
    "drop_pk_nk2_idx" btree (nk2)
    "drop_pk_nk2_valid_excl" EXCLUDE USING gist (nk2 WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "drop_pk_nk2_valid_pk_consistency_excl" EXCLUDE USING gist (nk2 WITH =, id WITH <>)
    "drop_pk_nk2_valid_uniq" UNIQUE CONSTRAINT, btree (nk2, valid_from, valid_until) DEFERRABLE
Check constraints:
    "drop_pk_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

SELECT sql_saga.drop_unique_key('pk_consistency.drop_pk', ARRAY['id']);
 drop_unique_key 
-----------------
 
(1 row)

\echo '--- Constraints after drop ---'
--- Constraints after drop ---
\d pk_consistency.drop_pk
                         Table "pk_consistency.drop_pk"
   Column    |  Type   | Collation | Nullable |             Default              
-------------+---------+-----------+----------+----------------------------------
 id          | integer |           | not null | generated by default as identity
 nk1         | text    |           |          | 
 nk2         | text    |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 'infinity'::date
Indexes:
    "drop_pk_id_idx" btree (id)
    "drop_pk_nk1_idx" btree (nk1)
    "drop_pk_nk1_valid_excl" EXCLUDE USING gist (nk1 WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "drop_pk_nk1_valid_pk_consistency_excl" EXCLUDE USING gist (nk1 WITH =, id WITH <>)
    "drop_pk_nk1_valid_uniq" UNIQUE CONSTRAINT, btree (nk1, valid_from, valid_until) DEFERRABLE
    "drop_pk_nk2_idx" btree (nk2)
    "drop_pk_nk2_valid_excl" EXCLUDE USING gist (nk2 WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "drop_pk_nk2_valid_pk_consistency_excl" EXCLUDE USING gist (nk2 WITH =, id WITH <>)
    "drop_pk_nk2_valid_uniq" UNIQUE CONSTRAINT, btree (nk2, valid_from, valid_until) DEFERRABLE
Check constraints:
    "drop_pk_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

ROLLBACK TO SAVEPOINT s5b;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
