\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
CREATE SCHEMA pk_consistency;
-- This test verifies the `enforce_consistency_with_primary_key` functionality of add_unique_key.
-- This feature adds a non-temporal EXCLUDE constraint to enforce that a natural
-- key value is permanently bound to a single primary key value throughout history.
-- Scenario 1: PK added first, then NK (default enforcement)
\echo --- Scenario 1: PK then NK (default) ---
--- Scenario 1: PK then NK (default) ---
SAVEPOINT s1;
CREATE TABLE pk_consistency.pk_first (
    id int GENERATED BY DEFAULT AS IDENTITY,
    natural_key text,
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.pk_first','valid_range');
NOTICE:  sql_saga: Created trigger "pk_first_synchronize_temporal_columns_trigger" on table pk_consistency.pk_first to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.pk_first', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table pk_consistency.pk_first to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
  add_unique_key   
-------------------
 pk_first_id_valid
(1 row)

TABLE sql_saga.unique_keys;
  unique_key_name  |  table_schema  | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
-------------------+----------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
 pk_first_id_valid | pk_consistency | pk_first   | primary  | {id}         | valid    | pk_first_pkey     |                    |                  |           |                            |                     |                                  | 
(1 row)

\echo '--- Constraints after PK only ---'
--- Constraints after PK only ---
\d pk_consistency.pk_first
                          Table "pk_consistency.pk_first"
   Column    |   Type    | Collation | Nullable |             Default              
-------------+-----------+-----------+----------+----------------------------------
 id          | integer   |           | not null | generated by default as identity
 natural_key | text      |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
Indexes:
    "pk_first_pkey" PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
    "pk_first_id_idx" btree (id)
Check constraints:
    "pk_first_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    pk_first_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_range, valid_from, valid_until ON pk_consistency.pk_first FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'null', 'date', 't')

SELECT sql_saga.add_unique_key('pk_consistency.pk_first', ARRAY['natural_key']); -- Use default enforcement
NOTICE:  sql_saga: altering table pk_consistency.pk_first to add constraints: ADD CONSTRAINT pk_first_natural_key_valid_uniq UNIQUE (natural_key, valid_range WITHOUT OVERLAPS), ADD CONSTRAINT pk_first_natural_key_valid_pk_consistency_excl EXCLUDE USING gist (natural_key WITH =, id WITH <>)
       add_unique_key       
----------------------------
 pk_first_natural_key_valid
(1 row)

TABLE sql_saga.unique_keys;
      unique_key_name       |  table_schema  | table_name | key_type | column_names  | era_name |        unique_constraint        | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names |         pk_consistency_constraint_names          
----------------------------+----------------+------------+----------+---------------+----------+---------------------------------+--------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+--------------------------------------------------
 pk_first_id_valid          | pk_consistency | pk_first   | primary  | {id}          | valid    | pk_first_pkey                   |                    |                  |           |                            |                     |                                  | 
 pk_first_natural_key_valid | pk_consistency | pk_first   | natural  | {natural_key} | valid    | pk_first_natural_key_valid_uniq |                    |                  |           |                            |                     |                                  | {pk_first_natural_key_valid_pk_consistency_excl}
(2 rows)

\echo '--- Constraints after NK ---'
--- Constraints after NK ---
\d pk_consistency.pk_first
                          Table "pk_consistency.pk_first"
   Column    |   Type    | Collation | Nullable |             Default              
-------------+-----------+-----------+----------+----------------------------------
 id          | integer   |           | not null | generated by default as identity
 natural_key | text      |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
Indexes:
    "pk_first_pkey" PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
    "pk_first_id_idx" btree (id)
    "pk_first_natural_key_idx" btree (natural_key)
    "pk_first_natural_key_valid_pk_consistency_excl" EXCLUDE USING gist (natural_key WITH =, id WITH <>)
    "pk_first_natural_key_valid_uniq" UNIQUE (natural_key, valid_range WITHOUT OVERLAPS)
Check constraints:
    "pk_first_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    pk_first_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_range, valid_from, valid_until ON pk_consistency.pk_first FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'null', 'date', 't')

ROLLBACK TO SAVEPOINT s1;
-- Scenario 2: NK added first, then PK
\echo

\echo --- Scenario 2: NK then PK ---
--- Scenario 2: NK then PK ---
SAVEPOINT s2;
CREATE TABLE pk_consistency.nk_first (
    id int GENERATED BY DEFAULT AS IDENTITY,
    natural_key text,
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.nk_first','valid_range');
NOTICE:  sql_saga: Created trigger "nk_first_synchronize_temporal_columns_trigger" on table pk_consistency.nk_first to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.nk_first', ARRAY['natural_key']); -- Enforcement is requested by default
NOTICE:  sql_saga: altering table pk_consistency.nk_first to add constraints: ADD CONSTRAINT nk_first_natural_key_valid_uniq UNIQUE (natural_key, valid_range WITHOUT OVERLAPS)
       add_unique_key       
----------------------------
 nk_first_natural_key_valid
(1 row)

TABLE sql_saga.unique_keys;
      unique_key_name       |  table_schema  | table_name | key_type | column_names  | era_name |        unique_constraint        | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
----------------------------+----------------+------------+----------+---------------+----------+---------------------------------+--------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
 nk_first_natural_key_valid | pk_consistency | nk_first   | natural  | {natural_key} | valid    | nk_first_natural_key_valid_uniq |                    |                  |           |                            |                     |                                  | {}
(1 row)

\echo '--- Constraints after NK only ---'
--- Constraints after NK only ---
\d pk_consistency.nk_first
                          Table "pk_consistency.nk_first"
   Column    |   Type    | Collation | Nullable |             Default              
-------------+-----------+-----------+----------+----------------------------------
 id          | integer   |           | not null | generated by default as identity
 natural_key | text      |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
Indexes:
    "nk_first_natural_key_idx" btree (natural_key)
    "nk_first_natural_key_valid_uniq" UNIQUE (natural_key, valid_range WITHOUT OVERLAPS)
Check constraints:
    "nk_first_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    nk_first_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_range, valid_from, valid_until ON pk_consistency.nk_first FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'null', 'date', 't')

SELECT sql_saga.add_unique_key('pk_consistency.nk_first', ARRAY['id'], key_type => 'primary'); -- This should retroactively apply the constraint
NOTICE:  sql_saga: altering table pk_consistency.nk_first to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
NOTICE:  sql_saga: retroactively applying pk consistency for table pk_consistency.nk_first: ADD CONSTRAINT nk_first_natural_key_valid_pk_consistency_excl EXCLUDE USING gist (natural_key WITH =, id WITH <>)
  add_unique_key   
-------------------
 nk_first_id_valid
(1 row)

TABLE sql_saga.unique_keys;
      unique_key_name       |  table_schema  | table_name | key_type | column_names  | era_name |        unique_constraint        | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
----------------------------+----------------+------------+----------+---------------+----------+---------------------------------+--------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
 nk_first_natural_key_valid | pk_consistency | nk_first   | natural  | {natural_key} | valid    | nk_first_natural_key_valid_uniq |                    |                  |           |                            |                     |                                  | {}
 nk_first_id_valid          | pk_consistency | nk_first   | primary  | {id}          | valid    | nk_first_pkey                   |                    |                  |           |                            |                     |                                  | 
(2 rows)

\echo '--- Constraints after PK ---'
--- Constraints after PK ---
\d pk_consistency.nk_first
                          Table "pk_consistency.nk_first"
   Column    |   Type    | Collation | Nullable |             Default              
-------------+-----------+-----------+----------+----------------------------------
 id          | integer   |           | not null | generated by default as identity
 natural_key | text      |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
Indexes:
    "nk_first_pkey" PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
    "nk_first_id_idx" btree (id)
    "nk_first_natural_key_idx" btree (natural_key)
    "nk_first_natural_key_valid_pk_consistency_excl" EXCLUDE USING gist (natural_key WITH =, id WITH <>)
    "nk_first_natural_key_valid_uniq" UNIQUE (natural_key, valid_range WITHOUT OVERLAPS)
Check constraints:
    "nk_first_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    nk_first_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_range, valid_from, valid_until ON pk_consistency.nk_first FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'null', 'date', 't')

-- Verify it works
INSERT INTO pk_consistency.nk_first (id, natural_key, valid_from) VALUES (1, 'NK1', '2023-01-01');
SAVEPOINT expect_error;
INSERT INTO pk_consistency.nk_first (id, natural_key, valid_from) VALUES (2, 'NK1', '2023-02-01'); -- fails
ERROR:  conflicting key value violates exclusion constraint "nk_first_natural_key_valid_uniq"
DETAIL:  Key (natural_key, valid_range)=(NK1, [2023-02-01,infinity)) conflicts with existing key (natural_key, valid_range)=(NK1, [2023-01-01,infinity)).
ROLLBACK TO SAVEPOINT expect_error;
ROLLBACK TO SAVEPOINT s2;
-- Scenario 3: Opt-out of enforcement
\echo

\echo --- Scenario 3: Opt-out ---
--- Scenario 3: Opt-out ---
SAVEPOINT s3;
CREATE TABLE pk_consistency.opt_out (
    id int GENERATED BY DEFAULT AS IDENTITY,
    natural_key text,
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.opt_out','valid_range');
NOTICE:  sql_saga: Created trigger "opt_out_synchronize_temporal_columns_trigger" on table pk_consistency.opt_out to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.opt_out', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table pk_consistency.opt_out to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
  add_unique_key  
------------------
 opt_out_id_valid
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.opt_out', ARRAY['natural_key'], enforce_consistency_with_primary_key => false);
NOTICE:  sql_saga: altering table pk_consistency.opt_out to add constraints: ADD CONSTRAINT opt_out_natural_key_valid_uniq UNIQUE (natural_key, valid_range WITHOUT OVERLAPS)
      add_unique_key       
---------------------------
 opt_out_natural_key_valid
(1 row)

TABLE sql_saga.unique_keys;
      unique_key_name      |  table_schema  | table_name | key_type | column_names  | era_name |       unique_constraint        | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
---------------------------+----------------+------------+----------+---------------+----------+--------------------------------+--------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
 opt_out_id_valid          | pk_consistency | opt_out    | primary  | {id}          | valid    | opt_out_pkey                   |                    |                  |           |                            |                     |                                  | 
 opt_out_natural_key_valid | pk_consistency | opt_out    | natural  | {natural_key} | valid    | opt_out_natural_key_valid_uniq |                    |                  |           |                            |                     |                                  | 
(2 rows)

\echo '--- Constraints after opting out ---'
--- Constraints after opting out ---
\d pk_consistency.opt_out
                          Table "pk_consistency.opt_out"
   Column    |   Type    | Collation | Nullable |             Default              
-------------+-----------+-----------+----------+----------------------------------
 id          | integer   |           | not null | generated by default as identity
 natural_key | text      |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
Indexes:
    "opt_out_pkey" PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
    "opt_out_id_idx" btree (id)
    "opt_out_natural_key_idx" btree (natural_key)
    "opt_out_natural_key_valid_uniq" UNIQUE (natural_key, valid_range WITHOUT OVERLAPS)
Check constraints:
    "opt_out_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    opt_out_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_range, valid_from, valid_until ON pk_consistency.opt_out FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'null', 'date', 't')

-- This would fail if the constraint existed
INSERT INTO pk_consistency.opt_out (id, natural_key, valid_from) VALUES (1, 'NK1', '2023-01-01');
INSERT INTO pk_consistency.opt_out (id, natural_key, valid_from) VALUES (2, 'NK1', '2023-02-01');
ERROR:  conflicting key value violates exclusion constraint "opt_out_natural_key_valid_uniq"
DETAIL:  Key (natural_key, valid_range)=(NK1, [2023-02-01,infinity)) conflicts with existing key (natural_key, valid_range)=(NK1, [2023-01-01,infinity)).
TABLE pk_consistency.opt_out;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK TO SAVEPOINT s3;
-- Scenario 4: FAIL on Composite Primary Key
\echo

\echo --- Scenario 4a: Fail on adding NK to existing Composite PK ---
--- Scenario 4a: Fail on adding NK to existing Composite PK ---
SAVEPOINT s4a;
CREATE TABLE pk_consistency.composite_pk_a (
    org_id int,
    unit_id int,
    natural_key text,
    valid_range daterange,
    valid_from date,
    valid_until date
);
ALTER TABLE pk_consistency.composite_pk_a ADD PRIMARY KEY (org_id, unit_id);
SELECT sql_saga.add_era('pk_consistency.composite_pk_a','valid_range');
WARNING:  Table "pk_consistency.composite_pk_a" has a simple PRIMARY KEY that does not include temporal columns. This schema is incompatible with SCD Type 2 history.
HINT:  If you plan to use a temporal primary key for this era, you must use a composite primary key that includes a temporal column (e.g., PRIMARY KEY (id, your_range_column)).
NOTICE:  sql_saga: Created trigger "composite_pk_a_synchronize_temporal_columns_trigger" on table pk_consistency.composite_pk_a to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SAVEPOINT expect_error;
SELECT sql_saga.add_unique_key('pk_consistency.composite_pk_a', ARRAY['natural_key']); -- fails
NOTICE:  sql_saga: altering table pk_consistency.composite_pk_a to add constraints: ADD CONSTRAINT composite_pk_a_natural_key_valid_uniq UNIQUE (natural_key, valid_range WITHOUT OVERLAPS)
          add_unique_key          
----------------------------------
 composite_pk_a_natural_key_valid
(1 row)

ROLLBACK TO SAVEPOINT expect_error;
ROLLBACK TO SAVEPOINT s4a;
\echo

\echo --- Scenario 4b: Fail on adding Composite PK to existing NK ---
--- Scenario 4b: Fail on adding Composite PK to existing NK ---
SAVEPOINT s4b;
CREATE TABLE pk_consistency.composite_pk_b (
    org_id int,
    unit_id int,
    natural_key text,
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.composite_pk_b','valid_range');
NOTICE:  sql_saga: Created trigger "composite_pk_b_synchronize_temporal_columns_trigger" on table pk_consistency.composite_pk_b to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.composite_pk_b', ARRAY['natural_key']);
NOTICE:  sql_saga: altering table pk_consistency.composite_pk_b to add constraints: ADD CONSTRAINT composite_pk_b_natural_key_valid_uniq UNIQUE (natural_key, valid_range WITHOUT OVERLAPS)
          add_unique_key          
----------------------------------
 composite_pk_b_natural_key_valid
(1 row)

SAVEPOINT expect_error;
SELECT sql_saga.add_unique_key('pk_consistency.composite_pk_b', ARRAY['org_id', 'unit_id'], key_type => 'primary'); -- fails
NOTICE:  sql_saga: altering table pk_consistency.composite_pk_b to add constraints: ALTER COLUMN org_id SET NOT NULL, ALTER COLUMN unit_id SET NOT NULL, ADD PRIMARY KEY (org_id, unit_id, valid_range WITHOUT OVERLAPS)
ERROR:  cannot add primary key (org_id, unit_id) to table "pk_consistency.composite_pk_b" because its stable part (org_id, unit_id) is composite, which is not supported for consistency enforcement required by existing natural keys
CONTEXT:  PL/pgSQL function sql_saga.add_unique_key(regclass,name[],name,sql_saga.unique_key_type,boolean,name,name,name,text,name[]) line 546 at RAISE
ROLLBACK TO SAVEPOINT expect_error;
ROLLBACK TO SAVEPOINT s4b;
-- Scenario 5: API Symmetry (Drop Key)
\echo

\echo --- Scenario 5a: Drop NK removes its consistency constraint ---
--- Scenario 5a: Drop NK removes its consistency constraint ---
SAVEPOINT s5a;
CREATE TABLE pk_consistency.drop_nk (
    id int GENERATED BY DEFAULT AS IDENTITY,
    natural_key text,
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.drop_nk','valid_range');
NOTICE:  sql_saga: Created trigger "drop_nk_synchronize_temporal_columns_trigger" on table pk_consistency.drop_nk to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.drop_nk', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table pk_consistency.drop_nk to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
  add_unique_key  
------------------
 drop_nk_id_valid
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.drop_nk', ARRAY['natural_key']);
NOTICE:  sql_saga: altering table pk_consistency.drop_nk to add constraints: ADD CONSTRAINT drop_nk_natural_key_valid_uniq UNIQUE (natural_key, valid_range WITHOUT OVERLAPS), ADD CONSTRAINT drop_nk_natural_key_valid_pk_consistency_excl EXCLUDE USING gist (natural_key WITH =, id WITH <>)
      add_unique_key       
---------------------------
 drop_nk_natural_key_valid
(1 row)

\echo '--- Constraints before drop ---'
--- Constraints before drop ---
\d pk_consistency.drop_nk
                          Table "pk_consistency.drop_nk"
   Column    |   Type    | Collation | Nullable |             Default              
-------------+-----------+-----------+----------+----------------------------------
 id          | integer   |           | not null | generated by default as identity
 natural_key | text      |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
Indexes:
    "drop_nk_pkey" PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
    "drop_nk_id_idx" btree (id)
    "drop_nk_natural_key_idx" btree (natural_key)
    "drop_nk_natural_key_valid_pk_consistency_excl" EXCLUDE USING gist (natural_key WITH =, id WITH <>)
    "drop_nk_natural_key_valid_uniq" UNIQUE (natural_key, valid_range WITHOUT OVERLAPS)
Check constraints:
    "drop_nk_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    drop_nk_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_range, valid_from, valid_until ON pk_consistency.drop_nk FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'null', 'date', 't')

SELECT sql_saga.drop_unique_key('pk_consistency.drop_nk', ARRAY['natural_key']);
NOTICE:  sql_saga: dropping constraint: ALTER TABLE pk_consistency.drop_nk DROP CONSTRAINT drop_nk_natural_key_valid_pk_consistency_excl
 drop_unique_key 
-----------------
 
(1 row)

\echo '--- Constraints after drop ---'
--- Constraints after drop ---
\d pk_consistency.drop_nk
                          Table "pk_consistency.drop_nk"
   Column    |   Type    | Collation | Nullable |             Default              
-------------+-----------+-----------+----------+----------------------------------
 id          | integer   |           | not null | generated by default as identity
 natural_key | text      |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
Indexes:
    "drop_nk_pkey" PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
    "drop_nk_id_idx" btree (id)
    "drop_nk_natural_key_idx" btree (natural_key)
Check constraints:
    "drop_nk_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    drop_nk_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_range, valid_from, valid_until ON pk_consistency.drop_nk FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'null', 'date', 't')

ROLLBACK TO SAVEPOINT s5a;
\echo

\echo --- Scenario 5b: Drop PK removes dependent consistency constraints ---
--- Scenario 5b: Drop PK removes dependent consistency constraints ---
SAVEPOINT s5b;
CREATE TABLE pk_consistency.drop_pk (
    id int GENERATED BY DEFAULT AS IDENTITY,
    nk1 text,
    nk2 text,
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('pk_consistency.drop_pk','valid_range');
NOTICE:  sql_saga: Created trigger "drop_pk_synchronize_temporal_columns_trigger" on table pk_consistency.drop_pk to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.drop_pk', ARRAY['nk1']);
NOTICE:  sql_saga: altering table pk_consistency.drop_pk to add constraints: ADD CONSTRAINT drop_pk_nk1_valid_uniq UNIQUE (nk1, valid_range WITHOUT OVERLAPS)
  add_unique_key   
-------------------
 drop_pk_nk1_valid
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.drop_pk', ARRAY['nk2']);
NOTICE:  sql_saga: altering table pk_consistency.drop_pk to add constraints: ADD CONSTRAINT drop_pk_nk2_valid_uniq UNIQUE (nk2, valid_range WITHOUT OVERLAPS)
  add_unique_key   
-------------------
 drop_pk_nk2_valid
(1 row)

SELECT sql_saga.add_unique_key('pk_consistency.drop_pk', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table pk_consistency.drop_pk to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
NOTICE:  sql_saga: retroactively applying pk consistency for table pk_consistency.drop_pk: ADD CONSTRAINT drop_pk_nk1_valid_pk_consistency_excl EXCLUDE USING gist (nk1 WITH =, id WITH <>), ADD CONSTRAINT drop_pk_nk2_valid_pk_consistency_excl EXCLUDE USING gist (nk2 WITH =, id WITH <>)
  add_unique_key  
------------------
 drop_pk_id_valid
(1 row)

\echo '--- Constraints before drop ---'
--- Constraints before drop ---
\d pk_consistency.drop_pk
                          Table "pk_consistency.drop_pk"
   Column    |   Type    | Collation | Nullable |             Default              
-------------+-----------+-----------+----------+----------------------------------
 id          | integer   |           | not null | generated by default as identity
 nk1         | text      |           |          | 
 nk2         | text      |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
Indexes:
    "drop_pk_pkey" PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
    "drop_pk_id_idx" btree (id)
    "drop_pk_nk1_idx" btree (nk1)
    "drop_pk_nk1_valid_pk_consistency_excl" EXCLUDE USING gist (nk1 WITH =, id WITH <>)
    "drop_pk_nk1_valid_uniq" UNIQUE (nk1, valid_range WITHOUT OVERLAPS)
    "drop_pk_nk2_idx" btree (nk2)
    "drop_pk_nk2_valid_pk_consistency_excl" EXCLUDE USING gist (nk2 WITH =, id WITH <>)
    "drop_pk_nk2_valid_uniq" UNIQUE (nk2, valid_range WITHOUT OVERLAPS)
Check constraints:
    "drop_pk_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    drop_pk_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_range, valid_from, valid_until ON pk_consistency.drop_pk FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'null', 'date', 't')

SELECT sql_saga.drop_unique_key('pk_consistency.drop_pk', ARRAY['id']);
 drop_unique_key 
-----------------
 
(1 row)

\echo '--- Constraints after drop ---'
--- Constraints after drop ---
\d pk_consistency.drop_pk
                          Table "pk_consistency.drop_pk"
   Column    |   Type    | Collation | Nullable |             Default              
-------------+-----------+-----------+----------+----------------------------------
 id          | integer   |           | not null | generated by default as identity
 nk1         | text      |           |          | 
 nk2         | text      |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
Indexes:
    "drop_pk_id_idx" btree (id)
    "drop_pk_nk1_idx" btree (nk1)
    "drop_pk_nk1_valid_pk_consistency_excl" EXCLUDE USING gist (nk1 WITH =, id WITH <>)
    "drop_pk_nk1_valid_uniq" UNIQUE (nk1, valid_range WITHOUT OVERLAPS)
    "drop_pk_nk2_idx" btree (nk2)
    "drop_pk_nk2_valid_pk_consistency_excl" EXCLUDE USING gist (nk2 WITH =, id WITH <>)
    "drop_pk_nk2_valid_uniq" UNIQUE (nk2, valid_range WITHOUT OVERLAPS)
Check constraints:
    "drop_pk_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    drop_pk_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_range, valid_from, valid_until ON pk_consistency.drop_pk FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'null', 'date', 't')

ROLLBACK TO SAVEPOINT s5b;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
