\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
SELECT $$
------------------------------------------------------------------------------------------
Test: Validate Timely Strategy for Temporal Operations
Concept:
  This test is a low-level validation of the core architectural assumptions that underpin
  the `temporal_merge` procedure, without using any `sql_saga` functions. It aims to prove
  that a specific sequence of DML operations (`INSERT` before `UPDATE`) within a
  transaction with deferred constraints is a valid and robust strategy for performing
  SCD Type 2 updates on tables with temporal-like foreign key and uniqueness constraints.

Assumptions to be Verified:
  1. INSERT-then-UPDATE with Deferred Constraints: A transaction can successfully perform
     an `INSERT` followed by an `UPDATE` that creates a temporary timeline overlap, as
     long as constraints are deferred. The final state is consistent, and the deferred
     `EXCLUDE` constraint will pass when checked at the end.
  2. MVCC Snapshot Visibility for Triggers: An `AFTER ROW` trigger (simulating our
     temporal FK check) fired by a DML statement will see the complete, consistent
     state of the database *after* the statement finishes, including the effects of
     prior statements within the same transaction. Specifically, the trigger on the
     `UPDATE` statement will see the row created by the preceding `INSERT` statement.

The Scenario:
  - A `parent` table has a temporal-like `EXCLUDE` constraint.
  - A `child` table has a foreign key to the `parent`.
  - An `AFTER` trigger on the `parent` table simulates the temporal foreign key check,
    ensuring no child records are ever orphaned.
  - We perform an SCD Type 2 update on a parent record, which requires shortening the
    old record and inserting a new one.
------------------------------------------------------------------------------------------
$$ as doc;
                                            doc                                             
--------------------------------------------------------------------------------------------
                                                                                           +
 ------------------------------------------------------------------------------------------+
 Test: Validate Timely Strategy for Temporal Operations                                    +
 Concept:                                                                                  +
   This test is a low-level validation of the core architectural assumptions that underpin +
   the `temporal_merge` procedure, without using any `sql_saga` functions. It aims to prove+
   that a specific sequence of DML operations (`INSERT` before `UPDATE`) within a          +
   transaction with deferred constraints is a valid and robust strategy for performing     +
   SCD Type 2 updates on tables with temporal-like foreign key and uniqueness constraints. +
                                                                                           +
 Assumptions to be Verified:                                                               +
   1. INSERT-then-UPDATE with Deferred Constraints: A transaction can successfully perform +
      an `INSERT` followed by an `UPDATE` that creates a temporary timeline overlap, as    +
      long as constraints are deferred. The final state is consistent, and the deferred    +
      `EXCLUDE` constraint will pass when checked at the end.                              +
   2. MVCC Snapshot Visibility for Triggers: An `AFTER ROW` trigger (simulating our        +
      temporal FK check) fired by a DML statement will see the complete, consistent        +
      state of the database *after* the statement finishes, including the effects of       +
      prior statements within the same transaction. Specifically, the trigger on the       +
      `UPDATE` statement will see the row created by the preceding `INSERT` statement.     +
                                                                                           +
 The Scenario:                                                                             +
   - A `parent` table has a temporal-like `EXCLUDE` constraint.                            +
   - A `child` table has a foreign key to the `parent`.                                    +
   - An `AFTER` trigger on the `parent` table simulates the temporal foreign key check,    +
     ensuring no child records are ever orphaned.                                          +
   - We perform an SCD Type 2 update on a parent record, which requires shortening the     +
     old record and inserting a new one.                                                   +
 ------------------------------------------------------------------------------------------+
 
(1 row)

-- Use a schema to isolate the test objects
CREATE SCHEMA s;
--------------------------------------------------------------------------------
-- 1. Setup: Mimic sql_saga's temporal constraints with raw SQL
--------------------------------------------------------------------------------
-- The "referenced" table, like `legal_unit`
CREATE TABLE s.parent (
    id int NOT NULL,
    value text,
    valid_from date NOT NULL,
    valid_until date NOT NULL,
    CHECK (valid_from < valid_until),
    -- This is the equivalent of a temporal unique key. It is deferrable.
    EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE INITIALLY IMMEDIATE
);
CREATE INDEX ON s.parent(id);
-- The "referencing" table, like `location`
CREATE TABLE s.child (
    id int,
    parent_id int,
    valid_from date,
    valid_until date,
    CHECK (valid_from < valid_until)
);
-- This trigger function simulates the logic of `sql_saga`'s `uk_update_check_c`
-- and `uk_delete_check_c` triggers. It ensures that any modification to a parent's
-- timeline does not leave any child records "orphaned".
CREATE FUNCTION s.check_child_coverage() RETURNS trigger
LANGUAGE plpgsql AS $$
DECLARE
    v_child_exists boolean;
BEGIN
    RAISE NOTICE 'Trigger % on % fired for parent ID %', TG_OP, TG_TABLE_NAME, COALESCE(NEW.id, OLD.id);

    -- After any change to a parent, check if any child is now left without a valid parent.
    -- This query joins child records against the *current* state of the parent table.
    -- The core of the test is to see if this query correctly sees the new row inserted
    -- before the UPDATE that fires this trigger.
    SELECT EXISTS (
        SELECT 1
        FROM s.child c
        LEFT JOIN s.parent p
            ON c.parent_id = p.id
            AND daterange(c.valid_from, c.valid_until) <@ daterange(p.valid_from, p.valid_until)
        WHERE p.id IS NULL -- Find children with no covering parent
    )
    INTO v_child_exists;

    IF v_child_exists THEN
        RAISE EXCEPTION 'Foreign key violation: child record is not covered by any parent record.';
    END IF;

    -- Return value depends on the trigger event
    IF (TG_OP = 'DELETE') THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
END;
$$;
-- Attach the trigger. It's an AFTER trigger, as sql_saga's are.
CREATE TRIGGER parent_fk_check
AFTER INSERT OR UPDATE OR DELETE ON s.parent
FOR EACH ROW EXECUTE FUNCTION s.check_child_coverage();
--------------------------------------------------------------------------------
-- 2. Initial State
--------------------------------------------------------------------------------
INSERT INTO s.parent VALUES (1, 'initial', '2024-01-01', 'infinity');
NOTICE:  Trigger INSERT on parent fired for parent ID 1
-- This test requires two child records to correctly simulate coverage across
-- the parent's SCD Type 2 change. The simplified trigger logic checks for
-- full containment within a *single* parent record, so we provide one child
-- for each of the parent's final time slices.
INSERT INTO s.child VALUES
    (101, 1, '2024-01-01', '2024-05-01'),
    (102, 1, '2024-05-01', 'infinity');
\echo '--- Initial State ---'
--- Initial State ---
TABLE s.parent;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | initial | 2024-01-01 | infinity
(1 row)

TABLE s.child ORDER BY id;
 id  | parent_id | valid_from | valid_until 
-----+-----------+------------+-------------
 101 |         1 | 2024-01-01 | 2024-05-01
 102 |         1 | 2024-05-01 | infinity
(2 rows)

--------------------------------------------------------------------------------
-- 3. The Test: Perform an SCD Type 2 update using the INSERT-then-UPDATE strategy
--------------------------------------------------------------------------------
\echo '\n--- Performing SCD Type 2 Update ---\n'

--- Performing SCD Type 2 Update ---

BEGIN;
SET CONSTRAINTS ALL DEFERRED;
\echo '--- Step 1: INSERT new version of parent record ---'
--- Step 1: INSERT new version of parent record ---
-- This insert creates a temporary overlap with the existing record for id=1.
-- The deferred EXCLUDE constraint allows this.
INSERT INTO s.parent VALUES (1, 'updated', '2024-05-01', 'infinity');
NOTICE:  Trigger INSERT on parent fired for parent ID 1
\echo '\n--- State after INSERT (within transaction) ---'

--- State after INSERT (within transaction) ---
TABLE s.parent;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | initial | 2024-01-01 | infinity
  1 | updated | 2024-05-01 | infinity
(2 rows)

\echo '\n--- Step 2: UPDATE old version of parent record to shorten its timeline ---'

--- Step 2: UPDATE old version of parent record to shorten its timeline ---
-- This update resolves the overlap.
-- The AFTER UPDATE trigger will fire here. It MUST see the result of the previous
-- INSERT statement to correctly validate that the child is still covered.
UPDATE s.parent SET valid_until = '2024-05-01' WHERE valid_from = '2024-01-01' AND id = 1;
NOTICE:  Trigger UPDATE on parent fired for parent ID 1
\echo '\n--- State after UPDATE (within transaction) ---'

--- State after UPDATE (within transaction) ---
TABLE s.parent;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | updated | 2024-05-01 | infinity
  1 | initial | 2024-01-01 | 2024-05-01
(2 rows)

\echo '\n--- Step 3: Check deferred constraints ---'

--- Step 3: Check deferred constraints ---
SET CONSTRAINTS ALL IMMEDIATE;
\echo '--- Deferred constraints passed ---'
--- Deferred constraints passed ---
COMMIT;
\echo '\n--- Transaction committed successfully ---\n'

--- Transaction committed successfully ---

--------------------------------------------------------------------------------
-- 4. Verification: Final state is correct and consistent.
--------------------------------------------------------------------------------
\echo '--- Final State ---'
--- Final State ---
\echo '--- parent ---'
--- parent ---
TABLE s.parent ORDER BY valid_from;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | initial | 2024-01-01 | 2024-05-01
  1 | updated | 2024-05-01 | infinity
(2 rows)

\echo '--- child ---'
--- child ---
TABLE s.child ORDER BY id;
 id  | parent_id | valid_from | valid_until 
-----+-----------+------------+-------------
 101 |         1 | 2024-01-01 | 2024-05-01
 102 |         1 | 2024-05-01 | infinity
(2 rows)

DROP SCHEMA s CASCADE;
NOTICE:  drop cascades to 3 other objects
DETAIL:  drop cascades to table s.parent
drop cascades to table s.child
drop cascades to function s.check_child_coverage()
SELECT $$
------------------------------------------------------------------------------------------
Test: Validate Timely Strategy using sql_saga
Concept:
  This test repeats the scenario from the previous test, but uses the high-level
  sql_saga functions (`add_era`, `add_unique_key`, `add_temporal_foreign_key`) to set up
  the constraints. Its purpose is to verify that the extension's own implementation
  of temporal uniqueness and foreign keys correctly adheres to the same architectural
  principles validated by the low-level test.

  This provides an end-to-end confirmation that the `INSERT -> UPDATE` strategy is
  compatible with the triggers and constraints created by `sql_saga`.
------------------------------------------------------------------------------------------
$$ as doc;
                                            doc                                             
--------------------------------------------------------------------------------------------
                                                                                           +
 ------------------------------------------------------------------------------------------+
 Test: Validate Timely Strategy using sql_saga                                             +
 Concept:                                                                                  +
   This test repeats the scenario from the previous test, but uses the high-level          +
   sql_saga functions (`add_era`, `add_unique_key`, `add_temporal_foreign_key`) to set up  +
   the constraints. Its purpose is to verify that the extension's own implementation       +
   of temporal uniqueness and foreign keys correctly adheres to the same architectural     +
   principles validated by the low-level test.                                             +
                                                                                           +
   This provides an end-to-end confirmation that the `INSERT -> UPDATE` strategy is        +
   compatible with the triggers and constraints created by `sql_saga`.                     +
 ------------------------------------------------------------------------------------------+
 
(1 row)

-- Use a new schema to isolate this test
CREATE SCHEMA ss;
--------------------------------------------------------------------------------
-- 1. Setup: Use sql_saga functions
--------------------------------------------------------------------------------
CREATE TABLE ss.parent (
    id int NOT NULL,
    value text,
    valid_from date NOT NULL,
    valid_until date NOT NULL
);
CREATE TABLE ss.child (
    id int,
    parent_id int,
    valid_from date,
    valid_until date
);
-- Register the tables and constraints with sql_saga
SELECT sql_saga.add_era('ss.parent');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('ss.parent', '{id}', unique_key_name => 'parent_uk');
NOTICE:  sql_saga: altering table ss.parent to add constraints: ADD CONSTRAINT parent_uk_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT parent_uk_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
 add_unique_key 
----------------
 parent_uk
(1 row)

SELECT sql_saga.add_era('ss.child');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_temporal_foreign_key(
    fk_table_oid => 'ss.child',
    fk_column_names => '{parent_id}',
    fk_era_name => 'valid',
    unique_key_name => 'parent_uk'
);
NOTICE:  No compatible index found for foreign key on table ss.child. Creating new index: CREATE INDEX child_parent_id_valid_gist_idx ON ss.child USING GIST (parent_id, daterange(valid_from, valid_until))
 add_temporal_foreign_key 
--------------------------
 child_parent_id_valid
(1 row)

--------------------------------------------------------------------------------
-- 2. Initial State (same as previous test)
--------------------------------------------------------------------------------
INSERT INTO ss.parent VALUES (1, 'initial', '2024-01-01', 'infinity');
INSERT INTO ss.child VALUES
    (101, 1, '2024-01-01', '2024-05-01'),
    (102, 1, '2024-05-01', 'infinity');
\echo '--- Initial State (sql_saga) ---'
--- Initial State (sql_saga) ---
TABLE ss.parent;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | initial | 2024-01-01 | infinity
(1 row)

TABLE ss.child ORDER BY id;
 id  | parent_id | valid_from | valid_until 
-----+-----------+------------+-------------
 101 |         1 | 2024-01-01 | 2024-05-01
 102 |         1 | 2024-05-01 | infinity
(2 rows)

--------------------------------------------------------------------------------
-- 3. The Test: Perform SCD Type 2 update (same as previous test)
--------------------------------------------------------------------------------
\echo '\n--- Performing SCD Type 2 Update (sql_saga) ---\n'

--- Performing SCD Type 2 Update (sql_saga) ---

BEGIN;
SET CONSTRAINTS ALL DEFERRED;
\echo '--- Step 1: INSERT new version ---'
--- Step 1: INSERT new version ---
INSERT INTO ss.parent VALUES (1, 'updated', '2024-05-01', 'infinity');
\echo '\n--- State after INSERT (within transaction) ---'

--- State after INSERT (within transaction) ---
TABLE ss.parent;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | initial | 2024-01-01 | infinity
  1 | updated | 2024-05-01 | infinity
(2 rows)

\echo '\n--- Step 2: UPDATE old version ---'

--- Step 2: UPDATE old version ---
UPDATE ss.parent SET valid_until = '2024-05-01' WHERE valid_from = '2024-01-01' AND id = 1;
\echo '\n--- State after UPDATE (within transaction) ---'

--- State after UPDATE (within transaction) ---
TABLE ss.parent;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | updated | 2024-05-01 | infinity
  1 | initial | 2024-01-01 | 2024-05-01
(2 rows)

\echo '\n--- Step 3: Check deferred constraints ---'

--- Step 3: Check deferred constraints ---
SET CONSTRAINTS ALL IMMEDIATE;
\echo '--- Deferred constraints passed ---'
--- Deferred constraints passed ---
COMMIT;
\echo '\n--- Transaction committed successfully ---\n'

--- Transaction committed successfully ---

--------------------------------------------------------------------------------
-- 4. Verification: Final state is correct and consistent.
--------------------------------------------------------------------------------
\echo '--- Final State (sql_saga) ---'
--- Final State (sql_saga) ---
\echo '--- parent ---'
--- parent ---
TABLE ss.parent ORDER BY valid_from;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | initial | 2024-01-01 | 2024-05-01
  1 | updated | 2024-05-01 | infinity
(2 rows)

\echo '--- child ---'
--- child ---
TABLE ss.child ORDER BY id;
 id  | parent_id | valid_from | valid_until 
-----+-----------+------------+-------------
 101 |         1 | 2024-01-01 | 2024-05-01
 102 |         1 | 2024-05-01 | infinity
(2 rows)

DROP SCHEMA ss CASCADE;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to table ss.parent
drop cascades to table ss.child
SELECT $$
------------------------------------------------------------------------------------------
Test: Validate Timely Strategy using temporal_merge
Concept:
  This final test provides an end-to-end validation, proving that the high-level
  `temporal_merge` procedure correctly implements the `INSERT -> UPDATE` strategy that
  was validated in the previous low-level tests.

  It confirms that `temporal_merge` can be safely used to perform SCD Type 2
  updates on tables that are referenced by temporal foreign keys, without causing
  constraint violations.
------------------------------------------------------------------------------------------
$$ as doc;
                                            doc                                             
--------------------------------------------------------------------------------------------
                                                                                           +
 ------------------------------------------------------------------------------------------+
 Test: Validate Timely Strategy using temporal_merge                                       +
 Concept:                                                                                  +
   This final test provides an end-to-end validation, proving that the high-level          +
   `temporal_merge` procedure correctly implements the `INSERT -> UPDATE` strategy that    +
   was validated in the previous low-level tests.                                          +
                                                                                           +
   It confirms that `temporal_merge` can be safely used to perform SCD Type 2              +
   updates on tables that are referenced by temporal foreign keys, without causing         +
   constraint violations.                                                                  +
 ------------------------------------------------------------------------------------------+
 
(1 row)

-- Use a new schema to isolate this test
CREATE SCHEMA stm;
--------------------------------------------------------------------------------
-- 1. Setup: Use sql_saga functions and create a source table
--------------------------------------------------------------------------------
CREATE TABLE stm.parent (
    id int NOT NULL,
    value text,
    valid_from date NOT NULL,
    valid_until date NOT NULL
);
CREATE TABLE stm.child (
    id int,
    parent_id int,
    valid_from date,
    valid_until date
);
-- Register the tables and constraints with sql_saga
SELECT sql_saga.add_era('stm.parent');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('stm.parent', '{id}', unique_key_name => 'parent_uk_stm');
NOTICE:  sql_saga: altering table stm.parent to add constraints: ADD CONSTRAINT parent_uk_stm_uniq UNIQUE (id, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT parent_uk_stm_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
 add_unique_key 
----------------
 parent_uk_stm
(1 row)

SELECT sql_saga.add_era('stm.child');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_temporal_foreign_key(
    fk_table_oid => 'stm.child',
    fk_column_names => '{parent_id}',
    fk_era_name => 'valid',
    unique_key_name => 'parent_uk_stm'
);
NOTICE:  No compatible index found for foreign key on table stm.child. Creating new index: CREATE INDEX child_parent_id_valid_gist_idx ON stm.child USING GIST (parent_id, daterange(valid_from, valid_until))
 add_temporal_foreign_key 
--------------------------
 child_parent_id_valid
(1 row)

-- Source table for the SCD Type 2 change
CREATE TABLE stm.source (
    row_id int primary key,
    id int,
    value text,
    valid_from date,
    valid_until date
);
--------------------------------------------------------------------------------
-- 2. Initial State (same as previous tests)
--------------------------------------------------------------------------------
INSERT INTO stm.parent VALUES (1, 'initial', '2024-01-01', 'infinity');
INSERT INTO stm.child VALUES
    (101, 1, '2024-01-01', '2024-05-01'),
    (102, 1, '2024-05-01', 'infinity');
-- The source data represents the change: from 2024-05-01 onwards, the value is 'updated'.
INSERT INTO stm.source VALUES (1, 1, 'updated', '2024-05-01', 'infinity');
\echo '--- Initial State (temporal_merge) ---'
--- Initial State (temporal_merge) ---
TABLE stm.parent;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | initial | 2024-01-01 | infinity
(1 row)

TABLE stm.child ORDER BY id;
 id  | parent_id | valid_from | valid_until 
-----+-----------+------------+-------------
 101 |         1 | 2024-01-01 | 2024-05-01
 102 |         1 | 2024-05-01 | infinity
(2 rows)

TABLE stm.source;
 row_id | id |  value  | valid_from | valid_until 
--------+----+---------+------------+-------------
      1 |  1 | updated | 2024-05-01 | infinity
(1 row)

--------------------------------------------------------------------------------
-- 3. The Test: Perform SCD Type 2 update using temporal_merge
--------------------------------------------------------------------------------
\echo '\n--- Performing SCD Type 2 Update (temporal_merge) ---\n'

--- Performing SCD Type 2 Update (temporal_merge) ---

BEGIN;
CALL sql_saga.temporal_merge(
    target_table => 'stm.parent',
    source_table => 'stm.source',
    primary_identity_columns => '{id}',
    ephemeral_columns => '{}',
    mode => 'MERGE_ENTITY_PATCH'
);
\echo '--- temporal_merge plan ---'
--- temporal_merge plan ---
SELECT * FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |         data         | feedback | trace |    grouping_key    
-------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+----------------------+----------+-------+--------------------
           1 | {1}     | INSERT    |               | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | finishes     | finished_by  | 2024-01-01     | infinity        | 2024-05-01     | infinity        | {"value": "updated"} |          |       | existing_entity__1
           2 | {1}     | UPDATE    | SHRINK        | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | finishes     | started_by   | 2024-01-01     | infinity        | 2024-01-01     | 2024-05-01      | {"value": "initial"} |          |       | existing_entity__1
(2 rows)

\echo '--- temporal_merge feedback ---'
--- temporal_merge feedback ---
SELECT * FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
             1 | [{"id": 1}]        | APPLIED | 
(1 row)

COMMIT;
\echo '--- temporal_merge call completed successfully ---'
--- temporal_merge call completed successfully ---
--------------------------------------------------------------------------------
-- 4. Verification: Final state is correct and consistent.
--------------------------------------------------------------------------------
\echo '\n--- Final State (temporal_merge) ---'

--- Final State (temporal_merge) ---
\echo '--- parent ---'
--- parent ---
TABLE stm.parent ORDER BY valid_from;
 id |  value  | valid_from | valid_until 
----+---------+------------+-------------
  1 | initial | 2024-01-01 | 2024-05-01
  1 | updated | 2024-05-01 | infinity
(2 rows)

\echo '--- child ---'
--- child ---
TABLE stm.child ORDER BY id;
 id  | parent_id | valid_from | valid_until 
-----+-----------+------------+-------------
 101 |         1 | 2024-01-01 | 2024-05-01
 102 |         1 | 2024-05-01 | infinity
(2 rows)

DROP SCHEMA stm CASCADE;
NOTICE:  drop cascades to 3 other objects
DETAIL:  drop cascades to table stm.parent
drop cascades to table stm.child
drop cascades to table stm.source
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
