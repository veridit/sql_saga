\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo 'Test Suite: `..._FOR_PORTION_OF` Mode Edge Cases'
Test Suite: `..._FOR_PORTION_OF` Mode Edge Cases
\echo 'Description:'
Description:
\echo '  This test suite verifies the behavior of the `..._FOR_PORTION_OF` modes'
  This test suite verifies the behavior of the `..._FOR_PORTION_OF` modes
\echo '  with a focus on complex timeline interactions, such as operations that'
  with a focus on complex timeline interactions, such as operations that
\echo '  straddle adjacent historical slices.'
  straddle adjacent historical slices.
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
SET client_min_messages TO NOTICE;
CREATE SCHEMA tm_portion_of;
CREATE TABLE tm_portion_of.target(
    id int,
    payload TEXT,
    edit_comment TEXT,
    valid_range daterange,
    valid_from DATE,
    valid_until DATE
);
SELECT sql_saga.add_era('tm_portion_of.target'::regclass, 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    era_name => 'valid');
NOTICE:  sql_saga: Created trigger "target_synchronize_temporal_columns_trigger" on table tm_portion_of.target to synchronize columns: valid_from, valid_until
NOTICE:  sql_saga: Created GIST index "target_valid_range_gist_idx" on column tm_portion_of.target.valid_range for temporal_merge performance
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tm_portion_of.target'::regclass, '{id}', 'valid');
NOTICE:  sql_saga: Added constraints to table tm_portion_of.target: ADD CONSTRAINT target_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
 add_unique_key  
-----------------
 target_id_valid
(1 row)

-- Helper function to reset target state
CREATE OR REPLACE PROCEDURE tm_portion_of.reset_target() AS $$
BEGIN
    TRUNCATE tm_portion_of.target;
    -- Target entity has two adjacent periods, a gap, and a final period
    INSERT INTO tm_portion_of.target (id, payload, edit_comment, valid_from, valid_until) VALUES
        (1, 'A-1', 'Adjacent 1', '2021-01-01', '2022-01-01'),
        (1, 'A-2', 'Adjacent 2', '2022-01-01', '2023-01-01'),
        (1, 'B-1', 'After Gap',  '2024-01-01', '2025-01-01');
END;
$$ LANGUAGE plpgsql;
--------------------------------------------------------------------------------
\echo 'Scenario 1: `PATCH_FOR_PORTION_OF` performs a surgical patch straddling adjacent slices'
Scenario 1: `PATCH_FOR_PORTION_OF` performs a surgical patch straddling adjacent slices
--------------------------------------------------------------------------------
SAVEPOINT s1;
CALL tm_portion_of.reset_target();
CREATE TEMP TABLE source_1 (row_id int, id int, payload text, edit_comment text, valid_from date, valid_until date) ON COMMIT DROP;
-- A straddling change that covers half of each adjacent period
INSERT INTO source_1 (row_id, id, payload, edit_comment, valid_from, valid_until) VALUES
    (101, 1, 'Patched-Straddle', 'Surgical Patch Straddling', '2021-07-01', '2022-07-01');
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
TABLE tm_portion_of.target ORDER BY id, valid_from;
 id | payload | edit_comment |       valid_range       | valid_from | valid_until 
----+---------+--------------+-------------------------+------------+-------------
  1 | A-1     | Adjacent 1   | [2021-01-01,2022-01-01) | 2021-01-01 | 2022-01-01
  1 | A-2     | Adjacent 2   | [2022-01-01,2023-01-01) | 2022-01-01 | 2023-01-01
  1 | B-1     | After Gap    | [2024-01-01,2025-01-01) | 2024-01-01 | 2025-01-01
(3 rows)

\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
TABLE source_1 ORDER BY row_id;
 row_id | id |     payload      |       edit_comment        | valid_from | valid_until 
--------+----+------------------+---------------------------+------------+-------------
    101 |  1 | Patched-Straddle | Surgical Patch Straddling | 2021-07-01 | 2022-07-01
(1 row)

CALL sql_saga.temporal_merge(target_table => 'tm_portion_of.target'::regclass, source_table => 'source_1'::regclass, primary_identity_columns => '{id}'::text[], ephemeral_columns => '{edit_comment}'::text[], mode => 'PATCH_FOR_PORTION_OF'::sql_saga.temporal_merge_mode, era_name => 'valid');
\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation  | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |     old_valid_range     |     new_valid_range     |                                     data                                     | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+---------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------+-------------------------+------------------------------------------------------------------------------+----------+-------+--------------------
           1 |             1 | {101}   | UPDATE    | SHRINK        | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | overlapped_by | started_by   | 2021-01-01     | 2022-01-01      | 2021-01-01     | 2021-07-01      | [2021-01-01,2022-01-01) | [2021-01-01,2021-07-01) | {"payload": "A-1", "edit_comment": "Adjacent 1"}                             |          |       | existing_entity__1
           2 |             1 | {101}   | UPDATE    | SHRINK        | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | overlaps      | finished_by  | 2022-01-01     | 2023-01-01      | 2022-07-01     | 2023-01-01      | [2022-01-01,2023-01-01) | [2022-07-01,2023-01-01) | {"payload": "A-2", "edit_comment": "Adjacent 2"}                             |          |       | existing_entity__1
           3 |             2 | {101}   | INSERT    |               | 101       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | overlapped_by | overlaps     | 2021-01-01     | 2022-01-01      | 2021-07-01     | 2022-07-01      | [2021-01-01,2022-01-01) | [2021-07-01,2022-07-01) | {"payload": "Patched-Straddle", "edit_comment": "Surgical Patch Straddling"} |          |       | existing_entity__1
(3 rows)

\echo '--- Executor: Actual Feedback ---'
--- Executor: Actual Feedback ---
TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           101 | [{"id": 1}]        | APPLIED | 
(1 row)

\echo '--- Target: Expected Final State ---'
--- Target: Expected Final State ---
SELECT * FROM (VALUES
    (1, 'A-1', 'Adjacent 1', '2021-01-01'::date, '2021-07-01'::date),
    (1, 'Patched-Straddle', 'Surgical Patch Straddling', '2021-07-01'::date, '2022-07-01'::date),
    (1, 'A-2', 'Adjacent 2', '2022-07-01'::date, '2023-01-01'::date),
    (1, 'B-1', 'After Gap', '2024-01-01'::date, '2025-01-01'::date)
) AS v(id, payload, edit_comment, valid_from, valid_until) ORDER BY id, valid_from;
 id |     payload      |       edit_comment        | valid_from | valid_until 
----+------------------+---------------------------+------------+-------------
  1 | A-1              | Adjacent 1                | 2021-01-01 | 2021-07-01
  1 | Patched-Straddle | Surgical Patch Straddling | 2021-07-01 | 2022-07-01
  1 | A-2              | Adjacent 2                | 2022-07-01 | 2023-01-01
  1 | B-1              | After Gap                 | 2024-01-01 | 2025-01-01
(4 rows)

\echo '--- Target: Final State ---'
--- Target: Final State ---
TABLE tm_portion_of.target ORDER BY id, valid_from;
 id |     payload      |       edit_comment        |       valid_range       | valid_from | valid_until 
----+------------------+---------------------------+-------------------------+------------+-------------
  1 | A-1              | Adjacent 1                | [2021-01-01,2021-07-01) | 2021-01-01 | 2021-07-01
  1 | Patched-Straddle | Surgical Patch Straddling | [2021-07-01,2022-07-01) | 2021-07-01 | 2022-07-01
  1 | A-2              | Adjacent 2                | [2022-07-01,2023-01-01) | 2022-07-01 | 2023-01-01
  1 | B-1              | After Gap                 | [2024-01-01,2025-01-01) | 2024-01-01 | 2025-01-01
(4 rows)

ROLLBACK TO SAVEPOINT s1;
--------------------------------------------------------------------------------
\echo 'Scenario 2: `REPLACE_FOR_PORTION_OF` performs a surgical replacement straddling adjacent slices'
Scenario 2: `REPLACE_FOR_PORTION_OF` performs a surgical replacement straddling adjacent slices
--------------------------------------------------------------------------------
SAVEPOINT s2;
CALL tm_portion_of.reset_target();
CREATE TEMP TABLE source_2 (row_id int, id int, payload text, edit_comment text, valid_from date, valid_until date) ON COMMIT DROP;
-- A straddling change that covers half of each adjacent period
INSERT INTO source_2 (row_id, id, payload, edit_comment, valid_from, valid_until) VALUES
    (201, 1, 'Replaced-Straddle', 'Surgical Replace Straddling', '2021-07-01', '2022-07-01');
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
TABLE tm_portion_of.target ORDER BY id, valid_from;
 id | payload | edit_comment |       valid_range       | valid_from | valid_until 
----+---------+--------------+-------------------------+------------+-------------
  1 | A-1     | Adjacent 1   | [2021-01-01,2022-01-01) | 2021-01-01 | 2022-01-01
  1 | A-2     | Adjacent 2   | [2022-01-01,2023-01-01) | 2022-01-01 | 2023-01-01
  1 | B-1     | After Gap    | [2024-01-01,2025-01-01) | 2024-01-01 | 2025-01-01
(3 rows)

\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
TABLE source_2 ORDER BY row_id;
 row_id | id |      payload      |        edit_comment         | valid_from | valid_until 
--------+----+-------------------+-----------------------------+------------+-------------
    201 |  1 | Replaced-Straddle | Surgical Replace Straddling | 2021-07-01 | 2022-07-01
(1 row)

CALL sql_saga.temporal_merge(target_table => 'tm_portion_of.target'::regclass, source_table => 'source_2'::regclass, primary_identity_columns => '{id}'::text[], ephemeral_columns => '{edit_comment}'::text[], mode => 'REPLACE_FOR_PORTION_OF'::sql_saga.temporal_merge_mode, era_name => 'valid');
\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation  | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |     old_valid_range     |     new_valid_range     |                                      data                                       | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+---------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------+-------------------------+---------------------------------------------------------------------------------+----------+-------+--------------------
           1 |             1 | {201}   | UPDATE    | SHRINK        | 201       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | overlapped_by | started_by   | 2021-01-01     | 2022-01-01      | 2021-01-01     | 2021-07-01      | [2021-01-01,2022-01-01) | [2021-01-01,2021-07-01) | {"payload": "A-1", "edit_comment": "Adjacent 1"}                                |          |       | existing_entity__1
           2 |             1 | {201}   | UPDATE    | SHRINK        | 201       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | overlaps      | finished_by  | 2022-01-01     | 2023-01-01      | 2022-07-01     | 2023-01-01      | [2022-01-01,2023-01-01) | [2022-07-01,2023-01-01) | {"payload": "A-2", "edit_comment": "Adjacent 2"}                                |          |       | existing_entity__1
           3 |             2 | {201}   | INSERT    |               | 201       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | overlapped_by | overlaps     | 2021-01-01     | 2022-01-01      | 2021-07-01     | 2022-07-01      | [2021-01-01,2022-01-01) | [2021-07-01,2022-07-01) | {"payload": "Replaced-Straddle", "edit_comment": "Surgical Replace Straddling"} |          |       | existing_entity__1
(3 rows)

\echo '--- Executor: Actual Feedback ---'
--- Executor: Actual Feedback ---
TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           201 | [{"id": 1}]        | APPLIED | 
(1 row)

\echo '--- Target: Expected Final State ---'
--- Target: Expected Final State ---
SELECT * FROM (VALUES
    (1, 'A-1', 'Adjacent 1', '2021-01-01'::date, '2021-07-01'::date),
    (1, 'Replaced-Straddle', 'Surgical Replace Straddling', '2021-07-01'::date, '2022-07-01'::date),
    (1, 'A-2', 'Adjacent 2', '2022-07-01'::date, '2023-01-01'::date),
    (1, 'B-1', 'After Gap', '2024-01-01'::date, '2025-01-01'::date)
) AS v(id, payload, edit_comment, valid_from, valid_until) ORDER BY id, valid_from;
 id |      payload      |        edit_comment         | valid_from | valid_until 
----+-------------------+-----------------------------+------------+-------------
  1 | A-1               | Adjacent 1                  | 2021-01-01 | 2021-07-01
  1 | Replaced-Straddle | Surgical Replace Straddling | 2021-07-01 | 2022-07-01
  1 | A-2               | Adjacent 2                  | 2022-07-01 | 2023-01-01
  1 | B-1               | After Gap                   | 2024-01-01 | 2025-01-01
(4 rows)

\echo '--- Target: Final State ---'
--- Target: Final State ---
TABLE tm_portion_of.target ORDER BY id, valid_from;
 id |      payload      |        edit_comment         |       valid_range       | valid_from | valid_until 
----+-------------------+-----------------------------+-------------------------+------------+-------------
  1 | A-1               | Adjacent 1                  | [2021-01-01,2021-07-01) | 2021-01-01 | 2021-07-01
  1 | Replaced-Straddle | Surgical Replace Straddling | [2021-07-01,2022-07-01) | 2021-07-01 | 2022-07-01
  1 | A-2               | Adjacent 2                  | [2022-07-01,2023-01-01) | 2022-07-01 | 2023-01-01
  1 | B-1               | After Gap                   | [2024-01-01,2025-01-01) | 2024-01-01 | 2025-01-01
(4 rows)

ROLLBACK TO SAVEPOINT s2;
--------------------------------------------------------------------------------
\echo 'Scenario 3: `DELETE_FOR_PORTION_OF` carves out a piece of the timeline straddling adjacent slices'
Scenario 3: `DELETE_FOR_PORTION_OF` carves out a piece of the timeline straddling adjacent slices
--------------------------------------------------------------------------------
SAVEPOINT s3;
CALL tm_portion_of.reset_target();
CREATE TEMP TABLE source_3 (row_id int, id int, payload text, edit_comment text, valid_from date, valid_until date) ON COMMIT DROP;
-- A straddling delete that covers half of each adjacent period
INSERT INTO source_3 (row_id, id, payload, edit_comment, valid_from, valid_until) VALUES
    (301, 1, '__DELETE__', 'Surgical Delete Straddling', '2021-07-01', '2022-07-01');
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
TABLE tm_portion_of.target ORDER BY id, valid_from;
 id | payload | edit_comment |       valid_range       | valid_from | valid_until 
----+---------+--------------+-------------------------+------------+-------------
  1 | A-1     | Adjacent 1   | [2021-01-01,2022-01-01) | 2021-01-01 | 2022-01-01
  1 | A-2     | Adjacent 2   | [2022-01-01,2023-01-01) | 2022-01-01 | 2023-01-01
  1 | B-1     | After Gap    | [2024-01-01,2025-01-01) | 2024-01-01 | 2025-01-01
(3 rows)

\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
TABLE source_3 ORDER BY row_id;
 row_id | id |  payload   |        edit_comment        | valid_from | valid_until 
--------+----+------------+----------------------------+------------+-------------
    301 |  1 | __DELETE__ | Surgical Delete Straddling | 2021-07-01 | 2022-07-01
(1 row)

CALL sql_saga.temporal_merge(target_table => 'tm_portion_of.target'::regclass, source_table => 'source_3'::regclass, primary_identity_columns => '{id}'::text[], ephemeral_columns => '{edit_comment}'::text[], mode => 'DELETE_FOR_PORTION_OF'::sql_saga.temporal_merge_mode, era_name => 'valid');
\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation  | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |     old_valid_range     |     new_valid_range     |                       data                       | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+---------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------+-------------------------+--------------------------------------------------+----------+-------+--------------------
           1 |             1 | {301}   | UPDATE    | SHRINK        | 301       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | overlapped_by | started_by   | 2021-01-01     | 2022-01-01      | 2021-01-01     | 2021-07-01      | [2021-01-01,2022-01-01) | [2021-01-01,2021-07-01) | {"payload": "A-1", "edit_comment": "Adjacent 1"} |          |       | existing_entity__1
           2 |             1 | {301}   | UPDATE    | SHRINK        | 301       | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | overlaps      | finished_by  | 2022-01-01     | 2023-01-01      | 2022-07-01     | 2023-01-01      | [2022-01-01,2023-01-01) | [2022-07-01,2023-01-01) | {"payload": "A-2", "edit_comment": "Adjacent 2"} |          |       | existing_entity__1
(2 rows)

\echo '--- Executor: Actual Feedback ---'
--- Executor: Actual Feedback ---
TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
           301 | [{"id": 1}]        | APPLIED | 
(1 row)

\echo '--- Target: Expected Final State ---'
--- Target: Expected Final State ---
SELECT * FROM (VALUES
    (1, 'A-1', 'Adjacent 1', '2021-01-01'::date, '2021-07-01'::date),
    (1, 'A-2', 'Adjacent 2', '2022-07-01'::date, '2023-01-01'::date),
    (1, 'B-1', 'After Gap', '2024-01-01'::date, '2025-01-01'::date)
) AS v(id, payload, edit_comment, valid_from, valid_until) ORDER BY id, valid_from;
 id | payload | edit_comment | valid_from | valid_until 
----+---------+--------------+------------+-------------
  1 | A-1     | Adjacent 1   | 2021-01-01 | 2021-07-01
  1 | A-2     | Adjacent 2   | 2022-07-01 | 2023-01-01
  1 | B-1     | After Gap    | 2024-01-01 | 2025-01-01
(3 rows)

\echo '--- Target: Final State ---'
--- Target: Final State ---
TABLE tm_portion_of.target ORDER BY id, valid_from;
 id | payload | edit_comment |       valid_range       | valid_from | valid_until 
----+---------+--------------+-------------------------+------------+-------------
  1 | A-1     | Adjacent 1   | [2021-01-01,2021-07-01) | 2021-01-01 | 2021-07-01
  1 | A-2     | Adjacent 2   | [2022-07-01,2023-01-01) | 2022-07-01 | 2023-01-01
  1 | B-1     | After Gap    | [2024-01-01,2025-01-01) | 2024-01-01 | 2025-01-01
(3 rows)

ROLLBACK TO SAVEPOINT s3;
--------------------------------------------------------------------------------
\echo 'Scenario 4: `PATCH_FOR_PORTION_OF` correctly carries over NOT NULL columns when splitting'
Scenario 4: `PATCH_FOR_PORTION_OF` correctly carries over NOT NULL columns when splitting
--------------------------------------------------------------------------------
SAVEPOINT s4;
-- 1. Setup a simple temporal table with a NOT NULL column
CREATE TABLE tm_portion_of.test_unit_not_null (
    id int,
    name text NOT NULL,
    value int,
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('tm_portion_of.test_unit_not_null'::regclass, 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until');
NOTICE:  sql_saga: Created trigger "test_unit_not_null_synchronize_temporal_columns_trigger" on table tm_portion_of.test_unit_not_null to synchronize columns: valid_from, valid_until
NOTICE:  sql_saga: Created GIST index "test_unit_not_null_valid_range_gist_idx" on column tm_portion_of.test_unit_not_null.valid_range for temporal_merge performance
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('tm_portion_of.test_unit_not_null'::regclass, ARRAY['id']);
NOTICE:  sql_saga: Added constraints to table tm_portion_of.test_unit_not_null: ADD CONSTRAINT test_unit_not_null_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
       add_unique_key        
-----------------------------
 test_unit_not_null_id_valid
(1 row)

-- 2. Insert an initial record
INSERT INTO tm_portion_of.test_unit_not_null (id, name, value, valid_from, valid_until)
VALUES (1, 'Initial Name', 100, '2024-01-01', 'infinity');
-- 3. Create a source table for the patch.
--    This patch starts *after* the initial record, forcing a split.
--    Crucially, it is missing the `name` column, which has a NOT NULL constraint.
CREATE TEMP TABLE source_4 (
    row_id int generated by default as identity,
    id int,
    value int,
    valid_from date,
    valid_until date
);
INSERT INTO source_4 (id, value, valid_from, valid_until) VALUES (1, 200, '2024-06-01', 'infinity');
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
TABLE tm_portion_of.test_unit_not_null;
 id |     name     | value |      valid_range      | valid_from | valid_until 
----+--------------+-------+-----------------------+------------+-------------
  1 | Initial Name |   100 | [2024-01-01,infinity) | 2024-01-01 | infinity
(1 row)

\echo '--- Source: Data to merge (missing "name" column) ---'
--- Source: Data to merge (missing "name" column) ---
TABLE source_4;
 row_id | id | value | valid_from | valid_until 
--------+----+-------+------------+-------------
      1 |  1 |   200 | 2024-06-01 | infinity
(1 row)

CALL sql_saga.temporal_merge(
  target_table => 'tm_portion_of.test_unit_not_null'::regclass,
  source_table => 'source_4'::regclass,
  primary_identity_columns => ARRAY['id'],
  ephemeral_columns => ARRAY[]::TEXT[],
  mode => 'PATCH_FOR_PORTION_OF'::sql_saga.temporal_merge_mode,
  row_id_column => 'row_id'
);
\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |    old_valid_range    |     new_valid_range     |                  data                  | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-----------------------+-------------------------+----------------------------------------+----------+-------+--------------------
           1 |             1 | {1}     | UPDATE    | SHRINK        | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | finishes     | started_by   | 2024-01-01     | infinity        | 2024-01-01     | 2024-06-01      | [2024-01-01,infinity) | [2024-01-01,2024-06-01) | {"name": "Initial Name", "value": 100} |          |       | existing_entity__1
           2 |             2 | {1}     | INSERT    |               | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | finishes     | finished_by  | 2024-01-01     | infinity        | 2024-06-01     | infinity        | [2024-01-01,infinity) | [2024-06-01,infinity)   | {"name": "Initial Name", "value": 200} |          |       | existing_entity__1
(2 rows)

\echo '--- Executor: Actual Feedback ---'
--- Executor: Actual Feedback ---
TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
             1 | [{"id": 1}]        | APPLIED | 
(1 row)

\echo '--- Target: Expected Final State ---'
--- Target: Expected Final State ---
SELECT * FROM (VALUES
    (1, 'Initial Name', 100, '2024-01-01'::date, '2024-06-01'::date),
    (1, 'Initial Name', 200, '2024-06-01'::date, 'infinity'::date)
) AS v(id, name, value, valid_from, valid_until) ORDER BY id, valid_from;
 id |     name     | value | valid_from | valid_until 
----+--------------+-------+------------+-------------
  1 | Initial Name |   100 | 2024-01-01 | 2024-06-01
  1 | Initial Name |   200 | 2024-06-01 | infinity
(2 rows)

\echo '--- Target: Final State ---'
--- Target: Final State ---
TABLE tm_portion_of.test_unit_not_null ORDER BY id, valid_from;
 id |     name     | value |       valid_range       | valid_from | valid_until 
----+--------------+-------+-------------------------+------------+-------------
  1 | Initial Name |   100 | [2024-01-01,2024-06-01) | 2024-01-01 | 2024-06-01
  1 | Initial Name |   200 | [2024-06-01,infinity)   | 2024-06-01 | infinity
(2 rows)

ROLLBACK TO SAVEPOINT s4;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
