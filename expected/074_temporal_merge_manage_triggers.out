\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
CREATE EXTENSION IF NOT EXISTS sql_saga;
NOTICE:  extension "sql_saga" already exists, skipping
CREATE SCHEMA mtt;
-- Setup: Parent and child tables with a temporal foreign key.
-- The child also has a synchronized column to ensure its trigger is NOT affected.
CREATE TABLE mtt.parent (
    id int, 
    name text, 
    valid_range daterange NOT NULL,
    valid_from date, 
    valid_until date, 
    valid_to date
);
SELECT sql_saga.add_era('mtt.parent', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
NOTICE:  sql_saga: Created trigger "parent_synchronize_temporal_columns_trigger" on table mtt.parent to synchronize columns: valid_to, valid_from, valid_until
NOTICE:  sql_saga: Created GIST index "parent_valid_range_gist_idx" on column mtt.parent.valid_range for temporal_merge performance
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(
    'mtt.parent',
    '{id}',
    unique_key_name => 'parent_id_valid'
);
NOTICE:  sql_saga: Added constraints to table mtt.parent: ADD CONSTRAINT parent_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
 add_unique_key  
-----------------
 parent_id_valid
(1 row)

CREATE TABLE mtt.child (
    id int, 
    parent_id int, 
    name text, 
    valid_range daterange NOT NULL,
    valid_from date, 
    valid_until date, 
    valid_to date
);
SELECT sql_saga.add_era('mtt.child', 'valid_range',
    valid_from_column_name => 'valid_from',
    valid_until_column_name => 'valid_until',
    valid_to_column_name => 'valid_to');
NOTICE:  sql_saga: Created trigger "child_synchronize_temporal_columns_trigger" on table mtt.child to synchronize columns: valid_to, valid_from, valid_until
NOTICE:  sql_saga: Created GIST index "child_valid_range_gist_idx" on column mtt.child.valid_range for temporal_merge performance
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(
    'mtt.child',
    '{id}',
    unique_key_name => 'child_id_valid'
);
NOTICE:  sql_saga: Added constraints to table mtt.child: ADD CONSTRAINT child_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
 add_unique_key 
----------------
 child_id_valid
(1 row)

SELECT sql_saga.add_temporal_foreign_key(
    fk_table_oid => 'mtt.child'::regclass,
    fk_column_names => ARRAY['parent_id'],
    fk_era_name => 'valid',
    unique_key_name => 'parent_id_valid'
);
NOTICE:  sql_saga: No compatible index found for foreign key on table mtt.child. Creating new index: CREATE INDEX child_parent_id_valid_gist_idx ON mtt.child USING GIST (parent_id, valid_range)
 add_temporal_foreign_key 
--------------------------
 child_parent_id_valid
(1 row)

-- Helper function to check trigger status
CREATE OR REPLACE FUNCTION mtt.get_trigger_status(p_table_oid regclass)
RETURNS TABLE(trigger_name name, is_enabled text) AS $$
    SELECT tgname,
           CASE tgenabled
               WHEN 'O' THEN 'enabled' -- Origin and local
               WHEN 'R' THEN 'enabled' -- Replica
               WHEN 'A' THEN 'enabled' -- Always
               WHEN 'D' THEN 'disabled'
           END
    FROM pg_trigger
    WHERE tgrelid = p_table_oid
      AND NOT tgisinternal
    ORDER BY tgname;
$$ LANGUAGE sql;
\echo '--- Trigger status BEFORE disabling ---'
--- Trigger status BEFORE disabling ---
\echo '-- Triggers on child table --'
-- Triggers on child table --
SELECT * FROM mtt.get_trigger_status('mtt.child');
         trigger_name          | is_enabled 
-------------------------------+------------
 child_valid_sync_temporal_trg | enabled
(1 row)

\echo '-- Triggers on parent table --'
-- Triggers on parent table --
SELECT * FROM mtt.get_trigger_status('mtt.parent');
          trigger_name          | is_enabled 
--------------------------------+------------
 parent_valid_sync_temporal_trg | enabled
(1 row)

\echo '--- Disabling triggers for both tables ---'
--- Disabling triggers for both tables ---
CALL sql_saga.disable_temporal_triggers('mtt.parent', 'mtt.child');
\echo '--- Trigger status AFTER disabling (FK triggers disabled, sync triggers enabled) ---'
--- Trigger status AFTER disabling (FK triggers disabled, sync triggers enabled) ---
\echo '-- Triggers on child table --'
-- Triggers on child table --
SELECT * FROM mtt.get_trigger_status('mtt.child');
         trigger_name          | is_enabled 
-------------------------------+------------
 child_valid_sync_temporal_trg | enabled
(1 row)

\echo '-- Triggers on parent table --'
-- Triggers on parent table --
SELECT * FROM mtt.get_trigger_status('mtt.parent');
          trigger_name          | is_enabled 
--------------------------------+------------
 parent_valid_sync_temporal_trg | enabled
(1 row)

\echo '--- Enabling triggers for both tables ---'
--- Enabling triggers for both tables ---
CALL sql_saga.enable_temporal_triggers('mtt.parent', 'mtt.child');
\echo '--- Trigger status AFTER enabling (all triggers enabled) ---'
--- Trigger status AFTER enabling (all triggers enabled) ---
\echo '-- Triggers on child table --'
-- Triggers on child table --
SELECT * FROM mtt.get_trigger_status('mtt.child');
         trigger_name          | is_enabled 
-------------------------------+------------
 child_valid_sync_temporal_trg | enabled
(1 row)

\echo '-- Triggers on parent table --'
-- Triggers on parent table --
SELECT * FROM mtt.get_trigger_status('mtt.parent');
          trigger_name          | is_enabled 
--------------------------------+------------
 parent_valid_sync_temporal_trg | enabled
(1 row)

ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
