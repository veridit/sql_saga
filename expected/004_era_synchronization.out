\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
SET ROLE TO sql_saga_unprivileged_user;
SET client_min_messages TO NOTICE;
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo 'Test: Automatic `valid_to` synchronization via add_era'
Test: Automatic `valid_to` synchronization via add_era
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo '--- 1. Test default behavior: trigger is auto-created for `valid_to` ---'
--- 1. Test default behavior: trigger is auto-created for `valid_to` ---
SAVEPOINT test_1;
CREATE TABLE sync_test_default (id int, valid_range daterange, valid_from date, valid_to date, valid_until date);
-- This will auto-detect all conventional columns: valid_from, valid_to, valid_until
SELECT sql_saga.add_era('sync_test_default', 'valid_range');
NOTICE:  sql_saga: Created trigger "sync_test_default_synchronize_temporal_columns_trigger" on table sync_test_default to synchronize columns: valid_to, valid_from, valid_until
 add_era 
---------
 t
(1 row)

\d sync_test_default
             Table "public.sync_test_default"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           |          | 
 valid_to    | date      |           |          | 
 valid_until | date      |           |          | 
Check constraints:
    "sync_test_default_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    sync_test_default_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_range, valid_to, valid_from, valid_until ON sync_test_default FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'valid_to', 'date', 't')

INSERT INTO sync_test_default (id, valid_from, valid_to) VALUES (1, '2024-01-01', '2024-12-31');
SELECT id, valid_range, valid_from, valid_to, valid_until FROM sync_test_default;
 id |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------------------------+------------+------------+-------------
  1 | [2024-01-01,2025-01-01) | 2024-01-01 | 2024-12-31 | 2025-01-01
(1 row)

UPDATE sync_test_default SET valid_until = '2026-01-01' WHERE id = 1;
SELECT id, valid_range, valid_from, valid_to, valid_until FROM sync_test_default;
 id |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------------------------+------------+------------+-------------
  1 | [2024-01-01,2026-01-01) | 2024-01-01 | 2025-12-31 | 2026-01-01
(1 row)

ROLLBACK TO SAVEPOINT test_1;
\echo '--- 2. Test disabling the feature with synchronize_columns => false ---'
--- 2. Test disabling the feature with synchronize_columns => false ---
SAVEPOINT test_2;
CREATE TABLE sync_test_disabled (id int, valid_range daterange, valid_from date, valid_to date, valid_until date);
-- Note: synchronize_columns is set to false to disable all synchronization.
SELECT sql_saga.add_era('sync_test_disabled', 'valid_range', synchronize_columns => false);
 add_era 
---------
 t
(1 row)

\d sync_test_disabled
            Table "public.sync_test_disabled"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           |          | 
 valid_to    | date      |           |          | 
 valid_until | date      |           |          | 
Check constraints:
    "sync_test_disabled_valid_check" CHECK (NOT isempty(valid_range))

INSERT INTO sync_test_disabled (id, valid_range              , valid_from  , valid_until , valid_to    )
                        VALUES (1, '[2023-01-01, 2023-12-31)'::DATERANGE, '2024-01-01', '2025-01-01', '2099-12-31');
SELECT id, valid_range, valid_from, valid_to, valid_until FROM sync_test_disabled;
 id |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------------------------+------------+------------+-------------
  1 | [2023-01-01,2023-12-31) | 2024-01-01 | 2099-12-31 | 2025-01-01
(1 row)

ROLLBACK TO SAVEPOINT test_2;
\echo '--- 3. Test with a custom column name ---'
--- 3. Test with a custom column name ---
SAVEPOINT test_3;
CREATE TABLE sync_test_custom_name (id int, date_range daterange, start_date date, until_date date, to_date date);
SELECT sql_saga.add_era('sync_test_custom_name', 'date_range', valid_from_column_name => 'start_date', valid_until_column_name => 'until_date', valid_to_column_name => 'to_date');
NOTICE:  sql_saga: Created trigger "sync_test_custom_name_synchronize_temporal_columns_trigger" on table sync_test_custom_name to synchronize columns: to_date, start_date, until_date
 add_era 
---------
 t
(1 row)

\d sync_test_custom_name
          Table "public.sync_test_custom_name"
   Column   |   Type    | Collation | Nullable | Default 
------------+-----------+-----------+----------+---------
 id         | integer   |           |          | 
 date_range | daterange |           | not null | 
 start_date | date      |           | not null | 
 until_date | date      |           |          | 
 to_date    | date      |           |          | 
Check constraints:
    "sync_test_custom_name_check" CHECK (start_date < until_date AND start_date > '-infinity'::date)
    "sync_test_custom_name_valid_check" CHECK (NOT isempty(date_range))
Triggers:
    sync_test_custom_name_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF date_range, to_date, start_date, until_date ON sync_test_custom_name FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('date_range', 'start_date', 'until_date', 'to_date', 'date', 't')

INSERT INTO sync_test_custom_name (id, start_date, to_date) VALUES (1, '2024-01-01', '2024-12-31');
SELECT id, date_range, start_date, until_date, to_date FROM sync_test_custom_name;
 id |       date_range        | start_date | until_date |  to_date   
----+-------------------------+------------+------------+------------
  1 | [2024-01-01,2025-01-01) | 2024-01-01 | 2025-01-01 | 2024-12-31
(1 row)

ROLLBACK TO SAVEPOINT test_3;
\echo '--- 4. Test edge case: generated column is skipped by auto-detection ---'
--- 4. Test edge case: generated column is skipped by auto-detection ---
SAVEPOINT test_4;
CREATE TABLE sync_test_generated (id int, valid_range daterange, valid_from date, valid_until date, valid_to date GENERATED ALWAYS AS (valid_until - INTERVAL '1 day') STORED);
-- Auto-detection should find from/until but skip the generated `valid_to`
SELECT sql_saga.add_era('sync_test_generated', 'valid_range');
NOTICE:  sql_saga: Created trigger "sync_test_generated_synchronize_temporal_columns_trigger" on table sync_test_generated to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

\d sync_test_generated
                                        Table "public.sync_test_generated"
   Column    |   Type    | Collation | Nullable |                             Default                              
-------------+-----------+-----------+----------+------------------------------------------------------------------
 id          | integer   |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
 valid_to    | date      |           |          | generated always as ((valid_until - '@ 1 day'::interval)) stored
Check constraints:
    "sync_test_generated_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    sync_test_generated_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_range, valid_from, valid_until ON sync_test_generated FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'null', 'date', 't')

INSERT INTO sync_test_generated (id, valid_range) VALUES (1, '[2024-01-01,2025-01-01)');
SELECT id, valid_from, valid_to, valid_until FROM sync_test_generated;
 id | valid_from |  valid_to  | valid_until 
----+------------+------------+-------------
  1 | 2024-01-01 | 2024-12-31 | 2025-01-01
(1 row)

ROLLBACK TO SAVEPOINT test_4;
\echo '--- 5. Test edge case: wrong data type is skipped by auto-detection ---'
--- 5. Test edge case: wrong data type is skipped by auto-detection ---
SAVEPOINT test_5;
CREATE TABLE sync_test_wrong_type (id int, valid_range daterange, valid_from date, valid_to text, valid_until date);
-- Auto-detection should find from/until but skip the text `valid_to`
SELECT sql_saga.add_era('sync_test_wrong_type', 'valid_range');
WARNING:  sql_saga: Synchronization column "valid_to" on table sync_test_wrong_type has an incompatible data type (text). It must match the era subtype (date). Skipping synchronization.
NOTICE:  sql_saga: Created trigger "sync_test_wrong_type_synchronize_temporal_columns_trigger" on table sync_test_wrong_type to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

\d sync_test_wrong_type
           Table "public.sync_test_wrong_type"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           |          | 
 valid_to    | text      |           |          | 
 valid_until | date      |           |          | 
Check constraints:
    "sync_test_wrong_type_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    sync_test_wrong_type_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_range, valid_from, valid_until ON sync_test_wrong_type FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'null', 'date', 't')

INSERT INTO sync_test_wrong_type (id, valid_from, valid_to, valid_until) VALUES (1, '2024-01-01', 'some text', '2025-01-01');
SELECT id, valid_range, valid_from, valid_to, valid_until FROM sync_test_wrong_type;
 id |       valid_range       | valid_from | valid_to  | valid_until 
----+-------------------------+------------+-----------+-------------
  1 | [2024-01-01,2025-01-01) | 2024-01-01 | some text | 2025-01-01
(1 row)

ROLLBACK TO SAVEPOINT test_5;
\echo '--- 6. Test NOT NULL on synchronized columns ---'
--- 6. Test NOT NULL on synchronized columns ---
SAVEPOINT test_6_top;
SAVEPOINT test_6a;
\echo '--- 6a. Trigger populates NOT NULL column when other bound is provided ---'
--- 6a. Trigger populates NOT NULL column when other bound is provided ---
-- valid_to is NOT NULL, but the trigger should populate it before the constraint is checked.
CREATE TABLE sync_test_not_null (id int, valid_range daterange, valid_from date, valid_to date NOT NULL, valid_until date);
SELECT sql_saga.add_era('sync_test_not_null', 'valid_range');
NOTICE:  sql_saga: Created trigger "sync_test_not_null_synchronize_temporal_columns_trigger" on table sync_test_not_null to synchronize columns: valid_to, valid_from, valid_until
 add_era 
---------
 t
(1 row)

-- Verify schema. Note that valid_from and valid_until are NOT NULL because
-- add_era adds the constraint, and valid_to is NOT NULL because we declared it.
\d sync_test_not_null
            Table "public.sync_test_not_null"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           |          | 
 valid_to    | date      |           | not null | 
 valid_until | date      |           |          | 
Check constraints:
    "sync_test_not_null_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    sync_test_not_null_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_range, valid_to, valid_from, valid_until ON sync_test_not_null FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'valid_to', 'date', 't')

-- This insert omits valid_to, but provides valid_until. The trigger will derive
-- valid_to, and the INSERT should succeed.
INSERT INTO sync_test_not_null (id, valid_from, valid_until) VALUES (1, '2024-01-01', '2025-01-01');
SELECT id, valid_range, valid_from, valid_to, valid_until FROM sync_test_not_null;
 id |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------------------------+------------+------------+-------------
  1 | [2024-01-01,2025-01-01) | 2024-01-01 | 2024-12-31 | 2025-01-01
(1 row)

RELEASE SAVEPOINT test_6a;
SAVEPOINT test_6b;
\echo '--- 6b. INSERT fails when no temporal bounds are provided and defaults are off ---'
--- 6b. INSERT fails when no temporal bounds are provided and defaults are off ---
CREATE TABLE sync_test_no_defaults (id int, valid_range daterange, valid_from date, valid_to date NOT NULL, valid_until date);
-- Note: add_defaults => false
-- This prevents the trigger from defaulting valid_until to 'infinity'.
SELECT sql_saga.add_era('sync_test_no_defaults', 'valid_range', add_defaults => false);
NOTICE:  sql_saga: Created trigger "sync_test_no_defaults_synchronize_temporal_columns_trigger" on table sync_test_no_defaults to synchronize columns: valid_to, valid_from, valid_until
 add_era 
---------
 t
(1 row)

-- This should fail with an exception from the trigger because no bounds can be determined.
INSERT INTO sync_test_no_defaults (id, valid_from) VALUES (1, '2024-01-01');
ERROR:  The temporal period could not be determined. At least one of "valid_range", "valid_to" (with "valid_from"), or the pair "valid_from"/"valid_until" must be provided.
CONTEXT:  PL/pgSQL function sql_saga.synchronize_temporal_columns() line 136 at RAISE
ROLLBACK TO SAVEPOINT test_6b;
SAVEPOINT test_6c;
\echo '--- 6c. INSERT succeeds with defaults enabled when only lower bound is provided ---'
--- 6c. INSERT succeeds with defaults enabled when only lower bound is provided ---
CREATE TABLE sync_test_nullable_with_defaults (id int, valid_range daterange, valid_from date NOT NULL, valid_to date, valid_until date);
-- Note: add_defaults => true (default)
SELECT sql_saga.add_era('sync_test_nullable_with_defaults', 'valid_range');
NOTICE:  sql_saga: Created trigger "sync_test_nullable_with_defaults_synchronize_temporal_columns_t" on table sync_test_nullable_with_defaults to synchronize columns: valid_to, valid_from, valid_until
 add_era 
---------
 t
(1 row)

\d sync_test_nullable_with_defaults
     Table "public.sync_test_nullable_with_defaults"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 valid_range | daterange |           | not null | 
 valid_from  | date      |           | not null | 
 valid_to    | date      |           |          | 
 valid_until | date      |           |          | 
Check constraints:
    "sync_test_nullable_with_defaults_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    sync_test_nullable_with_defaults_synchronize_temporal_columns_t BEFORE INSERT OR UPDATE OF valid_range, valid_to, valid_from, valid_until ON sync_test_nullable_with_defaults FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_range', 'valid_from', 'valid_until', 'valid_to', 'date', 't')

-- This should succeed. The trigger will see that valid_until is NULL, apply the
-- 'infinity' default, and then derive all other representations from that.
INSERT INTO sync_test_nullable_with_defaults (id, valid_from) VALUES (1, '2024-01-01');
SELECT id, valid_range, valid_from, valid_to, valid_until FROM sync_test_nullable_with_defaults;
 id |      valid_range      | valid_from | valid_to | valid_until 
----+-----------------------+------------+----------+-------------
  1 | [2024-01-01,infinity) | 2024-01-01 | infinity | infinity
(1 row)

RELEASE SAVEPOINT test_6c;
ROLLBACK TO SAVEPOINT test_6_top;
\echo '--- 7. Test UPDATEs setting synchronized columns to NULL ---'
--- 7. Test UPDATEs setting synchronized columns to NULL ---
SAVEPOINT test_7_top;
CREATE TABLE sync_test_null_update (id int, valid_range daterange, valid_from date, valid_to date, valid_until date);
SELECT sql_saga.add_era('sync_test_null_update', 'valid_range', add_defaults => false);
NOTICE:  sql_saga: Created trigger "sync_test_null_update_synchronize_temporal_columns_trigger" on table sync_test_null_update to synchronize columns: valid_to, valid_from, valid_until
 add_era 
---------
 t
(1 row)

INSERT INTO sync_test_null_update (id, valid_from, valid_to) VALUES (1, '2024-01-01', '2024-12-31');
SELECT * FROM sync_test_null_update;
 id |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------------------------+------------+------------+-------------
  1 | [2024-01-01,2025-01-01) | 2024-01-01 | 2024-12-31 | 2025-01-01
(1 row)

--- 7a. UPDATE setting valid_to to NULL should fail ---
SAVEPOINT test_7a;
-- This should fail because it creates an inconsistent state. The trigger raises an exception.
UPDATE sync_test_null_update SET valid_to = NULL WHERE id = 1;
ERROR:  The temporal period could not be determined. At least one of "valid_range", "valid_to" (with "valid_from"), or the pair "valid_from"/"valid_until" must be provided.
CONTEXT:  PL/pgSQL function sql_saga.synchronize_temporal_columns() line 136 at RAISE
ROLLBACK TO SAVEPOINT test_7a;
--- 7b. UPDATE setting valid_until to NULL should fail ---
SAVEPOINT test_7b;
-- This should also fail for the same reason.
UPDATE sync_test_null_update SET valid_until = NULL WHERE id = 1;
ERROR:  The temporal period could not be determined. At least one of "valid_range", "valid_to" (with "valid_from"), or the pair "valid_from"/"valid_until" must be provided.
CONTEXT:  PL/pgSQL function sql_saga.synchronize_temporal_columns() line 136 at RAISE
ROLLBACK TO SAVEPOINT test_7b;
--- 7c. UPDATE setting valid_from to NULL should fail ---
SAVEPOINT test_7c;
-- This should also fail for the same reason.
UPDATE sync_test_null_update SET valid_from = NULL WHERE id = 1;
ERROR:  The temporal period could not be determined. At least one of "valid_range", "valid_to" (with "valid_from"), or the pair "valid_from"/"valid_until" must be provided.
CONTEXT:  PL/pgSQL function sql_saga.synchronize_temporal_columns() line 136 at RAISE
ROLLBACK TO SAVEPOINT test_7c;
-- Verify the original row is unchanged after the failed update
SELECT * FROM sync_test_null_update;
 id |       valid_range       | valid_from |  valid_to  | valid_until 
----+-------------------------+------------+------------+-------------
  1 | [2024-01-01,2025-01-01) | 2024-01-01 | 2024-12-31 | 2025-01-01
(1 row)

ROLLBACK TO SAVEPOINT test_7_top;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
