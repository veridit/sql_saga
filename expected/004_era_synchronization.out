\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
SET ROLE TO sql_saga_unprivileged_user;
SET client_min_messages TO NOTICE;
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo 'Test: Automatic `valid_to` synchronization via add_era'
Test: Automatic `valid_to` synchronization via add_era
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo '--- 1. Test default behavior: trigger is created for `valid_to` ---'
--- 1. Test default behavior: trigger is created for `valid_to` ---
SAVEPOINT test_1;
CREATE TABLE sync_test_default (id int, valid_from date, valid_to date, valid_until date);
SELECT sql_saga.add_era('sync_test_default', synchronize_valid_to_column := 'valid_to');
NOTICE:  sql_saga: Created trigger "sync_test_default_synchronize_temporal_columns_trigger" on table sync_test_default to synchronize columns: valid_to
 add_era 
---------
 t
(1 row)

\d sync_test_default
            Table "public.sync_test_default"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 id          | integer |           |          | 
 valid_from  | date    |           | not null | 
 valid_to    | date    |           |          | 
 valid_until | date    |           | not null | 
Check constraints:
    "sync_test_default_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)
Triggers:
    sync_test_default_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_from, valid_until, valid_to ON sync_test_default FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_from', 'valid_until', 'valid_to', 'null', 'date', 't')

INSERT INTO sync_test_default (id, valid_from, valid_to) VALUES (1, '2024-01-01', '2024-12-31');
SELECT id, valid_from, valid_until, valid_to FROM sync_test_default;
 id | valid_from | valid_until |  valid_to  
----+------------+-------------+------------
  1 | 2024-01-01 | 2025-01-01  | 2024-12-31
(1 row)

UPDATE sync_test_default SET valid_until = '2026-01-01' WHERE id = 1;
SELECT id, valid_from, valid_until, valid_to FROM sync_test_default;
 id | valid_from | valid_until |  valid_to  
----+------------+-------------+------------
  1 | 2024-01-01 | 2026-01-01  | 2025-12-31
(1 row)

ROLLBACK TO SAVEPOINT test_1;
\echo '--- 2. Test disabling the feature with NULL ---'
--- 2. Test disabling the feature with NULL ---
SAVEPOINT test_2;
CREATE TABLE sync_test_disabled (id int, valid_from date, valid_to date, valid_until date);
SELECT sql_saga.add_era('sync_test_disabled');
 add_era 
---------
 t
(1 row)

\d sync_test_disabled
                Table "public.sync_test_disabled"
   Column    |  Type   | Collation | Nullable |     Default      
-------------+---------+-----------+----------+------------------
 id          | integer |           |          | 
 valid_from  | date    |           | not null | 
 valid_to    | date    |           |          | 
 valid_until | date    |           | not null | 'infinity'::date
Check constraints:
    "sync_test_disabled_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

INSERT INTO sync_test_disabled (id, valid_from, valid_until, valid_to) VALUES (1, '2024-01-01', '2025-01-01', '2099-12-31');
SELECT id, valid_from, valid_until, valid_to FROM sync_test_disabled;
 id | valid_from | valid_until |  valid_to  
----+------------+-------------+------------
  1 | 2024-01-01 | 2025-01-01  | 2099-12-31
(1 row)

ROLLBACK TO SAVEPOINT test_2;
\echo '--- 3. Test with a custom column name ---'
--- 3. Test with a custom column name ---
SAVEPOINT test_3;
CREATE TABLE sync_test_custom_name (id int, start_date date, until_date date, to_date date);
SELECT sql_saga.add_era('sync_test_custom_name', 'start_date', 'until_date', synchronize_valid_to_column := 'to_date');
NOTICE:  sql_saga: Created trigger "sync_test_custom_name_synchronize_temporal_columns_trigger" on table sync_test_custom_name to synchronize columns: to_date
 add_era 
---------
 t
(1 row)

\d sync_test_custom_name
         Table "public.sync_test_custom_name"
   Column   |  Type   | Collation | Nullable | Default 
------------+---------+-----------+----------+---------
 id         | integer |           |          | 
 start_date | date    |           | not null | 
 until_date | date    |           | not null | 
 to_date    | date    |           |          | 
Check constraints:
    "sync_test_custom_name_valid_check" CHECK (start_date < until_date AND start_date > '-infinity'::date)
Triggers:
    sync_test_custom_name_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF start_date, until_date, to_date ON sync_test_custom_name FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('start_date', 'until_date', 'to_date', 'null', 'date', 't')

INSERT INTO sync_test_custom_name (id, start_date, to_date) VALUES (1, '2024-01-01', '2024-12-31');
SELECT id, start_date, until_date, to_date FROM sync_test_custom_name;
 id | start_date | until_date |  to_date   
----+------------+------------+------------
  1 | 2024-01-01 | 2025-01-01 | 2024-12-31
(1 row)

ROLLBACK TO SAVEPOINT test_3;
\echo '--- 4. Test edge case: generated column is skipped ---'
--- 4. Test edge case: generated column is skipped ---
SAVEPOINT test_4;
CREATE TABLE sync_test_generated (id int, valid_from date, valid_until date, valid_to date GENERATED ALWAYS AS (valid_until - INTERVAL '1 day') STORED);
SELECT sql_saga.add_era('sync_test_generated', synchronize_valid_to_column := 'valid_to');
NOTICE:  sql_saga: Created trigger "sync_test_generated_synchronize_temporal_columns_trigger" on table sync_test_generated to synchronize columns: valid_to
 add_era 
---------
 t
(1 row)

\d sync_test_generated
                                       Table "public.sync_test_generated"
   Column    |  Type   | Collation | Nullable |                             Default                              
-------------+---------+-----------+----------+------------------------------------------------------------------
 id          | integer |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 
 valid_to    | date    |           |          | generated always as ((valid_until - '@ 1 day'::interval)) stored
Check constraints:
    "sync_test_generated_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)
Triggers:
    sync_test_generated_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_from, valid_until, valid_to ON sync_test_generated FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_from', 'valid_until', 'valid_to', 'null', 'date', 't')

INSERT INTO sync_test_generated (id, valid_from, valid_until) VALUES (1, '2024-01-01', '2025-01-01');
SELECT id, valid_from, valid_until, valid_to FROM sync_test_generated;
 id | valid_from | valid_until |  valid_to  
----+------------+-------------+------------
  1 | 2024-01-01 | 2025-01-01  | 2024-12-31
(1 row)

ROLLBACK TO SAVEPOINT test_4;
\echo '--- 5. Test edge case: wrong data type is skipped ---'
--- 5. Test edge case: wrong data type is skipped ---
SAVEPOINT test_5;
CREATE TABLE sync_test_wrong_type (id int, valid_from date, valid_to text, valid_until date);
SELECT sql_saga.add_era('sync_test_wrong_type', synchronize_valid_to_column := 'valid_to');
WARNING:  sql_saga: Synchronization column "valid_to" on table sync_test_wrong_type has an incompatible data type (text). It must match the era subtype (date). Skipping synchronization.
 add_era 
---------
 t
(1 row)

\d sync_test_wrong_type
          Table "public.sync_test_wrong_type"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 id          | integer |           |          | 
 valid_from  | date    |           | not null | 
 valid_to    | text    |           |          | 
 valid_until | date    |           | not null | 
Check constraints:
    "sync_test_wrong_type_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

INSERT INTO sync_test_wrong_type (id, valid_from, valid_until, valid_to) VALUES (1, '2024-01-01', '2025-01-01', 'some text');
SELECT id, valid_from, valid_until, valid_to FROM sync_test_wrong_type;
 id | valid_from | valid_until | valid_to  
----+------------+-------------+-----------
  1 | 2024-01-01 | 2025-01-01  | some text
(1 row)

ROLLBACK TO SAVEPOINT test_5;
\echo '--- 6. Test NOT NULL on synchronized columns ---'
--- 6. Test NOT NULL on synchronized columns ---
SAVEPOINT test_6_top;
SAVEPOINT test_6a;
\echo '--- 6a. Trigger populates NOT NULL column when other bound is provided ---'
--- 6a. Trigger populates NOT NULL column when other bound is provided ---
-- valid_to is NOT NULL, but the trigger should populate it before the constraint is checked.
CREATE TABLE sync_test_not_null (id int, valid_from date, valid_to date NOT NULL, valid_until date);
SELECT sql_saga.add_era('sync_test_not_null', synchronize_valid_to_column := 'valid_to');
NOTICE:  sql_saga: Created trigger "sync_test_not_null_synchronize_temporal_columns_trigger" on table sync_test_not_null to synchronize columns: valid_to
 add_era 
---------
 t
(1 row)

-- Verify schema. Note that valid_from and valid_until are NOT NULL because
-- add_era adds the constraint, and valid_to is NOT NULL because we declared it.
\d sync_test_not_null
           Table "public.sync_test_not_null"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 id          | integer |           |          | 
 valid_from  | date    |           | not null | 
 valid_to    | date    |           | not null | 
 valid_until | date    |           | not null | 
Check constraints:
    "sync_test_not_null_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)
Triggers:
    sync_test_not_null_synchronize_temporal_columns_trigger BEFORE INSERT OR UPDATE OF valid_from, valid_until, valid_to ON sync_test_not_null FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_from', 'valid_until', 'valid_to', 'null', 'date', 't')

-- This insert omits valid_to, but provides valid_until. The trigger will derive
-- valid_to, and the INSERT should succeed.
INSERT INTO sync_test_not_null (id, valid_from, valid_until) VALUES (1, '2024-01-01', '2025-01-01');
SELECT id, valid_from, valid_until, valid_to FROM sync_test_not_null;
 id | valid_from | valid_until |  valid_to  
----+------------+-------------+------------
  1 | 2024-01-01 | 2025-01-01  | 2024-12-31
(1 row)

RELEASE SAVEPOINT test_6a;
SAVEPOINT test_6b;
\echo '--- 6b. INSERT fails when no temporal bounds are provided and defaults are off ---'
--- 6b. INSERT fails when no temporal bounds are provided and defaults are off ---
CREATE TABLE sync_test_no_defaults (id int, valid_from date, valid_to date NOT NULL, valid_until date);
-- Note: add_defaults := false
-- This prevents the trigger from defaulting valid_until to 'infinity'.
SELECT sql_saga.add_era('sync_test_no_defaults', synchronize_valid_to_column := 'valid_to', add_defaults := false);
NOTICE:  sql_saga: Created trigger "sync_test_no_defaults_synchronize_temporal_columns_trigger" on table sync_test_no_defaults to synchronize columns: valid_to
 add_era 
---------
 t
(1 row)

-- This should fail with a NOT NULL violation because no upper bound was
-- provided and defaults are disabled. The trigger has no source to derive
-- the values from, so they remain NULL, violating a NOT NULL constraint
-- (either on valid_until or the synchronized valid_to).
INSERT INTO sync_test_no_defaults (id, valid_from) VALUES (1, '2024-01-01');
ERROR:  null value in column "valid_to" of relation "sync_test_no_defaults" violates not-null constraint
DETAIL:  Failing row contains (1, 2024-01-01, null, null).
ROLLBACK TO SAVEPOINT test_6b;
SAVEPOINT test_6c;
\echo '--- 6c. INSERT succeeds with defaults enabled when only lower bound is provided ---'
--- 6c. INSERT succeeds with defaults enabled when only lower bound is provided ---
CREATE TABLE sync_test_nullable_with_defaults (id int, valid_from date NOT NULL, valid_to date, valid_until date);
-- Note: add_defaults := true (default)
SELECT sql_saga.add_era('sync_test_nullable_with_defaults', synchronize_valid_to_column := 'valid_to');
NOTICE:  sql_saga: Created trigger "sync_test_nullable_with_defaults_synchronize_temporal_columns_t" on table sync_test_nullable_with_defaults to synchronize columns: valid_to
 add_era 
---------
 t
(1 row)

\d sync_test_nullable_with_defaults
    Table "public.sync_test_nullable_with_defaults"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 id          | integer |           |          | 
 valid_from  | date    |           | not null | 
 valid_to    | date    |           |          | 
 valid_until | date    |           | not null | 
Check constraints:
    "sync_test_nullable_with_defaults_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)
Triggers:
    sync_test_nullable_with_defaults_synchronize_temporal_columns_t BEFORE INSERT OR UPDATE OF valid_from, valid_until, valid_to ON sync_test_nullable_with_defaults FOR EACH ROW EXECUTE FUNCTION sql_saga.synchronize_temporal_columns('valid_from', 'valid_until', 'valid_to', 'null', 'date', 't')

-- This should succeed. The trigger will see that valid_until is NULL, apply the
-- 'infinity' default, and then derive valid_to from that.
INSERT INTO sync_test_nullable_with_defaults (id, valid_from) VALUES (1, '2024-01-01');
SELECT id, valid_from, valid_until, valid_to FROM sync_test_nullable_with_defaults;
 id | valid_from | valid_until | valid_to 
----+------------+-------------+----------
  1 | 2024-01-01 | infinity    | infinity
(1 row)

RELEASE SAVEPOINT test_6c;
ROLLBACK TO SAVEPOINT test_6_top;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
