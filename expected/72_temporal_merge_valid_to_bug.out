\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
SET datestyle TO 'ISO, DMY';
\echo '--- SETUP: Create temporal table with valid_to synchronization ---'
--- SETUP: Create temporal table with valid_to synchronization ---
CREATE TABLE public.my_temporal_table (
    id INT NOT NULL,
    name TEXT,
    death_date DATE,
    valid_from DATE NOT NULL,
    valid_until DATE,
    valid_to DATE
);
SELECT sql_saga.add_era('public.my_temporal_table', p_synchronize_valid_to_column => 'valid_to');
NOTICE:  sql_saga: Created trigger "my_temporal_table_synchronize_temporal_columns_trigger" on table my_temporal_table to synchronize columns: valid_to
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'public.my_temporal_table'::regclass, column_names => ARRAY['id'], unique_key_name => 'my_temporal_table_id_valid');
       add_unique_key       
----------------------------
 my_temporal_table_id_valid
(1 row)

\echo '--- SOURCE DATA: Two rows for one entity, second represents a death ---'
--- SOURCE DATA: Two rows for one entity, second represents a death ---
CREATE TEMP TABLE source_data (
    id INT NOT NULL,
    name TEXT,
    death_date DATE,
    valid_from DATE NOT NULL,
    valid_to DATE,
    founding_row_id INT,
    data_row_id INT,
    valid_until DATE
) ON COMMIT DROP;
INSERT INTO source_data (data_row_id, founding_row_id, id, name, valid_from, valid_to, death_date) VALUES
-- This first row represents the original state. Its valid_to is the final death date of the entity.
(1, 1, 101, 'Unit A v1', '2010-01-01', '2012-12-31', NULL),
-- This second row represents the death. valid_from and valid_to are the death date.
-- Crucially, the valid_to from the first row ('2012-12-31') is inconsistent for the
-- time slice that sql_saga will generate from it ('2010-01-01' to '2012-12-30').
(2, 1, 101, 'Unit A v1', '2012-12-31', '2012-12-31', '2012-12-31');
-- Mimic the import process deriving valid_until from valid_to
UPDATE source_data SET valid_until = valid_to + INTERVAL '1 day';
\echo 'Initial source data:'
Initial source data:
TABLE source_data;
 id  |   name    | death_date | valid_from |  valid_to  | founding_row_id | data_row_id | valid_until 
-----+-----------+------------+------------+------------+-----------------+-------------+-------------
 101 | Unit A v1 |            | 2010-01-01 | 2012-12-31 |               1 |           1 | 2013-01-01
 101 | Unit A v1 | 2012-12-31 | 2012-12-31 | 2012-12-31 |               1 |           2 | 2013-01-01
(2 rows)

\echo '--- VERIFY FIX (MERGE_ENTITY_REPLACE): Call temporal_merge, which should now succeed ---'
--- VERIFY FIX (MERGE_ENTITY_REPLACE): Call temporal_merge, which should now succeed ---
-- This call should now succeed. The planner will correctly calculate the
-- `valid_to` for the shortened time slice, preventing a constraint violation.
CALL sql_saga.temporal_merge(
    p_target_table => 'public.my_temporal_table',
    p_source_table => 'source_data',
    p_identity_columns => ARRAY['id'],
    p_ephemeral_columns => '{}',
    p_mode => 'MERGE_ENTITY_REPLACE',
    p_identity_correlation_column => 'founding_row_id',
    p_source_row_id_column => 'data_row_id'
);
\echo '--- VERIFICATION: Final state of my_temporal_table ---'
--- VERIFICATION: Final state of my_temporal_table ---
-- The target table should now contain two correct historical slices.
TABLE public.my_temporal_table;
 id  |   name    | death_date | valid_from | valid_until |  valid_to  
-----+-----------+------------+------------+-------------+------------
 101 | Unit A v1 |            | 2010-01-01 | 2012-12-31  | 2012-12-30
 101 | Unit A v1 | 2012-12-31 | 2012-12-31 | 2013-01-01  | 2012-12-31
(2 rows)

ROLLBACK;
--
-- Test DELETE_FOR_PORTION_OF to ensure the fix is generic
--
BEGIN;
SET datestyle TO 'ISO, DMY';
\echo '--- SETUP: Recreate table and initial data for DELETE_FOR_PORTION_OF test ---'
--- SETUP: Recreate table and initial data for DELETE_FOR_PORTION_OF test ---
CREATE TABLE public.my_temporal_table (
    id INT NOT NULL,
    name TEXT,
    valid_from DATE NOT NULL,
    valid_until DATE,
    valid_to DATE
);
SELECT sql_saga.add_era('public.my_temporal_table', p_synchronize_valid_to_column => 'valid_to');
NOTICE:  sql_saga: Created trigger "my_temporal_table_synchronize_temporal_columns_trigger" on table my_temporal_table to synchronize columns: valid_to
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'public.my_temporal_table'::regclass, column_names => ARRAY['id']);
       add_unique_key       
----------------------------
 my_temporal_table_id_valid
(1 row)

-- Insert one long-lived entity.
INSERT INTO public.my_temporal_table (id, name, valid_from, valid_until)
VALUES (101, 'Unit A', '2010-01-01', '2020-01-01');
\echo 'Initial target data:'
Initial target data:
TABLE public.my_temporal_table;
 id  |  name  | valid_from | valid_until |  valid_to  
-----+--------+------------+-------------+------------
 101 | Unit A | 2010-01-01 | 2020-01-01  | 2019-12-31
(1 row)

\echo '--- SOURCE DATA: A single row to delete a portion from the middle ---'
--- SOURCE DATA: A single row to delete a portion from the middle ---
CREATE TEMP TABLE source_data_delete (
    id INT NOT NULL,
    valid_from DATE NOT NULL,
    valid_until DATE,
    data_row_id INT
) ON COMMIT DROP;
INSERT INTO source_data_delete (data_row_id, id, valid_from, valid_until) VALUES
(1, 101, '2012-01-01', '2013-01-01');
\echo 'Source data for deletion:'
Source data for deletion:
TABLE source_data_delete;
 id  | valid_from | valid_until | data_row_id 
-----+------------+-------------+-------------
 101 | 2012-01-01 | 2013-01-01  |           1
(1 row)

\echo '--- VERIFY FIX (DELETE_FOR_PORTION_OF): Call temporal_merge ---'
--- VERIFY FIX (DELETE_FOR_PORTION_OF): Call temporal_merge ---
CALL sql_saga.temporal_merge(
    p_target_table => 'public.my_temporal_table',
    p_source_table => 'source_data_delete',
    p_identity_columns => ARRAY['id'],
    p_ephemeral_columns => '{}',
    p_mode => 'DELETE_FOR_PORTION_OF',
    p_source_row_id_column => 'data_row_id'
);
\echo '--- VERIFICATION: Final state of my_temporal_table ---'
--- VERIFICATION: Final state of my_temporal_table ---
-- The target table should now be split into two slices around the deleted portion,
-- with valid_to correctly calculated for both. The first slice is shortened,
-- so its valid_to must be recalculated.
TABLE public.my_temporal_table;
 id  |  name  | valid_from | valid_until |  valid_to  
-----+--------+------------+-------------+------------
 101 | Unit A | 2013-01-01 | 2020-01-01  | 2019-12-31
 101 | Unit A | 2010-01-01 | 2012-01-01  | 2011-12-31
(2 rows)

ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
