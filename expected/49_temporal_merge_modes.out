\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo 'Test Suite: Comprehensive `sql_saga.temporal_merge` Mode Behaviors'
Test Suite: Comprehensive `sql_saga.temporal_merge` Mode Behaviors
\echo 'Description:'
Description:
\echo '  This test suite provides a comprehensive validation of each `temporal_merge_mode`.'
  This test suite provides a comprehensive validation of each `temporal_merge_mode`.
\echo '  It uses a consistent, rich target timeline with gaps and adjacencies, and'
  It uses a consistent, rich target timeline with gaps and adjacencies, and
\echo '  a varied source dataset to test pre, post, adjacent, gap, and entry-crossing'
  a varied source dataset to test pre, post, adjacent, gap, and entry-crossing
\echo '  scenarios. Each scenario clearly prints the plan, feedback, and final state.'
  scenarios. Each scenario clearly prints the plan, feedback, and final state.
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
SET client_min_messages TO WARNING;
CREATE SCHEMA tmm; -- Temporal Merge Modes
-- Target table for all scenarios
CREATE TABLE tmm.target (id int, value text, edit_comment text, valid_from date, valid_until date);
SELECT sql_saga.add_era('tmm.target', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

-- Helper to reset state to a rich timeline
CREATE PROCEDURE tmm.reset_target() LANGUAGE plpgsql AS $$
BEGIN
    TRUNCATE tmm.target;
    INSERT INTO tmm.target VALUES
        -- Entity 1 has adjacent slices and a gap
        (1, 'A1', 'Slice 1',           '2024-01-01', '2024-02-01'),
        (1, 'A2', 'Slice 2 (Adjacent)','2024-02-01', '2024-03-01'),
        (1, 'A3', 'Slice 3 (After Gap)','2024-04-01', '2024-05-01'),
        -- Entity 2 is a simple, long-lived entity
        (2, 'B',  'Long-lived',        '2023-01-01', '2026-01-01');
END;
$$;
--------------------------------------------------------------------------------
\echo 'Scenario 1: `MERGE_ENTITY_PATCH`'
Scenario 1: `MERGE_ENTITY_PATCH`
\echo 'Use Case: Standard upsert. Patches existing data, preserves timeline gaps, and inserts new entities.'
Use Case: Standard upsert. Patches existing data, preserves timeline gaps, and inserts new entities.
--------------------------------------------------------------------------------
SAVEPOINT s1;
CALL tmm.reset_target();
CREATE TEMP TABLE source_1 (row_id int, id int, value text, edit_comment text, valid_from date, valid_until date) ON COMMIT DROP;
INSERT INTO source_1 VALUES
    -- 1.1: Surgical patch inside slice 2
    (101, 1, 'A2-patch', 'Patch inside S2', '2024-02-10', '2024-02-20'),
    -- 1.2: Bridge the gap between Slice 2 and 3
    (102, 1, 'A2.5-bridge', 'Bridge the gap', '2024-03-01', '2024-04-01'),
    -- 1.3: Insert a new entity 3
    (103, 3, 'C', 'New entity', '2024-01-01', '2025-01-01');
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
TABLE tmm.target ORDER BY id, valid_from;
 id | value |    edit_comment     | valid_from | valid_until 
----+-------+---------------------+------------+-------------
  1 | A1    | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2    | Slice 2 (Adjacent)  | 2024-02-01 | 2024-03-01
  1 | A3    | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B     | Long-lived          | 2023-01-01 | 2026-01-01
(4 rows)

\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
TABLE source_1 ORDER BY row_id;
 row_id | id |    value    |  edit_comment   | valid_from | valid_until 
--------+----+-------------+-----------------+------------+-------------
    101 |  1 | A2-patch    | Patch inside S2 | 2024-02-10 | 2024-02-20
    102 |  1 | A2.5-bridge | Bridge the gap  | 2024-03-01 | 2024-04-01
    103 |  3 | C           | New entity      | 2024-01-01 | 2025-01-01
(3 rows)

CALL sql_saga.temporal_merge(p_target_table => 'tmm.target'::regclass, p_source_table => 'source_1'::regclass, p_identity_columns => '{id}'::text[], p_ephemeral_columns => '{edit_comment}'::text[], p_mode => 'MERGE_ENTITY_PATCH'::sql_saga.temporal_merge_mode, p_era_name => 'valid');
\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids |   operation    | entity_ids | old_valid_from | new_valid_from | new_valid_until |                            data                            | relation 
-------------+----------------+----------------+------------+----------------+----------------+-----------------+------------------------------------------------------------+----------
           1 |                | SKIP_IDENTICAL | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-02-01      | {"value": "A1", "edit_comment": "Slice 1"}                 | equals
           2 | {101}          | UPDATE         | {"id": 1}  | 2024-02-01     | 2024-02-01     | 2024-02-10      | {"value": "A2", "edit_comment": "Slice 2 (Adjacent)"}      | starts
           3 | {101}          | INSERT         | {"id": 1}  |                | 2024-02-10     | 2024-02-20      | {"value": "A2-patch", "edit_comment": "Patch inside S2"}   | 
           4 | {101}          | INSERT         | {"id": 1}  |                | 2024-02-20     | 2024-03-01      | {"value": "A2", "edit_comment": "Slice 2 (Adjacent)"}      | 
           5 | {102}          | INSERT         | {"id": 1}  |                | 2024-03-01     | 2024-04-01      | {"value": "A2.5-bridge", "edit_comment": "Bridge the gap"} | 
           6 |                | SKIP_IDENTICAL | {"id": 1}  | 2024-04-01     | 2024-04-01     | 2024-05-01      | {"value": "A3", "edit_comment": "Slice 3 (After Gap)"}     | equals
           7 | {103}          | INSERT         | {"id": 3}  |                | 2024-01-01     | 2025-01-01      | {"value": "C", "edit_comment": "New entity"}               | 
(7 rows)

\echo '--- Executor: Actual Feedback ---'
--- Executor: Actual Feedback ---
TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_ids | status  | error_message 
---------------+-------------------+---------+---------------
           101 | [{"id": 1}]       | APPLIED | 
           102 | [{"id": 1}]       | APPLIED | 
           103 | [{"id": 3}]       | APPLIED | 
(3 rows)

\echo '--- Target: Expected Final State ---'
--- Target: Expected Final State ---
SELECT * FROM (VALUES
    (1, 'A1', 'Slice 1', '2024-01-01'::date, '2024-02-01'::date),
    (1, 'A2', 'Slice 2 (Adjacent)', '2024-02-01'::date, '2024-02-10'::date),
    (1, 'A2-patch', 'Patch inside S2', '2024-02-10'::date, '2024-02-20'::date),
    (1, 'A2', 'Slice 2 (Adjacent)', '2024-02-20'::date, '2024-03-01'::date),
    (1, 'A2.5-bridge', 'Bridge the gap', '2024-03-01'::date, '2024-04-01'::date),
    (1, 'A3', 'Slice 3 (After Gap)', '2024-04-01'::date, '2024-05-01'::date),
    (2, 'B', 'Long-lived', '2023-01-01'::date, '2026-01-01'::date),
    (3, 'C', 'New entity', '2024-01-01'::date, '2025-01-01'::date)
) t(id, value, edit_comment, valid_from, valid_until) ORDER BY id, valid_from;
 id |    value    |    edit_comment     | valid_from | valid_until 
----+-------------+---------------------+------------+-------------
  1 | A1          | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2          | Slice 2 (Adjacent)  | 2024-02-01 | 2024-02-10
  1 | A2-patch    | Patch inside S2     | 2024-02-10 | 2024-02-20
  1 | A2          | Slice 2 (Adjacent)  | 2024-02-20 | 2024-03-01
  1 | A2.5-bridge | Bridge the gap      | 2024-03-01 | 2024-04-01
  1 | A3          | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B           | Long-lived          | 2023-01-01 | 2026-01-01
  3 | C           | New entity          | 2024-01-01 | 2025-01-01
(8 rows)

\echo '--- Target: Final State ---'
--- Target: Final State ---
TABLE tmm.target ORDER BY id, valid_from;
 id |    value    |    edit_comment     | valid_from | valid_until 
----+-------------+---------------------+------------+-------------
  1 | A1          | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2          | Slice 2 (Adjacent)  | 2024-02-01 | 2024-02-10
  1 | A2-patch    | Patch inside S2     | 2024-02-10 | 2024-02-20
  1 | A2          | Slice 2 (Adjacent)  | 2024-02-20 | 2024-03-01
  1 | A2.5-bridge | Bridge the gap      | 2024-03-01 | 2024-04-01
  1 | A3          | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B           | Long-lived          | 2023-01-01 | 2026-01-01
  3 | C           | New entity          | 2024-01-01 | 2025-01-01
(8 rows)

ROLLBACK TO SAVEPOINT s1;
--------------------------------------------------------------------------------
\echo 'Scenario 2: `MERGE_ENTITY_REPLACE`'
Scenario 2: `MERGE_ENTITY_REPLACE`
\echo 'Use Case: Upsert with NULL overwrites. Replaces existing data, preserves timeline gaps, inserts new entities.'
Use Case: Upsert with NULL overwrites. Replaces existing data, preserves timeline gaps, inserts new entities.
--------------------------------------------------------------------------------
SAVEPOINT s2;
CALL tmm.reset_target();
CREATE TEMP TABLE source_2 (row_id int, id int, value text, edit_comment text, valid_from date, valid_until date) ON COMMIT DROP;
INSERT INTO source_2 VALUES
    -- 2.1: Surgical replace inside slice 2
    (201, 1, 'A2-replace', 'Replace inside S2', '2024-02-10', '2024-02-20'),
    -- 2.2: Surgical replace with NULL inside slice 3
    (202, 1, NULL, 'Replace with NULL', '2024-04-10', '2024-04-20'),
    -- 2.3: Insert a new entity 3
    (203, 3, 'C', 'New entity', '2024-01-01', '2025-01-01');
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
TABLE tmm.target ORDER BY id, valid_from;
 id | value |    edit_comment     | valid_from | valid_until 
----+-------+---------------------+------------+-------------
  1 | A1    | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2    | Slice 2 (Adjacent)  | 2024-02-01 | 2024-03-01
  1 | A3    | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B     | Long-lived          | 2023-01-01 | 2026-01-01
(4 rows)

\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
TABLE source_2 ORDER BY row_id;
 row_id | id |   value    |   edit_comment    | valid_from | valid_until 
--------+----+------------+-------------------+------------+-------------
    201 |  1 | A2-replace | Replace inside S2 | 2024-02-10 | 2024-02-20
    202 |  1 |            | Replace with NULL | 2024-04-10 | 2024-04-20
    203 |  3 | C          | New entity        | 2024-01-01 | 2025-01-01
(3 rows)

CALL sql_saga.temporal_merge(p_target_table => 'tmm.target'::regclass, p_source_table => 'source_2'::regclass, p_identity_columns => '{id}'::text[], p_ephemeral_columns => '{edit_comment}'::text[], p_mode => 'MERGE_ENTITY_REPLACE'::sql_saga.temporal_merge_mode, p_era_name => 'valid');
\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids |   operation    | entity_ids | old_valid_from | new_valid_from | new_valid_until |                             data                             | relation 
-------------+----------------+----------------+------------+----------------+----------------+-----------------+--------------------------------------------------------------+----------
           1 |                | SKIP_IDENTICAL | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-02-01      | {"value": "A1", "edit_comment": "Slice 1"}                   | equals
           2 | {201}          | UPDATE         | {"id": 1}  | 2024-02-01     | 2024-02-01     | 2024-02-10      | {"value": "A2", "edit_comment": "Slice 2 (Adjacent)"}        | starts
           3 | {201}          | INSERT         | {"id": 1}  |                | 2024-02-10     | 2024-02-20      | {"value": "A2-replace", "edit_comment": "Replace inside S2"} | 
           4 | {201}          | INSERT         | {"id": 1}  |                | 2024-02-20     | 2024-03-01      | {"value": "A2", "edit_comment": "Slice 2 (Adjacent)"}        | 
           5 | {202}          | UPDATE         | {"id": 1}  | 2024-04-01     | 2024-04-01     | 2024-04-10      | {"value": "A3", "edit_comment": "Slice 3 (After Gap)"}       | starts
           6 | {202}          | INSERT         | {"id": 1}  |                | 2024-04-10     | 2024-04-20      | {"value": null, "edit_comment": "Replace with NULL"}         | 
           7 | {202}          | INSERT         | {"id": 1}  |                | 2024-04-20     | 2024-05-01      | {"value": "A3", "edit_comment": "Slice 3 (After Gap)"}       | 
           8 | {203}          | INSERT         | {"id": 3}  |                | 2024-01-01     | 2025-01-01      | {"value": "C", "edit_comment": "New entity"}                 | 
(8 rows)

\echo '--- Executor: Actual Feedback ---'
--- Executor: Actual Feedback ---
TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_ids | status  | error_message 
---------------+-------------------+---------+---------------
           201 | [{"id": 1}]       | APPLIED | 
           202 | [{"id": 1}]       | APPLIED | 
           203 | [{"id": 3}]       | APPLIED | 
(3 rows)

\echo '--- Target: Expected Final State ---'
--- Target: Expected Final State ---
SELECT * FROM (VALUES
    (1, 'A1', 'Slice 1', '2024-01-01'::date, '2024-02-01'::date),
    (1, 'A2', 'Slice 2 (Adjacent)', '2024-02-01'::date, '2024-02-10'::date),
    (1, 'A2-replace', 'Replace inside S2', '2024-02-10'::date, '2024-02-20'::date),
    (1, 'A2', 'Slice 2 (Adjacent)', '2024-02-20'::date, '2024-03-01'::date),
    (1, 'A3', 'Slice 3 (After Gap)', '2024-04-01'::date, '2024-04-10'::date),
    (1, NULL, 'Replace with NULL', '2024-04-10'::date, '2024-04-20'::date),
    (1, 'A3', 'Slice 3 (After Gap)', '2024-04-20'::date, '2024-05-01'::date),
    (2, 'B', 'Long-lived', '2023-01-01'::date, '2026-01-01'::date),
    (3, 'C', 'New entity', '2024-01-01'::date, '2025-01-01'::date)
) t(id, value, edit_comment, valid_from, valid_until) ORDER BY id, valid_from;
 id |   value    |    edit_comment     | valid_from | valid_until 
----+------------+---------------------+------------+-------------
  1 | A1         | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2         | Slice 2 (Adjacent)  | 2024-02-01 | 2024-02-10
  1 | A2-replace | Replace inside S2   | 2024-02-10 | 2024-02-20
  1 | A2         | Slice 2 (Adjacent)  | 2024-02-20 | 2024-03-01
  1 | A3         | Slice 3 (After Gap) | 2024-04-01 | 2024-04-10
  1 |            | Replace with NULL   | 2024-04-10 | 2024-04-20
  1 | A3         | Slice 3 (After Gap) | 2024-04-20 | 2024-05-01
  2 | B          | Long-lived          | 2023-01-01 | 2026-01-01
  3 | C          | New entity          | 2024-01-01 | 2025-01-01
(9 rows)

\echo '--- Target: Final State ---'
--- Target: Final State ---
TABLE tmm.target ORDER BY id, valid_from;
 id |   value    |    edit_comment     | valid_from | valid_until 
----+------------+---------------------+------------+-------------
  1 | A1         | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2         | Slice 2 (Adjacent)  | 2024-02-01 | 2024-02-10
  1 | A2-replace | Replace inside S2   | 2024-02-10 | 2024-02-20
  1 | A2         | Slice 2 (Adjacent)  | 2024-02-20 | 2024-03-01
  1 | A3         | Slice 3 (After Gap) | 2024-04-01 | 2024-04-10
  1 |            | Replace with NULL   | 2024-04-10 | 2024-04-20
  1 | A3         | Slice 3 (After Gap) | 2024-04-20 | 2024-05-01
  2 | B          | Long-lived          | 2023-01-01 | 2026-01-01
  3 | C          | New entity          | 2024-01-01 | 2025-01-01
(9 rows)

ROLLBACK TO SAVEPOINT s2;
--------------------------------------------------------------------------------
\echo 'Scenario 3: `PATCH_FOR_PORTION_OF`'
Scenario 3: `PATCH_FOR_PORTION_OF`
\echo 'Use Case: Surgical patch on existing entities only; new entities are ignored.'
Use Case: Surgical patch on existing entities only; new entities are ignored.
--------------------------------------------------------------------------------
SAVEPOINT s3;
CALL tmm.reset_target();
CREATE TEMP TABLE source_3 (row_id int, id int, value text, edit_comment text, valid_from date, valid_until date) ON COMMIT DROP;
INSERT INTO source_3 VALUES
    -- 3.1: Surgical patch inside slice 2
    (301, 1, 'A2-patch', 'Patch inside S2', '2024-02-10', '2024-02-20'),
    -- 3.2: Attempt to insert a new entity 3 (should be skipped)
    (302, 3, 'C', 'New entity', '2024-01-01', '2025-01-01');
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
TABLE tmm.target ORDER BY id, valid_from;
 id | value |    edit_comment     | valid_from | valid_until 
----+-------+---------------------+------------+-------------
  1 | A1    | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2    | Slice 2 (Adjacent)  | 2024-02-01 | 2024-03-01
  1 | A3    | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B     | Long-lived          | 2023-01-01 | 2026-01-01
(4 rows)

\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
TABLE source_3 ORDER BY row_id;
 row_id | id |  value   |  edit_comment   | valid_from | valid_until 
--------+----+----------+-----------------+------------+-------------
    301 |  1 | A2-patch | Patch inside S2 | 2024-02-10 | 2024-02-20
    302 |  3 | C        | New entity      | 2024-01-01 | 2025-01-01
(2 rows)

CALL sql_saga.temporal_merge(p_target_table => 'tmm.target'::regclass, p_source_table => 'source_3'::regclass, p_identity_columns => '{id}'::text[], p_ephemeral_columns => '{edit_comment}'::text[], p_mode => 'PATCH_FOR_PORTION_OF'::sql_saga.temporal_merge_mode, p_era_name => 'valid');
\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids |   operation    | entity_ids | old_valid_from | new_valid_from | new_valid_until |                           data                           | relation 
-------------+----------------+----------------+------------+----------------+----------------+-----------------+----------------------------------------------------------+----------
           1 |                | SKIP_IDENTICAL | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-02-01      | {"value": "A1", "edit_comment": "Slice 1"}               | equals
           2 | {301}          | UPDATE         | {"id": 1}  | 2024-02-01     | 2024-02-01     | 2024-02-10      | {"value": "A2", "edit_comment": "Slice 2 (Adjacent)"}    | starts
           3 | {301}          | INSERT         | {"id": 1}  |                | 2024-02-10     | 2024-02-20      | {"value": "A2-patch", "edit_comment": "Patch inside S2"} | 
           4 | {301}          | INSERT         | {"id": 1}  |                | 2024-02-20     | 2024-03-01      | {"value": "A2", "edit_comment": "Slice 2 (Adjacent)"}    | 
           5 |                | SKIP_IDENTICAL | {"id": 1}  | 2024-04-01     | 2024-04-01     | 2024-05-01      | {"value": "A3", "edit_comment": "Slice 3 (After Gap)"}   | equals
           6 | {302}          | SKIP_NO_TARGET | {"id": 3}  |                |                |                 |                                                          | 
(6 rows)

\echo '--- Executor: Actual Feedback ---'
--- Executor: Actual Feedback ---
TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_ids |      status       | error_message 
---------------+-------------------+-------------------+---------------
           301 | [{"id": 1}]       | APPLIED           | 
           302 | [{"id": 3}]       | SKIPPED_NO_TARGET | 
(2 rows)

\echo '--- Target: Expected Final State ---'
--- Target: Expected Final State ---
SELECT * FROM (VALUES
    (1, 'A1', 'Slice 1', '2024-01-01'::date, '2024-02-01'::date),
    (1, 'A2', 'Slice 2 (Adjacent)', '2024-02-01'::date, '2024-02-10'::date),
    (1, 'A2-patch', 'Patch inside S2', '2024-02-10'::date, '2024-02-20'::date),
    (1, 'A2', 'Slice 2 (Adjacent)', '2024-02-20'::date, '2024-03-01'::date),
    (1, 'A3', 'Slice 3 (After Gap)', '2024-04-01'::date, '2024-05-01'::date),
    (2, 'B', 'Long-lived', '2023-01-01'::date, '2026-01-01'::date)
) t(id, value, edit_comment, valid_from, valid_until) ORDER BY id, valid_from;
 id |  value   |    edit_comment     | valid_from | valid_until 
----+----------+---------------------+------------+-------------
  1 | A1       | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2       | Slice 2 (Adjacent)  | 2024-02-01 | 2024-02-10
  1 | A2-patch | Patch inside S2     | 2024-02-10 | 2024-02-20
  1 | A2       | Slice 2 (Adjacent)  | 2024-02-20 | 2024-03-01
  1 | A3       | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B        | Long-lived          | 2023-01-01 | 2026-01-01
(6 rows)

\echo '--- Target: Final State ---'
--- Target: Final State ---
TABLE tmm.target ORDER BY id, valid_from;
 id |  value   |    edit_comment     | valid_from | valid_until 
----+----------+---------------------+------------+-------------
  1 | A1       | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2       | Slice 2 (Adjacent)  | 2024-02-01 | 2024-02-10
  1 | A2-patch | Patch inside S2     | 2024-02-10 | 2024-02-20
  1 | A2       | Slice 2 (Adjacent)  | 2024-02-20 | 2024-03-01
  1 | A3       | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B        | Long-lived          | 2023-01-01 | 2026-01-01
(6 rows)

ROLLBACK TO SAVEPOINT s3;
--------------------------------------------------------------------------------
\echo 'Scenario 4: `REPLACE_FOR_PORTION_OF`'
Scenario 4: `REPLACE_FOR_PORTION_OF`
\echo 'Use Case: Surgical replace on existing entities only; new entities are ignored.'
Use Case: Surgical replace on existing entities only; new entities are ignored.
--------------------------------------------------------------------------------
SAVEPOINT s4;
CALL tmm.reset_target();
CREATE TEMP TABLE source_4 (row_id int, id int, value text, edit_comment text, valid_from date, valid_until date) ON COMMIT DROP;
INSERT INTO source_4 VALUES
    -- 4.1: Surgical replace inside slice 2
    (401, 1, 'A2-replace', 'Replace inside S2', '2024-02-10', '2024-02-20'),
    -- 4.2: Attempt to insert a new entity 3 (should be skipped)
    (402, 3, 'C', 'New entity', '2024-01-01', '2025-01-01');
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
TABLE tmm.target ORDER BY id, valid_from;
 id | value |    edit_comment     | valid_from | valid_until 
----+-------+---------------------+------------+-------------
  1 | A1    | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2    | Slice 2 (Adjacent)  | 2024-02-01 | 2024-03-01
  1 | A3    | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B     | Long-lived          | 2023-01-01 | 2026-01-01
(4 rows)

\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
TABLE source_4 ORDER BY row_id;
 row_id | id |   value    |   edit_comment    | valid_from | valid_until 
--------+----+------------+-------------------+------------+-------------
    401 |  1 | A2-replace | Replace inside S2 | 2024-02-10 | 2024-02-20
    402 |  3 | C          | New entity        | 2024-01-01 | 2025-01-01
(2 rows)

CALL sql_saga.temporal_merge(p_target_table => 'tmm.target'::regclass, p_source_table => 'source_4'::regclass, p_identity_columns => '{id}'::text[], p_ephemeral_columns => '{edit_comment}'::text[], p_mode => 'REPLACE_FOR_PORTION_OF'::sql_saga.temporal_merge_mode, p_era_name => 'valid');
\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids |   operation    | entity_ids | old_valid_from | new_valid_from | new_valid_until |                             data                             | relation 
-------------+----------------+----------------+------------+----------------+----------------+-----------------+--------------------------------------------------------------+----------
           1 |                | SKIP_IDENTICAL | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-02-01      | {"value": "A1", "edit_comment": "Slice 1"}                   | equals
           2 | {401}          | UPDATE         | {"id": 1}  | 2024-02-01     | 2024-02-01     | 2024-02-10      | {"value": "A2", "edit_comment": "Slice 2 (Adjacent)"}        | starts
           3 | {401}          | INSERT         | {"id": 1}  |                | 2024-02-10     | 2024-02-20      | {"value": "A2-replace", "edit_comment": "Replace inside S2"} | 
           4 | {401}          | INSERT         | {"id": 1}  |                | 2024-02-20     | 2024-03-01      | {"value": "A2", "edit_comment": "Slice 2 (Adjacent)"}        | 
           5 |                | SKIP_IDENTICAL | {"id": 1}  | 2024-04-01     | 2024-04-01     | 2024-05-01      | {"value": "A3", "edit_comment": "Slice 3 (After Gap)"}       | equals
           6 | {402}          | SKIP_NO_TARGET | {"id": 3}  |                |                |                 |                                                              | 
(6 rows)

\echo '--- Executor: Actual Feedback ---'
--- Executor: Actual Feedback ---
TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_ids |      status       | error_message 
---------------+-------------------+-------------------+---------------
           401 | [{"id": 1}]       | APPLIED           | 
           402 | [{"id": 3}]       | SKIPPED_NO_TARGET | 
(2 rows)

\echo '--- Target: Expected Final State ---'
--- Target: Expected Final State ---
SELECT * FROM (VALUES
    (1, 'A1', 'Slice 1', '2024-01-01'::date, '2024-02-01'::date),
    (1, 'A2', 'Slice 2 (Adjacent)', '2024-02-01'::date, '2024-02-10'::date),
    (1, 'A2-replace', 'Replace inside S2', '2024-02-10'::date, '2024-02-20'::date),
    (1, 'A2', 'Slice 2 (Adjacent)', '2024-02-20'::date, '2024-03-01'::date),
    (1, 'A3', 'Slice 3 (After Gap)', '2024-04-01'::date, '2024-05-01'::date),
    (2, 'B', 'Long-lived', '2023-01-01'::date, '2026-01-01'::date)
) t(id, value, edit_comment, valid_from, valid_until) ORDER BY id, valid_from;
 id |   value    |    edit_comment     | valid_from | valid_until 
----+------------+---------------------+------------+-------------
  1 | A1         | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2         | Slice 2 (Adjacent)  | 2024-02-01 | 2024-02-10
  1 | A2-replace | Replace inside S2   | 2024-02-10 | 2024-02-20
  1 | A2         | Slice 2 (Adjacent)  | 2024-02-20 | 2024-03-01
  1 | A3         | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B          | Long-lived          | 2023-01-01 | 2026-01-01
(6 rows)

\echo '--- Target: Final State ---'
--- Target: Final State ---
TABLE tmm.target ORDER BY id, valid_from;
 id |   value    |    edit_comment     | valid_from | valid_until 
----+------------+---------------------+------------+-------------
  1 | A1         | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2         | Slice 2 (Adjacent)  | 2024-02-01 | 2024-02-10
  1 | A2-replace | Replace inside S2   | 2024-02-10 | 2024-02-20
  1 | A2         | Slice 2 (Adjacent)  | 2024-02-20 | 2024-03-01
  1 | A3         | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B          | Long-lived          | 2023-01-01 | 2026-01-01
(6 rows)

ROLLBACK TO SAVEPOINT s4;
--------------------------------------------------------------------------------
\echo 'Scenario 5: `INSERT_NEW_ENTITIES`'
Scenario 5: `INSERT_NEW_ENTITIES`
\echo 'Use Case: Insert only new entities; existing entities are ignored.'
Use Case: Insert only new entities; existing entities are ignored.
--------------------------------------------------------------------------------
SAVEPOINT s5;
CALL tmm.reset_target();
CREATE TEMP TABLE source_5 (row_id int, id int, value text, edit_comment text, valid_from date, valid_until date) ON COMMIT DROP;
INSERT INTO source_5 VALUES
    -- 5.1: Attempt to patch entity 1 (should be skipped)
    (501, 1, 'A2-patch', 'Patch inside S2', '2024-02-10', '2024-02-20'),
    -- 5.2: Insert a new entity 3
    (502, 3, 'C', 'New entity', '2024-01-01', '2025-01-01');
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
TABLE tmm.target ORDER BY id, valid_from;
 id | value |    edit_comment     | valid_from | valid_until 
----+-------+---------------------+------------+-------------
  1 | A1    | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2    | Slice 2 (Adjacent)  | 2024-02-01 | 2024-03-01
  1 | A3    | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B     | Long-lived          | 2023-01-01 | 2026-01-01
(4 rows)

\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
TABLE source_5 ORDER BY row_id;
 row_id | id |  value   |  edit_comment   | valid_from | valid_until 
--------+----+----------+-----------------+------------+-------------
    501 |  1 | A2-patch | Patch inside S2 | 2024-02-10 | 2024-02-20
    502 |  3 | C        | New entity      | 2024-01-01 | 2025-01-01
(2 rows)

CALL sql_saga.temporal_merge(p_target_table => 'tmm.target'::regclass, p_source_table => 'source_5'::regclass, p_identity_columns => '{id}'::text[], p_ephemeral_columns => '{edit_comment}'::text[], p_mode => 'INSERT_NEW_ENTITIES'::sql_saga.temporal_merge_mode, p_era_name => 'valid');
\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids |   operation    | entity_ids | old_valid_from | new_valid_from | new_valid_until |                          data                          | relation 
-------------+----------------+----------------+------------+----------------+----------------+-----------------+--------------------------------------------------------+----------
           1 |                | SKIP_IDENTICAL | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-02-01      | {"value": "A1", "edit_comment": "Slice 1"}             | equals
           2 |                | SKIP_IDENTICAL | {"id": 1}  | 2024-02-01     | 2024-02-01     | 2024-03-01      | {"value": "A2", "edit_comment": "Slice 2 (Adjacent)"}  | equals
           3 |                | SKIP_IDENTICAL | {"id": 1}  | 2024-04-01     | 2024-04-01     | 2024-05-01      | {"value": "A3", "edit_comment": "Slice 3 (After Gap)"} | equals
           4 | {502}          | INSERT         | {"id": 3}  |                | 2024-01-01     | 2025-01-01      | {"value": "C", "edit_comment": "New entity"}           | 
(4 rows)

\echo '--- Executor: Actual Feedback ---'
--- Executor: Actual Feedback ---
TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_ids |      status      | error_message 
---------------+-------------------+------------------+---------------
           501 | []                | SKIPPED_FILTERED | 
           502 | [{"id": 3}]       | APPLIED          | 
(2 rows)

\echo '--- Target: Expected Final State ---'
--- Target: Expected Final State ---
SELECT * FROM (VALUES
    (1, 'A1', 'Slice 1', '2024-01-01'::date, '2024-02-01'::date),
    (1, 'A2', 'Slice 2 (Adjacent)', '2024-02-01'::date, '2024-03-01'::date),
    (1, 'A3', 'Slice 3 (After Gap)', '2024-04-01'::date, '2024-05-01'::date),
    (2, 'B', 'Long-lived', '2023-01-01'::date, '2026-01-01'::date),
    (3, 'C', 'New entity', '2024-01-01'::date, '2025-01-01'::date)
) t(id, value, edit_comment, valid_from, valid_until) ORDER BY id, valid_from;
 id | value |    edit_comment     | valid_from | valid_until 
----+-------+---------------------+------------+-------------
  1 | A1    | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2    | Slice 2 (Adjacent)  | 2024-02-01 | 2024-03-01
  1 | A3    | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B     | Long-lived          | 2023-01-01 | 2026-01-01
  3 | C     | New entity          | 2024-01-01 | 2025-01-01
(5 rows)

\echo '--- Target: Final State ---'
--- Target: Final State ---
TABLE tmm.target ORDER BY id, valid_from;
 id | value |    edit_comment     | valid_from | valid_until 
----+-------+---------------------+------------+-------------
  1 | A1    | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2    | Slice 2 (Adjacent)  | 2024-02-01 | 2024-03-01
  1 | A3    | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B     | Long-lived          | 2023-01-01 | 2026-01-01
  3 | C     | New entity          | 2024-01-01 | 2025-01-01
(5 rows)

ROLLBACK TO SAVEPOINT s5;
--------------------------------------------------------------------------------
\echo 'Scenario 6: `DELETE_FOR_PORTION_OF`'
Scenario 6: `DELETE_FOR_PORTION_OF`
\echo 'Use Case: Surgical delete on existing entities only; new entities are ignored.'
Use Case: Surgical delete on existing entities only; new entities are ignored.
--------------------------------------------------------------------------------
SAVEPOINT s6;
CALL tmm.reset_target();
CREATE TEMP TABLE source_6 (row_id int, id int, value text, edit_comment text, valid_from date, valid_until date) ON COMMIT DROP;
INSERT INTO source_6 VALUES
    -- 6.1: Surgical delete inside slice 2
    (601, 1, '__DELETE__', 'Delete inside S2', '2024-02-10', '2024-02-20'),
    -- 6.2: Attempt to insert a new entity 3 (should be skipped)
    (602, 3, 'C', 'New entity', '2024-01-01', '2025-01-01');
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
TABLE tmm.target ORDER BY id, valid_from;
 id | value |    edit_comment     | valid_from | valid_until 
----+-------+---------------------+------------+-------------
  1 | A1    | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2    | Slice 2 (Adjacent)  | 2024-02-01 | 2024-03-01
  1 | A3    | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B     | Long-lived          | 2023-01-01 | 2026-01-01
(4 rows)

\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
TABLE source_6 ORDER BY row_id;
 row_id | id |   value    |   edit_comment   | valid_from | valid_until 
--------+----+------------+------------------+------------+-------------
    601 |  1 | __DELETE__ | Delete inside S2 | 2024-02-10 | 2024-02-20
    602 |  3 | C          | New entity       | 2024-01-01 | 2025-01-01
(2 rows)

CALL sql_saga.temporal_merge(p_target_table => 'tmm.target'::regclass, p_source_table => 'source_6'::regclass, p_identity_columns => '{id}'::text[], p_ephemeral_columns => '{edit_comment}'::text[], p_mode => 'DELETE_FOR_PORTION_OF'::sql_saga.temporal_merge_mode, p_era_name => 'valid');
\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids |   operation    | entity_ids | old_valid_from | new_valid_from | new_valid_until |                          data                          | relation 
-------------+----------------+----------------+------------+----------------+----------------+-----------------+--------------------------------------------------------+----------
           1 |                | SKIP_IDENTICAL | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-02-01      | {"value": "A1", "edit_comment": "Slice 1"}             | equals
           2 | {601}          | UPDATE         | {"id": 1}  | 2024-02-01     | 2024-02-01     | 2024-02-10      | {"value": "A2", "edit_comment": "Slice 2 (Adjacent)"}  | starts
           3 | {601}          | SKIP_IDENTICAL | {"id": 1}  |                | 2024-02-10     | 2024-02-20      |                                                        | 
           4 | {601}          | INSERT         | {"id": 1}  |                | 2024-02-20     | 2024-03-01      | {"value": "A2", "edit_comment": "Slice 2 (Adjacent)"}  | 
           5 |                | SKIP_IDENTICAL | {"id": 1}  | 2024-04-01     | 2024-04-01     | 2024-05-01      | {"value": "A3", "edit_comment": "Slice 3 (After Gap)"} | equals
           6 | {602}          | SKIP_NO_TARGET | {"id": 3}  |                |                |                 |                                                        | 
(6 rows)

\echo '--- Executor: Actual Feedback ---'
--- Executor: Actual Feedback ---
TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_ids |      status       | error_message 
---------------+-------------------+-------------------+---------------
           601 | [{"id": 1}]       | APPLIED           | 
           602 | [{"id": 3}]       | SKIPPED_NO_TARGET | 
(2 rows)

\echo '--- Target: Expected Final State ---'
--- Target: Expected Final State ---
SELECT * FROM (VALUES
    (1, 'A1', 'Slice 1', '2024-01-01'::date, '2024-02-01'::date),
    (1, 'A2', 'Slice 2 (Adjacent)', '2024-02-01'::date, '2024-02-10'::date),
    (1, 'A2', 'Slice 2 (Adjacent)', '2024-02-20'::date, '2024-03-01'::date),
    (1, 'A3', 'Slice 3 (After Gap)', '2024-04-01'::date, '2024-05-01'::date),
    (2, 'B', 'Long-lived', '2023-01-01'::date, '2026-01-01'::date)
) t(id, value, edit_comment, valid_from, valid_until) ORDER BY id, valid_from;
 id | value |    edit_comment     | valid_from | valid_until 
----+-------+---------------------+------------+-------------
  1 | A1    | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2    | Slice 2 (Adjacent)  | 2024-02-01 | 2024-02-10
  1 | A2    | Slice 2 (Adjacent)  | 2024-02-20 | 2024-03-01
  1 | A3    | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B     | Long-lived          | 2023-01-01 | 2026-01-01
(5 rows)

\echo '--- Target: Final State ---'
--- Target: Final State ---
TABLE tmm.target ORDER BY id, valid_from;
 id | value |    edit_comment     | valid_from | valid_until 
----+-------+---------------------+------------+-------------
  1 | A1    | Slice 1             | 2024-01-01 | 2024-02-01
  1 | A2    | Slice 2 (Adjacent)  | 2024-02-01 | 2024-02-10
  1 | A2    | Slice 2 (Adjacent)  | 2024-02-20 | 2024-03-01
  1 | A3    | Slice 3 (After Gap) | 2024-04-01 | 2024-05-01
  2 | B     | Long-lived          | 2023-01-01 | 2026-01-01
(5 rows)

ROLLBACK TO SAVEPOINT s6;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
