\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
\echo 'Test Suite: `sql_saga.temporal_merge` Mode Behaviors'
Test Suite: `sql_saga.temporal_merge` Mode Behaviors
\echo 'Description:'
Description:
\echo '  This test suite verifies the distinct behavior of each `temporal_merge_mode`.'
  This test suite verifies the distinct behavior of each `temporal_merge_mode`.
\echo '  It focuses on the "happy path" for each mode to provide clear, readable'
  It focuses on the "happy path" for each mode to provide clear, readable
\echo '  examples of their intended use.'
  examples of their intended use.
\echo '----------------------------------------------------------------------------'
----------------------------------------------------------------------------
SET client_min_messages TO WARNING;
CREATE SCHEMA tmm; -- Temporal Merge Modes
-- Target table for all scenarios
CREATE TABLE tmm.target (id int, valid_from date, valid_until date, value text);
SELECT sql_saga.add_era('tmm.target', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

-- Helper to reset state
CREATE PROCEDURE tmm.reset_target() LANGUAGE plpgsql AS $$
BEGIN
    TRUNCATE tmm.target;
    INSERT INTO tmm.target VALUES
        (1, '2024-01-01', '2025-01-01', 'Original A'),
        (2, '2024-01-01', '2025-01-01', 'Original B');
END;
$$;
--------------------------------------------------------------------------------
\echo 'Scenario 1: `upsert_patch` (Update existing, Insert new)'
Scenario 1: `upsert_patch` (Update existing, Insert new)
--------------------------------------------------------------------------------
CALL tmm.reset_target();
CREATE TEMP TABLE temp_source_1 (row_id int, id int, valid_from date, valid_until date, value text);
INSERT INTO temp_source_1 VALUES
    (101, 1, '2024-06-01', '2024-09-01', 'Patched A'), -- Update entity 1
    (102, 3, '2024-01-01', '2025-01-01', 'New C');     -- Insert entity 3
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
SELECT * FROM tmm.target ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
(2 rows)

\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
SELECT * FROM temp_source_1 ORDER BY row_id;
 row_id | id | valid_from | valid_until |   value   
--------+----+------------+-------------+-----------
    101 |  1 | 2024-06-01 | 2024-09-01  | Patched A
    102 |  3 | 2024-01-01 | 2025-01-01  | New C
(2 rows)

CALL sql_saga.temporal_merge('tmm.target'::regclass, 'temp_source_1'::regclass, '{id}'::text[], '{}'::text[], 'MERGE_ENTITY_PATCH'::sql_saga.temporal_merge_mode, 'valid');
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{101}'::INT[], 'UPDATE'::sql_saga.planner_action, '{"id": 1}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-06-01'::DATE, '{"value": "Original A"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{101}'::INT[], 'INSERT'::sql_saga.planner_action, '{"id": 1}'::JSONB, NULL::DATE,         '2024-06-01'::DATE, '2024-09-01'::DATE, '{"value": "Patched A"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{101}'::INT[], 'INSERT'::sql_saga.planner_action, '{"id": 1}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": "Original A"}'::JSONB, NULL::sql_saga.allen_interval_relation),
    (4, '{102}'::INT[], 'INSERT'::sql_saga.planner_action, '{"id": 3}'::JSONB, NULL::DATE,         '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": "New C"}'::JSONB,     NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation) ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |          data           | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+-------------------------+----------
           1 | {101}          | UPDATE    | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-06-01      | {"value": "Original A"} | starts
           2 | {101}          | INSERT    | {"id": 1}  |                | 2024-06-01     | 2024-09-01      | {"value": "Patched A"}  | 
           3 | {101}          | INSERT    | {"id": 1}  |                | 2024-09-01     | 2025-01-01      | {"value": "Original A"} | 
           4 | {102}          | INSERT    | {"id": 3}  |                | 2024-01-01     | 2025-01-01      | {"value": "New C"}      | 
(4 rows)

\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |          data           | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+-------------------------+----------
           1 | {101}          | UPDATE    | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-06-01      | {"value": "Original A"} | starts
           2 | {101}          | INSERT    | {"id": 1}  |                | 2024-06-01     | 2024-09-01      | {"value": "Patched A"}  | 
           3 | {101}          | INSERT    | {"id": 1}  |                | 2024-09-01     | 2025-01-01      | {"value": "Original A"} | 
           4 | {102}          | INSERT    | {"id": 3}  |                | 2024-01-01     | 2025-01-01      | {"value": "New C"}      | 
(4 rows)

\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES
    (101, '[{"id": 1}]'::jsonb, 'APPLIED'::sql_saga.temporal_merge_status),
    (102, '[{"id": 3}]'::jsonb, 'APPLIED'::sql_saga.temporal_merge_status)
) t(source_row_id, target_entity_ids, status) ORDER BY source_row_id;
 source_row_id | target_entity_ids | status  
---------------+-------------------+---------
           101 | [{"id": 1}]       | APPLIED
           102 | [{"id": 3}]       | APPLIED
(2 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT source_row_id, target_entity_ids, status FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_ids | status  
---------------+-------------------+---------
           101 | [{"id": 1}]       | APPLIED
           102 | [{"id": 3}]       | APPLIED
(2 rows)

\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{101}'::INT[], 'UPDATE'::sql_saga.planner_action, '{"id": 1}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-06-01'::DATE, '{"value": "Original A"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{101}'::INT[], 'INSERT'::sql_saga.planner_action, '{"id": 1}'::JSONB, NULL::DATE,         '2024-06-01'::DATE, '2024-09-01'::DATE, '{"value": "Patched A"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{101}'::INT[], 'INSERT'::sql_saga.planner_action, '{"id": 1}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": "Original A"}'::JSONB, NULL::sql_saga.allen_interval_relation),
    (4, '{102}'::INT[], 'INSERT'::sql_saga.planner_action, '{"id": 3}'::JSONB, NULL::DATE,         '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": "New C"}'::JSONB,     NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation) ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |          data           | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+-------------------------+----------
           1 | {101}          | UPDATE    | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-06-01      | {"value": "Original A"} | starts
           2 | {101}          | INSERT    | {"id": 1}  |                | 2024-06-01     | 2024-09-01      | {"value": "Patched A"}  | 
           3 | {101}          | INSERT    | {"id": 1}  |                | 2024-09-01     | 2025-01-01      | {"value": "Original A"} | 
           4 | {102}          | INSERT    | {"id": 3}  |                | 2024-01-01     | 2025-01-01      | {"value": "New C"}      | 
(4 rows)

\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |          data           | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+-------------------------+----------
           1 | {101}          | UPDATE    | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-06-01      | {"value": "Original A"} | starts
           2 | {101}          | INSERT    | {"id": 1}  |                | 2024-06-01     | 2024-09-01      | {"value": "Patched A"}  | 
           3 | {101}          | INSERT    | {"id": 1}  |                | 2024-09-01     | 2025-01-01      | {"value": "Original A"} | 
           4 | {102}          | INSERT    | {"id": 3}  |                | 2024-01-01     | 2025-01-01      | {"value": "New C"}      | 
(4 rows)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, '2024-01-01'::date, '2024-06-01'::date, 'Original A'),
    (1, '2024-06-01'::date, '2024-09-01'::date, 'Patched A'),
    (1, '2024-09-01'::date, '2025-01-01'::date, 'Original A'),
    (2, '2024-01-01'::date, '2025-01-01'::date, 'Original B'),
    (3, '2024-01-01'::date, '2025-01-01'::date, 'New C')
) t(id, valid_from, valid_until, value) ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2024-06-01  | Original A
  1 | 2024-06-01 | 2024-09-01  | Patched A
  1 | 2024-09-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
  3 | 2024-01-01 | 2025-01-01  | New C
(5 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT * FROM tmm.target ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2024-06-01  | Original A
  1 | 2024-06-01 | 2024-09-01  | Patched A
  1 | 2024-09-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
  3 | 2024-01-01 | 2025-01-01  | New C
(5 rows)

DROP TABLE temp_source_1;
--------------------------------------------------------------------------------
\echo 'Scenario 2: `upsert_replace` (Update existing, Insert new, NULLs overwrite)'
Scenario 2: `upsert_replace` (Update existing, Insert new, NULLs overwrite)
--------------------------------------------------------------------------------
CALL tmm.reset_target();
CREATE TEMP TABLE temp_source_2 (row_id int, id int, valid_from date, valid_until date, value text);
INSERT INTO temp_source_2 VALUES
    (201, 1, '2024-06-01', '2024-09-01', NULL),     -- Replace entity 1 with NULL
    (202, 3, '2024-01-01', '2025-01-01', 'New C');  -- Insert entity 3
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
SELECT * FROM tmm.target ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
(2 rows)

\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
SELECT * FROM temp_source_2 ORDER BY row_id;
 row_id | id | valid_from | valid_until | value 
--------+----+------------+-------------+-------
    201 |  1 | 2024-06-01 | 2024-09-01  | 
    202 |  3 | 2024-01-01 | 2025-01-01  | New C
(2 rows)

CALL sql_saga.temporal_merge('tmm.target'::regclass, 'temp_source_2'::regclass, '{id}'::text[], '{}'::text[], 'MERGE_ENTITY_REPLACE'::sql_saga.temporal_merge_mode, 'valid');
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{201}'::INT[], 'UPDATE'::sql_saga.planner_action, '{"id": 1}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-06-01'::DATE, '{"value": "Original A"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{201}'::INT[], 'INSERT'::sql_saga.planner_action, '{"id": 1}'::JSONB, NULL::DATE,         '2024-06-01'::DATE, '2024-09-01'::DATE, '{"value": null}'::JSONB,        NULL::sql_saga.allen_interval_relation),
    (3, '{201}'::INT[], 'INSERT'::sql_saga.planner_action, '{"id": 1}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": "Original A"}'::JSONB, NULL::sql_saga.allen_interval_relation),
    (4, '{202}'::INT[], 'INSERT'::sql_saga.planner_action, '{"id": 3}'::JSONB, NULL::DATE,         '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": "New C"}'::JSONB,     NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation) ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |          data           | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+-------------------------+----------
           1 | {201}          | UPDATE    | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-06-01      | {"value": "Original A"} | starts
           2 | {201}          | INSERT    | {"id": 1}  |                | 2024-06-01     | 2024-09-01      | {"value": null}         | 
           3 | {201}          | INSERT    | {"id": 1}  |                | 2024-09-01     | 2025-01-01      | {"value": "Original A"} | 
           4 | {202}          | INSERT    | {"id": 3}  |                | 2024-01-01     | 2025-01-01      | {"value": "New C"}      | 
(4 rows)

\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |          data           | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+-------------------------+----------
           1 | {201}          | UPDATE    | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-06-01      | {"value": "Original A"} | starts
           2 | {201}          | INSERT    | {"id": 1}  |                | 2024-06-01     | 2024-09-01      | {"value": null}         | 
           3 | {201}          | INSERT    | {"id": 1}  |                | 2024-09-01     | 2025-01-01      | {"value": "Original A"} | 
           4 | {202}          | INSERT    | {"id": 3}  |                | 2024-01-01     | 2025-01-01      | {"value": "New C"}      | 
(4 rows)

\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES
    (201, '[{"id": 1}]'::jsonb, 'APPLIED'::sql_saga.temporal_merge_status),
    (202, '[{"id": 3}]'::jsonb, 'APPLIED'::sql_saga.temporal_merge_status)
) t(source_row_id, target_entity_ids, status) ORDER BY source_row_id;
 source_row_id | target_entity_ids | status  
---------------+-------------------+---------
           201 | [{"id": 1}]       | APPLIED
           202 | [{"id": 3}]       | APPLIED
(2 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT source_row_id, target_entity_ids, status FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_ids | status  
---------------+-------------------+---------
           201 | [{"id": 1}]       | APPLIED
           202 | [{"id": 3}]       | APPLIED
(2 rows)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, '2024-01-01'::date, '2024-06-01'::date, 'Original A'),
    (1, '2024-06-01'::date, '2024-09-01'::date, NULL::text),
    (1, '2024-09-01'::date, '2025-01-01'::date, 'Original A'),
    (2, '2024-01-01'::date, '2025-01-01'::date, 'Original B'),
    (3, '2024-01-01'::date, '2025-01-01'::date, 'New C')
) t(id, valid_from, valid_until, value) ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2024-06-01  | Original A
  1 | 2024-06-01 | 2024-09-01  | 
  1 | 2024-09-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
  3 | 2024-01-01 | 2025-01-01  | New C
(5 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT * FROM tmm.target ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2024-06-01  | Original A
  1 | 2024-06-01 | 2024-09-01  | 
  1 | 2024-09-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
  3 | 2024-01-01 | 2025-01-01  | New C
(5 rows)

DROP TABLE temp_source_2;
--------------------------------------------------------------------------------
\echo 'Scenario 3: `patch_only` (Update existing, IGNORE new)'
Scenario 3: `patch_only` (Update existing, IGNORE new)
--------------------------------------------------------------------------------
CALL tmm.reset_target();
CREATE TEMP TABLE temp_source_3 (row_id int, id int, valid_from date, valid_until date, value text);
INSERT INTO temp_source_3 VALUES
    (301, 1, '2024-06-01', '2024-09-01', 'Patched A'), -- Update entity 1
    (302, 3, '2024-01-01', '2025-01-01', 'New C');     -- IGNORED: Insert entity 3
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
SELECT * FROM tmm.target ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
(2 rows)

\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
SELECT * FROM temp_source_3 ORDER BY row_id;
 row_id | id | valid_from | valid_until |   value   
--------+----+------------+-------------+-----------
    301 |  1 | 2024-06-01 | 2024-09-01  | Patched A
    302 |  3 | 2024-01-01 | 2025-01-01  | New C
(2 rows)

CALL sql_saga.temporal_merge('tmm.target'::regclass, 'temp_source_3'::regclass, '{id}'::text[], '{}'::text[], 'PATCH_FOR_PORTION_OF'::sql_saga.temporal_merge_mode, 'valid');
\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES
    (301, '[{"id": 1}]'::jsonb, 'APPLIED'::sql_saga.temporal_merge_status),
    (302, '[]'::jsonb, 'TARGET_NOT_FOUND'::sql_saga.temporal_merge_status)
) t(source_row_id, target_entity_ids, status) ORDER BY source_row_id;
 source_row_id | target_entity_ids |      status      
---------------+-------------------+------------------
           301 | [{"id": 1}]       | APPLIED
           302 | []                | TARGET_NOT_FOUND
(2 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT source_row_id, target_entity_ids, status FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_ids |      status      
---------------+-------------------+------------------
           301 | [{"id": 1}]       | APPLIED
           302 | []                | TARGET_NOT_FOUND
(2 rows)

\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{301}'::INT[], 'UPDATE'::sql_saga.planner_action, '{"id": 1}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-06-01'::DATE, '{"value": "Original A"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{301}'::INT[], 'INSERT'::sql_saga.planner_action, '{"id": 1}'::JSONB, NULL::DATE,         '2024-06-01'::DATE, '2024-09-01'::DATE, '{"value": "Patched A"}'::JSONB,  NULL::sql_saga.allen_interval_relation),
    (3, '{301}'::INT[], 'INSERT'::sql_saga.planner_action, '{"id": 1}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": "Original A"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |          data           | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+-------------------------+----------
           1 | {301}          | UPDATE    | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-06-01      | {"value": "Original A"} | starts
           2 | {301}          | INSERT    | {"id": 1}  |                | 2024-06-01     | 2024-09-01      | {"value": "Patched A"}  | 
           3 | {301}          | INSERT    | {"id": 1}  |                | 2024-09-01     | 2025-01-01      | {"value": "Original A"} | 
(3 rows)

\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |          data           | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+-------------------------+----------
           1 | {301}          | UPDATE    | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-06-01      | {"value": "Original A"} | starts
           2 | {301}          | INSERT    | {"id": 1}  |                | 2024-06-01     | 2024-09-01      | {"value": "Patched A"}  | 
           3 | {301}          | INSERT    | {"id": 1}  |                | 2024-09-01     | 2025-01-01      | {"value": "Original A"} | 
(3 rows)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, '2024-01-01'::date, '2024-06-01'::date, 'Original A'),
    (1, '2024-06-01'::date, '2024-09-01'::date, 'Patched A'),
    (1, '2024-09-01'::date, '2025-01-01'::date, 'Original A'),
    (2, '2024-01-01'::date, '2025-01-01'::date, 'Original B')
) t(id, valid_from, valid_until, value) ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2024-06-01  | Original A
  1 | 2024-06-01 | 2024-09-01  | Patched A
  1 | 2024-09-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
(4 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT * FROM tmm.target ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2024-06-01  | Original A
  1 | 2024-06-01 | 2024-09-01  | Patched A
  1 | 2024-09-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
(4 rows)

DROP TABLE temp_source_3;
--------------------------------------------------------------------------------
\echo 'Scenario 4: `replace_only` (Update existing, IGNORE new, NULLs overwrite)'
Scenario 4: `replace_only` (Update existing, IGNORE new, NULLs overwrite)
--------------------------------------------------------------------------------
CALL tmm.reset_target();
CREATE TEMP TABLE temp_source_4 (row_id int, id int, valid_from date, valid_until date, value text);
INSERT INTO temp_source_4 VALUES
    (401, 1, '2024-06-01', '2024-09-01', NULL),     -- Replace entity 1
    (402, 3, '2024-01-01', '2025-01-01', 'New C');  -- IGNORED: Insert entity 3
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
SELECT * FROM tmm.target ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
(2 rows)

\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
SELECT * FROM temp_source_4 ORDER BY row_id;
 row_id | id | valid_from | valid_until | value 
--------+----+------------+-------------+-------
    401 |  1 | 2024-06-01 | 2024-09-01  | 
    402 |  3 | 2024-01-01 | 2025-01-01  | New C
(2 rows)

CALL sql_saga.temporal_merge('tmm.target'::regclass, 'temp_source_4'::regclass, '{id}'::text[], '{}'::text[], 'REPLACE_FOR_PORTION_OF'::sql_saga.temporal_merge_mode, 'valid');
\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES
    (401, '[{"id": 1}]'::jsonb, 'APPLIED'::sql_saga.temporal_merge_status),
    (402, '[]'::jsonb, 'TARGET_NOT_FOUND'::sql_saga.temporal_merge_status)
) t(source_row_id, target_entity_ids, status) ORDER BY source_row_id;
 source_row_id | target_entity_ids |      status      
---------------+-------------------+------------------
           401 | [{"id": 1}]       | APPLIED
           402 | []                | TARGET_NOT_FOUND
(2 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT source_row_id, target_entity_ids, status FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_ids |      status      
---------------+-------------------+------------------
           401 | [{"id": 1}]       | APPLIED
           402 | []                | TARGET_NOT_FOUND
(2 rows)

\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, '{401}'::INT[], 'UPDATE'::sql_saga.planner_action, '{"id": 1}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2024-06-01'::DATE, '{"value": "Original A"}'::JSONB, 'starts'::sql_saga.allen_interval_relation),
    (2, '{401}'::INT[], 'INSERT'::sql_saga.planner_action, '{"id": 1}'::JSONB, NULL::DATE,         '2024-06-01'::DATE, '2024-09-01'::DATE, '{"value": null}'::JSONB,        NULL::sql_saga.allen_interval_relation),
    (3, '{401}'::INT[], 'INSERT'::sql_saga.planner_action, '{"id": 1}'::JSONB, NULL::DATE,         '2024-09-01'::DATE, '2025-01-01'::DATE, '{"value": "Original A"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |          data           | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+-------------------------+----------
           1 | {401}          | UPDATE    | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-06-01      | {"value": "Original A"} | starts
           2 | {401}          | INSERT    | {"id": 1}  |                | 2024-06-01     | 2024-09-01      | {"value": null}         | 
           3 | {401}          | INSERT    | {"id": 1}  |                | 2024-09-01     | 2025-01-01      | {"value": "Original A"} | 
(3 rows)

\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |          data           | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+-------------------------+----------
           1 | {401}          | UPDATE    | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2024-06-01      | {"value": "Original A"} | starts
           2 | {401}          | INSERT    | {"id": 1}  |                | 2024-06-01     | 2024-09-01      | {"value": null}         | 
           3 | {401}          | INSERT    | {"id": 1}  |                | 2024-09-01     | 2025-01-01      | {"value": "Original A"} | 
(3 rows)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, '2024-01-01'::date, '2024-06-01'::date, 'Original A'),
    (1, '2024-06-01'::date, '2024-09-01'::date, NULL::text),
    (1, '2024-09-01'::date, '2025-01-01'::date, 'Original A'),
    (2, '2024-01-01'::date, '2025-01-01'::date, 'Original B')
) t(id, valid_from, valid_until, value) ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2024-06-01  | Original A
  1 | 2024-06-01 | 2024-09-01  | 
  1 | 2024-09-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
(4 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT * FROM tmm.target ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2024-06-01  | Original A
  1 | 2024-06-01 | 2024-09-01  | 
  1 | 2024-09-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
(4 rows)

DROP TABLE temp_source_4;
--------------------------------------------------------------------------------
\echo 'Scenario 5: `insert_only` (IGNORE existing, Insert new)'
Scenario 5: `insert_only` (IGNORE existing, Insert new)
--------------------------------------------------------------------------------
CALL tmm.reset_target();
CREATE TEMP TABLE temp_source_5 (row_id int, id int, valid_from date, valid_until date, value text);
INSERT INTO temp_source_5 VALUES
    (501, 1, '2024-06-01', '2024-09-01', 'Patched A'), -- IGNORED: Update entity 1
    (502, 3, '2024-01-01', '2025-01-01', 'New C');     -- Insert entity 3
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
SELECT * FROM tmm.target ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
(2 rows)

\echo '--- Source: Data to be merged ---'
--- Source: Data to be merged ---
SELECT * FROM temp_source_5 ORDER BY row_id;
 row_id | id | valid_from | valid_until |   value   
--------+----+------------+-------------+-----------
    501 |  1 | 2024-06-01 | 2024-09-01  | Patched A
    502 |  3 | 2024-01-01 | 2025-01-01  | New C
(2 rows)

CALL sql_saga.temporal_merge('tmm.target'::regclass, 'temp_source_5'::regclass, '{id}'::text[], '{}'::text[], 'INSERT_NEW_ENTITIES'::sql_saga.temporal_merge_mode, 'valid');
\echo '--- Planner: Expected Plan ---'
--- Planner: Expected Plan ---
SELECT * FROM (VALUES
    (1, NULL::INT[], 'IDENTICAL'::sql_saga.planner_action, '{"id": 1}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": "Original A"}'::JSONB, 'equals'::sql_saga.allen_interval_relation),
    (2, '{502}'::INT[], 'INSERT'::sql_saga.planner_action, '{"id": 3}'::JSONB, NULL::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": "New C"}'::JSONB, NULL::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation) ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |          data           | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+-------------------------+----------
           1 |                | IDENTICAL | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2025-01-01      | {"value": "Original A"} | equals
           2 | {502}          | INSERT    | {"id": 3}  |                | 2024-01-01     | 2025-01-01      | {"value": "New C"}      | 
(2 rows)

\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |          data           | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+-------------------------+----------
           1 |                | IDENTICAL | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2025-01-01      | {"value": "Original A"} | equals
           2 | {502}          | INSERT    | {"id": 3}  |                | 2024-01-01     | 2025-01-01      | {"value": "New C"}      | 
(2 rows)

\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES
    (501, '[]'::jsonb, 'SKIPPED'::sql_saga.temporal_merge_status),
    (502, '[{"id": 3}]'::jsonb, 'APPLIED'::sql_saga.temporal_merge_status)
) t(source_row_id, target_entity_ids, status) ORDER BY source_row_id;
 source_row_id | target_entity_ids | status  
---------------+-------------------+---------
           501 | []                | SKIPPED
           502 | [{"id": 3}]       | APPLIED
(2 rows)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT source_row_id, target_entity_ids, status FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_ids | status  
---------------+-------------------+---------
           501 | []                | SKIPPED
           502 | [{"id": 3}]       | APPLIED
(2 rows)

\echo '--- Orchestrator: Expected Final State ---'
--- Orchestrator: Expected Final State ---
SELECT * FROM (VALUES
    (1, '2024-01-01'::date, '2025-01-01'::date, 'Original A'),
    (2, '2024-01-01'::date, '2025-01-01'::date, 'Original B'),
    (3, '2024-01-01'::date, '2025-01-01'::date, 'New C')
) t(id, valid_from, valid_until, value) ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
  3 | 2024-01-01 | 2025-01-01  | New C
(3 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT * FROM tmm.target ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
  3 | 2024-01-01 | 2025-01-01  | New C
(3 rows)

DROP TABLE temp_source_5;
--------------------------------------------------------------------------------
\echo 'Scenario 6: `upsert_patch` with identical data (should be SKIPPED)'
Scenario 6: `upsert_patch` with identical data (should be SKIPPED)
--------------------------------------------------------------------------------
CALL tmm.reset_target();
CREATE TEMP TABLE temp_source_6 (row_id int, id int, valid_from date, valid_until date, value text);
INSERT INTO temp_source_6 VALUES
    (601, 1, '2024-01-01', '2025-01-01', 'Original A'); -- Identical data
\echo '--- Target: Initial State ---'
--- Target: Initial State ---
SELECT * FROM tmm.target ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
(2 rows)

\echo '--- Source: Data to merge ---'
--- Source: Data to merge ---
SELECT * FROM temp_source_6 ORDER BY row_id;
 row_id | id | valid_from | valid_until |   value    
--------+----+------------+-------------+------------
    601 |  1 | 2024-01-01 | 2025-01-01  | Original A
(1 row)

CALL sql_saga.temporal_merge('tmm.target'::regclass, 'temp_source_6'::regclass, '{id}'::text[], '{}'::text[], 'MERGE_ENTITY_PATCH'::sql_saga.temporal_merge_mode, 'valid');
\echo '--- Orchestrator: Expected Feedback ---'
--- Orchestrator: Expected Feedback ---
SELECT * FROM (VALUES
    (601, '[]'::jsonb, 'SKIPPED'::sql_saga.temporal_merge_status)
) t(source_row_id, target_entity_ids, status) ORDER BY source_row_id;
 source_row_id | target_entity_ids | status  
---------------+-------------------+---------
           601 | []                | SKIPPED
(1 row)

\echo '--- Orchestrator: Actual Feedback ---'
--- Orchestrator: Actual Feedback ---
SELECT source_row_id, target_entity_ids, status FROM pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_ids | status  
---------------+-------------------+---------
           601 | []                | SKIPPED
(1 row)

\echo '--- Planner: Expected Plan (a single IDENTICAL operation) ---'
--- Planner: Expected Plan (a single IDENTICAL operation) ---
SELECT * FROM (VALUES
    (1, '{601}'::INT[], 'IDENTICAL'::sql_saga.planner_action, '{"id": 1}'::JSONB, '2024-01-01'::DATE, '2024-01-01'::DATE, '2025-01-01'::DATE, '{"value": "Original A"}'::JSONB, 'equals'::sql_saga.allen_interval_relation)
) AS t (plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation);
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |          data           | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+-------------------------+----------
           1 | {601}          | IDENTICAL | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2025-01-01      | {"value": "Original A"} | equals
(1 row)

\echo '--- Planner: Actual Plan ---'
--- Planner: Actual Plan ---
SELECT plan_op_seq, source_row_ids, operation, entity_ids, old_valid_from, new_valid_from, new_valid_until, data, relation FROM pg_temp.temporal_merge_plan;
 plan_op_seq | source_row_ids | operation | entity_ids | old_valid_from | new_valid_from | new_valid_until |          data           | relation 
-------------+----------------+-----------+------------+----------------+----------------+-----------------+-------------------------+----------
           1 | {601}          | IDENTICAL | {"id": 1}  | 2024-01-01     | 2024-01-01     | 2025-01-01      | {"value": "Original A"} | equals
(1 row)

\echo '--- Orchestrator: Expected Final State (unchanged) ---'
--- Orchestrator: Expected Final State (unchanged) ---
SELECT * FROM (VALUES
    (1, '2024-01-01'::date, '2025-01-01'::date, 'Original A'),
    (2, '2024-01-01'::date, '2025-01-01'::date, 'Original B')
) t(id, valid_from, valid_until, value) ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
(2 rows)

\echo '--- Orchestrator: Actual Final State ---'
--- Orchestrator: Actual Final State ---
SELECT * FROM tmm.target ORDER BY id, valid_from;
 id | valid_from | valid_until |   value    
----+------------+-------------+------------
  1 | 2024-01-01 | 2025-01-01  | Original A
  2 | 2024-01-01 | 2025-01-01  | Original B
(2 rows)

DROP TABLE temp_source_6;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
