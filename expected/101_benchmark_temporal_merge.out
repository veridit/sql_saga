\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
SET ROLE TO sql_saga_unprivileged_user;
\i sql/include/benchmark_setup.sql
CREATE TEMPORARY TABLE benchmark (
  seq_id BIGINT GENERATED ALWAYS AS IDENTITY,
  timestamp TIMESTAMPTZ DEFAULT clock_timestamp(),
  event TEXT,
  row_count INTEGER,
  is_performance_benchmark BOOLEAN NOT NULL
);
INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('BEGIN', 0, false);
-- Enable detailed temporal_merge index logging for this benchmark session.
--SET sql_saga.temporal_merge.log_index_checks = true;
CREATE TABLE legal_unit_tm (
  id INTEGER,
  valid_from date,
  valid_until date,
  name varchar NOT NULL
);
CREATE TABLE establishment_tm (
  id INTEGER,
  valid_from date,
  valid_until date,
  legal_unit_id INTEGER NOT NULL,
  postal_place TEXT NOT NULL
);
-- Enable sql_saga constraints
SELECT sql_saga.add_era(table_oid => 'legal_unit_tm', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_era(table_oid => 'establishment_tm', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'legal_unit_tm', column_names => ARRAY['id'], era_name => 'valid', unique_key_name => 'legal_unit_tm_id_valid');
     add_unique_key     
------------------------
 legal_unit_tm_id_valid
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'establishment_tm', column_names => ARRAY['id'], era_name => 'valid');
      add_unique_key       
---------------------------
 establishment_tm_id_valid
(1 row)

SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'establishment_tm',
    fk_column_names => ARRAY['legal_unit_id'],
    pk_table_oid => 'legal_unit_tm',
    pk_column_names => ARRAY['id'],
    fk_era_name => 'valid',
    create_index => true
);
NOTICE:  No compatible index found for foreign key on table establishment_tm. Creating new index: CREATE INDEX establishment_tm_legal_unit_id_valid_gist_idx ON establishment_tm USING GIST (legal_unit_id, daterange(valid_from, valid_until))
           add_foreign_key            
--------------------------------------
 establishment_tm_legal_unit_id_valid
(1 row)

-- Indices according to warning from temporal_merge
CREATE INDEX ON legal_unit_tm USING BTREE (id);
CREATE INDEX ON legal_unit_tm USING GIST (daterange(valid_from, valid_until));
CREATE INDEX ON establishment_tm USING BTREE (id);
CREATE INDEX ON establishment_tm USING GIST (daterange(valid_from, valid_until));
-- Seed 80% of the data.
BEGIN;
  CREATE TEMPORARY TABLE legal_unit_seed_source (row_id int, id int, valid_from date, valid_until date, name varchar);
  CREATE TEMPORARY TABLE establishment_seed_source (row_id int, id int, valid_from date, valid_until date, legal_unit_id int, postal_place text);
  INSERT INTO legal_unit_seed_source SELECT i, i, '2015-01-01', 'infinity', 'Company ' || i FROM generate_series(1, 8000) AS i;
  INSERT INTO establishment_seed_source SELECT i, i, '2015-01-01', 'infinity', i, 'Shop ' || i FROM generate_series(1, 8000) AS i;
  -- Add indices suggested by temporal_merge warning.
  CREATE INDEX ON legal_unit_seed_source USING BTREE (id);
  CREATE INDEX ON legal_unit_seed_source USING GIST (daterange(valid_from, valid_until, '[)'));
  CREATE INDEX ON establishment_seed_source USING BTREE (id);
  CREATE INDEX ON establishment_seed_source USING GIST (daterange(valid_from, valid_until, '[)'));
  ANALYZE legal_unit_seed_source;
  ANALYZE establishment_seed_source;
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge SEED Parent (Triggers ON)', 0, false);
  CALL sql_saga.temporal_merge(target_table => 'legal_unit_tm'::regclass, source_table => 'legal_unit_seed_source'::regclass, identity_columns => ARRAY['id'], ephemeral_columns => ARRAY[]::TEXT[]);
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge SEED Parent (Triggers ON) end', 8000, true);
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge SEED Child (Triggers ON)', 0, false);
  CALL sql_saga.temporal_merge(target_table => 'establishment_tm'::regclass, source_table => 'establishment_seed_source'::regclass, identity_columns => ARRAY['id'], ephemeral_columns => ARRAY[]::TEXT[]);
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge SEED Child (Triggers ON) end', 8000, true);
END;
BEGIN;
  CREATE TEMPORARY TABLE legal_unit_source (row_id int, id int, valid_from date, valid_until date, name varchar);
  CREATE TEMPORARY TABLE establishment_source (row_id int, id int, valid_from date, valid_until date, legal_unit_id int, postal_place text);
  -- Source data for 80% PATCH
  INSERT INTO legal_unit_source SELECT i, i, '2015-01-01', 'infinity', 'Updated Company ' || i FROM generate_series(1, 8000) AS i;
  INSERT INTO establishment_source SELECT i, i, '2015-01-01', 'infinity', i, 'Updated Shop ' || i FROM generate_series(1, 8000) AS i;
  -- Source data for 20% INSERT
  INSERT INTO legal_unit_source SELECT i, i, '2015-01-01', 'infinity', 'Company ' || i FROM generate_series(8001, 10000) AS i;
  INSERT INTO establishment_source SELECT i, i, '2015-01-01', 'infinity', i, 'Shop ' || i FROM generate_series(8001, 10000) AS i;
  -- Add indices suggested by temporal_merge performance hints.
  -- The BTREE index on the lookup key (`id`) is critical for the initial filtering of target rows.
  -- The GIST index on the temporal range is critical for the main timeline reconstruction logic.
  CREATE INDEX ON legal_unit_source USING BTREE (id);
  CREATE INDEX ON legal_unit_source USING GIST (daterange(valid_from, valid_until, '[)'));
  CREATE INDEX ON establishment_source USING BTREE (id);
  CREATE INDEX ON establishment_source USING GIST (daterange(valid_from, valid_until, '[)'));
  ANALYZE legal_unit_source;
  ANALYZE establishment_source;
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge 20% INSERT 80% PATCH Parent (Triggers ON)', 0, false);
  CALL sql_saga.temporal_merge(target_table => 'legal_unit_tm'::regclass, source_table => 'legal_unit_source'::regclass, identity_columns => ARRAY['id'], ephemeral_columns => ARRAY[]::TEXT[]);
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge 20% INSERT 80% PATCH Parent (Triggers ON) end', 10000, true);
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge 20% INSERT 80% PATCH Child (Triggers ON)', 0, false);
  CALL sql_saga.temporal_merge(target_table => 'establishment_tm'::regclass, source_table => 'establishment_source'::regclass, identity_columns => ARRAY['id'], ephemeral_columns => ARRAY[]::TEXT[]);
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge 20% INSERT 80% PATCH Child (Triggers ON) end', 10000, true);
END;
SELECT 'legal_unit_tm' AS type, COUNT(*) AS count FROM legal_unit_tm
UNION ALL
SELECT 'establishment_tm' AS type, COUNT(*) AS count FROM establishment_tm;
       type       | count 
------------------+-------
 legal_unit_tm    | 10000
 establishment_tm | 10000
(2 rows)

--
-- Benchmark with temporal_merge (Triggers Disabled)
--
CREATE TABLE legal_unit_tm_dt (
  id INTEGER,
  valid_from date,
  valid_until date,
  name varchar NOT NULL
);
CREATE TABLE establishment_tm_dt (
  id INTEGER,
  valid_from date,
  valid_until date,
  legal_unit_id INTEGER NOT NULL,
  postal_place TEXT NOT NULL
);
-- This is the critical index for FK performance on the parent table.
CREATE INDEX ON establishment_tm_dt USING GIST (legal_unit_id, daterange(valid_from, valid_until));
-- Enable sql_saga constraints
SELECT sql_saga.add_era(table_oid => 'legal_unit_tm_dt', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_era(table_oid => 'establishment_tm_dt', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'legal_unit_tm_dt', column_names => ARRAY['id'], era_name => 'valid', unique_key_name => 'legal_unit_tm_dt_id_valid');
      add_unique_key       
---------------------------
 legal_unit_tm_dt_id_valid
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'establishment_tm_dt', column_names => ARRAY['id'], era_name => 'valid');
        add_unique_key        
------------------------------
 establishment_tm_dt_id_valid
(1 row)

SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'establishment_tm_dt',
    fk_column_names => ARRAY['legal_unit_id'],
    pk_table_oid => 'legal_unit_tm_dt',
    pk_column_names => ARRAY['id'],
    fk_era_name => 'valid'
);
             add_foreign_key             
-----------------------------------------
 establishment_tm_dt_legal_unit_id_valid
(1 row)

-- Seed 80% of the data.
BEGIN;
  CALL sql_saga.disable_temporal_triggers('legal_unit_tm_dt', 'establishment_tm_dt');
  CREATE TEMPORARY TABLE legal_unit_seed_source_dt (row_id int, id int, valid_from date, valid_until date, name varchar);
  CREATE TEMPORARY TABLE establishment_seed_source_dt (row_id int, id int, valid_from date, valid_until date, legal_unit_id int, postal_place text);
  INSERT INTO legal_unit_seed_source_dt SELECT i, i, '2015-01-01', 'infinity', 'Company ' || i FROM generate_series(1, 8000) AS i;
  INSERT INTO establishment_seed_source_dt SELECT i, i, '2015-01-01', 'infinity', i, 'Shop ' || i FROM generate_series(1, 8000) AS i;
  -- Add indices suggested by temporal_merge warning.
  CREATE INDEX ON legal_unit_seed_source_dt USING BTREE (id);
  CREATE INDEX ON legal_unit_seed_source_dt USING GIST (daterange(valid_from, valid_until, '[)'));
  CREATE INDEX ON establishment_seed_source_dt USING BTREE (id);
  CREATE INDEX ON establishment_seed_source_dt USING GIST (daterange(valid_from, valid_until, '[)'));
  ANALYZE legal_unit_seed_source_dt;
  ANALYZE establishment_seed_source_dt;
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge SEED Parent (Triggers OFF)', 0, false);
  CALL sql_saga.temporal_merge(target_table => 'legal_unit_tm_dt'::regclass, source_table => 'legal_unit_seed_source_dt'::regclass, identity_columns => ARRAY['id'], ephemeral_columns => ARRAY[]::TEXT[]);
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge SEED Parent (Triggers OFF) end', 8000, true);
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge SEED Child (Triggers OFF)', 0, false);
  CALL sql_saga.temporal_merge(target_table => 'establishment_tm_dt'::regclass, source_table => 'establishment_seed_source_dt'::regclass, identity_columns => ARRAY['id'], ephemeral_columns => ARRAY[]::TEXT[]);
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge SEED Child (Triggers OFF) end', 8000, true);
  CALL sql_saga.enable_temporal_triggers('legal_unit_tm_dt', 'establishment_tm_dt');
END;
BEGIN;
  CALL sql_saga.disable_temporal_triggers('legal_unit_tm_dt', 'establishment_tm_dt');
  CREATE TEMPORARY TABLE legal_unit_source_dt (row_id int, id int, valid_from date, valid_until date, name varchar);
  CREATE TEMPORARY TABLE establishment_source_dt (row_id int, id int, valid_from date, valid_until date, legal_unit_id int, postal_place text);
  -- Source data for 80% PATCH
  INSERT INTO legal_unit_source_dt SELECT i, i, '2015-01-01', 'infinity', 'Updated Company ' || i FROM generate_series(1, 8000) AS i;
  INSERT INTO establishment_source_dt SELECT i, i, '2015-01-01', 'infinity', i, 'Updated Shop ' || i FROM generate_series(1, 8000) AS i;
  -- Source data for 20% INSERT
  INSERT INTO legal_unit_source_dt SELECT i, i, '2015-01-01', 'infinity', 'Company ' || i FROM generate_series(8001, 10000) AS i;
  INSERT INTO establishment_source_dt SELECT i, i, '2015-01-01', 'infinity', i, 'Shop ' || i FROM generate_series(8001, 10000) AS i;
  -- Add indices suggested by temporal_merge warning.
  CREATE INDEX ON legal_unit_source_dt USING BTREE (id);
  CREATE INDEX ON legal_unit_source_dt USING GIST (daterange(valid_from, valid_until, '[)'));
  CREATE INDEX ON establishment_source_dt USING BTREE (id);
  CREATE INDEX ON establishment_source_dt USING GIST (daterange(valid_from, valid_until, '[)'));
  ANALYZE legal_unit_source_dt;
  ANALYZE establishment_source_dt;
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge 20% INSERT 80% PATCH Parent (Triggers OFF)', 0, false);
  CALL sql_saga.temporal_merge(target_table => 'legal_unit_tm_dt'::regclass, source_table => 'legal_unit_source_dt'::regclass, identity_columns => ARRAY['id'], ephemeral_columns => ARRAY[]::TEXT[]);
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge 20% INSERT 80% PATCH Parent (Triggers OFF) end', 10000, true);
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge 20% INSERT 80% PATCH Child (Triggers OFF)', 0, false);
  CALL sql_saga.temporal_merge(target_table => 'establishment_tm_dt'::regclass, source_table => 'establishment_source_dt'::regclass, identity_columns => ARRAY['id'], ephemeral_columns => ARRAY[]::TEXT[]);
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge 20% INSERT 80% PATCH Child (Triggers OFF) end', 10000, true);
  CALL sql_saga.enable_temporal_triggers('legal_unit_tm_dt', 'establishment_tm_dt');
END;
SELECT 'legal_unit_tm_dt' AS type, COUNT(*) AS count FROM legal_unit_tm_dt
UNION ALL
SELECT 'establishment_tm_dt' AS type, COUNT(*) AS count FROM establishment_tm_dt;
        type         | count 
---------------------+-------
 legal_unit_tm_dt    | 10000
 establishment_tm_dt | 10000
(2 rows)

-- Teardown for temporal_merge tables
SELECT sql_saga.drop_foreign_key('establishment_tm', ARRAY['legal_unit_id'], 'valid');
NOTICE:  Dropping automatically created index "establishment_tm_legal_unit_id_valid_gist_idx" for foreign key "establishment_tm_legal_unit_id_valid"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_unique_key('establishment_tm', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('establishment_tm', cleanup => true);
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_unique_key('legal_unit_tm', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('legal_unit_tm', cleanup => true);
 drop_era 
----------
 t
(1 row)

-- Teardown for temporal_merge tables with disabled triggers
SELECT sql_saga.drop_foreign_key('establishment_tm_dt', ARRAY['legal_unit_id'], 'valid');
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_unique_key('establishment_tm_dt', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('establishment_tm_dt', cleanup => true);
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_unique_key('legal_unit_tm_dt', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('legal_unit_tm_dt', cleanup => true);
 drop_era 
----------
 t
(1 row)

DROP TABLE establishment_tm;
DROP TABLE legal_unit_tm;
DROP TABLE establishment_tm_dt;
DROP TABLE legal_unit_tm_dt;
-- Verify the benchmark events and row counts, but exclude volatile timing data
-- from the regression test output to ensure stability.
SELECT event, row_count FROM benchmark ORDER BY seq_id;
                             event                             | row_count 
---------------------------------------------------------------+-----------
 BEGIN                                                         |         0
 Temporal Merge SEED Parent (Triggers ON)                      |         0
 Temporal Merge SEED Parent (Triggers ON) end                  |      8000
 Temporal Merge SEED Child (Triggers ON)                       |         0
 Temporal Merge SEED Child (Triggers ON) end                   |      8000
 Temporal Merge 20% INSERT 80% PATCH Parent (Triggers ON)      |         0
 Temporal Merge 20% INSERT 80% PATCH Parent (Triggers ON) end  |     10000
 Temporal Merge 20% INSERT 80% PATCH Child (Triggers ON)       |         0
 Temporal Merge 20% INSERT 80% PATCH Child (Triggers ON) end   |     10000
 Temporal Merge SEED Parent (Triggers OFF)                     |         0
 Temporal Merge SEED Parent (Triggers OFF) end                 |      8000
 Temporal Merge SEED Child (Triggers OFF)                      |         0
 Temporal Merge SEED Child (Triggers OFF) end                  |      8000
 Temporal Merge 20% INSERT 80% PATCH Parent (Triggers OFF)     |         0
 Temporal Merge 20% INSERT 80% PATCH Parent (Triggers OFF) end |     10000
 Temporal Merge 20% INSERT 80% PATCH Child (Triggers OFF)      |         0
 Temporal Merge 20% INSERT 80% PATCH Child (Triggers OFF) end  |     10000
(17 rows)

-- Capture performance metrics to a separate file for manual review.
\o expected/101_benchmark_temporal_merge_performance.out
\i sql/include/benchmark_report.sql
-- Calculate rows per second
CREATE OR REPLACE FUNCTION format_duration(p_interval interval) RETURNS TEXT AS $$
BEGIN
    IF p_interval IS NULL THEN RETURN ''; END IF;
    IF EXTRACT(EPOCH FROM p_interval) >= 1 THEN
        RETURN ROUND(EXTRACT(EPOCH FROM p_interval))::numeric || ' secs';
    ELSE
        RETURN ROUND(EXTRACT(EPOCH FROM p_interval) * 1000)::numeric || ' ms';
    END IF;
END;
$$ LANGUAGE plpgsql;
WITH benchmark_events AS (
  SELECT
    seq_id,
    timestamp,
    event,
    row_count,
    is_performance_benchmark,
    regexp_replace(event, ' (start|end)$', '') AS operation,
    CASE
      WHEN event LIKE '% start' THEN 'start'
      WHEN event LIKE '% end' THEN 'end'
      ELSE 'milestone'
    END AS phase,
    FIRST_VALUE(timestamp) OVER (ORDER BY seq_id) as benchmark_start_time,
    LAG(timestamp) OVER (ORDER BY seq_id) as prev_event_time
  FROM
    benchmark
),
benchmark_durations AS (
  SELECT
    *,
    LAG(timestamp) OVER (PARTITION BY operation ORDER BY seq_id) AS operation_start_time
  FROM
    benchmark_events
)
SELECT
  CASE WHEN phase = 'end' THEN operation ELSE event END AS event,
  row_count,
  format_duration(timestamp - benchmark_start_time) AS time_from_start,
  CASE
    WHEN phase = 'end' THEN format_duration(timestamp - operation_start_time)
    WHEN phase = 'milestone' THEN format_duration(timestamp - prev_event_time)
    ELSE ''
  END AS time_from_prev,
  row_count || ' rows' AS row_count,
  CASE
    WHEN is_performance_benchmark AND phase = 'end' THEN
        '~' ||
            CASE
            WHEN EXTRACT(EPOCH FROM (timestamp - operation_start_time)) > 0.001 THEN
                ROUND(row_count::FLOAT8 / EXTRACT(EPOCH FROM (timestamp - operation_start_time)))::text
            ELSE
                '0'
            END
        || ' rows/s'
    ELSE
        ''
  END AS rows_per_second
FROM
  benchmark_durations
WHERE phase <> 'start'
ORDER BY
  seq_id;
-- Stop redirecting output
\o
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
