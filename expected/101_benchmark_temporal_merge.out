\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
\i sql/include/benchmark_setup.sql
\set ECHO none
SET ROLE TO sql_saga_unprivileged_user;
--------------------------------------------------------------------------------
-- BENCHMARK: temporal_merge Performance with Range-Only Tables
--
-- This benchmark measures temporal_merge performance using the recommended
-- range-only table pattern with proper indexing via add_foreign_key(create_index => true).
--
-- For comparison of range-only vs synchronized columns, see tests 104 and 105.
--------------------------------------------------------------------------------
CREATE TABLE legal_unit_tm (
  id INTEGER,
  valid_range daterange NOT NULL,
  name varchar NOT NULL
);
CREATE TABLE establishment_tm (
  id INTEGER,
  valid_range daterange NOT NULL,
  legal_unit_id INTEGER NOT NULL,
  postal_place TEXT NOT NULL
);
-- Enable sql_saga constraints (creates optimal GIST index for FK via create_index => true)
SELECT sql_saga.add_era('legal_unit_tm'::regclass, 'valid_range', 'valid');
NOTICE:  sql_saga: Created GIST index "legal_unit_tm_valid_range_gist_idx" on column public.legal_unit_tm.valid_range for temporal_merge performance
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_era('establishment_tm'::regclass, 'valid_range', 'valid');
NOTICE:  sql_saga: Created GIST index "establishment_tm_valid_range_gist_idx" on column public.establishment_tm.valid_range for temporal_merge performance
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'legal_unit_tm', column_names => ARRAY['id'], era_name => 'valid', unique_key_name => 'legal_unit_tm_id_valid');
NOTICE:  sql_saga: Added constraints to table legal_unit_tm: ADD CONSTRAINT legal_unit_tm_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
     add_unique_key     
------------------------
 legal_unit_tm_id_valid
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'establishment_tm', column_names => ARRAY['id'], era_name => 'valid');
NOTICE:  sql_saga: Added constraints to table establishment_tm: ADD CONSTRAINT establishment_tm_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
      add_unique_key       
---------------------------
 establishment_tm_id_valid
(1 row)

SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'establishment_tm',
    fk_column_names => ARRAY['legal_unit_id'],
    pk_table_oid => 'legal_unit_tm',
    pk_column_names => ARRAY['id'],
    fk_era_name => 'valid',
    create_index => true
);
NOTICE:  sql_saga: No compatible index found for foreign key on table establishment_tm. Creating new index: CREATE INDEX establishment_tm_legal_unit_id_valid_gist_idx ON establishment_tm USING GIST (legal_unit_id, valid_range)
           add_foreign_key            
--------------------------------------
 establishment_tm_legal_unit_id_valid
(1 row)

-- Additional indices recommended by temporal_merge for source/target lookup
CREATE INDEX ON legal_unit_tm USING BTREE (id);
CREATE INDEX ON legal_unit_tm USING GIST (valid_range);
CREATE INDEX ON establishment_tm USING BTREE (id);
CREATE INDEX ON establishment_tm USING GIST (valid_range);
-- Show indices for documentation
\echo '--- Table Indices ---'
--- Table Indices ---
SELECT indexname, indexdef FROM pg_indexes WHERE tablename IN ('legal_unit_tm', 'establishment_tm') ORDER BY tablename, indexname;
                   indexname                   |                                                           indexdef                                                            
-----------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------
 establishment_tm_id_idx                       | CREATE INDEX establishment_tm_id_idx ON public.establishment_tm USING btree (id)
 establishment_tm_id_idx1                      | CREATE INDEX establishment_tm_id_idx1 ON public.establishment_tm USING btree (id)
 establishment_tm_id_valid_range_idx           | CREATE INDEX establishment_tm_id_valid_range_idx ON public.establishment_tm USING btree (id, valid_range)
 establishment_tm_id_valid_uniq                | CREATE UNIQUE INDEX establishment_tm_id_valid_uniq ON public.establishment_tm USING gist (id, valid_range)
 establishment_tm_legal_unit_id_valid_gist_idx | CREATE INDEX establishment_tm_legal_unit_id_valid_gist_idx ON public.establishment_tm USING gist (legal_unit_id, valid_range)
 establishment_tm_valid_range_gist_idx         | CREATE INDEX establishment_tm_valid_range_gist_idx ON public.establishment_tm USING gist (valid_range) WITH (fillfactor='90')
 establishment_tm_valid_range_idx              | CREATE INDEX establishment_tm_valid_range_idx ON public.establishment_tm USING gist (valid_range)
 legal_unit_tm_id_idx                          | CREATE INDEX legal_unit_tm_id_idx ON public.legal_unit_tm USING btree (id)
 legal_unit_tm_id_idx1                         | CREATE INDEX legal_unit_tm_id_idx1 ON public.legal_unit_tm USING btree (id)
 legal_unit_tm_id_valid_range_idx              | CREATE INDEX legal_unit_tm_id_valid_range_idx ON public.legal_unit_tm USING btree (id, valid_range)
 legal_unit_tm_id_valid_uniq                   | CREATE UNIQUE INDEX legal_unit_tm_id_valid_uniq ON public.legal_unit_tm USING gist (id, valid_range)
 legal_unit_tm_valid_range_gist_idx            | CREATE INDEX legal_unit_tm_valid_range_gist_idx ON public.legal_unit_tm USING gist (valid_range) WITH (fillfactor='90')
 legal_unit_tm_valid_range_idx                 | CREATE INDEX legal_unit_tm_valid_range_idx ON public.legal_unit_tm USING gist (valid_range)
(13 rows)

--------------------------------------------------------------------------------
\echo '--- Temporal Merge SEED (2000 rows) ---'
--- Temporal Merge SEED (2000 rows) ---
--------------------------------------------------------------------------------
BEGIN;
  CREATE TEMPORARY TABLE legal_unit_seed_source (row_id int, id int, valid_range daterange, name varchar);
  CREATE TEMPORARY TABLE establishment_seed_source (row_id int, id int, valid_range daterange, legal_unit_id int, postal_place text);
  INSERT INTO legal_unit_seed_source SELECT i, i, daterange('2015-01-01', 'infinity', '[)'), 'Company ' || i FROM generate_series(1, 2000) AS i;
  INSERT INTO establishment_seed_source SELECT i, i, daterange('2015-01-01', 'infinity', '[)'), i, 'Shop ' || i FROM generate_series(1, 2000) AS i;
  CREATE INDEX ON legal_unit_seed_source USING BTREE (id);
  CREATE INDEX ON legal_unit_seed_source USING GIST (valid_range);
  CREATE INDEX ON establishment_seed_source USING BTREE (id);
  CREATE INDEX ON establishment_seed_source USING GIST (valid_range);
  ANALYZE legal_unit_seed_source;
  ANALYZE establishment_seed_source;
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge SEED Parent', 0, false);
  CALL sql_saga.benchmark_reset();
  CALL sql_saga.temporal_merge(target_table => 'legal_unit_tm'::regclass, source_table => 'legal_unit_seed_source'::regclass, primary_identity_columns => ARRAY['id'], ephemeral_columns => ARRAY[]::TEXT[]);
  CALL sql_saga.benchmark_log_and_reset('Temporal Merge SEED Parent');
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge SEED Parent end', 2000, true);
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge SEED Child', 0, false);
  CALL sql_saga.benchmark_reset();
  CALL sql_saga.temporal_merge(target_table => 'establishment_tm'::regclass, source_table => 'establishment_seed_source'::regclass, primary_identity_columns => ARRAY['id'], ephemeral_columns => ARRAY[]::TEXT[]);
  CALL sql_saga.benchmark_log_and_reset('Temporal Merge SEED Child');
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge SEED Child end', 2000, true);
END;
--------------------------------------------------------------------------------
\echo '--- Temporal Merge 20% INSERT + 80% PATCH (2500 rows) ---'
--- Temporal Merge 20% INSERT + 80% PATCH (2500 rows) ---
--------------------------------------------------------------------------------
BEGIN;
  CREATE TEMPORARY TABLE legal_unit_source (row_id int, id int, valid_range daterange, name varchar);
  CREATE TEMPORARY TABLE establishment_source (row_id int, id int, valid_range daterange, legal_unit_id int, postal_place text);
  -- Source data for 80% PATCH (update existing)
  INSERT INTO legal_unit_source SELECT i, i, daterange('2015-01-01', 'infinity', '[)'), 'Updated Company ' || i FROM generate_series(1, 2000) AS i;
  INSERT INTO establishment_source SELECT i, i, daterange('2015-01-01', 'infinity', '[)'), i, 'Updated Shop ' || i FROM generate_series(1, 2000) AS i;
  -- Source data for 20% INSERT (new entities)
  INSERT INTO legal_unit_source SELECT i, i, daterange('2015-01-01', 'infinity', '[)'), 'Company ' || i FROM generate_series(2001, 2500) AS i;
  INSERT INTO establishment_source SELECT i, i, daterange('2015-01-01', 'infinity', '[)'), i, 'Shop ' || i FROM generate_series(2001, 2500) AS i;
  CREATE INDEX ON legal_unit_source USING BTREE (id);
  CREATE INDEX ON legal_unit_source USING GIST (valid_range);
  CREATE INDEX ON establishment_source USING BTREE (id);
  CREATE INDEX ON establishment_source USING GIST (valid_range);
  ANALYZE legal_unit_source;
  ANALYZE establishment_source;
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge 20% INSERT 80% PATCH Parent', 0, false);
  CALL sql_saga.benchmark_reset();
  CALL sql_saga.temporal_merge(target_table => 'legal_unit_tm'::regclass, source_table => 'legal_unit_source'::regclass, primary_identity_columns => ARRAY['id'], ephemeral_columns => ARRAY[]::TEXT[]);
  CALL sql_saga.benchmark_log_and_reset('Temporal Merge 20% INSERT 80% PATCH Parent');
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge 20% INSERT 80% PATCH Parent end', 2500, true);
  \set benchmark_explain_log_filename expected/performance/101_benchmark_temporal_merge_explain.log
  \set benchmark_source_table 'legal_unit_source'
  \set benchmark_target_table 'legal_unit_tm'
  \i sql/include/benchmark_explain_log.sql
\set ECHO none
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge 20% INSERT 80% PATCH Child', 0, false);
  CALL sql_saga.benchmark_reset();
  CALL sql_saga.temporal_merge(target_table => 'establishment_tm'::regclass, source_table => 'establishment_source'::regclass, primary_identity_columns => ARRAY['id'], ephemeral_columns => ARRAY[]::TEXT[]);
  CALL sql_saga.benchmark_log_and_reset('Temporal Merge 20% INSERT 80% PATCH Child');
  INSERT INTO benchmark (event, row_count, is_performance_benchmark) VALUES ('Temporal Merge 20% INSERT 80% PATCH Child end', 2500, true);
END;
SELECT 'legal_unit_tm' AS type, COUNT(*) AS count FROM legal_unit_tm
UNION ALL
SELECT 'establishment_tm' AS type, COUNT(*) AS count FROM establishment_tm;
       type       | count 
------------------+-------
 legal_unit_tm    |  2500
 establishment_tm |  2500
(2 rows)

-- Teardown
SELECT sql_saga.drop_foreign_key('establishment_tm', ARRAY['legal_unit_id'], 'valid');
NOTICE:  sql_saga: Dropping automatically created index "establishment_tm_legal_unit_id_valid_gist_idx" for foreign key "establishment_tm_legal_unit_id_valid"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_unique_key('establishment_tm', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('establishment_tm', cleanup => true);
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_unique_key('legal_unit_tm', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('legal_unit_tm', cleanup => true);
 drop_era 
----------
 t
(1 row)

DROP TABLE establishment_tm;
DROP TABLE legal_unit_tm;
\echo '-- Performance log from pg_stat_monitor --'
-- Performance log from pg_stat_monitor --
\set monitor_log_filename expected/performance/101_benchmark_temporal_merge_benchmark_monitor.csv
\i sql/include/benchmark_monitor_csv.sql
\set ECHO none
 monitor_log_has_rows 
----------------------
 t
(1 row)

-- Verify the benchmark events and row counts
SELECT event, row_count FROM benchmark ORDER BY seq_id;
                     event                      | row_count 
------------------------------------------------+-----------
 BEGIN                                          |         0
 Temporal Merge SEED Parent                     |         0
 Temporal Merge SEED Parent end                 |      2000
 Temporal Merge SEED Child                      |         0
 Temporal Merge SEED Child end                  |      2000
 Temporal Merge 20% INSERT 80% PATCH Parent     |         0
 Temporal Merge 20% INSERT 80% PATCH Parent end |      2500
 Temporal Merge 20% INSERT 80% PATCH Child      |         0
 Temporal Merge 20% INSERT 80% PATCH Child end  |      2500
(9 rows)

-- Capture performance metrics to a separate file for manual review
\set benchmark_log_filename expected/performance/101_benchmark_temporal_merge_benchmark_report.log
\i sql/include/benchmark_report_log.sql
\set ECHO none
\i sql/include/benchmark_teardown.sql
\set ECHO none
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
