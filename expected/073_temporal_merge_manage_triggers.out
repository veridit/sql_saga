\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
CREATE EXTENSION IF NOT EXISTS sql_saga;
NOTICE:  extension "sql_saga" already exists, skipping
CREATE SCHEMA mtt;
-- Setup: Parent and child tables with a temporal foreign key.
-- The child also has a synchronized column to ensure its trigger is NOT affected.
CREATE TABLE mtt.parent (id int, name text, valid_from date, valid_until date, valid_to date);
SELECT sql_saga.add_era('mtt.parent', synchronize_valid_to_column := 'valid_to');
NOTICE:  sql_saga: Created trigger "parent_synchronize_temporal_columns_trigger" on table mtt.parent to synchronize columns: valid_to
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(
    'mtt.parent',
    '{id}',
    unique_key_name => 'parent_id_valid',
    unique_constraint => 'parent_id_valid_uniq',
    exclude_constraint => 'parent_id_valid_excl'
);
 add_unique_key  
-----------------
 parent_id_valid
(1 row)

CREATE TABLE mtt.child (id int, parent_id int, name text, valid_from date, valid_until date, valid_to date);
SELECT sql_saga.add_era('mtt.child', synchronize_valid_to_column := 'valid_to');
NOTICE:  sql_saga: Created trigger "child_synchronize_temporal_columns_trigger" on table mtt.child to synchronize columns: valid_to
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key(
    'mtt.child',
    '{id}',
    unique_key_name => 'child_id_valid',
    unique_constraint => 'child_id_valid_uniq',
    exclude_constraint => 'child_id_valid_excl'
);
 add_unique_key 
----------------
 child_id_valid
(1 row)

SELECT sql_saga.add_temporal_foreign_key(
    fk_table_oid => 'mtt.child'::regclass,
    fk_column_names => ARRAY['parent_id'],
    fk_era_name => 'valid',
    unique_key_name => 'parent_id_valid'
);
NOTICE:  No compatible index found for foreign key on table mtt.child. Creating new index: CREATE INDEX child_parent_id_valid_gist_idx ON mtt.child USING GIST (parent_id, daterange(valid_from, valid_until))
 add_temporal_foreign_key 
--------------------------
 child_parent_id_valid
(1 row)

-- Helper function to check trigger status
CREATE OR REPLACE FUNCTION mtt.get_trigger_status(p_table_oid regclass)
RETURNS TABLE(trigger_name name, is_enabled text) AS $$
    SELECT tgname,
           CASE tgenabled
               WHEN 'O' THEN 'enabled' -- Origin and local
               WHEN 'R' THEN 'enabled' -- Replica
               WHEN 'A' THEN 'enabled' -- Always
               WHEN 'D' THEN 'disabled'
           END
    FROM pg_trigger
    WHERE tgrelid = p_table_oid
      AND NOT tgisinternal
    ORDER BY tgname;
$$ LANGUAGE sql;
\echo '--- Trigger status BEFORE disabling ---'
--- Trigger status BEFORE disabling ---
\echo '-- Triggers on child table --'
-- Triggers on child table --
SELECT * FROM mtt.get_trigger_status('mtt.child');
                trigger_name                | is_enabled 
--------------------------------------------+------------
 child_parent_id_valid_fk_insert            | enabled
 child_parent_id_valid_fk_update            | enabled
 child_synchronize_temporal_columns_trigger | enabled
(3 rows)

\echo '-- Triggers on parent table --'
-- Triggers on parent table --
SELECT * FROM mtt.get_trigger_status('mtt.parent');
                trigger_name                 | is_enabled 
---------------------------------------------+------------
 child_parent_id_valid_uk_delete             | enabled
 child_parent_id_valid_uk_update             | enabled
 parent_synchronize_temporal_columns_trigger | enabled
(3 rows)

\echo '--- Disabling triggers for both tables ---'
--- Disabling triggers for both tables ---
CALL sql_saga.disable_temporal_triggers('mtt.parent', 'mtt.child');
\echo '--- Trigger status AFTER disabling (FK triggers disabled, sync triggers enabled) ---'
--- Trigger status AFTER disabling (FK triggers disabled, sync triggers enabled) ---
\echo '-- Triggers on child table --'
-- Triggers on child table --
SELECT * FROM mtt.get_trigger_status('mtt.child');
                trigger_name                | is_enabled 
--------------------------------------------+------------
 child_parent_id_valid_fk_insert            | disabled
 child_parent_id_valid_fk_update            | disabled
 child_synchronize_temporal_columns_trigger | enabled
(3 rows)

\echo '-- Triggers on parent table --'
-- Triggers on parent table --
SELECT * FROM mtt.get_trigger_status('mtt.parent');
                trigger_name                 | is_enabled 
---------------------------------------------+------------
 child_parent_id_valid_uk_delete             | disabled
 child_parent_id_valid_uk_update             | disabled
 parent_synchronize_temporal_columns_trigger | enabled
(3 rows)

\echo '--- Enabling triggers for both tables ---'
--- Enabling triggers for both tables ---
CALL sql_saga.enable_temporal_triggers('mtt.parent', 'mtt.child');
\echo '--- Trigger status AFTER enabling (all triggers enabled) ---'
--- Trigger status AFTER enabling (all triggers enabled) ---
\echo '-- Triggers on child table --'
-- Triggers on child table --
SELECT * FROM mtt.get_trigger_status('mtt.child');
                trigger_name                | is_enabled 
--------------------------------------------+------------
 child_parent_id_valid_fk_insert            | enabled
 child_parent_id_valid_fk_update            | enabled
 child_synchronize_temporal_columns_trigger | enabled
(3 rows)

\echo '-- Triggers on parent table --'
-- Triggers on parent table --
SELECT * FROM mtt.get_trigger_status('mtt.parent');
                trigger_name                 | is_enabled 
---------------------------------------------+------------
 child_parent_id_valid_uk_delete             | enabled
 child_parent_id_valid_uk_update             | enabled
 parent_synchronize_temporal_columns_trigger | enabled
(3 rows)

ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
