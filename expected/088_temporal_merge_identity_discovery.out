\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
CREATE SCHEMA identity_discovery;
-- This test verifies the "convention-over-configuration" behavior of
-- temporal_merge. When identity columns are omitted, the procedure should
-- discover them from metadata and use them automatically.
-- 1. A target table with one primary key and MULTIPLE natural keys.
CREATE TABLE identity_discovery.person (
    id int GENERATED BY DEFAULT AS IDENTITY,
    ssn text,
    employee_nr text,
    email text,
    full_name text,
    valid_from date NOT NULL,
    valid_until date
);
SELECT sql_saga.add_era('identity_discovery.person');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table identity_discovery.person to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_from) DEFERRABLE, ADD CONSTRAINT person_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
 add_unique_key  
-----------------
 person_id_valid
(1 row)

SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['employee_nr'], key_type => 'natural');
NOTICE:  sql_saga: altering table identity_discovery.person to add constraints: ADD CONSTRAINT person_employee_nr_valid_uniq UNIQUE (employee_nr, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT person_employee_nr_valid_excl EXCLUDE USING gist (employee_nr WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE, ADD CONSTRAINT person_employee_nr_valid_pk_consistency_excl EXCLUDE USING gist (employee_nr WITH =, id WITH <>)
      add_unique_key      
--------------------------
 person_employee_nr_valid
(1 row)

SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['ssn'], key_type => 'natural');
NOTICE:  sql_saga: altering table identity_discovery.person to add constraints: ADD CONSTRAINT person_ssn_valid_uniq UNIQUE (ssn, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT person_ssn_valid_excl EXCLUDE USING gist (ssn WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE, ADD CONSTRAINT person_ssn_valid_pk_consistency_excl EXCLUDE USING gist (ssn WITH =, id WITH <>)
  add_unique_key  
------------------
 person_ssn_valid
(1 row)

\d identity_discovery.person
                        Table "identity_discovery.person"
   Column    |  Type   | Collation | Nullable |             Default              
-------------+---------+-----------+----------+----------------------------------
 id          | integer |           | not null | generated by default as identity
 ssn         | text    |           |          | 
 employee_nr | text    |           |          | 
 email       | text    |           |          | 
 full_name   | text    |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 'infinity'::date
Indexes:
    "person_pkey" PRIMARY KEY, btree (id, valid_from) DEFERRABLE
    "person_employee_nr_idx" btree (employee_nr)
    "person_employee_nr_valid_excl" EXCLUDE USING gist (employee_nr WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "person_employee_nr_valid_pk_consistency_excl" EXCLUDE USING gist (employee_nr WITH =, id WITH <>)
    "person_employee_nr_valid_uniq" UNIQUE CONSTRAINT, btree (employee_nr, valid_from, valid_until) DEFERRABLE
    "person_id_idx" btree (id)
    "person_id_valid_excl" EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "person_ssn_idx" btree (ssn)
    "person_ssn_valid_excl" EXCLUDE USING gist (ssn WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "person_ssn_valid_pk_consistency_excl" EXCLUDE USING gist (ssn WITH =, id WITH <>)
    "person_ssn_valid_uniq" UNIQUE CONSTRAINT, btree (ssn, valid_from, valid_until) DEFERRABLE
Check constraints:
    "person_valid_check" CHECK (valid_from < valid_until AND valid_from > '-infinity'::date)

-- 2. The source table for data loading, with a columns.
CREATE TEMP TABLE source_data (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id int,
    ssn text,
    employee_nr text,
    email text,
    full_name text,
    valid_from date,
    valid_until date,
    errors jsonb,
    merge_status jsonb
) ON COMMIT DROP;
-- 3. Load initial state.
\echo '--- Loading initial state ---'
--- Loading initial state ---
INSERT INTO source_data (employee_id, ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    (NULL, '111', 'E101', 'alice@example.com', 'Alice Smith', '2023-01-01', '2024-01-01'),
    (NULL, '111', 'E101', 'alice@example.com', 'Alice Baker', '2024-01-01', '2025-01-01'),
    (NULL, '111', 'E101', 'alice@baker.com', 'Alice Baker', '2025-01-01', 'infinity');
-- The key of this test: CALL temporal_merge WITHOUT specifying identity columns.
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- State after initial load ---'
--- State after initial load ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;
 id | ssn | employee_nr |       email       |  full_name  | valid_from | valid_until 
----+-----+-------------+-------------------+-------------+------------+-------------
  1 | 111 | E101        | alice@example.com | Alice Smith | 2023-01-01 | 2024-01-01
  1 | 111 | E101        | alice@example.com | Alice Baker | 2024-01-01 | 2025-01-01
  1 | 111 | E101        | alice@baker.com   | Alice Baker | 2025-01-01 | infinity
(3 rows)

-- 4. Update via `employee_nr`. This creates a new historical record (SCD Type 2).
\echo '--- Updating via employee_nr ---'
--- Updating via employee_nr ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (employee_nr, full_name, valid_from, valid_until) VALUES
    ('E101', 'Alice Jones', '2023-06-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
    
\echo '--- State after update via employee_nr ---'
--- State after update via employee_nr ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;
 id | ssn | employee_nr |       email       |  full_name  | valid_from | valid_until 
----+-----+-------------+-------------------+-------------+------------+-------------
  1 | 111 | E101        | alice@example.com | Alice Smith | 2023-01-01 | 2023-06-01
  1 | 111 | E101        | alice@example.com | Alice Jones | 2023-06-01 | 2024-01-01
  1 | 111 | E101        | alice@example.com | Alice Baker | 2024-01-01 | 2025-01-01
  1 | 111 | E101        | alice@baker.com   | Alice Baker | 2025-01-01 | infinity
(4 rows)

-- 5. Update via `email`. This creates a third historical record.
\echo '--- Updating via email ---'
--- Updating via email ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (email, full_name, valid_from, valid_until) VALUES
    ('alice@example.com', 'Alice Jones-Carter', '2023-09-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- Final State after update via email ---'
--- Final State after update via email ---
-- The state is unchanged because the source row was unidentifiable (email is not a natural key).
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;
 id | ssn | employee_nr |       email       |  full_name  | valid_from | valid_until 
----+-----+-------------+-------------------+-------------+------------+-------------
  1 | 111 | E101        | alice@example.com | Alice Smith | 2023-01-01 | 2023-06-01
  1 | 111 | E101        | alice@example.com | Alice Jones | 2023-06-01 | 2024-01-01
  1 | 111 | E101        | alice@example.com | Alice Baker | 2024-01-01 | 2025-01-01
  1 | 111 | E101        | alice@baker.com   | Alice Baker | 2025-01-01 | infinity
(4 rows)

-- 6. Add a second person.
\echo '--- Adding a second person ---'
--- Adding a second person ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('222', 'E102', 'bob@example.com', 'Bob Johnson', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;
 id | ssn | employee_nr |       email       |  full_name  | valid_from | valid_until 
----+-----+-------------+-------------------+-------------+------------+-------------
  1 | 111 | E101        | alice@example.com | Alice Smith | 2023-01-01 | 2023-06-01
  1 | 111 | E101        | alice@example.com | Alice Jones | 2023-06-01 | 2024-01-01
  1 | 111 | E101        | alice@example.com | Alice Baker | 2024-01-01 | 2025-01-01
  1 | 111 | E101        | alice@baker.com   | Alice Baker | 2025-01-01 | infinity
  2 | 222 | E102        | bob@example.com   | Bob Johnson | 2023-01-01 | 2024-01-01
(5 rows)

SAVEPOINT s7;
-- 7. FAIL: Attempt to update with conflicting natural keys.
\echo '--- Updating with conflicting keys (expect error) ---'
--- Updating with conflicting keys (expect error) ---
TRUNCATE source_data RESTART IDENTITY;
-- This source row links Alice's employee_nr with Bob's ssn, creating ambiguity.
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('222', 'E101', 'conflict@example.com', 'Conflict Person', '2023-10-01', '2024-01-01');
    
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    update_source_with_feedback => true,
    feedback_status_column => 'merge_status',
    feedback_status_key => 'test',
    feedback_error_column => 'errors',
    feedback_error_key => 'test'    
);
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | row_ids | operation | update_effect | causal_id | is_new_entity |                  entity_keys                   | identity_keys |              lookup_keys              | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until | data |                                                    feedback                                                    | trace |    grouping_key    
-------------+---------+-----------+---------------+-----------+---------------+------------------------------------------------+---------------+---------------------------------------+--------------+--------------+----------------+-----------------+----------------+-----------------+------+----------------------------------------------------------------------------------------------------------------+-------+--------------------
           1 | {1}     | ERROR     |               | 1         | f             | {"id": 1, "ssn": "222", "employee_nr": "E101"} | {"id": 1}     | {"ssn": "222", "employee_nr": "E101"} |              |              |                |                 |                |                 |      | {"error": "Source row is ambiguous. It matches multiple distinct target entities: [{\"id\": 1}, {\"id\": 2}]"} |       | existing_entity__1
(1 row)

\echo '--- Feedback for ambiguous row ---'
--- Feedback for ambiguous row ---
SELECT row_id, merge_status, errors
FROM source_data;
 row_id |   merge_status    |                                                    errors                                                     
--------+-------------------+---------------------------------------------------------------------------------------------------------------
      1 | {"test": "ERROR"} | {"test": "Source row is ambiguous. It matches multiple distinct target entities: [{\"id\": 1}, {\"id\": 2}]"}
(1 row)

ROLLBACK TO SAVEPOINT s7;
-- 8. FAIL: Attempt to insert a completely unidentifiable row.
SAVEPOINT s8;
\echo '--- Inserting unidentifiable row (expect error feedback) ---'
--- Inserting unidentifiable row (expect error feedback) ---
TRUNCATE source_data RESTART IDENTITY;
-- This row has NULL for all identifying columns.
INSERT INTO source_data (full_name, valid_from, valid_until) VALUES
    ('Ghost Person', '2023-11-01', '2024-01-01');
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    update_source_with_feedback => true,
    feedback_status_column => 'merge_status',
    feedback_status_key => 'test',
    feedback_error_column => 'errors',
    feedback_error_key => 'test'
);
\echo '--- Feedback for unidentifiable row ---'
--- Feedback for unidentifiable row ---
-- The status should be ERROR with a specific message.
SELECT row_id, merge_status, errors
FROM source_data;
 row_id |   merge_status    |                                                                 errors                                                                 
--------+-------------------+----------------------------------------------------------------------------------------------------------------------------------------
      1 | {"test": "ERROR"} | {"test": "Source row is unidentifiable. It has NULL for all stable identity columns {id} and all natural keys [[employee_nr], [ssn]]"}
(1 row)

ROLLBACK TO SAVEPOINT s8;
-- 9. Multi-row update to a single entity
\echo '--- Scenario 9: Multi-row update to a single entity with different identity strategies ---'
--- Scenario 9: Multi-row update to a single entity with different identity strategies ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('333', 'E103', 'charlie@example.com', 'Charlie Day', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- State after adding Charlie ---'
--- State after adding Charlie ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
 id | ssn | employee_nr |        email        |  full_name  | valid_from | valid_until 
----+-----+-------------+---------------------+-------------+------------+-------------
  3 | 333 | E103        | charlie@example.com | Charlie Day | 2023-01-01 | 2024-01-01
(1 row)

-- Source data with two consecutive updates for Charlie
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, full_name, valid_from, valid_until) VALUES
    -- Updates by employee_nr
    (NULL, 'E103', 'Charlie Kelly', '2023-04-01', '2023-08-01'),
    (NULL, 'E103', 'Charles Kelly', '2023-08-01', '2024-01-01'),
    -- Updates by ssn
    ('333', NULL, 'C. Day', '2023-02-01', '2023-03-01'),
    ('333', NULL, 'Chuck Day', '2023-03-01', '2023-04-01');
\echo

\echo '--- Case 9a: Multi-row update with auto-discovered keys ---'
--- Case 9a: Multi-row update with auto-discovered keys ---
SAVEPOINT s9;
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => NULL,
    natural_identity_columns => NULL
);
\echo '--- Final state (9a) ---'
--- Final state (9a) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
 id | ssn | employee_nr |        email        |   full_name   | valid_from | valid_until 
----+-----+-------------+---------------------+---------------+------------+-------------
  3 | 333 | E103        | charlie@example.com | Charlie Day   | 2023-01-01 | 2023-02-01
  3 | 333 | E103        | charlie@example.com | C. Day        | 2023-02-01 | 2023-03-01
  3 | 333 | E103        | charlie@example.com | Chuck Day     | 2023-03-01 | 2023-04-01
  3 | 333 | E103        | charlie@example.com | Charlie Kelly | 2023-04-01 | 2023-08-01
  3 | 333 | E103        | charlie@example.com | Charles Kelly | 2023-08-01 | 2024-01-01
(5 rows)

ROLLBACK TO SAVEPOINT s9;
\echo

\echo '--- Case 9b: Multi-row update with explicit stable key and natural key for lookup ---'
--- Case 9b: Multi-row update with explicit stable key and natural key for lookup ---
SAVEPOINT s9;
TABLE identity_discovery.person;
 id | ssn | employee_nr |        email        |  full_name  | valid_from | valid_until 
----+-----+-------------+---------------------+-------------+------------+-------------
  1 | 111 | E101        | alice@example.com   | Alice Baker | 2024-01-01 | 2025-01-01
  1 | 111 | E101        | alice@baker.com     | Alice Baker | 2025-01-01 | infinity
  1 | 111 | E101        | alice@example.com   | Alice Jones | 2023-06-01 | 2024-01-01
  1 | 111 | E101        | alice@example.com   | Alice Smith | 2023-01-01 | 2023-06-01
  2 | 222 | E102        | bob@example.com     | Bob Johnson | 2023-01-01 | 2024-01-01
  3 | 333 | E103        | charlie@example.com | Charlie Day | 2023-01-01 | 2024-01-01
(6 rows)

TABLE source_data;
 row_id | employee_id | ssn | employee_nr | email |   full_name   | valid_from | valid_until | errors | merge_status 
--------+-------------+-----+-------------+-------+---------------+------------+-------------+--------+--------------
      1 |             |     | E103        |       | Charlie Kelly | 2023-04-01 | 2023-08-01  |        | 
      2 |             |     | E103        |       | Charles Kelly | 2023-08-01 | 2024-01-01  |        | 
      3 |             | 333 |             |       | C. Day        | 2023-02-01 | 2023-03-01  |        | 
      4 |             | 333 |             |       | Chuck Day     | 2023-03-01 | 2023-04-01  |        | 
(4 rows)

CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['employee_nr']
);
\echo '--- Final state (9b) ---'
--- Final state (9b) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
 id | ssn | employee_nr |        email        |   full_name   | valid_from | valid_until 
----+-----+-------------+---------------------+---------------+------------+-------------
  3 | 333 | E103        | charlie@example.com | Charlie Day   | 2023-01-01 | 2023-04-01
  3 | 333 | E103        | charlie@example.com | Charlie Kelly | 2023-04-01 | 2023-08-01
  3 | 333 | E103        | charlie@example.com | Charles Kelly | 2023-08-01 | 2024-01-01
(3 rows)

ROLLBACK TO SAVEPOINT s9;
\echo

\echo '--- Case 9c: Multi-row update with explicit natural key (employee_nr only) ---'
--- Case 9c: Multi-row update with explicit natural key (employee_nr only) ---
\echo '--- This will only apply updates from source rows that have a non-NULL employee_nr. ---'
--- This will only apply updates from source rows that have a non-NULL employee_nr. ---
SAVEPOINT s9;
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => NULL,
    natural_identity_columns => ARRAY['employee_nr']
);
\echo '--- Final state (9c) ---'
--- Final state (9c) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
 id | ssn | employee_nr |        email        |   full_name   | valid_from | valid_until 
----+-----+-------------+---------------------+---------------+------------+-------------
  3 | 333 | E103        | charlie@example.com | Charlie Day   | 2023-01-01 | 2023-04-01
  3 | 333 | E103        | charlie@example.com | Charlie Kelly | 2023-04-01 | 2023-08-01
  3 | 333 | E103        | charlie@example.com | Charles Kelly | 2023-08-01 | 2024-01-01
(3 rows)

ROLLBACK TO SAVEPOINT s9;
\echo

\echo '--- Case 9d: Multi-row update with explicit natural key (ssn only) ---'
--- Case 9d: Multi-row update with explicit natural key (ssn only) ---
\echo '--- This will only apply updates from source rows that have a non-NULL ssn. ---'
--- This will only apply updates from source rows that have a non-NULL ssn. ---
SAVEPOINT s9;
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => NULL,
    natural_identity_columns => ARRAY['ssn']
);
\echo '--- Final state (9d) ---'
--- Final state (9d) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
 id | ssn | employee_nr |        email        |  full_name  | valid_from | valid_until 
----+-----+-------------+---------------------+-------------+------------+-------------
  3 | 333 | E103        | charlie@example.com | Charlie Day | 2023-01-01 | 2023-02-01
  3 | 333 | E103        | charlie@example.com | C. Day      | 2023-02-01 | 2023-03-01
  3 | 333 | E103        | charlie@example.com | Chuck Day   | 2023-03-01 | 2023-04-01
  3 | 333 | E103        | charlie@example.com | Charlie Day | 2023-04-01 | 2024-01-01
(4 rows)

ROLLBACK TO SAVEPOINT s9;
\echo

\echo '--- Case 9e: Multi-row update with explicit natural key (both ssn and employee_nr) ---'
--- Case 9e: Multi-row update with explicit natural key (both ssn and employee_nr) ---
\echo '--- The planner will try both keys and should apply all updates. ---'
--- The planner will try both keys and should apply all updates. ---
SAVEPOINT s9;
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => NULL,
    natural_identity_columns => NULL -- Let the planner auto-discover both ['ssn'] and ['employee_nr']
);
\echo '--- Final state (9e) ---'
--- Final state (9e) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E103' ORDER BY id, valid_from;
 id | ssn | employee_nr |        email        |   full_name   | valid_from | valid_until 
----+-----+-------------+---------------------+---------------+------------+-------------
  3 | 333 | E103        | charlie@example.com | Charlie Day   | 2023-01-01 | 2023-02-01
  3 | 333 | E103        | charlie@example.com | C. Day        | 2023-02-01 | 2023-03-01
  3 | 333 | E103        | charlie@example.com | Chuck Day     | 2023-03-01 | 2023-04-01
  3 | 333 | E103        | charlie@example.com | Charlie Kelly | 2023-04-01 | 2023-08-01
  3 | 333 | E103        | charlie@example.com | Charles Kelly | 2023-08-01 | 2024-01-01
(5 rows)

ROLLBACK TO SAVEPOINT s9;
-- 10. Multi-row insert for a new entity using natural key
\echo '--- Scenario 10: Multi-row insert for a new entity using auto-discovered natural key ---'
--- Scenario 10: Multi-row insert for a new entity using auto-discovered natural key ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('444', 'E104', 'dennis@example.com', 'Dennis Reynolds', '2023-01-01', '2023-06-01'),
    ('444', 'E104', 'dennis@example.com', 'Dennis R. Reynolds', '2023-06-01', '2024-01-01');
\echo '--- Source for new person Dennis ---'
--- Source for new person Dennis ---
TABLE source_data;
 row_id | employee_id | ssn | employee_nr |       email        |     full_name      | valid_from | valid_until | errors | merge_status 
--------+-------------+-----+-------------+--------------------+--------------------+------------+-------------+--------+--------------
      1 |             | 444 | E104        | dennis@example.com | Dennis Reynolds    | 2023-01-01 | 2023-06-01  |        | 
      2 |             | 444 | E104        | dennis@example.com | Dennis R. Reynolds | 2023-06-01 | 2024-01-01  |        | 
(2 rows)

CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data'
    -- No identity columns specified, should auto-discover and group by natural key
);
\echo '--- Final state after multi-row insert ---'
--- Final state after multi-row insert ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E104' ORDER BY id, valid_from;
 id | ssn | employee_nr |       email        |     full_name      | valid_from | valid_until 
----+-----+-------------+--------------------+--------------------+------------+-------------
  4 | 444 | E104        | dennis@example.com | Dennis Reynolds    | 2023-01-01 | 2023-06-01
  4 | 444 | E104        | dennis@example.com | Dennis R. Reynolds | 2023-06-01 | 2024-01-01
(2 rows)

-- 11. Multi-row update of a multi-row target
\echo '--- Scenario 11: Multi-row update of a multi-row target ---'
--- Scenario 11: Multi-row update of a multi-row target ---
SAVEPOINT s11;
-- First, create a target with a multi-row history in a single merge call.
-- This creates three distinct time slices for the entity.
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('555', 'E105', 'dee@doe.com'    , 'Dee Doe'  , '2023-01-01', '2024-01-01'),
    ('555',  NULL , 'dee@example.com', NULL       , '2023-02-01', '2023-04-01'),
    ('555',  NULL , NULL             , 'Sweet Dee', '2023-04-01', '2023-06-01'),
    ( NULL, 'E105', 'doe@example.com', NULL       , '2023-03-01', '2023-05-01'),
    ( NULL, 'E105', NULL             , 'Sweet Doe', '2023-05-01', '2023-07-01');
TABLE source_data ORDER BY row_id;
 row_id | employee_id | ssn | employee_nr |      email      | full_name | valid_from | valid_until | errors | merge_status 
--------+-------------+-----+-------------+-----------------+-----------+------------+-------------+--------+--------------
      1 |             | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2024-01-01  |        | 
      2 |             | 555 |             | dee@example.com |           | 2023-02-01 | 2023-04-01  |        | 
      3 |             | 555 |             |                 | Sweet Dee | 2023-04-01 | 2023-06-01  |        | 
      4 |             |     | E105        | doe@example.com |           | 2023-03-01 | 2023-05-01  |        | 
      5 |             |     | E105        |                 | Sweet Doe | 2023-05-01 | 2023-07-01  |        | 
(5 rows)

CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data', mode => 'MERGE_ENTITY_PATCH');
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | row_ids | operation | update_effect | causal_id | is_new_entity |                  entity_keys                   | identity_keys |              lookup_keys              | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |                          data                          | feedback | trace |     grouping_key      
-------------+---------+-----------+---------------+-----------+---------------+------------------------------------------------+---------------+---------------------------------------+--------------+--------------+----------------+-----------------+----------------+-----------------+--------------------------------------------------------+----------+-------+-----------------------
           1 | {1}     | INSERT    |               | 1         | t             | {"id": 5, "ssn": "555", "employee_nr": "E105"} | {"id": null}  | {"ssn": "555", "employee_nr": "E105"} |              |              |                |                 | 2023-01-01     | 2023-02-01      | {"email": "dee@doe.com", "full_name": "Dee Doe"}       |          |       | new_entity__E105__555
           2 | {1,2}   | INSERT    |               | 2         | t             | {"id": 5, "ssn": "555", "employee_nr": "E105"} | {"id": null}  | {"ssn": "555", "employee_nr": "E105"} |              |              |                |                 | 2023-02-01     | 2023-03-01      | {"email": "dee@example.com", "full_name": "Dee Doe"}   |          |       | new_entity__E105__555
           3 | {1,2,4} | INSERT    |               | 4         | t             | {"id": 5, "ssn": "555", "employee_nr": "E105"} | {"id": null}  | {"ssn": "555", "employee_nr": "E105"} |              |              |                |                 | 2023-03-01     | 2023-04-01      | {"email": "doe@example.com", "full_name": "Dee Doe"}   |          |       | new_entity__E105__555
           4 | {1,3,4} | INSERT    |               | 3         | t             | {"id": 5, "ssn": "555", "employee_nr": "E105"} | {"id": null}  | {"ssn": "555", "employee_nr": "E105"} |              |              |                |                 | 2023-04-01     | 2023-05-01      | {"email": "doe@example.com", "full_name": "Sweet Dee"} |          |       | new_entity__E105__555
           5 | {1,3,5} | INSERT    |               | 5         | t             | {"id": 5, "ssn": "555", "employee_nr": "E105"} | {"id": null}  | {"ssn": "555", "employee_nr": "E105"} |              |              |                |                 | 2023-05-01     | 2023-07-01      | {"email": "dee@doe.com", "full_name": "Sweet Doe"}     |          |       | new_entity__E105__555
           6 | {1}     | INSERT    |               | 5         | t             | {"id": 5, "ssn": "555", "employee_nr": "E105"} | {"id": null}  | {"ssn": "555", "employee_nr": "E105"} |              |              |                |                 | 2023-07-01     | 2024-01-01      | {"email": "dee@doe.com", "full_name": "Dee Doe"}       |          |       | new_entity__E105__555
(6 rows)

\echo '--- State after adding Dee (multi-row target) ---'
--- State after adding Dee (multi-row target) ---
-- This scenario tests the planner's ability to create a complex history for a single new entity from
-- multiple source rows with fragmented natural key and data information. The planner must correctly:
-- 1. Unify all 5 source rows under a single grouping key.
-- 2. For each atomic time segment, find all overlapping source rows.
-- 3. Apply the PATCH logic by merging the data payloads of the source rows in ascending order of their row_id.
-- 4. Correctly aggregate the `row_ids` of all contributing source rows for each final plan operation.
-- 5. Coalesce adjacent segments with identical final data payloads.
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      | full_name | valid_from | valid_until 
----+-----+-------------+-----------------+-----------+------------+-------------
  5 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-01-01 | 2023-02-01
  5 | 555 | E105        | dee@example.com | Dee Doe   | 2023-02-01 | 2023-03-01
  5 | 555 | E105        | doe@example.com | Dee Doe   | 2023-03-01 | 2023-04-01
  5 | 555 | E105        | doe@example.com | Sweet Dee | 2023-04-01 | 2023-05-01
  5 | 555 | E105        | dee@doe.com     | Sweet Doe | 2023-05-01 | 2023-07-01
  5 | 555 | E105        | dee@doe.com     | Dee Doe   | 2023-07-01 | 2024-01-01
(6 rows)

-- Now, apply a multi-row update to the multi-row target
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (employee_nr, full_name, valid_from, valid_until) VALUES
    ('E105', 'Bird', '2023-02-01', '2023-05-01'),
    ('E105', 'Aluminum Monster', '2023-07-01', '2023-09-01');
\echo '--- Source for multi-row update ---'
--- Source for multi-row update ---
TABLE source_data;
 row_id | employee_id | ssn | employee_nr | email |    full_name     | valid_from | valid_until | errors | merge_status 
--------+-------------+-----+-------------+-------+------------------+------------+-------------+--------+--------------
      1 |             |     | E105        |       | Bird             | 2023-02-01 | 2023-05-01  |        | 
      2 |             |     | E105        |       | Aluminum Monster | 2023-07-01 | 2023-09-01  |        | 
(2 rows)

CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data'
);
\echo '--- Final state after multi-row update ---'
--- Final state after multi-row update ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      |    full_name     | valid_from | valid_until 
----+-----+-------------+-----------------+------------------+------------+-------------
  5 | 555 | E105        | dee@doe.com     | Dee Doe          | 2023-01-01 | 2023-02-01
  5 | 555 | E105        | dee@example.com | Bird             | 2023-02-01 | 2023-03-01
  5 | 555 | E105        | doe@example.com | Bird             | 2023-03-01 | 2023-05-01
  5 | 555 | E105        | dee@doe.com     | Sweet Doe        | 2023-05-01 | 2023-07-01
  5 | 555 | E105        | dee@doe.com     | Aluminum Monster | 2023-07-01 | 2023-09-01
  5 | 555 | E105        | dee@doe.com     | Dee Doe          | 2023-09-01 | 2024-01-01
(6 rows)

ROLLBACK TO SAVEPOINT s11;
-- 12. Multi-row update of multi-row target with pre-filled stable ID
\echo '--- Scenario 12: Multi-row update of multi-row target with pre-filled stable ID ---'
--- Scenario 12: Multi-row update of multi-row target with pre-filled stable ID ---
SAVEPOINT s12;
-- Reset the target state by truncating and re-populating with all previous entities
-- to ensure the IDENTITY column generates a predictable ID for the final entity.
TRUNCATE identity_discovery.person RESTART IDENTITY CASCADE;
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('111', 'E101', 'alice@example.com', 'Alice Smith', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('222', 'E102', 'bob@example.com', 'Bob Johnson', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('333', 'E103', 'charlie@example.com', 'Charlie Day', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('444', 'E104', 'dennis@example.com', 'Dennis Reynolds', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
-- Now, re-create the multi-row history for Dee. She will receive id=5.
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (ssn, employee_nr, email, full_name, valid_from, valid_until) VALUES ('555', 'E105', 'dee@example.com', 'Deandra Reynolds', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (employee_nr, full_name, valid_from, valid_until) VALUES ('E105', 'Sweet Dee', '2023-03-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- State after re-adding Dee (multi-row target) ---'
--- State after re-adding Dee (multi-row target) ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      |    full_name     | valid_from | valid_until 
----+-----+-------------+-----------------+------------------+------------+-------------
  5 | 555 | E105        | dee@example.com | Deandra Reynolds | 2023-01-01 | 2023-03-01
  5 | 555 | E105        | dee@example.com | Sweet Dee        | 2023-03-01 | 2024-01-01
(2 rows)

-- The source data now includes the stable `id` which was looked up ahead of time.
TRUNCATE source_data RESTART IDENTITY;
ALTER TABLE source_data ADD COLUMN id INT;
INSERT INTO source_data (id, ssn, employee_nr, full_name, valid_from, valid_until) VALUES
    (5, '555', 'E105', 'Bird', '2023-02-01', '2023-05-01'),
    (5, '555', 'E105', 'Aluminum Monster', '2023-07-01', '2023-09-01');
\echo '--- Source for multi-row update with pre-filled ID ---'
--- Source for multi-row update with pre-filled ID ---
TABLE source_data;
 row_id | employee_id | ssn | employee_nr | email |    full_name     | valid_from | valid_until | errors | merge_status | id 
--------+-------------+-----+-------------+-------+------------------+------------+-------------+--------+--------------+----
      1 |             | 555 | E105        |       | Bird             | 2023-02-01 | 2023-05-01  |        |              |  5
      2 |             | 555 | E105        |       | Aluminum Monster | 2023-07-01 | 2023-09-01  |        |              |  5
(2 rows)

CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['employee_nr'] -- Still provided for robust lookup
);
\echo '--- Final state after multi-row update with pre-filled ID ---'
--- Final state after multi-row update with pre-filled ID ---
SELECT id, ssn, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person WHERE employee_nr = 'E105' OR ssn = '555' ORDER BY id, valid_from;
 id | ssn | employee_nr |      email      |    full_name     | valid_from | valid_until 
----+-----+-------------+-----------------+------------------+------------+-------------
  5 | 555 | E105        | dee@example.com | Deandra Reynolds | 2023-01-01 | 2023-02-01
  5 | 555 | E105        | dee@example.com | Bird             | 2023-02-01 | 2023-05-01
  5 | 555 | E105        | dee@example.com | Sweet Dee        | 2023-05-01 | 2023-07-01
  5 | 555 | E105        | dee@example.com | Aluminum Monster | 2023-07-01 | 2023-09-01
  5 | 555 | E105        | dee@example.com | Sweet Dee        | 2023-09-01 | 2024-01-01
(5 rows)

ROLLBACK TO SAVEPOINT s12;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
