\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
CREATE SCHEMA identity_discovery;
-- This test verifies the "convention-over-configuration" behavior of
-- temporal_merge. When identity columns are omitted, the procedure should
-- discover them from metadata and use them automatically.
-- 1. A target table with one primary key and MULTIPLE natural keys.
CREATE TABLE identity_discovery.person (
    id int GENERATED BY DEFAULT AS IDENTITY,
    employee_nr text,
    email text,
    full_name text,
    valid_from date NOT NULL,
    valid_until date
);
SELECT sql_saga.add_era('identity_discovery.person');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table identity_discovery.person to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_from) DEFERRABLE, ADD CONSTRAINT person_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
 add_unique_key  
-----------------
 person_id_valid
(1 row)

SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['employee_nr'], key_type => 'natural');
NOTICE:  sql_saga: altering table identity_discovery.person to add constraints: ADD CONSTRAINT person_employee_nr_valid_uniq UNIQUE (employee_nr, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT person_employee_nr_valid_excl EXCLUDE USING gist (employee_nr WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
      add_unique_key      
--------------------------
 person_employee_nr_valid
(1 row)

SELECT sql_saga.add_unique_key('identity_discovery.person', ARRAY['email'], key_type => 'natural');
NOTICE:  sql_saga: altering table identity_discovery.person to add constraints: ADD CONSTRAINT person_email_valid_uniq UNIQUE (email, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT person_email_valid_excl EXCLUDE USING gist (email WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
   add_unique_key   
--------------------
 person_email_valid
(1 row)

-- 2. The source table for data loading, with a feedback column.
CREATE TEMP TABLE source_data (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_nr text,
    email text,
    full_name text,
    valid_from date,
    valid_until date,
    feedback jsonb
) ON COMMIT DROP;
-- 3. Load initial state.
\echo '--- Loading initial state ---'
--- Loading initial state ---
INSERT INTO source_data (employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('E101', 'alice@example.com', 'Alice Smith', '2023-01-01', '2024-01-01');
-- The key of this test: CALL temporal_merge WITHOUT specifying identity columns.
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- State after initial load ---'
--- State after initial load ---
SELECT id, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;
 id | employee_nr |       email       |  full_name  | valid_from | valid_until 
----+-------------+-------------------+-------------+------------+-------------
  1 | E101        | alice@example.com | Alice Smith | 2023-01-01 | 2024-01-01
(1 row)

-- 4. Update via `employee_nr`. This creates a new historical record (SCD Type 2).
\echo '--- Updating via employee_nr ---'
--- Updating via employee_nr ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (employee_nr, full_name, valid_from, valid_until) VALUES
    ('E101', 'Alice Jones', '2023-06-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- State after update via employee_nr ---'
--- State after update via employee_nr ---
SELECT id, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;
 id | employee_nr |       email       |  full_name  | valid_from | valid_until 
----+-------------+-------------------+-------------+------------+-------------
  1 | E101        | alice@example.com | Alice Smith | 2023-01-01 | 2023-06-01
  1 | E101        | alice@example.com | Alice Jones | 2023-06-01 | 2024-01-01
(2 rows)

-- 5. Update via `email`. This creates a third historical record.
\echo '--- Updating via email ---'
--- Updating via email ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (email, full_name, valid_from, valid_until) VALUES
    ('alice@example.com', 'Alice Jones-Carter', '2023-09-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
\echo '--- Final State after update via email ---'
--- Final State after update via email ---
SELECT id, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;
 id | employee_nr |       email       |     full_name      | valid_from | valid_until 
----+-------------+-------------------+--------------------+------------+-------------
  1 | E101        | alice@example.com | Alice Smith        | 2023-01-01 | 2023-06-01
  1 | E101        | alice@example.com | Alice Jones        | 2023-06-01 | 2023-09-01
  1 | E101        | alice@example.com | Alice Jones-Carter | 2023-09-01 | 2024-01-01
(3 rows)

-- 6. Add a second person.
\echo '--- Adding a second person ---'
--- Adding a second person ---
TRUNCATE source_data RESTART IDENTITY;
INSERT INTO source_data (employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('E102', 'bob@example.com', 'Bob Johnson', '2023-01-01', '2024-01-01');
CALL sql_saga.temporal_merge('identity_discovery.person', 'source_data');
SELECT id, employee_nr, email, full_name, valid_from, valid_until
FROM identity_discovery.person ORDER BY id, valid_from;
 id | employee_nr |       email       |     full_name      | valid_from | valid_until 
----+-------------+-------------------+--------------------+------------+-------------
  1 | E101        | alice@example.com | Alice Smith        | 2023-01-01 | 2023-06-01
  1 | E101        | alice@example.com | Alice Jones        | 2023-06-01 | 2023-09-01
  1 | E101        | alice@example.com | Alice Jones-Carter | 2023-09-01 | 2024-01-01
  2 | E102        | bob@example.com   | Bob Johnson        | 2023-01-01 | 2024-01-01
(4 rows)

-- 7. FAIL: Attempt to update with conflicting natural keys.
\echo '--- Updating with conflicting keys (expect error) ---'
--- Updating with conflicting keys (expect error) ---
TRUNCATE source_data RESTART IDENTITY;
-- This source row links Alice's employee_nr with Bob's email, creating ambiguity.
INSERT INTO source_data (employee_nr, email, full_name, valid_from, valid_until) VALUES
    ('E101', 'bob@example.com', 'Conflict Person', '2023-10-01', '2024-01-01');
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    update_source_with_feedback => true,
    feedback_status_column => 'feedback',
    feedback_status_key => 'test'
);
\echo '--- Feedback for ambiguous row ---'
--- Feedback for ambiguous row ---
SELECT row_id, feedback->'test'->>'status' as status, feedback->'test'->>'error_message' as error_message
FROM source_data;
 row_id | status | error_message 
--------+--------+---------------
      1 |        | 
(1 row)

-- 8. FAIL: Attempt to insert a completely unidentifiable row.
\echo '--- Inserting unidentifiable row (expect error feedback) ---'
--- Inserting unidentifiable row (expect error feedback) ---
TRUNCATE source_data RESTART IDENTITY;
-- This row has NULL for all identifying columns.
INSERT INTO source_data (full_name, valid_from, valid_until) VALUES
    ('Ghost Person', '2023-11-01', '2024-01-01');
CALL sql_saga.temporal_merge(
    target_table => 'identity_discovery.person',
    source_table => 'source_data',
    update_source_with_feedback => true,
    feedback_status_column => 'feedback',
    feedback_status_key => 'test'
);
\echo '--- Feedback for unidentifiable row ---'
--- Feedback for unidentifiable row ---
-- The status should be ERROR with a specific message.
SELECT row_id, feedback->'test'->>'status' as status, feedback->'test'->>'error_message' as error_message
FROM source_data;
 row_id | status | error_message 
--------+--------+---------------
      1 |        | 
(1 row)

ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
