\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
CREATE TABLE products (
    id int,
    name text,
    price numeric,
    valid_range daterange,
    valid_from date,
    valid_until date
);
-- Register era and unique key
SELECT sql_saga.add_era('products', 'valid_range');
NOTICE:  sql_saga: Created trigger "products_synchronize_temporal_columns_trigger" on table products to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('products', ARRAY['id']);
NOTICE:  sql_saga: Added constraints to table products: ADD CONSTRAINT products_id_valid_uniq UNIQUE (id, valid_range WITHOUT OVERLAPS)
  add_unique_key   
-------------------
 products_id_valid
(1 row)

-- Populate with some historical data
INSERT INTO products(id,name,price,valid_from,valid_until) VALUES
(1, 'Laptop', 1200, '2023-01-01', '2024-01-01'),
(1, 'Laptop', 1150, '2024-01-01', 'infinity'),
(2, 'Mouse', 25, '2023-05-01', 'infinity');
TABLE products ORDER BY id, valid_from;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1200 | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  1 | Laptop |  1150 | [2024-01-01,infinity)   | 2024-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(3 rows)

-- Test API Lifecycle
-- ==================
-- Add the for_portion_of view
SELECT sql_saga.add_for_portion_of_view('products'::regclass);
 add_for_portion_of_view 
-------------------------
 t
(1 row)

\d products__for_portion_of_valid
       View "public.products__for_portion_of_valid"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           |          | 
 name        | text      |           |          | 
 price       | numeric   |           |          | 
 valid_range | daterange |           |          | 
 valid_from  | date      |           |          | 
 valid_until | date      |           |          | 
Triggers:
    for_portion_of_valid INSTEAD OF INSERT OR DELETE OR UPDATE ON products__for_portion_of_valid FOR EACH ROW EXECUTE FUNCTION sql_saga.for_portion_of_trigger('id')

TABLE sql_saga.updatable_view;
 view_schema |           view_name            |   view_type    | table_schema | table_name | era_name |     trigger_name     | current_func | generated_columns | ephemeral_columns 
-------------+--------------------------------+----------------+--------------+------------+----------+----------------------+--------------+-------------------+-------------------
 public      | products__for_portion_of_valid | for_portion_of | public       | products   | valid    | for_portion_of_valid |              | {}                | 
(1 row)

-- Test DML Semantics
-- ==================
-- Test SELECT
-- Should show the complete history, same as the base table.
CREATE VIEW products_view_select_for_portion_of AS
TABLE products__for_portion_of_valid ORDER BY id, valid_from;
TABLE products_view_select_for_portion_of;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1200 | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  1 | Laptop |  1150 | [2024-01-01,infinity)   | 2024-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(3 rows)

-- Test INSERT (should be disallowed)
SAVEPOINT insert_should_fail;
INSERT INTO products__for_portion_of_valid (id, name, price, valid_from, valid_until)
VALUES (3, 'Keyboard', 75, '2023-01-01', 'infinity');
ERROR:  sql_saga: The "for_portion_of" view only supports UPDATE operations. For INSERTs or DELETEs, please use the base table directly.
CONTEXT:  PL/pgSQL function sql_saga.for_portion_of_trigger() line 11 at RAISE
ROLLBACK TO insert_should_fail;
-- The table should be unchanged.
TABLE products ORDER BY id, valid_from;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1200 | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  1 | Laptop |  1150 | [2024-01-01,infinity)   | 2024-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(3 rows)

TABLE products_view_select_for_portion_of;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1200 | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  1 | Laptop |  1150 | [2024-01-01,infinity)   | 2024-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(3 rows)

-- Test simple UPDATE (no temporal bounds in SET clause)
-- This is now allowed as a "bulk historical correction".
-- It will update the price on ALL historical records for entity 1.
SAVEPOINT simple_update_should_succeed;
UPDATE products__for_portion_of_valid SET price = 1250 WHERE id = 1;
-- Verify both rows for product 1 are updated.
TABLE products ORDER BY id, valid_from;
 id |  name  | price |      valid_range      | valid_from | valid_until 
----+--------+-------+-----------------------+------------+-------------
  1 | Laptop |  1250 | [2023-01-01,infinity) | 2023-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity) | 2023-05-01 | infinity
(2 rows)

ROLLBACK TO simple_update_should_succeed;
-- The table should be unchanged.
TABLE products ORDER BY id, valid_from;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1200 | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  1 | Laptop |  1150 | [2024-01-01,infinity)   | 2024-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(3 rows)

-- Test exact match UPDATE (data correction on a specific historical slice)
SAVEPOINT exact_match_update_with_where_should_succeed;
UPDATE products__for_portion_of_valid
SET
    price = 1250,
    valid_from = '2023-01-01',
    valid_until = '2024-01-01'
WHERE id = 1
  -- Notice this matches the REST represenation of valid_from=gte.x&valid_until=lt.y
  AND valid_from >= '2023-01-01'
  AND valid_until <= '2024-01-01';
-- Verify there is not DELETE in the plan
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |     old_valid_range     |     new_valid_range     |               data                | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------+-------------------------+-----------------------------------+----------+-------+--------------------
           1 |             1 | {1}     | UPDATE    | NONE          | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | equals       | equals       | 2023-01-01     | 2024-01-01      | 2023-01-01     | 2024-01-01      | [2023-01-01,2024-01-01) | [2023-01-01,2024-01-01) | {"name": "Laptop", "price": 1250} |          |       | existing_entity__1
(1 row)

TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
             1 | [{"id": 1}]        | APPLIED | 
(1 row)

-- Verify price is updated on just that one row.
TABLE products ORDER BY id, valid_from;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1250 | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  1 | Laptop |  1150 | [2024-01-01,infinity)   | 2024-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(3 rows)

ROLLBACK TO exact_match_update_with_where_should_succeed;
-- Verify state is restored
TABLE products ORDER BY id, valid_from;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1200 | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  1 | Laptop |  1150 | [2024-01-01,infinity)   | 2024-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(3 rows)

TABLE products_view_select_for_portion_of;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1200 | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  1 | Laptop |  1150 | [2024-01-01,infinity)   | 2024-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(3 rows)

-- Test exact match UPDATE (data correction on a specific historical slice)
-- This is now allowed.
SAVEPOINT exact_temporal_match_without_where_should_succeed;
UPDATE products__for_portion_of_valid
SET
    price = 1250,
    valid_from = '2023-01-01',
    valid_until = '2024-01-01'
WHERE id = 1;
-- Verify there is not DELETE in the plan
TABLE pg_temp.temporal_merge_plan ORDER BY plan_op_seq;
 plan_op_seq | statement_seq | row_ids | operation | update_effect | causal_id | is_new_entity | entity_keys | identity_keys | lookup_keys | s_t_relation | b_a_relation | old_valid_from | old_valid_until | new_valid_from | new_valid_until |     old_valid_range     |     new_valid_range     |               data                | feedback | trace |    grouping_key    
-------------+---------------+---------+-----------+---------------+-----------+---------------+-------------+---------------+-------------+--------------+--------------+----------------+-----------------+----------------+-----------------+-------------------------+-------------------------+-----------------------------------+----------+-------+--------------------
           1 |             1 | {1}     | UPDATE    | NONE          | 1         | f             | {"id": 1}   | {"id": 1}     | {"id": 1}   | equals       | equals       | 2023-01-01     | 2024-01-01      | 2023-01-01     | 2024-01-01      | [2023-01-01,2024-01-01) | [2023-01-01,2024-01-01) | {"name": "Laptop", "price": 1250} |          |       | existing_entity__1
(1 row)

TABLE pg_temp.temporal_merge_feedback ORDER BY source_row_id;
 source_row_id | target_entity_keys | status  | error_message 
---------------+--------------------+---------+---------------
             1 | [{"id": 1}]        | APPLIED | 
(1 row)

-- Verify price is updated on just that one row.
TABLE products ORDER BY id, valid_from;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1250 | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  1 | Laptop |  1150 | [2024-01-01,infinity)   | 2024-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(3 rows)

ROLLBACK TO exact_temporal_match_without_where_should_succeed;
-- Verify state is restored
TABLE products ORDER BY id, valid_from;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1200 | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  1 | Laptop |  1150 | [2024-01-01,infinity)   | 2024-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(3 rows)

TABLE products_view_select_for_portion_of;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1200 | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  1 | Laptop |  1150 | [2024-01-01,infinity)   | 2024-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(3 rows)

-- Test UPDATE (applying a change to a portion of the timeline)
-- Apply a price change to Laptop for a 3-month period.
-- This should split the second historical record into three distinct parts.
UPDATE products__for_portion_of_valid
SET
    price = 1175,
    valid_from = '2024-03-01', -- Parameter for start of change
    valid_until = '2024-06-01'  -- Parameter for end of change
WHERE id = 1;
-- The timeline for Laptop should now have 4 distinct periods.
TABLE products ORDER BY id, valid_from;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1200 | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  1 | Laptop |  1150 | [2024-01-01,2024-03-01) | 2024-01-01 | 2024-03-01
  1 | Laptop |  1175 | [2024-03-01,2024-06-01) | 2024-03-01 | 2024-06-01
  1 | Laptop |  1150 | [2024-06-01,infinity)   | 2024-06-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(5 rows)

TABLE products_view_select_for_portion_of;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1200 | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  1 | Laptop |  1150 | [2024-01-01,2024-03-01) | 2024-01-01 | 2024-03-01
  1 | Laptop |  1175 | [2024-03-01,2024-06-01) | 2024-03-01 | 2024-06-01
  1 | Laptop |  1150 | [2024-06-01,infinity)   | 2024-06-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(5 rows)

-- Test UPDATE (spanning multiple historical records)
-- This should shorten two records and insert a new one in the middle.
-- To get a clean state, we delete and re-insert product 1's history.
DELETE FROM products WHERE id = 1;
INSERT INTO products(id,name,price,valid_from,valid_until) VALUES
(1, 'Laptop', 1200, '2023-01-01', '2024-01-01'),
(1, 'Laptop', 1150, '2024-01-01', 'infinity');
TABLE products ORDER BY id, valid_from;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1200 | [2023-01-01,2024-01-01) | 2023-01-01 | 2024-01-01
  1 | Laptop |  1150 | [2024-01-01,infinity)   | 2024-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(3 rows)

UPDATE products__for_portion_of_valid
SET
    price = 1180,
    valid_from = '2023-10-01',
    valid_until = '2024-04-01'
WHERE id = 1;
-- This should now result in a single coalesced record for the 1180 price.
TABLE products ORDER BY id, valid_from;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1200 | [2023-01-01,2023-10-01) | 2023-01-01 | 2023-10-01
  1 | Laptop |  1180 | [2023-10-01,2024-04-01) | 2023-10-01 | 2024-04-01
  1 | Laptop |  1150 | [2024-04-01,infinity)   | 2024-04-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(4 rows)

TABLE products_view_select_for_portion_of;
 id |  name  | price |       valid_range       | valid_from | valid_until 
----+--------+-------+-------------------------+------------+-------------
  1 | Laptop |  1200 | [2023-01-01,2023-10-01) | 2023-01-01 | 2023-10-01
  1 | Laptop |  1180 | [2023-10-01,2024-04-01) | 2023-10-01 | 2024-04-01
  1 | Laptop |  1150 | [2024-04-01,infinity)   | 2024-04-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity)   | 2023-05-01 | infinity
(4 rows)

-- Test UPDATE (fully surrounding all existing records for an entity)
-- This runs on the result of the previous test and should replace all
-- historical records for Laptop with a single new one.
UPDATE products__for_portion_of_valid
SET
    price = 1300,
    valid_from = '2022-01-01',
    valid_until = 'infinity'
WHERE id = 1;
TABLE products ORDER BY id, valid_from;
 id |  name  | price |      valid_range      | valid_from | valid_until 
----+--------+-------+-----------------------+------------+-------------
  1 | Laptop |  1300 | [2023-01-01,infinity) | 2023-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity) | 2023-05-01 | infinity
(2 rows)

TABLE products_view_select_for_portion_of;
 id |  name  | price |      valid_range      | valid_from | valid_until 
----+--------+-------+-----------------------+------------+-------------
  1 | Laptop |  1300 | [2023-01-01,infinity) | 2023-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity) | 2023-05-01 | infinity
(2 rows)

-- Test DELETE (should be disallowed)
-- Delete the Mouse record
SAVEPOINT delete_should_fail;
DELETE FROM products__for_portion_of_valid WHERE id = 2;
ERROR:  sql_saga: The "for_portion_of" view only supports UPDATE operations. For INSERTs or DELETEs, please use the base table directly.
CONTEXT:  PL/pgSQL function sql_saga.for_portion_of_trigger() line 11 at RAISE
ROLLBACK TO delete_should_fail;
-- The record for the mouse should still be present
TABLE products ORDER BY id, valid_from;
 id |  name  | price |      valid_range      | valid_from | valid_until 
----+--------+-------+-----------------------+------------+-------------
  1 | Laptop |  1300 | [2023-01-01,infinity) | 2023-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity) | 2023-05-01 | infinity
(2 rows)

TABLE products_view_select_for_portion_of;
 id |  name  | price |      valid_range      | valid_from | valid_until 
----+--------+-------+-----------------------+------------+-------------
  1 | Laptop |  1300 | [2023-01-01,infinity) | 2023-01-01 | infinity
  2 | Mouse  |    25 | [2023-05-01,infinity) | 2023-05-01 | infinity
(2 rows)

-- Drop the dependent view first
DROP VIEW products_view_select_for_portion_of;
-- Drop the view
SELECT sql_saga.drop_for_portion_of_view('products'::regclass);
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

TABLE sql_saga.updatable_view;
 view_schema | view_name | view_type | table_schema | table_name | era_name | trigger_name | current_func | generated_columns | ephemeral_columns 
-------------+-----------+-----------+--------------+------------+----------+--------------+--------------+-------------------+-------------------
(0 rows)

-- The view should no longer exist. This will fail if it does.
SAVEPOINT view_is_gone;
SELECT * FROM products__for_portion_of_valid;
ERROR:  relation "products__for_portion_of_valid" does not exist
LINE 1: SELECT * FROM products__for_portion_of_valid;
                      ^
ROLLBACK TO view_is_gone;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
