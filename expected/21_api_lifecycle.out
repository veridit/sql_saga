\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
SET ROLE TO sql_saga_unprivileged_user;
\i sql/support/shifts_houses_rooms_tables.sql
--
-- Creates the shifts, houses, and rooms tables used by many legacy tests.
--
CREATE TABLE shifts (
  job_id INTEGER,
  worker_id INTEGER,
  valid_from DATE,
  valid_until DATE
);
CREATE TABLE houses (
  id INTEGER,
  assessment FLOAT,
  valid_from DATE,
  valid_until DATE
);
CREATE TABLE rooms (
  id INTEGER,
  house_id INTEGER,
  valid_from DATE,
  valid_until DATE
);
-- Before using sql_saga
\d rooms
                  Table "public.rooms"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 id          | integer |           |          | 
 house_id    | integer |           |          | 
 valid_from  | date    |           |          | 
 valid_until | date    |           |          | 

\d houses
                      Table "public.houses"
   Column    |       Type       | Collation | Nullable | Default 
-------------+------------------+-----------+----------+---------
 id          | integer          |           |          | 
 assessment  | double precision |           |          | 
 valid_from  | date             |           |          | 
 valid_until | date             |           |          | 

\d shifts
                 Table "public.shifts"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 job_id      | integer |           |          | 
 worker_id   | integer |           |          | 
 valid_from  | date    |           |          | 
 valid_until | date    |           |          | 

-- Verify that enable and disable each work correctly.
SELECT sql_saga.add_era(table_oid => 'shifts', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_era(table_oid => 'houses', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until', era_name => 'valid');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_era(table_oid => 'rooms', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until');
 add_era 
---------
 t
(1 row)

TABLE sql_saga.era;
 table_schema | table_name | era_name | valid_from_column_name | valid_until_column_name | range_type | bounds_check_constraint | audit_schema_name | audit_table_name 
--------------+------------+----------+------------------------+-------------------------+------------+-------------------------+-------------------+------------------
 public       | shifts     | valid    | valid_from             | valid_until             | daterange  | shifts_valid_check      |                   | 
 public       | houses     | valid    | valid_from             | valid_until             | daterange  | houses_valid_check      |                   | 
 public       | rooms      | valid    | valid_from             | valid_until             | daterange  | rooms_valid_check       |                   | 
(3 rows)

SELECT sql_saga.add_unique_key(table_oid => 'shifts', column_names => ARRAY['job_id','worker_id'], era_name => 'valid');
        add_unique_key         
-------------------------------
 shifts_job_id_worker_id_valid
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'houses', column_names => ARRAY['id'], era_name => 'valid');
 add_unique_key  
-----------------
 houses_id_valid
(1 row)

SELECT sql_saga.add_unique_key(table_oid => 'rooms', column_names => ARRAY['id'], era_name => 'valid');
 add_unique_key 
----------------
 rooms_id_valid
(1 row)

SELECT * FROM sql_saga.unique_keys ORDER BY unique_key_name;
        unique_key_name        | table_schema | table_name |    column_names    | era_name |                 unique_constraint                  |         exclude_constraint         | predicate 
-------------------------------+--------------+------------+--------------------+----------+----------------------------------------------------+------------------------------------+-----------
 houses_id_valid               | public       | houses     | {id}               | valid    | houses_id_valid_from_valid_until_key               | houses_id_valid_excl               | 
 rooms_id_valid                | public       | rooms      | {id}               | valid    | rooms_id_valid_from_valid_until_key                | rooms_id_valid_excl                | 
 shifts_job_id_worker_id_valid | public       | shifts     | {job_id,worker_id} | valid    | shifts_job_id_worker_id_valid_from_valid_until_key | shifts_job_id_worker_id_valid_excl | 
(3 rows)

SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'rooms',
    fk_column_names => ARRAY['house_id'],
    fk_era_name => 'valid',
    unique_key_name => 'houses_id_valid'
);
   add_foreign_key    
----------------------
 rooms_house_id_valid
(1 row)

TABLE sql_saga.foreign_keys;
   foreign_key_name   |         type         | table_schema | table_name | column_names | fk_era_name |      fk_table_columns_snapshot       | unique_key_name | match_type | update_action | delete_action |       fk_insert_trigger        |       fk_update_trigger        | fk_check_constraint | fk_helper_function |       uk_update_trigger        |       uk_delete_trigger        
----------------------+----------------------+--------------+------------+--------------+-------------+--------------------------------------+-----------------+------------+---------------+---------------+--------------------------------+--------------------------------+---------------------+--------------------+--------------------------------+--------------------------------
 rooms_house_id_valid | temporal_to_temporal | public       | rooms      | {house_id}   | valid       | {id,house_id,valid_from,valid_until} | houses_id_valid | SIMPLE     | NO ACTION     | NO ACTION     | rooms_house_id_valid_fk_insert | rooms_house_id_valid_fk_update |                     |                    | rooms_house_id_valid_uk_update | rooms_house_id_valid_uk_delete
(1 row)

-- Add API views
SELECT sql_saga.add_updatable_views('houses');
 add_updatable_views 
---------------------
 t
(1 row)

TABLE sql_saga.api_view;
 table_schema | table_name | era_name | view_schema_name |       view_table_name        |     trigger_name     
--------------+------------+----------+------------------+------------------------------+----------------------
 public       | houses     | valid    | public           | houses__for_portion_of_valid | for_portion_of_valid
(1 row)

\d houses_valid_v
-- While sql_saga is active
\d rooms
                  Table "public.rooms"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 id          | integer |           |          | 
 house_id    | integer |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 
Indexes:
    "rooms_id_idx" btree (id)
    "rooms_id_valid_excl" EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "rooms_id_valid_from_valid_until_key" UNIQUE CONSTRAINT, btree (id, valid_from, valid_until) DEFERRABLE
Check constraints:
    "rooms_valid_check" CHECK (valid_from < valid_until)
Triggers:
    rooms_house_id_valid_fk_insert AFTER INSERT ON rooms FROM houses DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION sql_saga.fk_insert_check_c('rooms_house_id_valid', 'public', 'rooms', '{house_id}', 'valid', 'valid_from', 'valid_until', 'public', 'houses', '{id}', 'valid', 'valid_from', 'valid_until', 'SIMPLE', 'NO ACTION', 'NO ACTION')
    rooms_house_id_valid_fk_update AFTER UPDATE OF house_id, valid_from, valid_until ON rooms FROM houses DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION sql_saga.fk_update_check_c('rooms_house_id_valid', 'public', 'rooms', '{house_id}', 'valid', 'valid_from', 'valid_until', 'public', 'houses', '{id}', 'valid', 'valid_from', 'valid_until', 'SIMPLE', 'NO ACTION', 'NO ACTION')

\d houses
                      Table "public.houses"
   Column    |       Type       | Collation | Nullable | Default 
-------------+------------------+-----------+----------+---------
 id          | integer          |           |          | 
 assessment  | double precision |           |          | 
 valid_from  | date             |           | not null | 
 valid_until | date             |           | not null | 
Indexes:
    "houses_id_idx" btree (id)
    "houses_id_valid_excl" EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "houses_id_valid_from_valid_until_key" UNIQUE CONSTRAINT, btree (id, valid_from, valid_until) DEFERRABLE
Check constraints:
    "houses_valid_check" CHECK (valid_from < valid_until)
Triggers:
    rooms_house_id_valid_uk_delete AFTER DELETE ON houses FROM rooms DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION sql_saga.uk_delete_check_c('rooms_house_id_valid', 'public', 'rooms', '{house_id}', 'valid', 'valid_from', 'valid_until', 'public', 'houses', '{id}', 'valid', 'valid_from', 'valid_until', 'SIMPLE', 'NO ACTION', 'NO ACTION', 'temporal_to_temporal')
    rooms_house_id_valid_uk_update AFTER UPDATE OF id, valid_from, valid_until ON houses FROM rooms DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION sql_saga.uk_update_check_c('rooms_house_id_valid', 'public', 'rooms', '{house_id}', 'valid', 'valid_from', 'valid_until', 'public', 'houses', '{id}', 'valid', 'valid_from', 'valid_until', 'SIMPLE', 'NO ACTION', 'NO ACTION', 'temporal_to_temporal')

\d shifts
                 Table "public.shifts"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 job_id      | integer |           |          | 
 worker_id   | integer |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 
Indexes:
    "shifts_job_id_worker_id_idx" btree (job_id, worker_id)
    "shifts_job_id_worker_id_valid_excl" EXCLUDE USING gist (job_id WITH =, worker_id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
    "shifts_job_id_worker_id_valid_from_valid_until_key" UNIQUE CONSTRAINT, btree (job_id, worker_id, valid_from, valid_until) DEFERRABLE
Check constraints:
    "shifts_valid_check" CHECK (valid_from < valid_until)

-- Remove sql_saga
SELECT sql_saga.drop_updatable_views('houses', 'valid');
 drop_updatable_views 
----------------------
 t
(1 row)

TABLE sql_saga.api_view;
 table_schema | table_name | era_name | view_schema_name | view_table_name | trigger_name 
--------------+------------+----------+------------------+-----------------+--------------
(0 rows)

SELECT sql_saga.drop_foreign_key('rooms', ARRAY['house_id'], 'valid');
 drop_foreign_key 
------------------
 
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name | type | table_schema | table_name | column_names | fk_era_name | fk_table_columns_snapshot | unique_key_name | match_type | update_action | delete_action | fk_insert_trigger | fk_update_trigger | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger 
------------------+------+--------------+------------+--------------+-------------+---------------------------+-----------------+------------+---------------+---------------+-------------------+-------------------+---------------------+--------------------+-------------------+-------------------
(0 rows)

SELECT sql_saga.drop_unique_key('rooms', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_unique_key('houses', ARRAY['id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_unique_key('shifts', ARRAY['job_id','worker_id'], 'valid');
 drop_unique_key 
-----------------
 
(1 row)

SELECT * FROM sql_saga.unique_keys ORDER BY unique_key_name;
 unique_key_name | table_schema | table_name | column_names | era_name | unique_constraint | exclude_constraint | predicate 
-----------------+--------------+------------+--------------+----------+-------------------+--------------------+-----------
(0 rows)

SELECT sql_saga.drop_era('rooms');
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_era('houses');
 drop_era 
----------
 t
(1 row)

SELECT sql_saga.drop_era('shifts');
 drop_era 
----------
 t
(1 row)

TABLE sql_saga.era;
 table_schema | table_name | era_name | valid_from_column_name | valid_until_column_name | range_type | bounds_check_constraint | audit_schema_name | audit_table_name 
--------------+------------+----------+------------------------+-------------------------+------------+-------------------------+-------------------+------------------
(0 rows)

-- After removing sql_saga, it should be as before.
\d rooms
                  Table "public.rooms"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 id          | integer |           |          | 
 house_id    | integer |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 
Indexes:
    "rooms_id_idx" btree (id)
Check constraints:
    "rooms_valid_check" CHECK (valid_from < valid_until)

\d houses
                      Table "public.houses"
   Column    |       Type       | Collation | Nullable | Default 
-------------+------------------+-----------+----------+---------
 id          | integer          |           |          | 
 assessment  | double precision |           |          | 
 valid_from  | date             |           | not null | 
 valid_until | date             |           | not null | 
Indexes:
    "houses_id_idx" btree (id)
Check constraints:
    "houses_valid_check" CHECK (valid_from < valid_until)

\d shifts
                 Table "public.shifts"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 job_id      | integer |           |          | 
 worker_id   | integer |           |          | 
 valid_from  | date    |           | not null | 
 valid_until | date    |           | not null | 
Indexes:
    "shifts_job_id_worker_id_idx" btree (job_id, worker_id)
Check constraints:
    "shifts_valid_check" CHECK (valid_from < valid_until)

ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
