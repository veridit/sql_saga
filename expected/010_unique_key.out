\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
/* Run tests as unprivileged user */
SET ROLE TO sql_saga_unprivileged_user;
-- Unique keys are already pretty much guaranteed by the underlying features of
-- PostgreSQL, but test them anyway.
CREATE TABLE uk (id integer, valid_range int4range, valid_from integer, valid_until integer, CONSTRAINT uk_pkey PRIMARY KEY (id, valid_range WITHOUT OVERLAPS));
SELECT sql_saga.add_era('uk', 'valid_range', 'p');
NOTICE:  sql_saga: Created trigger "uk_synchronize_temporal_columns_trigger" on table uk to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

-- Adopt an existing primary key
SELECT sql_saga.add_unique_key('uk'::regclass, ARRAY['id'], 'p', key_type => 'primary', unique_key_name => 'uk_id_p', unique_constraint => 'uk_pkey');
NOTICE:  sql_saga: altering table public.uk to add constraints: ALTER COLUMN id SET NOT NULL
 add_unique_key 
----------------
 uk_id_p
(1 row)

TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
 uk_id_p         | public       | uk         | primary  | {id}         | p        | uk_pkey           |                    |                  |           |                            |                     |                                  | 
(1 row)

INSERT INTO uk (id, valid_range) VALUES (100, int4range(2, 4)), (100, int4range(4, 5)), (100, int4range(5, 11)); -- success
INSERT INTO uk (id, valid_range) VALUES (200, int4range(2, 4)), (200, int4range(4, 5)), (200, int4range(6, 11)); -- success
SAVEPOINT pristine;
INSERT INTO uk (id, valid_range) VALUES (300, int4range(2, 4)), (300, int4range(4, 6)), (300, int4range(5, 11)); -- fail (overlapping ranges)
ERROR:  conflicting key value violates exclusion constraint "uk_pkey"
DETAIL:  Key (id, valid_range)=(300, [5,11)) conflicts with existing key (id, valid_range)=(300, [4,6)).
ROLLBACK TO SAVEPOINT pristine;
CREATE TABLE fk (id integer, uk_id integer, valid_range int4range, valid_from integer, valid_until integer, PRIMARY KEY (id, valid_range WITHOUT OVERLAPS) DEFERRABLE);
SELECT sql_saga.add_era('fk', 'valid_range', 'q');
NOTICE:  sql_saga: Created trigger "fk_synchronize_temporal_columns_trigger" on table fk to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_temporal_foreign_key('fk', ARRAY['uk_id'], 'q', 'uk_id_p',
    foreign_key_name => 'fk_uk_id_q',
    fk_insert_trigger => 'fki',
    fk_update_trigger => 'fku',
    uk_update_trigger => 'uku',
    uk_delete_trigger => 'ukd');
NOTICE:  No compatible index found for foreign key on table fk. Creating new index: CREATE INDEX fk_uk_id_q_gist_idx ON fk USING GIST (uk_id, valid_range)
 add_temporal_foreign_key 
--------------------------
 fk_uk_id_q
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name |         type         | table_schema | table_name | column_names | fk_era_name |           fk_table_columns_snapshot           | unique_key_name | match_type | update_action | delete_action | fk_insert_trigger | fk_update_trigger | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger |    fk_index_name    
------------------+----------------------+--------------+------------+--------------+-------------+-----------------------------------------------+-----------------+------------+---------------+---------------+-------------------+-------------------+---------------------+--------------------+-------------------+-------------------+---------------------
 fk_uk_id_q       | temporal_to_temporal | public       | fk         | {uk_id}      | q           | {id,uk_id,valid_range,valid_from,valid_until} | uk_id_p         | SIMPLE     | NO ACTION     | NO ACTION     |                   |                   |                     |                    |                   |                   | fk_uk_id_q_gist_idx
(1 row)

SELECT sql_saga.drop_foreign_key('fk', ARRAY['uk_id'], 'q');
NOTICE:  Dropping automatically created index "fk_uk_id_q_gist_idx" for foreign key "fk_uk_id_q"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.add_temporal_foreign_key('fk', ARRAY['uk_id'], 'q', 'uk_id_p', foreign_key_name => 'fk_uk_id_q');
NOTICE:  No compatible index found for foreign key on table fk. Creating new index: CREATE INDEX fk_uk_id_q_gist_idx ON fk USING GIST (uk_id, valid_range)
 add_temporal_foreign_key 
--------------------------
 fk_uk_id_q
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name |         type         | table_schema | table_name | column_names | fk_era_name |           fk_table_columns_snapshot           | unique_key_name | match_type | update_action | delete_action | fk_insert_trigger | fk_update_trigger | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger |    fk_index_name    
------------------+----------------------+--------------+------------+--------------+-------------+-----------------------------------------------+-----------------+------------+---------------+---------------+-------------------+-------------------+---------------------+--------------------+-------------------+-------------------+---------------------
 fk_uk_id_q       | temporal_to_temporal | public       | fk         | {uk_id}      | q           | {id,uk_id,valid_range,valid_from,valid_until} | uk_id_p         | SIMPLE     | NO ACTION     | NO ACTION     |                   |                   |                     |                    |                   |                   | fk_uk_id_q_gist_idx
(1 row)

-- INSERT
SAVEPOINT insert_test;
INSERT INTO fk VALUES (0, 100, int4range(1, 2)); -- fail (not covered by uk)
ERROR:  insert or update on table "fk" violates foreign key constraint "fk_uk_id_q"
DETAIL:  Key (uk_id, valid_range)=(100, [1,2)) is not present in table "uk".
ROLLBACK TO SAVEPOINT insert_test;
INSERT INTO fk VALUES (0, 100, int4range(1, 11)); -- fail (extends beyond uk coverage)
ERROR:  insert or update on table "fk" violates foreign key constraint "fk_uk_id_q"
DETAIL:  Key (uk_id, valid_range)=(100, [1,11)) is not present in table "uk".
ROLLBACK TO SAVEPOINT insert_test;
INSERT INTO fk VALUES (0, 100, int4range(2, 12)); -- fail (extends beyond uk coverage)
ERROR:  insert or update on table "fk" violates foreign key constraint "fk_uk_id_q"
DETAIL:  Key (uk_id, valid_range)=(100, [2,12)) is not present in table "uk".
ROLLBACK TO SAVEPOINT insert_test;
INSERT INTO fk VALUES (1, 100, int4range(2, 4)); -- success
INSERT INTO fk VALUES (2, 100, int4range(2, 11)); -- success
-- UPDATE
SAVEPOINT update_fk_test;
UPDATE fk SET valid_range = int4range(2, 21) WHERE id = 1; -- fail (extends beyond uk coverage)
ERROR:  insert or update on table "fk" violates foreign key constraint "fk_uk_id_q"
DETAIL:  Key (uk_id, valid_range)=(100, [2,21)) is not present in table "uk".
ROLLBACK TO SAVEPOINT update_fk_test;
UPDATE fk SET valid_range = int4range(2, 7) WHERE id = 1; -- success
SAVEPOINT update_uk_test;
UPDATE uk SET valid_range = int4range(3, 4) WHERE (id, valid_range) = (100, int4range(2, 4)); -- fail (would break fk reference)
ERROR:  update or delete on table "uk" violates foreign key constraint "fk_uk_id_q" on table "fk"
DETAIL:  Key (id, valid_range)=(100, [2,4)) is still referenced from table "fk".
ROLLBACK TO SAVEPOINT update_uk_test;
UPDATE uk SET valid_range = int4range(1, 4) WHERE (id, valid_range) = (100, int4range(2, 4)); -- success (extends coverage)
-- DELETE
SAVEPOINT delete_test;
DELETE FROM uk WHERE (id, valid_range) = (100, int4range(4, 5)); -- fail (referenced by fk)
ERROR:  update or delete on table "uk" violates foreign key constraint "fk_uk_id_q" on table "fk"
DETAIL:  Key (id, valid_range)=(100, [4,5)) is still referenced from table "fk".
ROLLBACK TO SAVEPOINT delete_test;
DELETE FROM uk WHERE (id, valid_range) = (200, int4range(4, 5)); -- success (not referenced)
SELECT sql_saga.drop_foreign_key('fk', ARRAY['uk_id'], 'q');
NOTICE:  Dropping automatically created index "fk_uk_id_q_gist_idx" for foreign key "fk_uk_id_q"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_era('fk', 'q');
 drop_era 
----------
 t
(1 row)

DROP TABLE fk;
SELECT sql_saga.drop_unique_key('uk', ARRAY['id'], 'p');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('uk', 'p');
 drop_era 
----------
 t
(1 row)

DROP TABLE uk;
-- Test primary key creation
CREATE TABLE pk_test (id integer, valid_range int4range, valid_from integer, valid_until integer);
SELECT sql_saga.add_era('pk_test', 'valid_range');
NOTICE:  sql_saga: Created trigger "pk_test_synchronize_temporal_columns_trigger" on table pk_test to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_test', '{id}', key_type => 'primary');
NOTICE:  sql_saga: altering table public.pk_test to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
  add_unique_key  
------------------
 pk_test_id_valid
(1 row)

\d pk_test
                  Table "public.pk_test"
   Column    |   Type    | Collation | Nullable | Default 
-------------+-----------+-----------+----------+---------
 id          | integer   |           | not null | 
 valid_range | int4range |           | not null | 
 valid_from  | integer   |           |          | 
 valid_until | integer   |           |          | 
Indexes:
    "pk_test_pkey" PRIMARY KEY (id, valid_range WITHOUT OVERLAPS)
    "pk_test_id_idx" btree (id)
    "pk_test_id_valid_range_idx" btree (id, valid_range)
Check constraints:
    "pk_test_valid_check" CHECK (NOT isempty(valid_range))
Triggers:
    pk_test_valid_sync_temporal_trg BEFORE INSERT OR UPDATE OF valid_range, valid_from, valid_until ON pk_test FOR EACH ROW EXECUTE FUNCTION sql_saga.public_pk_test_valid_template_sync()

TABLE sql_saga.unique_keys;
 unique_key_name  | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names | pk_consistency_constraint_names 
------------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------+----------------------------------+---------------------------------
 pk_test_id_valid | public       | pk_test    | primary  | {id}         | valid    | pk_test_pkey      |                    |                  |           |                            |                     |                                  | 
(1 row)

SELECT sql_saga.drop_unique_key('pk_test', '{id}');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('pk_test');
 drop_era 
----------
 t
(1 row)

DROP TABLE pk_test;
\echo '--- Test: add_unique_key validation for incompatible simple PRIMARY KEY ---'
--- Test: add_unique_key validation for incompatible simple PRIMARY KEY ---
CREATE TABLE public.simple_pk (
    id int PRIMARY KEY DEFERRABLE,
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('public.simple_pk', 'valid_range');
WARNING:  Table "simple_pk" has a simple PRIMARY KEY that does not include temporal columns. This schema is incompatible with SCD Type 2 history.
HINT:  If you plan to use a temporal primary key for this era, you must use a composite primary key that includes a temporal column (e.g., PRIMARY KEY (id, your_range_column)).
NOTICE:  sql_saga: Created trigger "simple_pk_synchronize_temporal_columns_trigger" on table simple_pk to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SAVEPOINT expect_error;
\echo 'Attempting to add a temporal primary key to a table with a simple primary key (should fail)'
Attempting to add a temporal primary key to a table with a simple primary key (should fail)
SELECT sql_saga.add_unique_key('public.simple_pk', '{id}', key_type => 'primary');
ERROR:  table "simple_pk" has a simple PRIMARY KEY that does not include the temporal range column ("valid_range"); this is incompatible with SCD Type 2 history
CONTEXT:  PL/pgSQL function sql_saga.add_unique_key(regclass,name[],name,sql_saga.unique_key_type,boolean,name,name,name,text,name[]) line 160 at RAISE
ROLLBACK TO SAVEPOINT expect_error;
DROP TABLE public.simple_pk;
\echo '--- Test: add_unique_key validation for GENERATED ALWAYS identity column ---'
--- Test: add_unique_key validation for GENERATED ALWAYS identity column ---
CREATE TABLE public.generated_always (
    id int GENERATED ALWAYS AS IDENTITY PRIMARY KEY DEFERRABLE,
    valid_range daterange,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('public.generated_always', 'valid_range');
WARNING:  Table "generated_always" has a simple PRIMARY KEY that does not include temporal columns. This schema is incompatible with SCD Type 2 history.
HINT:  If you plan to use a temporal primary key for this era, you must use a composite primary key that includes a temporal column (e.g., PRIMARY KEY (id, your_range_column)).
WARNING:  Table "generated_always" has a GENERATED ALWAYS AS IDENTITY column ("id"). This schema is incompatible with SCD Type 2 history.
HINT:  If you plan to use a temporal primary key for this era, the identity column must be GENERATED BY DEFAULT AS IDENTITY to allow inserting historical records.
NOTICE:  sql_saga: Created trigger "generated_always_synchronize_temporal_columns_trigger" on table generated_always to synchronize columns: valid_from, valid_until
 add_era 
---------
 t
(1 row)

SAVEPOINT expect_error_2;
\echo 'Attempting to add a temporal primary key to a table with a GENERATED ALWAYS identity (should fail)'
Attempting to add a temporal primary key to a table with a GENERATED ALWAYS identity (should fail)
SELECT sql_saga.add_unique_key('public.generated_always', '{id}', key_type => 'primary');
ERROR:  table "generated_always" has a GENERATED ALWAYS AS IDENTITY column ("id"); this is incompatible with SCD Type 2 history as it prevents inserting new historical versions of an entity
CONTEXT:  PL/pgSQL function sql_saga.add_unique_key(regclass,name[],name,sql_saga.unique_key_type,boolean,name,name,name,text,name[]) line 141 at RAISE
ROLLBACK TO SAVEPOINT expect_error_2;
DROP TABLE public.generated_always;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
