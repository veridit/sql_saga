\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
/* Run tests as unprivileged user */
SET ROLE TO sql_saga_unprivileged_user;
-- Unique keys are already pretty much guaranteed by the underlying features of
-- PostgreSQL, but test them anyway.
CREATE TABLE uk (id integer, valid_from integer, valid_until integer, CONSTRAINT uk_pkey PRIMARY KEY (id, valid_from, valid_until) DEFERRABLE);
SELECT sql_saga.add_era('uk', 'valid_from', 'valid_until', 'p');
 add_era 
---------
 t
(1 row)

-- Adopt an existing primary key
SELECT sql_saga.add_unique_key('uk'::regclass, ARRAY['id'], 'p', key_type => 'primary', unique_key_name => 'uk_id_p', unique_constraint => 'uk_pkey');
NOTICE:  sql_saga: altering table public.uk to add constraints: ALTER COLUMN id SET NOT NULL, ADD CONSTRAINT uk_id_p_excl EXCLUDE USING gist (id WITH =, int4range(valid_from, valid_until) WITH &&) DEFERRABLE
 add_unique_key 
----------------
 uk_id_p
(1 row)

TABLE sql_saga.unique_keys;
 unique_key_name | table_schema | table_name | key_type | column_names | era_name | unique_constraint | exclude_constraint | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names 
-----------------+--------------+------------+----------+--------------+----------+-------------------+--------------------+------------------+-----------+----------------------------+---------------------+----------------------------------
 uk_id_p         | public       | uk         | primary  | {id}         | p        | uk_pkey           | uk_id_p_excl       |                  |           |                            |                     | 
(1 row)

INSERT INTO uk (id, valid_from, valid_until) VALUES (100, 2, 4), (100, 4, 5), (100, 5, 11); -- success
INSERT INTO uk (id, valid_from, valid_until) VALUES (200, 2, 4), (200, 4, 5), (200, 6, 11); -- success
SAVEPOINT pristine;
INSERT INTO uk (id, valid_from, valid_until) VALUES (300, 2, 4), (300, 4, 6), (300, 5, 11); -- fail
ERROR:  conflicting key value violates exclusion constraint "uk_id_p_excl"
DETAIL:  Key (id, int4range(valid_from, valid_until))=(300, [5,11)) conflicts with existing key (id, int4range(valid_from, valid_until))=(300, [4,6)).
ROLLBACK TO SAVEPOINT pristine;
CREATE TABLE fk (id integer, uk_id integer, valid_from integer, valid_until integer, PRIMARY KEY (id, valid_from));
SELECT sql_saga.add_era('fk', 'valid_from', 'valid_until', 'q');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_temporal_foreign_key('fk', ARRAY['uk_id'], 'q', 'uk_id_p',
    foreign_key_name => 'fk_uk_id_q',
    fk_insert_trigger => 'fki',
    fk_update_trigger => 'fku',
    uk_update_trigger => 'uku',
    uk_delete_trigger => 'ukd');
NOTICE:  No compatible index found for foreign key on table fk. Creating new index: CREATE INDEX fk_uk_id_q_gist_idx ON fk USING GIST (uk_id, int4range(valid_from, valid_until))
 add_temporal_foreign_key 
--------------------------
 fk_uk_id_q
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name |         type         | table_schema | table_name | column_names | fk_era_name |     fk_table_columns_snapshot     | unique_key_name | match_type | update_action | delete_action | fk_insert_trigger | fk_update_trigger | fk_check_constraint | fk_helper_function | uk_update_trigger | uk_delete_trigger |    fk_index_name    
------------------+----------------------+--------------+------------+--------------+-------------+-----------------------------------+-----------------+------------+---------------+---------------+-------------------+-------------------+---------------------+--------------------+-------------------+-------------------+---------------------
 fk_uk_id_q       | temporal_to_temporal | public       | fk         | {uk_id}      | q           | {id,uk_id,valid_from,valid_until} | uk_id_p         | SIMPLE     | NO ACTION     | NO ACTION     | fki               | fku               |                     |                    | uku               | ukd               | fk_uk_id_q_gist_idx
(1 row)

SELECT sql_saga.drop_foreign_key('fk', ARRAY['uk_id'], 'q');
NOTICE:  Dropping automatically created index "fk_uk_id_q_gist_idx" for foreign key "fk_uk_id_q"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.add_temporal_foreign_key('fk', ARRAY['uk_id'], 'q', 'uk_id_p', foreign_key_name => 'fk_uk_id_q');
NOTICE:  No compatible index found for foreign key on table fk. Creating new index: CREATE INDEX fk_uk_id_q_gist_idx ON fk USING GIST (uk_id, int4range(valid_from, valid_until))
 add_temporal_foreign_key 
--------------------------
 fk_uk_id_q
(1 row)

TABLE sql_saga.foreign_keys;
 foreign_key_name |         type         | table_schema | table_name | column_names | fk_era_name |     fk_table_columns_snapshot     | unique_key_name | match_type | update_action | delete_action |  fk_insert_trigger   |  fk_update_trigger   | fk_check_constraint | fk_helper_function |  uk_update_trigger   |  uk_delete_trigger   |    fk_index_name    
------------------+----------------------+--------------+------------+--------------+-------------+-----------------------------------+-----------------+------------+---------------+---------------+----------------------+----------------------+---------------------+--------------------+----------------------+----------------------+---------------------
 fk_uk_id_q       | temporal_to_temporal | public       | fk         | {uk_id}      | q           | {id,uk_id,valid_from,valid_until} | uk_id_p         | SIMPLE     | NO ACTION     | NO ACTION     | fk_uk_id_q_fk_insert | fk_uk_id_q_fk_update |                     |                    | fk_uk_id_q_uk_update | fk_uk_id_q_uk_delete | fk_uk_id_q_gist_idx
(1 row)

-- INSERT
SAVEPOINT insert_test;
INSERT INTO fk VALUES (0, 100, 1, 2); -- fail
ERROR:  insert or update on table "public.fk" violates foreign key constraint "fk_uk_id_q"
ROLLBACK TO SAVEPOINT insert_test;
INSERT INTO fk VALUES (0, 100, 1, 11); -- fail
ERROR:  insert or update on table "public.fk" violates foreign key constraint "fk_uk_id_q"
ROLLBACK TO SAVEPOINT insert_test;
INSERT INTO fk VALUES (0, 100, 2, 12); -- fail
ERROR:  insert or update on table "public.fk" violates foreign key constraint "fk_uk_id_q"
ROLLBACK TO SAVEPOINT insert_test;
INSERT INTO fk VALUES (1, 100, 2, 4); -- success
INSERT INTO fk VALUES (2, 100, 2, 11); -- success
-- UPDATE
SAVEPOINT update_fk_test;
UPDATE fk SET valid_until = 21 WHERE id = 1; -- fail
ERROR:  insert or update on table "public.fk" violates foreign key constraint "fk_uk_id_q"
ROLLBACK TO SAVEPOINT update_fk_test;
UPDATE fk SET valid_until = 7 WHERE id = 1; -- success
SAVEPOINT update_uk_test;
UPDATE uk SET valid_from = 3 WHERE (id, valid_from, valid_until) = (100, 2, 4); -- fail
ERROR:  update or delete on table "public.uk" violates foreign key constraint "fk_uk_id_q" on table "public.fk"
ROLLBACK TO SAVEPOINT update_uk_test;
UPDATE uk SET valid_from = 1 WHERE (id, valid_from, valid_until) = (100, 2, 4); -- success
-- DELETE
SAVEPOINT delete_test;
DELETE FROM uk WHERE (id, valid_from, valid_until) = (100, 4, 5); -- fail
ERROR:  update or delete on table "public.uk" violates foreign key constraint "fk_uk_id_q" on table "public.fk"
ROLLBACK TO SAVEPOINT delete_test;
DELETE FROM uk WHERE (id, valid_from, valid_until) = (200, 4, 6); -- success
SELECT sql_saga.drop_foreign_key('fk', ARRAY['uk_id'], 'q');
NOTICE:  Dropping automatically created index "fk_uk_id_q_gist_idx" for foreign key "fk_uk_id_q"
 drop_foreign_key 
------------------
 
(1 row)

SELECT sql_saga.drop_era('fk', 'q');
 drop_era 
----------
 t
(1 row)

DROP TABLE fk;
SELECT sql_saga.drop_unique_key('uk', ARRAY['id'], 'p');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('uk', 'p');
 drop_era 
----------
 t
(1 row)

DROP TABLE uk;
-- Test primary key creation
CREATE TABLE pk_test (id integer, valid_from integer, valid_until integer);
SELECT sql_saga.add_era('pk_test', 'valid_from', 'valid_until');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('pk_test', '{id}', key_type => 'primary');
NOTICE:  sql_saga: altering table public.pk_test to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_from) DEFERRABLE, ADD CONSTRAINT pk_test_id_valid_excl EXCLUDE USING gist (id WITH =, int4range(valid_from, valid_until) WITH &&) DEFERRABLE
  add_unique_key  
------------------
 pk_test_id_valid
(1 row)

\d pk_test
                 Table "public.pk_test"
   Column    |  Type   | Collation | Nullable | Default 
-------------+---------+-----------+----------+---------
 id          | integer |           | not null | 
 valid_from  | integer |           | not null | 
 valid_until | integer |           | not null | 
Indexes:
    "pk_test_pkey" PRIMARY KEY, btree (id, valid_from) DEFERRABLE
    "pk_test_id_idx" btree (id)
    "pk_test_id_valid_excl" EXCLUDE USING gist (id WITH =, int4range(valid_from, valid_until) WITH &&) DEFERRABLE
Check constraints:
    "pk_test_valid_check" CHECK (valid_from < valid_until)

TABLE sql_saga.unique_keys;
 unique_key_name  | table_schema | table_name | key_type | column_names | era_name | unique_constraint |  exclude_constraint   | check_constraint | predicate | mutually_exclusive_columns | partial_index_names | partial_exclude_constraint_names 
------------------+--------------+------------+----------+--------------+----------+-------------------+-----------------------+------------------+-----------+----------------------------+---------------------+----------------------------------
 pk_test_id_valid | public       | pk_test    | primary  | {id}         | valid    | pk_test_pkey      | pk_test_id_valid_excl |                  |           |                            |                     | 
(1 row)

SELECT sql_saga.drop_unique_key('pk_test', '{id}');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('pk_test');
 drop_era 
----------
 t
(1 row)

DROP TABLE pk_test;
\echo '--- Test: add_unique_key validation for incompatible simple PRIMARY KEY ---'
--- Test: add_unique_key validation for incompatible simple PRIMARY KEY ---
CREATE TABLE public.simple_pk (
    id int PRIMARY KEY DEFERRABLE,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('public.simple_pk');
WARNING:  Table "simple_pk" has a simple PRIMARY KEY that does not include temporal columns. This schema is incompatible with SCD Type 2 history.
HINT:  If you plan to use a temporal primary key for this era, you must use a composite primary key that includes a temporal column (e.g., PRIMARY KEY (id, valid_from)).
 add_era 
---------
 t
(1 row)

SAVEPOINT expect_error;
\echo 'Attempting to add a temporal primary key to a table with a simple primary key (should fail)'
Attempting to add a temporal primary key to a table with a simple primary key (should fail)
SELECT sql_saga.add_unique_key('public.simple_pk', '{id}', key_type => 'primary');
ERROR:  table "simple_pk" has a simple PRIMARY KEY that does not include the temporal columns; this is incompatible with SCD Type 2 history
CONTEXT:  PL/pgSQL function sql_saga.add_unique_key(regclass,name[],name,sql_saga.unique_key_type,name,name,name,text,name[]) line 140 at RAISE
ROLLBACK TO SAVEPOINT expect_error;
DROP TABLE public.simple_pk;
\echo '--- Test: add_unique_key validation for GENERATED ALWAYS identity column ---'
--- Test: add_unique_key validation for GENERATED ALWAYS identity column ---
CREATE TABLE public.generated_always (
    id int GENERATED ALWAYS AS IDENTITY PRIMARY KEY DEFERRABLE,
    valid_from date,
    valid_until date
);
SELECT sql_saga.add_era('public.generated_always');
WARNING:  Table "generated_always" has a simple PRIMARY KEY that does not include temporal columns. This schema is incompatible with SCD Type 2 history.
HINT:  If you plan to use a temporal primary key for this era, you must use a composite primary key that includes a temporal column (e.g., PRIMARY KEY (id, valid_from)).
WARNING:  Table "generated_always" has a GENERATED ALWAYS AS IDENTITY column ("id"). This schema is incompatible with SCD Type 2 history.
HINT:  If you plan to use a temporal primary key for this era, the identity column must be GENERATED BY DEFAULT AS IDENTITY to allow inserting historical records.
 add_era 
---------
 t
(1 row)

SAVEPOINT expect_error_2;
\echo 'Attempting to add a temporal primary key to a table with a GENERATED ALWAYS identity (should fail)'
Attempting to add a temporal primary key to a table with a GENERATED ALWAYS identity (should fail)
SELECT sql_saga.add_unique_key('public.generated_always', '{id}', key_type => 'primary');
ERROR:  table "generated_always" has a GENERATED ALWAYS AS IDENTITY column ("id"); this is incompatible with SCD Type 2 history as it prevents inserting new historical versions of an entity
CONTEXT:  PL/pgSQL function sql_saga.add_unique_key(regclass,name[],name,sql_saga.unique_key_type,name,name,name,text,name[]) line 121 at RAISE
ROLLBACK TO SAVEPOINT expect_error_2;
DROP TABLE public.generated_always;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
