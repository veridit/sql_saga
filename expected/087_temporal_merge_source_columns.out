\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
CREATE SCHEMA repro;
-- Target table
CREATE TABLE repro.units (
    id int GENERATED BY DEFAULT AS IDENTITY,
    org_nr text NOT NULL,
    name text,
    valid_from date NOT NULL,
    valid_until date
);
SELECT sql_saga.add_era('repro.units');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('repro.units', ARRAY['id'], key_type => 'primary');
NOTICE:  sql_saga: altering table repro.units to add constraints: ALTER COLUMN id SET NOT NULL, ADD PRIMARY KEY (id, valid_from) DEFERRABLE, ADD CONSTRAINT units_id_valid_excl EXCLUDE USING gist (id WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE
 add_unique_key 
----------------
 units_id_valid
(1 row)

SELECT sql_saga.add_unique_key('repro.units', ARRAY['org_nr'], key_type => 'natural');
NOTICE:  sql_saga: altering table repro.units to add constraints: ADD CONSTRAINT units_org_nr_valid_uniq UNIQUE (org_nr, valid_from, valid_until) DEFERRABLE, ADD CONSTRAINT units_org_nr_valid_excl EXCLUDE USING gist (org_nr WITH =, daterange(valid_from, valid_until) WITH &&) DEFERRABLE, ADD CONSTRAINT units_org_nr_valid_pk_consistency_excl EXCLUDE USING gist (org_nr WITH =, id WITH <>)
   add_unique_key   
--------------------
 units_org_nr_valid
(1 row)

-- Source table
CREATE TEMP TABLE source_units (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    org_nr text,
    name text,
    valid_from date,
    valid_until date
) ON COMMIT DROP;
INSERT INTO source_units (org_nr, name, valid_from, valid_until) VALUES
    ('111', 'Unit A', '2023-01-01', '2024-01-01');
\echo '--- Scenario 1: FAIL - identity_column missing from source, when it is the only lookup key ---'
--- Scenario 1: FAIL - identity_column missing from source, when it is the only lookup key ---
SAVEPOINT expect_error;
-- This call is expected to fail because 'id' is not in 'source_units' and no natural key is provided for lookup.
CALL sql_saga.temporal_merge(
    target_table => 'repro.units',
    source_table => 'source_units',
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => NULL
);
ROLLBACK TO SAVEPOINT expect_error;
\echo '--- Scenario 2: FAIL - natural_identity_column missing from source ---'
--- Scenario 2: FAIL - natural_identity_column missing from source ---
SAVEPOINT expect_error;
-- This call is expected to fail because 'org_nr_typo' is not in 'source_units'
CALL sql_saga.temporal_merge(
    target_table => 'repro.units',
    source_table => 'source_units',
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['org_nr_typo']
);
ERROR:  lookup_column org_nr_typo does not exist in target table repro.units
CONTEXT:  PL/pgSQL function sql_saga.temporal_merge_plan(regclass,regclass,sql_saga.temporal_merge_mode,name,text[],name,name,sql_saga.temporal_merge_delete_mode,jsonb,text[],boolean,boolean) line 399 at RAISE
SQL statement "INSERT INTO temporal_merge_plan
    SELECT * FROM sql_saga.temporal_merge_plan(
        target_table => temporal_merge.target_table,
        source_table => temporal_merge.source_table,
        mode => temporal_merge.mode,
        era_name => temporal_merge.era_name,
        identity_columns => v_identity_cols_discovered,
        row_id_column => temporal_merge.row_id_column,
        founding_id_column => temporal_merge.founding_id_column,
        delete_mode => temporal_merge.delete_mode,
        lookup_keys => v_natural_identity_keys_discovered,
        ephemeral_columns => temporal_merge.ephemeral_columns,
        p_log_trace => v_log_trace,
        p_log_sql => v_log_sql
    )"
PL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 166 at SQL statement
ROLLBACK TO SAVEPOINT expect_error;
\echo '--- Scenario 3: FAIL - natural_identity_column missing from target ---'
--- Scenario 3: FAIL - natural_identity_column missing from target ---
SAVEPOINT expect_error;
-- This call is expected to fail because 'org_nr_typo' is not in 'repro.units'
CREATE TEMP TABLE source_with_typo (row_id int, org_nr_typo text, valid_from date, valid_to date) ON COMMIT DROP;
CALL sql_saga.temporal_merge(
    target_table => 'repro.units',
    source_table => 'source_with_typo',
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['org_nr_typo']
);
ERROR:  lookup_column org_nr_typo does not exist in target table repro.units
CONTEXT:  PL/pgSQL function sql_saga.temporal_merge_plan(regclass,regclass,sql_saga.temporal_merge_mode,name,text[],name,name,sql_saga.temporal_merge_delete_mode,jsonb,text[],boolean,boolean) line 399 at RAISE
SQL statement "INSERT INTO temporal_merge_plan
    SELECT * FROM sql_saga.temporal_merge_plan(
        target_table => temporal_merge.target_table,
        source_table => temporal_merge.source_table,
        mode => temporal_merge.mode,
        era_name => temporal_merge.era_name,
        identity_columns => v_identity_cols_discovered,
        row_id_column => temporal_merge.row_id_column,
        founding_id_column => temporal_merge.founding_id_column,
        delete_mode => temporal_merge.delete_mode,
        lookup_keys => v_natural_identity_keys_discovered,
        ephemeral_columns => temporal_merge.ephemeral_columns,
        p_log_trace => v_log_trace,
        p_log_sql => v_log_sql
    )"
PL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 166 at SQL statement
ROLLBACK TO SAVEPOINT expect_error;
\echo '--- Scenario 4: FAIL - identity_column missing from target ---'
--- Scenario 4: FAIL - identity_column missing from target ---
SAVEPOINT expect_error;
-- This call is expected to fail because 'id_typo' is not in 'repro.units'
CREATE TEMP TABLE source_with_id (row_id int, org_nr text, id_typo int, valid_from date, valid_to date) ON COMMIT DROP;
CALL sql_saga.temporal_merge(
    target_table => 'repro.units',
    source_table => 'source_with_id',
    primary_identity_columns => ARRAY['id_typo'],
    natural_identity_columns => ARRAY['org_nr']
);
ERROR:  identity_column id_typo does not exist in target table repro.units
CONTEXT:  PL/pgSQL function sql_saga.temporal_merge_plan(regclass,regclass,sql_saga.temporal_merge_mode,name,text[],name,name,sql_saga.temporal_merge_delete_mode,jsonb,text[],boolean,boolean) line 385 at RAISE
SQL statement "INSERT INTO temporal_merge_plan
    SELECT * FROM sql_saga.temporal_merge_plan(
        target_table => temporal_merge.target_table,
        source_table => temporal_merge.source_table,
        mode => temporal_merge.mode,
        era_name => temporal_merge.era_name,
        identity_columns => v_identity_cols_discovered,
        row_id_column => temporal_merge.row_id_column,
        founding_id_column => temporal_merge.founding_id_column,
        delete_mode => temporal_merge.delete_mode,
        lookup_keys => v_natural_identity_keys_discovered,
        ephemeral_columns => temporal_merge.ephemeral_columns,
        p_log_trace => v_log_trace,
        p_log_sql => v_log_sql
    )"
PL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 166 at SQL statement
ROLLBACK TO SAVEPOINT expect_error;
\echo '--- Scenario 5: Happy path (ID back-filling) ---'
--- Scenario 5: Happy path (ID back-filling) ---
\echo '--- State before merge ---'
--- State before merge ---
SELECT id, org_nr, name, valid_from, valid_until FROM repro.units ORDER BY id, valid_from;
 id | org_nr | name | valid_from | valid_until 
----+--------+------+------------+-------------
(0 rows)

\echo '--- Source before merge ---'
--- Source before merge ---
TABLE source_units;
 row_id | org_nr |  name  | valid_from | valid_until 
--------+--------+--------+------------+-------------
      1 | 111    | Unit A | 2023-01-01 | 2024-01-01
(1 row)

-- This should succeed. 'id' is not in the source, but 'org_nr' is, so the
-- planner can look up the entity, see it is new, and the executor will
-- insert it and allow the database to generate the new 'id'.
CALL sql_saga.temporal_merge(
    target_table => 'repro.units',
    source_table => 'source_units',
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['org_nr'],
    mode => 'MERGE_ENTITY_UPSERT'
);
\echo '--- State after merge ---'
--- State after merge ---
SELECT id, org_nr, name, valid_from, valid_until FROM repro.units ORDER BY id, valid_from;
 id | org_nr |  name  | valid_from | valid_until 
----+--------+--------+------------+-------------
  2 | 111    | Unit A | 2023-01-01 | 2024-01-01
(1 row)

DELETE FROM source_units;
INSERT INTO source_units (org_nr, name, valid_from, valid_until) VALUES
    ('222', 'Unit B', '2023-01-01', '2024-01-01');
\echo '--- Scenario 6: Happy path (Auto-discovery) ---'
--- Scenario 6: Happy path (Auto-discovery) ---
\echo '--- State before merge ---'
--- State before merge ---
SELECT id, org_nr, name, valid_from, valid_until FROM repro.units ORDER BY id, valid_from;
 id | org_nr |  name  | valid_from | valid_until 
----+--------+--------+------------+-------------
  2 | 111    | Unit A | 2023-01-01 | 2024-01-01
(1 row)

\echo '--- Source before merge ---'
--- Source before merge ---
TABLE source_units;
 row_id | org_nr |  name  | valid_from | valid_until 
--------+--------+--------+------------+-------------
      2 | 222    | Unit B | 2023-01-01 | 2024-01-01
(1 row)

-- This should succeed. Both identity_columns and natural_identity_columns are
-- NULL, so they are discovered from sql_saga.unique_keys.
CALL sql_saga.temporal_merge(
    target_table => 'repro.units',
    source_table => 'source_units',
    primary_identity_columns => NULL,
    natural_identity_columns => NULL,
    mode => 'MERGE_ENTITY_UPSERT'
);
\echo '--- State after merge ---'
--- State after merge ---
SELECT id, org_nr, name, valid_from, valid_until FROM repro.units ORDER BY id, valid_from;
 id | org_nr |  name  | valid_from | valid_until 
----+--------+--------+------------+-------------
  2 | 111    | Unit A | 2023-01-01 | 2024-01-01
  3 | 222    | Unit B | 2023-01-01 | 2024-01-01
(2 rows)

\echo '--- Scenario 7: FAIL - update_source_with_identity is true, but identity column is missing from source ---'
--- Scenario 7: FAIL - update_source_with_identity is true, but identity column is missing from source ---
SAVEPOINT expect_error;
-- This call is expected to fail because 'id' is not in 'source_units'
CALL sql_saga.temporal_merge(
    target_table => 'repro.units',
    source_table => 'source_units',
    primary_identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['org_nr'],
    update_source_with_identity => true
);
ERROR:  When update_source_with_identity is true, identity_column "id" must exist in the source table "source_units" to be updated.
CONTEXT:  PL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 127 at RAISE
ROLLBACK TO SAVEPOINT expect_error;
\echo '--- Scenario 8: FAIL - update_source_with_identity is true, but auto-discovered identity column is missing from source ---'
--- Scenario 8: FAIL - update_source_with_identity is true, but auto-discovered identity column is missing from source ---
SAVEPOINT expect_error;
-- This call is expected to fail because 'id' is not in 'source_units', and identity_columns is auto-discovered.
CALL sql_saga.temporal_merge(
    target_table => 'repro.units',
    source_table => 'source_units',
    primary_identity_columns => NULL,
    natural_identity_columns => NULL,
    update_source_with_identity => true
);
ERROR:  When update_source_with_identity is true, identity_column "id" must exist in the source table "source_units" to be updated.
CONTEXT:  PL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 127 at RAISE
ROLLBACK TO SAVEPOINT expect_error;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
