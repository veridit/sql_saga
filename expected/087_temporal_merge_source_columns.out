\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
CREATE SCHEMA repro;
-- Target table
CREATE TABLE repro.units (
    id int GENERATED BY DEFAULT AS IDENTITY,
    org_nr text NOT NULL,
    name text,
    valid_from date NOT NULL,
    valid_until date
);
SELECT sql_saga.add_era('repro.units');
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_unique_key('repro.units', ARRAY['id'], key_type => 'primary');
 add_unique_key 
----------------
 units_id_valid
(1 row)

SELECT sql_saga.add_unique_key('repro.units', ARRAY['org_nr'], key_type => 'natural');
   add_unique_key   
--------------------
 units_org_nr_valid
(1 row)

-- Source table
CREATE TEMP TABLE source_units (
    row_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    org_nr text,
    name text,
    valid_from date,
    valid_until date
) ON COMMIT DROP;
INSERT INTO source_units (org_nr, name, valid_from, valid_until) VALUES
    ('111', 'Unit A', '2023-01-01', '2024-01-01');
\echo '--- Scenario 1: identity_column missing from source ---'
--- Scenario 1: identity_column missing from source ---
SAVEPOINT expect_error;
-- This call is expected to fail because 'id' is not in 'source_units'
CALL sql_saga.temporal_merge(
    target_table => 'repro.units',
    source_table => 'source_units',
    identity_columns => ARRAY['id'],
    natural_identity_columns => ARRAY['org_nr']
);
ERROR:  identity_column id does not exist in source table source_units
CONTEXT:  PL/pgSQL function sql_saga.temporal_merge_plan(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,sql_saga.temporal_merge_delete_mode,text[],text[],boolean,boolean) line 62 at RAISE
SQL statement "INSERT INTO temporal_merge_plan
    SELECT * FROM sql_saga.temporal_merge_plan(
        target_table => temporal_merge.target_table,
        source_table => temporal_merge.source_table,
        identity_columns => temporal_merge.identity_columns,
        mode => temporal_merge.mode,
        era_name => temporal_merge.era_name,
        row_id_column => temporal_merge.row_id_column,
        founding_id_column => temporal_merge.founding_id_column,
        delete_mode => temporal_merge.delete_mode,
        natural_identity_columns => temporal_merge.natural_identity_columns,
        ephemeral_columns => temporal_merge.ephemeral_columns,
        p_log_trace => v_log_trace,
        p_log_sql => v_log_sql
    )"
PL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[]) line 38 at SQL statement
ROLLBACK TO SAVEPOINT expect_error;
\echo '--- Scenario 2: natural_identity_column missing from source ---'
--- Scenario 2: natural_identity_column missing from source ---
SAVEPOINT expect_error;
-- This call is expected to fail because 'org_nr_typo' is not in 'source_units'
CALL sql_saga.temporal_merge(
    target_table => 'repro.units',
    source_table => 'source_units',
    identity_columns => ARRAY[]::text[],
    natural_identity_columns => ARRAY['org_nr_typo']
);
ERROR:  natural_identity_column org_nr_typo does not exist in source table source_units
CONTEXT:  PL/pgSQL function sql_saga.temporal_merge_plan(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,sql_saga.temporal_merge_delete_mode,text[],text[],boolean,boolean) line 71 at RAISE
SQL statement "INSERT INTO temporal_merge_plan
    SELECT * FROM sql_saga.temporal_merge_plan(
        target_table => temporal_merge.target_table,
        source_table => temporal_merge.source_table,
        identity_columns => temporal_merge.identity_columns,
        mode => temporal_merge.mode,
        era_name => temporal_merge.era_name,
        row_id_column => temporal_merge.row_id_column,
        founding_id_column => temporal_merge.founding_id_column,
        delete_mode => temporal_merge.delete_mode,
        natural_identity_columns => temporal_merge.natural_identity_columns,
        ephemeral_columns => temporal_merge.ephemeral_columns,
        p_log_trace => v_log_trace,
        p_log_sql => v_log_sql
    )"
PL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[]) line 38 at SQL statement
ROLLBACK TO SAVEPOINT expect_error;
\echo '--- Scenario 3: identity_column missing from target ---'
--- Scenario 3: identity_column missing from target ---
SAVEPOINT expect_error;
-- This call is expected to fail because 'id_typo' is not in 'repro.units'
-- We need a source table with the column for this test.
CREATE TEMP TABLE source_with_id (row_id int, org_nr text, name text, valid_from date, valid_until date, id_typo int) ON COMMIT DROP;
CALL sql_saga.temporal_merge(
    target_table => 'repro.units',
    source_table => 'source_with_id',
    identity_columns => ARRAY['id_typo'],
    natural_identity_columns => ARRAY['org_nr']
);
ERROR:  identity_column id_typo does not exist in target table repro.units
CONTEXT:  PL/pgSQL function sql_saga.temporal_merge_plan(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,sql_saga.temporal_merge_delete_mode,text[],text[],boolean,boolean) line 64 at RAISE
SQL statement "INSERT INTO temporal_merge_plan
    SELECT * FROM sql_saga.temporal_merge_plan(
        target_table => temporal_merge.target_table,
        source_table => temporal_merge.source_table,
        identity_columns => temporal_merge.identity_columns,
        mode => temporal_merge.mode,
        era_name => temporal_merge.era_name,
        row_id_column => temporal_merge.row_id_column,
        founding_id_column => temporal_merge.founding_id_column,
        delete_mode => temporal_merge.delete_mode,
        natural_identity_columns => temporal_merge.natural_identity_columns,
        ephemeral_columns => temporal_merge.ephemeral_columns,
        p_log_trace => v_log_trace,
        p_log_sql => v_log_sql
    )"
PL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[]) line 38 at SQL statement
ROLLBACK TO SAVEPOINT expect_error;
\echo '--- Scenario 4: Happy path (identity_columns not specified, so not validated) ---'
--- Scenario 4: Happy path (identity_columns not specified, so not validated) ---
-- This should succeed. The previous test run showed it does when identity_columns is empty.
CALL sql_saga.temporal_merge(
    target_table => 'repro.units',
    source_table => 'source_units',
    identity_columns => ARRAY[]::text[],
    natural_identity_columns => ARRAY['org_nr'],
    mode => 'MERGE_ENTITY_UPSERT'
);
\echo '--- State after merge ---'
--- State after merge ---
SELECT id, org_nr, name, valid_from, valid_until FROM repro.units ORDER BY id, valid_from;
 id | org_nr |  name  | valid_from | valid_until 
----+--------+--------+------------+-------------
  1 | 111    | Unit A | 2023-01-01 | 2024-01-01
(1 row)

ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
