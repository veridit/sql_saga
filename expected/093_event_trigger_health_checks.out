\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
/* Run tests as unprivileged user */
SET ROLE TO sql_saga_unprivileged_user;
/* DDL on unrelated tables should not be affected */
CREATE UNLOGGED TABLE unrelated();
ALTER TABLE unrelated SET LOGGED;
ALTER TABLE unrelated SET UNLOGGED;
DROP TABLE unrelated;
/* Ensure tables with periods are persistent */
CREATE UNLOGGED TABLE log (id bigint, valid_range daterange NOT NULL, valid_from date, valid_until date);
SAVEPOINT s1;
SELECT sql_saga.add_era('log', 'valid_range', 'p', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until'); -- fails
ERROR:  table "log" must be persistent
CONTEXT:  PL/pgSQL function sql_saga.add_era(regclass,name,name,boolean,name,name,name,boolean,boolean,boolean,regtype,name,name[]) line 83 at RAISE
ROLLBACK TO SAVEPOINT s1;
ALTER TABLE log SET LOGGED;
SELECT sql_saga.add_era('log', 'valid_range', 'p', valid_from_column_name => 'valid_from', valid_until_column_name => 'valid_until'); -- passes
NOTICE:  sql_saga: Created trigger "log_synchronize_temporal_columns_trigger" on table log to synchronize columns: valid_from, valid_until
NOTICE:  sql_saga: Created GIST index "log_valid_range_gist_idx" on column public.log.valid_range for temporal_merge performance
 add_era 
---------
 t
(1 row)

SAVEPOINT s2;
ALTER TABLE log SET UNLOGGED; -- fails
ERROR:  table "log" must remain persistent because it has an era
CONTEXT:  PL/pgSQL function health_checks() line 20 at RAISE
ROLLBACK TO SAVEPOINT s2;
DROP TABLE log;
ROLLBACK;
--------------------------------------------------------------------------------
-- SYSTEM VERSIONING HEALTH CHECKS
--------------------------------------------------------------------------------
\echo '\n--- System Versioning Health Checks ---'

--- System Versioning Health Checks ---
-- These tests need to run outside the transaction with controlled commits
-- because event triggers fire at end of DDL statements
-- Create a test table with system versioning
CREATE TABLE hc_sysver (
    id serial PRIMARY KEY,
    data text
);
SELECT sql_saga.add_system_versioning('hc_sysver');
 add_system_versioning 
-----------------------
 
(1 row)

-- Verify objects exist
\echo '--- Verify system versioning objects created ---'
--- Verify system versioning objects created ---
SELECT table_name, history_table_name, view_table_name FROM sql_saga.system_versioning WHERE table_name = 'hc_sysver';
 table_name | history_table_name |    view_table_name     
------------+--------------------+------------------------
 hc_sysver  | hc_sysver_history  | hc_sysver_with_history
(1 row)

-- Test 1: GRANT propagation
\echo '\n--- Test: GRANT propagation ---'

--- Test: GRANT propagation ---
GRANT SELECT ON hc_sysver TO sql_saga_unprivileged_user;
-- Verify grants propagated to history table
\echo '--- Checking history table privileges ---'
--- Checking history table privileges ---
SELECT has_table_privilege('sql_saga_unprivileged_user', 'hc_sysver_history', 'SELECT') AS history_select;
 history_select 
----------------
 t
(1 row)

-- Verify grants propagated to view
\echo '--- Checking history view privileges ---'
--- Checking history view privileges ---
SELECT has_table_privilege('sql_saga_unprivileged_user', 'hc_sysver_with_history', 'SELECT') AS view_select;
 view_select 
-------------
 t
(1 row)

-- Verify EXECUTE granted on functions
\echo '--- Checking function privileges ---'
--- Checking function privileges ---
SELECT
    has_function_privilege('sql_saga_unprivileged_user', sv.func_as_of::regprocedure, 'EXECUTE') AS as_of_execute,
    has_function_privilege('sql_saga_unprivileged_user', sv.func_between::regprocedure, 'EXECUTE') AS between_execute,
    has_function_privilege('sql_saga_unprivileged_user', sv.func_between_symmetric::regprocedure, 'EXECUTE') AS between_symmetric_execute,
    has_function_privilege('sql_saga_unprivileged_user', sv.func_from_to::regprocedure, 'EXECUTE') AS from_to_execute
FROM sql_saga.system_versioning sv
WHERE sv.table_name = 'hc_sysver';
 as_of_execute | between_execute | between_symmetric_execute | from_to_execute 
---------------+-----------------+---------------------------+-----------------
 t             | t               | t                         | t
(1 row)

-- Test 2: REVOKE propagation
\echo '\n--- Test: REVOKE propagation ---'

--- Test: REVOKE propagation ---
REVOKE SELECT ON hc_sysver FROM sql_saga_unprivileged_user;
-- Verify revokes propagated
\echo '--- Checking privileges revoked from history objects ---'
--- Checking privileges revoked from history objects ---
SELECT
    has_table_privilege('sql_saga_unprivileged_user', 'hc_sysver_history', 'SELECT') AS history_select,
    has_table_privilege('sql_saga_unprivileged_user', 'hc_sysver_with_history', 'SELECT') AS view_select;
 history_select | view_select 
----------------+-------------
 f              | f
(1 row)

\echo '--- Checking function privileges revoked ---'
--- Checking function privileges revoked ---
SELECT
    has_function_privilege('sql_saga_unprivileged_user', sv.func_as_of::regprocedure, 'EXECUTE') AS as_of_execute,
    has_function_privilege('sql_saga_unprivileged_user', sv.func_between::regprocedure, 'EXECUTE') AS between_execute,
    has_function_privilege('sql_saga_unprivileged_user', sv.func_between_symmetric::regprocedure, 'EXECUTE') AS between_symmetric_execute,
    has_function_privilege('sql_saga_unprivileged_user', sv.func_from_to::regprocedure, 'EXECUTE') AS from_to_execute
FROM sql_saga.system_versioning sv
WHERE sv.table_name = 'hc_sysver';
 as_of_execute | between_execute | between_symmetric_execute | from_to_execute 
---------------+-----------------+---------------------------+-----------------
 f             | f               | f                         | f
(1 row)

-- Test 3: Ownership propagation
\echo '\n--- Test: Ownership propagation ---'

--- Test: Ownership propagation ---
-- Change owner of base table
ALTER TABLE hc_sysver OWNER TO sql_saga_unprivileged_user;
-- Verify history objects ownership changed
\echo '--- Checking history object ownership ---'
--- Checking history object ownership ---
SELECT
    c.relname,
    pg_get_userbyid(c.relowner) AS owner
FROM pg_class c
WHERE c.relname IN ('hc_sysver', 'hc_sysver_history', 'hc_sysver_with_history')
ORDER BY c.relname;
        relname         |           owner            
------------------------+----------------------------
 hc_sysver              | sql_saga_unprivileged_user
 hc_sysver_history      | sql_saga_unprivileged_user
 hc_sysver_with_history | sql_saga_unprivileged_user
(3 rows)

-- Verify function ownership changed
\echo '--- Checking function ownership ---'
--- Checking function ownership ---
SELECT
    p.proname,
    pg_get_userbyid(p.proowner) AS owner
FROM sql_saga.system_versioning sv
JOIN pg_proc p ON p.oid = ANY (ARRAY[sv.func_as_of, sv.func_between, sv.func_between_symmetric, sv.func_from_to]::regprocedure[])
WHERE sv.table_name = 'hc_sysver'
ORDER BY p.proname;
           proname            |           owner            
------------------------------+----------------------------
 hc_sysver__as_of             | sql_saga_unprivileged_user
 hc_sysver__between           | sql_saga_unprivileged_user
 hc_sysver__between_symmetric | sql_saga_unprivileged_user
 hc_sysver__from_to           | sql_saga_unprivileged_user
(4 rows)

-- Cleanup - change owner back before dropping
ALTER TABLE hc_sysver OWNER TO CURRENT_USER;
SELECT sql_saga.drop_system_versioning('hc_sysver');
 drop_system_versioning 
------------------------
 t
(1 row)

DROP TABLE hc_sysver;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
