\i sql/include/test_setup.sql
--
-- test_setup.sql
--
-- Common setup for regression tests that need to be self-contained.
-- This script creates the extension, a user role, and grants permissions.
--
SET datestyle = 'ISO, YMD';
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS sql_saga CASCADE;
DO $$
BEGIN
    CREATE ROLE sql_saga_unprivileged_user;
EXCEPTION WHEN duplicate_object THEN
END
$$;
GRANT USAGE ON SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT SELECT ON ALL TABLES IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA sql_saga TO sql_saga_unprivileged_user;
/*
 * Allow the unprivileged user to create tables in the public schema.
 * This is required for tests that create their own tables.
 * PG 15+ restricts this by default.
 */
GRANT CREATE ON SCHEMA public TO PUBLIC;
BEGIN;
/* Run tests as unprivileged user */
SET ROLE TO sql_saga_unprivileged_user;
/* DDL on unrelated tables should not be affected */
CREATE TABLE unrelated();
DROP TABLE unrelated;
/* Make sure nobody drops the objects we keep track of in our catalogs. */
CREATE TYPE integerrange AS RANGE (SUBTYPE = integer);
CREATE TABLE dp (
    id bigint,
    v integerrange NOT NULL,
    s integer,
    e integer,
    x boolean
);
/* era */
SELECT sql_saga.add_era('dp', 'v', 'p', valid_from_column_name => 's', valid_until_column_name => 'e');
NOTICE:  sql_saga: Created trigger "dp_synchronize_temporal_columns_trigger" on table dp to synchronize columns: s, e
NOTICE:  sql_saga: Created GIST index "dp_v_gist_idx" on column public.dp.v for temporal_merge performance
 add_era 
---------
 t
(1 row)

SAVEPOINT s1;
ALTER TABLE dp DROP COLUMN s; -- fails
ERROR:  cannot drop column s of table dp because other objects depend on it
DETAIL:  trigger dp_p_sync_temporal_trg on table dp depends on column s of table dp
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
ROLLBACK TO SAVEPOINT s1;
SAVEPOINT s2;
ALTER TABLE dp ALTER COLUMN s TYPE text; -- fails
ERROR:  cannot alter type of a column used in a trigger definition
DETAIL:  trigger dp_p_sync_temporal_trg on table dp depends on column "s"
ROLLBACK TO SAVEPOINT s2;
SAVEPOINT s3;
DROP TYPE integerrange; -- fails
ERROR:  cannot drop type integerrange because other objects depend on it
DETAIL:  column v of table dp depends on type integerrange
trigger dp_p_sync_temporal_trg on table dp depends on column v of table dp
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
ROLLBACK TO SAVEPOINT s3;
/* api */
ALTER TABLE dp ADD CONSTRAINT dp_pkey PRIMARY KEY (id);
SELECT sql_saga.add_for_portion_of_view('dp', 'p');
 add_for_portion_of_view 
-------------------------
 t
(1 row)

SAVEPOINT s4;
DROP VIEW dp__for_portion_of_p;
ERROR:  cannot drop view "public.dp__for_portion_of_p", call "sql_saga.drop_for_portion_of_view()" instead
CONTEXT:  PL/pgSQL function drop_protection() line 210 at RAISE
ROLLBACK TO SAVEPOINT s4;
SAVEPOINT s5;
DROP TRIGGER for_portion_of_p ON dp__for_portion_of_p;
ERROR:  cannot drop trigger "for_portion_of_p" on view "dp__for_portion_of_p" because it is part of an updatable view for era "p" on table "dp"
CONTEXT:  PL/pgSQL function drop_protection() line 222 at RAISE
ROLLBACK TO SAVEPOINT s5;
SAVEPOINT s6;
ALTER TABLE dp DROP CONSTRAINT dp_pkey;
ERROR:  table "dp" must have a primary key or a single-column temporal unique key to support its updatable view for era "p"
CONTEXT:  PL/pgSQL function drop_protection() line 243 at RAISE
ROLLBACK TO SAVEPOINT s6;
SELECT sql_saga.drop_for_portion_of_view('dp', 'p');
 drop_for_portion_of_view 
--------------------------
 t
(1 row)

ALTER TABLE dp DROP CONSTRAINT dp_pkey;
CREATE TABLE dp_current (
    id bigint,
    v daterange NOT NULL,
    s date NOT NULL,
    e date NOT NULL
);
ALTER TABLE dp_current ADD CONSTRAINT dp_current_pkey PRIMARY KEY (id, v WITHOUT OVERLAPS);
SELECT sql_saga.add_era('dp_current', 'v', 'p', valid_from_column_name => 's', valid_until_column_name => 'e');
NOTICE:  sql_saga: Created trigger "dp_current_synchronize_temporal_columns_trigger" on table dp_current to synchronize columns: s, e
NOTICE:  sql_saga: Created GIST index "dp_current_v_gist_idx" on column public.dp_current.v for temporal_merge performance
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_current_view('dp_current', 'p');
 add_current_view 
------------------
 t
(1 row)

SAVEPOINT s_current_view;
DROP VIEW dp_current__current_p; -- fails
ERROR:  cannot drop view "public.dp_current__current_p", call "sql_saga.drop_current_view()" instead
CONTEXT:  PL/pgSQL function drop_protection() line 210 at RAISE
ROLLBACK TO SAVEPOINT s_current_view;
SAVEPOINT s_current_trigger;
DROP TRIGGER current_p ON dp_current__current_p; -- fails
ERROR:  cannot drop trigger "current_p" on view "dp_current__current_p" because it is part of an updatable view for era "p" on table "dp_current"
CONTEXT:  PL/pgSQL function drop_protection() line 222 at RAISE
ROLLBACK TO SAVEPOINT s_current_trigger;
SAVEPOINT s_current_pkey;
ALTER TABLE dp_current DROP CONSTRAINT dp_current_pkey; -- fails
ERROR:  table "dp_current" must have a primary key or a single-column temporal unique key to support its updatable view for era "p"
CONTEXT:  PL/pgSQL function drop_protection() line 243 at RAISE
ROLLBACK TO SAVEPOINT s_current_pkey;
SELECT sql_saga.drop_current_view('dp_current', 'p');
 drop_current_view 
-------------------
 t
(1 row)

ALTER TABLE dp_current DROP CONSTRAINT dp_current_pkey;
SELECT sql_saga.drop_era('dp_current', 'p');
 drop_era 
----------
 t
(1 row)

DROP TABLE dp_current;
/* unique_keys */
ALTER TABLE dp
    ADD CONSTRAINT u UNIQUE (id, v WITHOUT OVERLAPS);
SELECT sql_saga.add_unique_key(
    table_oid => 'dp'::regclass,
    column_names => ARRAY['id'],
    era_name => 'p',
    unique_key_name => 'k',
    unique_constraint => 'u'
);
 add_unique_key 
----------------
 k
(1 row)

SAVEPOINT s7;
ALTER TABLE dp DROP CONSTRAINT u; -- fails
ERROR:  cannot drop constraint "u" on table "dp" because it is used in era unique key "k"
CONTEXT:  PL/pgSQL function drop_protection() line 299 at RAISE
ROLLBACK TO SAVEPOINT s7;
SAVEPOINT s9;
ALTER TABLE dp DROP CONSTRAINT dp_p_check; -- fails (bounds check constraint)
ROLLBACK TO SAVEPOINT s9;
SAVEPOINT s10;
/* unique_keys - pk_consistency */
CREATE TABLE dp_pk_consistency (
    id int,
    nk text,
    v daterange NOT NULL,
    s date,
    e date
);
SELECT sql_saga.add_era('dp_pk_consistency', 'v', 'p', valid_from_column_name => 's', valid_until_column_name => 'e');
NOTICE:  sql_saga: Created trigger "dp_pk_consistency_synchronize_temporal_columns_trigger" on table dp_pk_consistency to synchronize columns: s, e
NOTICE:  sql_saga: Created GIST index "dp_pk_consistency_v_gist_idx" on column public.dp_pk_consistency.v for temporal_merge performance
 add_era 
---------
 t
(1 row)

ALTER TABLE dp_pk_consistency ADD PRIMARY KEY (id);
SELECT sql_saga.add_unique_key(
    table_oid => 'dp_pk_consistency',
    column_names => ARRAY['nk'],
    era_name => 'p',
    key_type => 'natural',
    unique_key_name => 'dp_pk_consistency_nk_valid'
);
NOTICE:  sql_saga: Added constraints to table dp_pk_consistency: ADD CONSTRAINT dp_pk_consistency_nk_valid_uniq UNIQUE (nk, v WITHOUT OVERLAPS); ADD CONSTRAINT dp_pk_consistency_nk_valid_pk_consistency_excl EXCLUDE USING gist (nk WITH =, id WITH <>)
       add_unique_key       
----------------------------
 dp_pk_consistency_nk_valid
(1 row)

SAVEPOINT expect_error;
ALTER TABLE dp_pk_consistency DROP CONSTRAINT dp_pk_consistency_nk_valid_pk_consistency_excl; -- fails
ERROR:  cannot drop constraint "dp_pk_consistency_nk_valid_pk_consistency_excl" on table "dp_pk_consistency" because it is used in era unique key "dp_pk_consistency_nk_valid"
CONTEXT:  PL/pgSQL function drop_protection() line 324 at RAISE
ROLLBACK TO SAVEPOINT expect_error;
SELECT sql_saga.drop_unique_key('dp_pk_consistency', ARRAY['nk'], 'p');
NOTICE:  sql_saga: dropping constraint: ALTER TABLE public.dp_pk_consistency DROP CONSTRAINT dp_pk_consistency_nk_valid_pk_consistency_excl
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('dp_pk_consistency', 'p');
 drop_era 
----------
 t
(1 row)

ROLLBACK TO SAVEPOINT s10;
SAVEPOINT s11;
/* foreign_keys */
CREATE TABLE dp_ref (LIKE dp);
SELECT sql_saga.add_era('dp_ref', 'v', 'p', valid_from_column_name => 's', valid_until_column_name => 'e');
NOTICE:  sql_saga: Created trigger "dp_ref_synchronize_temporal_columns_trigger" on table dp_ref to synchronize columns: s, e
NOTICE:  sql_saga: Created GIST index "dp_ref_v_gist_idx" on column public.dp_ref.v for temporal_merge performance
 add_era 
---------
 t
(1 row)

SELECT sql_saga.add_temporal_foreign_key('dp_ref', ARRAY['id'], 'p', 'k', foreign_key_name => 'f');
NOTICE:  sql_saga: No compatible index found for foreign key on table dp_ref. Creating new index: CREATE INDEX dp_ref_id_p_gist_idx ON dp_ref USING GIST (id, v)
 add_temporal_foreign_key 
--------------------------
 f
(1 row)

-- Note: In the new API with native PostgreSQL 18 temporal FKs, there are no FK triggers to test dropping.
SELECT sql_saga.drop_foreign_key('dp_ref', ARRAY['id'], 'p');
NOTICE:  sql_saga: Dropping automatically created index "dp_ref_id_p_gist_idx" for foreign key "f"
 drop_foreign_key 
------------------
 
(1 row)

DROP TABLE dp_ref;
SELECT sql_saga.drop_unique_key('dp', ARRAY['id'], 'p');
 drop_unique_key 
-----------------
 
(1 row)

SELECT sql_saga.drop_era('dp', 'p');
 drop_era 
----------
 t
(1 row)

ROLLBACK TO SAVEPOINT s11;
SAVEPOINT system_versioning_tests;
/* system_versioning - test drop protection for system-versioned tables */
CREATE TABLE dp_sysver (id int PRIMARY KEY, name text);
SELECT sql_saga.add_system_versioning('dp_sysver');
 add_system_versioning 
-----------------------
 
(1 row)

-- Test that we can't drop the history table directly
SAVEPOINT sv_history_table;
DROP TABLE dp_sysver_history; -- should fail
ERROR:  cannot drop table dp_sysver_history because other objects depend on it
DETAIL:  view dp_sysver_with_history depends on table dp_sysver_history
function dp_sysver__as_of(timestamp with time zone) depends on type dp_sysver_with_history
function dp_sysver__between(timestamp with time zone,timestamp with time zone) depends on type dp_sysver_with_history
function dp_sysver__between_symmetric(timestamp with time zone,timestamp with time zone) depends on type dp_sysver_with_history
function dp_sysver__from_to(timestamp with time zone,timestamp with time zone) depends on type dp_sysver_with_history
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
ROLLBACK TO SAVEPOINT sv_history_table;
-- Test that we can't drop the history view directly
SAVEPOINT sv_history_view;
DROP VIEW dp_sysver_with_history; -- should fail
ERROR:  cannot drop view dp_sysver_with_history because other objects depend on it
DETAIL:  function dp_sysver__as_of(timestamp with time zone) depends on type dp_sysver_with_history
function dp_sysver__between(timestamp with time zone,timestamp with time zone) depends on type dp_sysver_with_history
function dp_sysver__between_symmetric(timestamp with time zone,timestamp with time zone) depends on type dp_sysver_with_history
function dp_sysver__from_to(timestamp with time zone,timestamp with time zone) depends on type dp_sysver_with_history
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
ROLLBACK TO SAVEPOINT sv_history_view;
-- Test that we can't drop the generated_always trigger
SAVEPOINT sv_gen_trigger;
DROP TRIGGER dp_sysver_system_time_generated_always ON dp_sysver; -- should fail
ERROR:  cannot drop trigger "dp_sysver_system_time_generated_always" on table "dp_sysver" because it is used in SYSTEM_TIME period
CONTEXT:  PL/pgSQL function drop_protection() line 154 at RAISE
ROLLBACK TO SAVEPOINT sv_gen_trigger;
-- Test that we can't drop the write_history trigger
SAVEPOINT sv_write_trigger;
DROP TRIGGER dp_sysver_system_time_write_history ON dp_sysver; -- should fail
ERROR:  cannot drop trigger "dp_sysver_system_time_write_history" on table "dp_sysver" because it is used in SYSTEM_TIME period
CONTEXT:  PL/pgSQL function drop_protection() line 166 at RAISE
ROLLBACK TO SAVEPOINT sv_write_trigger;
-- Test that we can't drop the truncate trigger
SAVEPOINT sv_truncate_trigger;
DROP TRIGGER dp_sysver_truncate ON dp_sysver; -- should fail
ERROR:  cannot drop trigger "dp_sysver_truncate" on table "dp_sysver" because it is used in SYSTEM_TIME period
CONTEXT:  PL/pgSQL function drop_protection() line 178 at RAISE
ROLLBACK TO SAVEPOINT sv_truncate_trigger;
-- Test that we can't drop the infinity check constraint
SAVEPOINT sv_infinity_check;
ALTER TABLE dp_sysver DROP CONSTRAINT dp_sysver_system_valid_range_infinity_check; -- should fail
ERROR:  cannot drop constraint "dp_sysver_system_valid_range_infinity_check" on table "dp_sysver" because it is used in SYSTEM_TIME period
CONTEXT:  PL/pgSQL function drop_protection() line 142 at RAISE
ROLLBACK TO SAVEPOINT sv_infinity_check;
-- Test proper cleanup works
SELECT sql_saga.drop_system_versioning('dp_sysver');
 drop_system_versioning 
------------------------
 t
(1 row)

DROP TABLE dp_sysver;
ROLLBACK TO SAVEPOINT system_versioning_tests;
ROLLBACK;
\i sql/include/test_teardown.sql
--
-- test_teardown.sql
--
-- Common teardown for regression tests. This script drops the unprivileged
-- user role created by test_setup.sql.
--
-- It is important to reset the role first, in case a test fails and
-- leaves the session role set to the user that is about to be dropped.
RESET ROLE;
-- Drop the extensions to ensure a clean state for the next test.
-- Use CASCADE to remove any dependent objects created by sql_saga.
DROP EXTENSION IF EXISTS sql_saga CASCADE;
DROP EXTENSION IF EXISTS btree_gist CASCADE;
-- Revoke any privileges held by the test user and drop any objects they own.
-- This is necessary before the role can be dropped.
DROP OWNED BY sql_saga_unprivileged_user;
DROP ROLE IF EXISTS sql_saga_unprivileged_user;
